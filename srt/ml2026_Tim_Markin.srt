1
00:00:00,500 --> 00:00:01,280
Speaker 35: Hello everybody.

2
00:00:01,280 --> 00:00:07,260
My name is Tim, and today I'm gonna talk
about AI driven engineering quality.

3
00:00:07,979 --> 00:00:09,870
So a little bit about myself.

4
00:00:10,000 --> 00:00:13,570
I'm working in the IT
industry for over five years.

5
00:00:13,960 --> 00:00:16,450
I've been building
games most of my career.

6
00:00:17,020 --> 00:00:22,790
For the first three years I worked as
a software engineer and I worked on

7
00:00:22,790 --> 00:00:25,280
apps that have over 10 million users.

8
00:00:25,910 --> 00:00:30,669
And for the past two years I switched
to product management and I worked on

9
00:00:30,669 --> 00:00:33,720
an app that has over 800,000 users.

10
00:00:34,220 --> 00:00:39,439
And on average the apps that I
shipped, they have 200,000 plus users.

11
00:00:39,939 --> 00:00:47,649
The problem I've been facing for my whole
career is the wrong time estimation of,

12
00:00:47,729 --> 00:00:52,199
the delivery time, how long it's gonna
take the feature for the engineering

13
00:00:52,199 --> 00:00:55,050
team to build and put into production.

14
00:00:56,050 --> 00:01:03,190
About half a year ago I am I realized
that AI is good enough to estimate

15
00:01:03,310 --> 00:01:09,550
the time and I decided to work
on the implementation of AI into.

16
00:01:09,970 --> 00:01:12,850
Discovery and engineering workflows.

17
00:01:13,350 --> 00:01:20,150
So the solution that I've built internally
in the company I work at is a predictive

18
00:01:20,150 --> 00:01:22,550
pipeline that estimates delivery time.

19
00:01:23,355 --> 00:01:30,585
So before the coding is done, the
discovery team come to meet a delivery

20
00:01:30,585 --> 00:01:37,304
team and they can discuss the time it is
gonna take for the feature to be coded

21
00:01:37,394 --> 00:01:39,434
and delivered, put into production.

22
00:01:39,895 --> 00:01:47,415
So before we could only use engineers
knowledge to estimate it and also the.

23
00:01:47,640 --> 00:01:52,309
Past Jira sprints to
correct their estimation.

24
00:01:52,339 --> 00:01:57,379
But now we can use AI to estimate
these discovery documents.

25
00:01:57,649 --> 00:02:04,379
And also this tools helps developers
because when developer commits something

26
00:02:04,839 --> 00:02:11,679
the AI gives feedback on every commit
and every PR and, if engineers find the

27
00:02:11,679 --> 00:02:17,259
information useful, he doesn't have to
wait for the review by another engineer.

28
00:02:17,289 --> 00:02:24,170
He can just work on the AI review and
make changes to the code and commit again.

29
00:02:24,670 --> 00:02:29,009
So the architecture is the first
step is feature extraction.

30
00:02:29,309 --> 00:02:33,734
The we provide the Git history and to.

31
00:02:34,644 --> 00:02:38,284
AI model that then analyzes this.

32
00:02:38,344 --> 00:02:42,644
And also it uses rug retrieval
to see the past work.

33
00:02:42,974 --> 00:02:48,524
And if it can relate the new feature
to one of the previous features,

34
00:02:49,004 --> 00:02:54,924
then the estimation is gonna be
better than LLM analysis step where.

35
00:02:55,424 --> 00:03:01,094
It reasons about complexity, risk
factors, and then it outputs the

36
00:03:02,054 --> 00:03:07,614
the key findings that are the time
estimation with confidence, risk

37
00:03:07,614 --> 00:03:10,074
scores, and actionable recommendations.

38
00:03:10,574 --> 00:03:18,024
For this demo, I built, the pipeline from
scratch and it's not production ready.

39
00:03:18,584 --> 00:03:23,294
So if you want to use this tool
that I'm talking about you can't put

40
00:03:23,294 --> 00:03:25,874
it into production straight away.

41
00:03:25,964 --> 00:03:27,704
You'll have to build on it.

42
00:03:28,329 --> 00:03:29,819
To make it production ready.

43
00:03:29,879 --> 00:03:36,719
I didn't use the tool that we use in
the company and also the repository.

44
00:03:36,869 --> 00:03:40,979
I've participated in hackathon
two months ago and I decided to

45
00:03:40,979 --> 00:03:46,469
take this hackathon repository as
an example to deliver this demo.

46
00:03:47,079 --> 00:03:49,120
The project I worked on it.

47
00:03:49,999 --> 00:03:53,029
It is made out of three different
repositories, the backend, the

48
00:03:53,029 --> 00:03:55,219
front end, and the smart contract.

49
00:03:55,219 --> 00:03:57,259
It's what was a Web3 hackathon?

50
00:03:57,759 --> 00:04:03,690
Study code analysis the first step
AI gives us the number of files,

51
00:04:03,690 --> 00:04:08,519
lines of code, complexity and risk
score of each of these repositories.

52
00:04:09,020 --> 00:04:13,620
So the backend is an SJS and
Postgres, and it has a good

53
00:04:13,620 --> 00:04:16,190
architecture and risk is very low.

54
00:04:16,550 --> 00:04:21,510
The front end I use coco game Engine
and and, in this environment you have

55
00:04:21,510 --> 00:04:26,159
to manually connect UI to scripts
and do something on the scene.

56
00:04:26,549 --> 00:04:29,830
And AI is not very good
at understanding that.

57
00:04:29,859 --> 00:04:31,770
So this the risk is higher.

58
00:04:32,129 --> 00:04:37,890
For example, if I use React as a front
end, then it would be 15, 20 points lower,

59
00:04:38,369 --> 00:04:44,370
probably if the code was written in like
with a good architecture and et cetera.

60
00:04:44,870 --> 00:04:51,099
So the next step is when Discovery
team comes to you and asks you how long

61
00:04:51,099 --> 00:04:53,849
it's gonna take to build this feature.

62
00:04:54,349 --> 00:05:01,710
So instead of talking to developers
and going to meetings the product

63
00:05:01,710 --> 00:05:04,770
manager, like marketing product
manager, can use this tool.

64
00:05:05,270 --> 00:05:11,925
And they just write down the task they
want, like the what, the feature that

65
00:05:11,925 --> 00:05:14,805
they want the delivery team to deliver.

66
00:05:15,645 --> 00:05:22,185
And then AI find similar past work and
analyzes it and gives like the estimation,

67
00:05:22,335 --> 00:05:25,635
estimated time, then complexity.

68
00:05:25,935 --> 00:05:31,110
So moderate complexity because
it involves backend front end.

69
00:05:31,610 --> 00:05:37,480
And also it's advise here the
query optimization, then the risk.

70
00:05:38,050 --> 00:05:39,350
It's not a high risk.

71
00:05:39,860 --> 00:05:46,690
Then this rack for retrieval for
previous features that are somewhat

72
00:05:46,690 --> 00:05:49,600
similar and some recommendations.

73
00:05:50,100 --> 00:05:52,140
So that's the first part of it.

74
00:05:52,640 --> 00:05:56,300
Now we're moving on to the
second part is the code review.

75
00:05:57,065 --> 00:05:59,975
For example, like this,
commit with NFT service.

76
00:06:00,045 --> 00:06:03,585
Not gonna go through the code again
at the end of the presentation.

77
00:06:03,585 --> 00:06:04,425
I have links.

78
00:06:04,485 --> 00:06:05,655
You can have a look at it.

79
00:06:06,405 --> 00:06:09,215
But yeah, it's not very well written.

80
00:06:09,335 --> 00:06:17,115
I used actually some AI to write it,
and now AI is running the analysis.

81
00:06:17,615 --> 00:06:18,785
It reviews the code.

82
00:06:19,175 --> 00:06:21,845
And here is, here are the insights.

83
00:06:22,775 --> 00:06:27,455
So risk score is high, and quality
is low, changes are needed.

84
00:06:27,585 --> 00:06:28,845
Here is the summary.

85
00:06:28,965 --> 00:06:32,355
We have critical security
issues and lots of warnings.

86
00:06:32,855 --> 00:06:40,175
So in production, if AI score is higher
than 50% or quality is lower than 50%,

87
00:06:40,955 --> 00:06:48,535
then the team leads, they get notification
and also the stakeholders, they know

88
00:06:48,535 --> 00:06:53,854
about it and they're gonna ask about
it during the demo of the feature.

89
00:06:54,354 --> 00:07:01,175
So engineer is likely go and work
more on this feature but maybe

90
00:07:01,205 --> 00:07:07,205
0.1% of the time around like
that certainty AI gets something.

91
00:07:07,715 --> 00:07:08,195
Wrong.

92
00:07:08,795 --> 00:07:15,864
And if engineer actually proves that
AI made a mistake, then can go on

93
00:07:15,925 --> 00:07:21,984
with the feature and just ignore ai,
then we'll have to fine tune the ai.

94
00:07:22,135 --> 00:07:29,884
So it does make this mistake again
but it is 100% worth it because 99.9%

95
00:07:29,884 --> 00:07:31,774
of the time, AI gets things right.

96
00:07:32,465 --> 00:07:38,695
And after we train it more and
more, it gets even better accuracy.

97
00:07:38,875 --> 00:07:41,345
So this is pretty accurate.

98
00:07:41,845 --> 00:07:43,945
Let's go on to the next example.

99
00:07:44,035 --> 00:07:46,705
So here is the bed code example.

100
00:07:46,765 --> 00:07:52,135
I'm just gonna run it for AI to analyze
and meanwhile we can have a look.

101
00:07:52,765 --> 00:07:55,825
It has like secret, key exposed hardcoded.

102
00:07:56,325 --> 00:07:56,745
Then.

103
00:07:57,540 --> 00:08:02,140
No input, validation, then
like command injection.

104
00:08:02,640 --> 00:08:06,140
Both bypass, so lots of
issues with this code.

105
00:08:06,530 --> 00:08:11,350
And yeah AI runs the
analysis and say 100% risk.

106
00:08:11,530 --> 00:08:14,229
It's unsafe for production.

107
00:08:14,529 --> 00:08:18,459
It's very low quality changes
needed, obviously critical warnings.

108
00:08:18,459 --> 00:08:19,119
Security.

109
00:08:19,119 --> 00:08:19,839
Security.

110
00:08:20,339 --> 00:08:20,519
Yeah.

111
00:08:20,519 --> 00:08:24,619
So if you get this code into
production, it's gonna be a nightmare.

112
00:08:25,119 --> 00:08:25,419
Yeah.

113
00:08:25,919 --> 00:08:31,599
Also we can, as I mentioned before, we
can compare the AI estimations to actual

114
00:08:32,229 --> 00:08:34,449
time it took to deliver the feature.

115
00:08:34,949 --> 00:08:38,174
So it's in this demo, it's simple.

116
00:08:38,204 --> 00:08:40,994
It filters the eight hour gaps.

117
00:08:41,474 --> 00:08:46,754
So during the nighttime when
developer was sleeping, it kind of

118
00:08:46,754 --> 00:08:51,164
filters these gaps and then counts
everything else as the working time.

119
00:08:51,674 --> 00:08:52,994
And based on.

120
00:08:53,759 --> 00:08:59,060
This and based on like comments
and when the feature, when the

121
00:08:59,060 --> 00:09:03,800
work on the feature was stopped, it
can give pretty accurate estimate.

122
00:09:04,579 --> 00:09:07,379
And as you can see, it
gets everything right.

123
00:09:07,879 --> 00:09:09,469
Apart from backend setup.

124
00:09:09,979 --> 00:09:10,459
Yeah.

125
00:09:10,494 --> 00:09:15,129
But because it was done with the
help of ai, it went much faster.

126
00:09:15,629 --> 00:09:20,449
So to summarize what we built we built ai.

127
00:09:20,550 --> 00:09:26,609
We built a tool that uses AI to
extract features from Git history.

128
00:09:27,209 --> 00:09:30,680
Then it can analyze the code.

129
00:09:31,129 --> 00:09:34,449
It uses rack to retrieve the.

130
00:09:35,229 --> 00:09:39,009
Previous features and compare
them to the new feature.

131
00:09:39,280 --> 00:09:44,309
It uses estimation LLM, powered
Estimation and Code Review

132
00:09:45,239 --> 00:09:47,169
detects code vulnerability.

133
00:09:47,949 --> 00:09:50,429
And yeah, that's about it.

134
00:09:50,649 --> 00:09:55,250
In terms of results, when the
team started using this tool.

135
00:09:55,750 --> 00:10:01,820
We got delivery estimates
up to 80% from 60%.

136
00:10:02,180 --> 00:10:04,600
So that's a lot.

137
00:10:05,170 --> 00:10:11,410
And we can catch security issues
before merge and PMs can prioritize

138
00:10:11,410 --> 00:10:16,470
tasks themself without doing long
meetings with delivery teams.

139
00:10:17,425 --> 00:10:24,285
Also it helps engineers to work because
they can see something that AI advises

140
00:10:24,285 --> 00:10:27,225
that's probably they didn't think about.

141
00:10:27,525 --> 00:10:32,285
And it saves time of other
engineers who have to review this

142
00:10:32,285 --> 00:10:35,485
code because in general, prs they.

143
00:10:36,250 --> 00:10:39,310
Became much better after
this tool was used.

144
00:10:39,760 --> 00:10:45,250
And in terms of tech Stack, we, for
this demo use Python Fast, API, chroma

145
00:10:45,250 --> 00:10:50,160
DB and Cloud API, and we use pretty
much the same thing in production.

146
00:10:50,490 --> 00:10:57,440
Yeah, it's just the code quality and
security is better in our production

147
00:10:57,500 --> 00:11:00,125
than in this demo, but the basis are.

148
00:11:00,800 --> 00:11:01,460
The same.

149
00:11:01,960 --> 00:11:03,310
So thank you very much.

150
00:11:03,340 --> 00:11:07,640
Here you can see GitHub
repository of this demo.

151
00:11:08,150 --> 00:11:13,010
You can run it with git clone, just copy
and paste this inside your terminal.

152
00:11:13,950 --> 00:11:20,590
But also you'll have to use the
cloud API key or open rotor, API key.

153
00:11:20,850 --> 00:11:23,940
Otherwise the LLM is not gonna work.

154
00:11:24,885 --> 00:11:26,655
Thank you so much for your time.

155
00:11:26,745 --> 00:11:28,215
I hope it was useful.

156
00:11:28,995 --> 00:11:29,355
Bye.

