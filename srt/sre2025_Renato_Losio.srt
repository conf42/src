1
00:00:00,500 --> 00:00:01,370
Hi everyone.

2
00:00:01,610 --> 00:00:09,260
My name is cio and today I would like
to tell you my story As a known database

3
00:00:09,260 --> 00:00:14,510
administrator running managed databases
on the cloud, specific AWS for Rob.

4
00:00:15,010 --> 00:00:16,090
I will share my.

5
00:00:16,720 --> 00:00:24,780
Mistakes, my hard challenges and
hopefully as well some lesson and

6
00:00:24,780 --> 00:00:26,460
some things to learn along the way.

7
00:00:26,960 --> 00:00:31,160
Quick agenda, I will give you a
brief review of my how D has journey

8
00:00:31,160 --> 00:00:32,810
so far, why that is important.

9
00:00:32,810 --> 00:00:37,370
Why does that help to understand
what I will explain later on, I

10
00:00:37,370 --> 00:00:41,720
will show some interesting cases
and by cases mean support cases.

11
00:00:42,635 --> 00:00:46,175
I'll discuss some challenges,
hopefully as well, some solutions.

12
00:00:47,105 --> 00:00:51,365
And I will go through some, what
I call super simple experiment.

13
00:00:51,365 --> 00:00:54,785
I wouldn't call them benchmarks, but
something to give an idea about how

14
00:00:54,785 --> 00:00:57,785
to run our DS and manage databases.

15
00:00:58,145 --> 00:00:59,795
And we'll recap with some lesson learned.

16
00:01:00,185 --> 00:01:03,185
But before starting, I would
like to remember you one number,

17
00:01:03,435 --> 00:01:04,575
a hundred thousand record.

18
00:01:04,575 --> 00:01:05,730
Think about how you can.

19
00:01:06,180 --> 00:01:08,880
Store a hundred thousand record databases.

20
00:01:08,880 --> 00:01:13,200
Sounds like a very simple
task, but how do you do it?

21
00:01:13,620 --> 00:01:15,840
How long does it take milliseconds?

22
00:01:15,930 --> 00:01:17,340
10 seconds, one minute.

23
00:01:18,240 --> 00:01:18,780
Who knows?

24
00:01:19,170 --> 00:01:20,040
Depends how you do it.

25
00:01:20,370 --> 00:01:21,870
We'll see that later on.

26
00:01:22,120 --> 00:01:26,410
My RDS journey so far, I've been
running databases on the cloud

27
00:01:26,410 --> 00:01:28,630
for over a decade, since 2011.

28
00:01:29,400 --> 00:01:31,890
That makes me old,
doesn't make me an expert.

29
00:01:32,200 --> 00:01:35,800
I've been mostly running
my databases on Amazon.

30
00:01:35,800 --> 00:01:41,230
RDS, Amazon DS is a service that was
introduced by Amazon just about, yeah,

31
00:01:41,230 --> 00:01:45,650
15 years ago now this is the post that
Jeff Barr published in October, 2009.

32
00:01:46,050 --> 00:01:48,960
That's almost the entire post
that give you a really, an idea.

33
00:01:48,960 --> 00:01:50,250
What was at that time.

34
00:01:50,250 --> 00:01:54,690
Are this a very simple database
compatible with my SQL 5.2.

35
00:01:54,855 --> 00:02:00,455
One back in 2011 when it started, so
not long after it was announced the key

36
00:02:00,455 --> 00:02:02,435
part of the service were simplicity.

37
00:02:02,945 --> 00:02:04,384
There was not much to choose.

38
00:02:04,384 --> 00:02:09,095
We see that later on what the benefits
and what the limitation of that are.

39
00:02:09,305 --> 00:02:13,405
There were of course, a lot of
constraints and when we talk about once

40
00:02:13,405 --> 00:02:18,755
upon a time and a good time when the
cloud was simpler we tend to forget

41
00:02:18,755 --> 00:02:20,210
that was very much more expensive.

42
00:02:20,315 --> 00:02:20,765
At that time.

43
00:02:20,825 --> 00:02:23,435
So anyway, what was the feature?

44
00:02:23,435 --> 00:02:24,785
What, why?

45
00:02:25,085 --> 00:02:28,385
First of all, I started
to use managed databases.

46
00:02:28,435 --> 00:02:32,455
I was, and I'm still
somehow a software engineer.

47
00:02:32,455 --> 00:02:34,525
I started as a Java software developer.

48
00:02:34,945 --> 00:02:40,135
I was familiar with web application,
java, web application but databases.

49
00:02:40,165 --> 00:02:41,365
Yeah, I was using them.

50
00:02:41,905 --> 00:02:46,135
Was I able to install my SQR
postcards on my machine or run one?

51
00:02:46,195 --> 00:02:47,185
Yes, definitely.

52
00:02:47,685 --> 00:02:50,505
Was I able to manage a cluster?

53
00:02:50,565 --> 00:02:51,105
Absolutely.

54
00:02:51,105 --> 00:02:51,315
No.

55
00:02:51,315 --> 00:02:53,385
I had no idea how to do failovers.

56
00:02:53,385 --> 00:02:54,375
I had no idea.

57
00:02:54,435 --> 00:02:56,614
I was scared about full tolerance.

58
00:02:56,614 --> 00:03:00,415
I had no idea how to
manage a, active master.

59
00:03:00,535 --> 00:03:03,595
How to do a failover,
how to manage a replica.

60
00:03:03,864 --> 00:03:09,804
What actually, even at that time, I
dunno, a delay on replication meant so.

61
00:03:10,690 --> 00:03:14,030
What was the feature that drove
me to move to the cloud was multi

62
00:03:14,215 --> 00:03:18,019
Z. Multi Z was a very simple
feature conceptually from Amazon.

63
00:03:18,019 --> 00:03:22,070
RDS was the idea that here is your
endpoint, a c name, that's your

64
00:03:22,070 --> 00:03:27,560
my Sqr instance, and behind the
scene we do the failover for you.

65
00:03:27,859 --> 00:03:30,140
The replication is done
for you out of the box.

66
00:03:30,170 --> 00:03:32,000
You can have backups, you
can have whatever you.

67
00:03:32,595 --> 00:03:37,335
Whatever you want out of the box that
drove me and many other people to the

68
00:03:37,335 --> 00:03:39,915
cloud and to use managed databases on RDS.

69
00:03:40,545 --> 00:03:44,115
When I say that the good of time when
there were many, not many choices

70
00:03:44,145 --> 00:03:48,075
were, is rather more expensive time,
was that even without considering that

71
00:03:48,075 --> 00:03:52,575
the new latest systems are much, much
better as processor than the old one.

72
00:03:52,915 --> 00:03:55,615
The benefits are well
beyond the just the price.

73
00:03:56,285 --> 00:03:58,475
You can see that even the price
of an instance, if you can

74
00:03:58,475 --> 00:03:59,675
see an extra large instance.

75
00:03:59,960 --> 00:04:02,240
Went down along the time.

76
00:04:02,240 --> 00:04:07,990
So IM seven G instance is actually cheaper
than an M1 instance over a decade ago,

77
00:04:08,290 --> 00:04:09,910
and it's definitely much more performant.

78
00:04:10,510 --> 00:04:17,955
So when I say there were many limitations,
I means that in 2011 was somehow simple.

79
00:04:18,060 --> 00:04:22,170
The job of a cloud architect,
somehow it's much better for you now.

80
00:04:22,530 --> 00:04:26,460
If you start now or if you work now on the
cloud, because you have many options with

81
00:04:26,460 --> 00:04:30,450
many options, have a lot of responsibility
in your choices at that time once you have

82
00:04:31,050 --> 00:04:33,150
made the decision to move to the cloud.

83
00:04:33,250 --> 00:04:34,030
It was pretty simple.

84
00:04:34,030 --> 00:04:38,830
There was just my SQL it was just
one engine with 5.1 and no much else.

85
00:04:38,830 --> 00:04:40,450
There was no A ranges.

86
00:04:40,450 --> 00:04:43,180
There were no process,
no SQL, no Maria db.

87
00:04:43,600 --> 00:04:48,070
And actually many people think that
I'm not an expert, but I'm a big

88
00:04:48,070 --> 00:04:50,140
sport, a big fan of my SQL actually.

89
00:04:50,620 --> 00:04:53,950
When I moved to the cloud, I
was running a posts database.

90
00:04:53,950 --> 00:04:58,960
I moved to Mascar to be able to
have a managed service on a, on AWS.

91
00:04:59,140 --> 00:05:01,645
That time there was no
choice on storage class.

92
00:05:01,825 --> 00:05:04,705
There was no GP P two, no GP
three, no provision io no i,

93
00:05:04,705 --> 00:05:06,655
O one, IO two or whatever.

94
00:05:06,955 --> 00:05:08,665
You had magnetic and that was it.

95
00:05:08,735 --> 00:05:11,855
You were paying for how many operation
you were doing on the storage,

96
00:05:12,635 --> 00:05:13,685
and of course there were no fees.

97
00:05:13,685 --> 00:05:15,845
Like of course there was no
Amazon Aurora at that time.

98
00:05:15,845 --> 00:05:19,420
There was no performance in size, so
no, no advanced money, no kind of.

99
00:05:19,780 --> 00:05:24,550
Previous feature that you used to
find just on the that you were not

100
00:05:24,550 --> 00:05:26,080
used to find in the communication.

101
00:05:26,580 --> 00:05:30,740
So the very first lesson of this talk
that you should take on is with you, is

102
00:05:31,010 --> 00:05:33,450
keep iterating keep yourself up to date.

103
00:05:33,780 --> 00:05:35,490
We love to go to reinvent.

104
00:05:35,490 --> 00:05:39,760
We had a big conference, not just
on AWS and even clap when they do

105
00:05:39,760 --> 00:05:41,770
announcement of new cool features.

106
00:05:42,040 --> 00:05:45,430
Reality is that's the moment when your
deployment might become a bit obsolete.

107
00:05:45,820 --> 00:05:50,410
I'm not saying change immediately,
but roof time after two, three years,

108
00:05:50,410 --> 00:05:53,140
you haven't changed anything on
your deployment, on your database.

109
00:05:53,290 --> 00:05:54,460
Probably are missing out.

110
00:05:54,490 --> 00:05:56,680
I'm not saying it's more
expensive than before.

111
00:05:56,890 --> 00:06:00,520
It's just that as a cloud architect
is your goal to keep yourself

112
00:06:00,520 --> 00:06:03,790
up to date and take advantage
of new feature and reduce costs.

113
00:06:04,290 --> 00:06:08,100
I would like to now move to some
what I call interesting cases.

114
00:06:08,160 --> 00:06:12,030
I call them cases because they're
actually AWS support cases.

115
00:06:12,530 --> 00:06:12,860
Big.

116
00:06:12,910 --> 00:06:13,390
What here?

117
00:06:13,690 --> 00:06:16,600
Those are 10 cases that
I opened myself on.

118
00:06:16,640 --> 00:06:18,740
The AWS support using tickets.

119
00:06:19,190 --> 00:06:23,720
Some of them come from having enterprise
support, some other with business support,

120
00:06:23,720 --> 00:06:24,950
some other with developer support.

121
00:06:25,400 --> 00:06:26,840
Actually, it doesn't matter that much.

122
00:06:27,170 --> 00:06:28,880
I just want to use them as an example.

123
00:06:29,060 --> 00:06:34,345
And the very second lesson I want to
share is I think interacting with AWS

124
00:06:34,345 --> 00:06:40,665
Apple has been one of the biggest way
I've learned using and the service

125
00:06:40,665 --> 00:06:42,315
and as well the limitation of service.

126
00:06:43,275 --> 00:06:48,095
The subject are actually as they
were I removed the case number, but.

127
00:06:48,815 --> 00:06:52,685
You can see quickly scanning through
them is, some of them are issues.

128
00:06:52,685 --> 00:06:57,065
So I reported issue, I don't know,
the replica was broken after scaling

129
00:06:57,065 --> 00:07:03,425
up, or, I dunno the RDS was stuck
in storage optimization, 99% for

130
00:07:03,425 --> 00:07:05,045
almost 24 hours or whatever else.

131
00:07:05,045 --> 00:07:07,655
But some of them are actually,
you can see I've just questioned

132
00:07:08,195 --> 00:07:13,175
the roadmap, minor roadmap versus
the years of Amazon Aurora, or.

133
00:07:13,425 --> 00:07:18,025
Build on transaction compression support
for Linda to be redo log capacity.

134
00:07:18,325 --> 00:07:20,365
And those question, why do I open them?

135
00:07:20,435 --> 00:07:22,175
Because it's not just to have information.

136
00:07:22,175 --> 00:07:24,245
They help you as well to drive decision.

137
00:07:24,635 --> 00:07:25,595
What do we mean by that?

138
00:07:25,595 --> 00:07:29,585
I mean that if you have an idea how
you're gonna change your database also

139
00:07:29,615 --> 00:07:33,425
for storage operation, that might be hard
to revert and might take a lot of time.

140
00:07:33,925 --> 00:07:37,585
Throw, write down your idea and how
you're gonna do it and the doubts you

141
00:07:37,585 --> 00:07:39,385
have, and double check with support.

142
00:07:39,385 --> 00:07:43,525
If they see an issue sometime, I'm not
saying ask them, oh, how do I do that?

143
00:07:43,525 --> 00:07:47,395
I'm just saying, give what you have
in mind to do and check if there's

144
00:07:47,395 --> 00:07:49,495
something wrong that they can help a lot.

145
00:07:49,915 --> 00:07:54,635
And as well, maybe you say, okay, there's
no transaction compression support that

146
00:07:54,635 --> 00:07:56,075
is available in the community edition.

147
00:07:56,629 --> 00:07:58,070
Okay, it's not there in R Ds.

148
00:07:58,120 --> 00:08:01,059
You can open a case and just advocate
that they're gonna have it, but as well,

149
00:08:01,059 --> 00:08:02,829
you can ask, okay, then it's not there.

150
00:08:03,429 --> 00:08:04,150
How can I achieve that?

151
00:08:04,179 --> 00:08:06,069
How can I reduce the size of my binary?

152
00:08:06,069 --> 00:08:10,270
There are other ways, of course
there's not gonna be compression, but

153
00:08:10,299 --> 00:08:11,679
maybe they help you in other ways.

154
00:08:12,189 --> 00:08:16,120
So let's go to some challenges.

155
00:08:16,120 --> 00:08:16,689
A solution.

156
00:08:17,190 --> 00:08:20,164
Let's take some of those cases
that we say a few seconds ago.

157
00:08:20,414 --> 00:08:21,839
First one is.

158
00:08:22,339 --> 00:08:25,729
I said, when you play with a
managed database, you have to

159
00:08:25,729 --> 00:08:27,894
think about storage on Aurora.

160
00:08:27,954 --> 00:08:29,304
That's pretty simple.

161
00:08:29,554 --> 00:08:31,145
You pay for the storage,
you use, you have not.

162
00:08:31,834 --> 00:08:33,484
To allocate anything, so that's cool.

163
00:08:33,604 --> 00:08:34,650
That's no brainer.

164
00:08:35,069 --> 00:08:36,390
What do you do on RDS?

165
00:08:36,479 --> 00:08:38,880
On RDS, you allocate the storage up front.

166
00:08:39,180 --> 00:08:40,860
You decide on what storage you want.

167
00:08:40,930 --> 00:08:43,480
It might impact how many
I oaks you have upfront.

168
00:08:43,480 --> 00:08:46,690
For example, on GP three, if
there's storage, the size of

169
00:08:46,690 --> 00:08:48,820
this is below 400 gigabyte.

170
00:08:49,170 --> 00:08:50,820
You have 3000 iops.

171
00:08:51,250 --> 00:08:52,840
If you're above, you have 12,000.

172
00:08:52,840 --> 00:08:56,140
But there are many different combination,
but generally you're just thinking about

173
00:08:56,140 --> 00:09:00,070
how much storage you need, how much free
storage I need to avoid to fill up my

174
00:09:00,070 --> 00:09:02,350
disc, can end up that my database crashes.

175
00:09:02,660 --> 00:09:06,540
One is the option is to
enable out scale storage.

176
00:09:06,540 --> 00:09:08,700
It's been there for a few
years and that's cool.

177
00:09:08,730 --> 00:09:12,330
When you go below 10% for the
storage is cased automatically.

178
00:09:13,070 --> 00:09:15,080
The problem with that is
pretty hard to go back.

179
00:09:15,260 --> 00:09:18,440
Actually until recently, there
was no real easy way to go back.

180
00:09:18,800 --> 00:09:23,750
Now you can do some blue, green and
re reduce the storage, but it still

181
00:09:23,750 --> 00:09:28,880
requires some significant work because
you need to create the BlueLine

182
00:09:29,180 --> 00:09:31,800
and you need to swap the point.

183
00:09:31,800 --> 00:09:36,240
So it's still not a easy task for
large database, but this is an example.

184
00:09:37,165 --> 00:09:40,165
There are two terabyte
of free storage is a lot.

185
00:09:40,345 --> 00:09:40,945
It's little.

186
00:09:40,945 --> 00:09:41,845
Why did it jump?

187
00:09:41,975 --> 00:09:48,355
It jumped there because I did a mistake
to go to do a optimize of a large table,

188
00:09:48,445 --> 00:09:53,690
or you can as well do an altar table
that requires a copy of your, so that is

189
00:09:53,690 --> 00:09:57,985
not a in place that you're copying the
data from your old table to the new one.

190
00:09:58,495 --> 00:10:01,975
And what happened is my outer
scaling was initiated on my instance

191
00:10:02,515 --> 00:10:03,775
was the implication of that.

192
00:10:03,775 --> 00:10:04,375
That basically.

193
00:10:04,945 --> 00:10:10,515
That's a rocky mistake that the moment
you're doing something very intensive

194
00:10:10,515 --> 00:10:15,195
from the database that is modify your
schema or change your data, the last

195
00:10:15,195 --> 00:10:19,365
thing you want is that first that you
increase the free storage that you might

196
00:10:19,365 --> 00:10:23,355
not need because maybe that ten three
percent that you had was good enough.

197
00:10:23,775 --> 00:10:24,795
And secondly is.

198
00:10:25,155 --> 00:10:28,035
You're doing an operation that is very
heavy on iops and you are actually

199
00:10:28,035 --> 00:10:32,955
triggering a system operation that is
applying changes to the storage that is

200
00:10:32,955 --> 00:10:34,815
actually consuming your IOPS as well.

201
00:10:35,115 --> 00:10:37,185
So that's the full first lesson I learned.

202
00:10:37,185 --> 00:10:40,005
The other way was disable out scaling.

203
00:10:40,005 --> 00:10:44,595
Anytime you do some optimization on
some methods, so your database anyway.

204
00:10:45,095 --> 00:10:49,325
You may wonder, apart from application
reason, why do I, how and why I want to

205
00:10:49,325 --> 00:10:51,905
do an al alter optimize an email DB table.

206
00:10:51,965 --> 00:10:56,465
We'll come back to why I want to
optimize a table in a second to recover

207
00:10:56,465 --> 00:10:58,145
storage and why is that important?

208
00:10:58,145 --> 00:11:01,565
But how do you do a AL
table or optimize as well?

209
00:11:01,825 --> 00:11:05,245
You have different, you can do
an alter table using the engine.

210
00:11:05,305 --> 00:11:08,125
So on my sqr, I can do
alter table, whatever.

211
00:11:08,500 --> 00:11:09,405
Change the way I want.

212
00:11:09,790 --> 00:11:12,940
I can as well use third party tool
that sometime allow me to control

213
00:11:12,940 --> 00:11:16,760
better how I do it in term of
load on the production database.

214
00:11:16,760 --> 00:11:19,820
So I might want to do it in a
slower way, but it affects less the

215
00:11:19,820 --> 00:11:21,710
production or that is recoverable.

216
00:11:21,710 --> 00:11:24,880
So for example, pera PT
online schema changes.

217
00:11:24,880 --> 00:11:28,690
Part of the per toolkit is perfect
for that, but there are other option

218
00:11:28,690 --> 00:11:29,980
in the open source world as well.

219
00:11:30,480 --> 00:11:31,770
The key questions as well.

220
00:11:31,770 --> 00:11:35,160
Being on the cloud where there are so
many options, where do I do my change?

221
00:11:35,250 --> 00:11:38,430
I might do it on the primary node is
a small table or I want to take the

222
00:11:38,430 --> 00:11:40,560
risk, or I want a simple approach.

223
00:11:40,560 --> 00:11:41,550
Simple approaches.

224
00:11:41,850 --> 00:11:47,250
Go on the database on my multi z, go on
the connect to the primary node and do

225
00:11:47,370 --> 00:11:50,340
alter table that has some disadvantage.

226
00:11:50,640 --> 00:11:55,460
If that might kill my database,
I might be able to roll back,

227
00:11:56,060 --> 00:11:57,170
may have some challenges.

228
00:11:57,380 --> 00:11:58,880
Second approach is.

229
00:11:59,810 --> 00:12:01,190
Create a replica node.

230
00:12:01,280 --> 00:12:06,420
If the change I'm applying for for
example, adding a column is compatible

231
00:12:06,420 --> 00:12:11,490
with the replication, I might stop the
replication, apply the change on the

232
00:12:11,730 --> 00:12:17,290
replica, re-enable replication, and then
at the end do the swap of the endpoint.

233
00:12:18,040 --> 00:12:22,190
That's much safer, a bit more
complex with a lot of flexibility.

234
00:12:22,595 --> 00:12:26,015
Or I can do it with Amazon, RDS
Bluegreen, something that's been

235
00:12:26,015 --> 00:12:27,125
around now for a couple of years.

236
00:12:27,125 --> 00:12:30,005
That is a wrap around my
replica note approach.

237
00:12:30,215 --> 00:12:32,285
That is basically you
have a blue and a green.

238
00:12:32,465 --> 00:12:34,915
You decide to do changes on your own.

239
00:12:35,165 --> 00:12:36,755
Green deployment, and then you swap.

240
00:12:36,785 --> 00:12:37,685
That's cool as well.

241
00:12:37,930 --> 00:12:41,790
The end result is that the free storage
space you have might change a lot if

242
00:12:41,790 --> 00:12:44,310
you do alter table and optimization.

243
00:12:44,640 --> 00:12:46,440
And remember how much storage you need.

244
00:12:46,540 --> 00:12:48,100
It's not just the storage of the table.

245
00:12:48,100 --> 00:12:50,710
You are copying that, so at
least that extra storage.

246
00:12:50,710 --> 00:12:53,800
So if you have a large table of
one terabyte on a database of

247
00:12:53,800 --> 00:12:55,090
three terabyte means that you need.

248
00:12:55,675 --> 00:12:58,135
Quite some free storage on
that table to be able on that

249
00:12:58,135 --> 00:12:59,395
database to be able to do it.

250
00:12:59,635 --> 00:13:03,025
But as well, if you, for example,
stop the replica for a certain amount

251
00:13:03,025 --> 00:13:06,995
of time, you might build up a lot of
binary doc that you need to replicate.

252
00:13:06,995 --> 00:13:09,115
And that's that you need to apply.

253
00:13:09,115 --> 00:13:12,535
So it is on your replica, so you
might even need more storage.

254
00:13:12,535 --> 00:13:16,975
So consider front how much storage you
need for those changes and make sure

255
00:13:16,975 --> 00:13:21,055
that there's no automatic change in
storage while you apply those changes.

256
00:13:21,305 --> 00:13:23,975
Why do I say optimizing
your table is vital?

257
00:13:24,285 --> 00:13:27,585
One of the things you want to have a
managed database and what you love about

258
00:13:27,585 --> 00:13:32,775
managed databases that they are managed
so as well, backups are out of the box.

259
00:13:32,775 --> 00:13:34,005
There's nothing to be done.

260
00:13:34,155 --> 00:13:35,085
They are there.

261
00:13:35,205 --> 00:13:38,955
And even Amazon from day one tells you
how well up to a hundred percent of your

262
00:13:38,955 --> 00:13:40,695
total database storage for a region.

263
00:13:41,085 --> 00:13:42,225
It's free backup.

264
00:13:42,285 --> 00:13:43,575
That's nothing to be done.

265
00:13:43,735 --> 00:13:46,795
Our expert database means
they'll tell you the majority

266
00:13:46,795 --> 00:13:48,715
of customers don't pay anything.

267
00:13:49,415 --> 00:13:52,085
That's pretty much true
if you don't write a lot.

268
00:13:52,145 --> 00:13:56,695
And if you keep maybe one, two days
of point in time recovery, if you

269
00:13:56,695 --> 00:14:01,165
have a backup point in time, recovery
of 30, 35 days, that is the maximum.

270
00:14:01,385 --> 00:14:02,585
You might start to pay for that.

271
00:14:02,795 --> 00:14:04,295
Actually, that's.

272
00:14:04,760 --> 00:14:08,600
Second lesson I want to share is
sometimes CPU is overestimated.

273
00:14:08,600 --> 00:14:09,380
It's overrated.

274
00:14:09,800 --> 00:14:14,240
I hear a lot of conversation at
a coffee machine at conferences

275
00:14:14,780 --> 00:14:18,520
where we discuss what's the best
instance class, what's the best CPU

276
00:14:18,520 --> 00:14:20,680
utilization for that specific workload.

277
00:14:20,900 --> 00:14:24,680
I have you already moved from
M six G to M seven G. Are you

278
00:14:24,680 --> 00:14:26,510
using our instance or whatever?

279
00:14:27,155 --> 00:14:30,335
How they hear people discussing,
or at least not as often people

280
00:14:30,335 --> 00:14:31,535
about storage and backup.

281
00:14:31,865 --> 00:14:34,415
This is an example of a production
database that I'm managing.

282
00:14:34,785 --> 00:14:38,580
You can see that it's a. In
three years, the CPU is going on.

283
00:14:38,640 --> 00:14:40,230
There's some reserve instance behind.

284
00:14:40,410 --> 00:14:44,480
It's a healthy project going up and
costs are going up because it's a

285
00:14:44,480 --> 00:14:46,490
healthy project that is growing.

286
00:14:46,550 --> 00:14:47,120
That's cool.

287
00:14:47,420 --> 00:14:51,380
But you can see that the CPU is not
even half of the total cost of your

288
00:14:51,530 --> 00:14:55,520
database and back up is significantly,
it's almost as costly as the CPU.

289
00:14:55,940 --> 00:14:57,110
And why is that significant?

290
00:14:57,110 --> 00:14:59,060
Because if you think about your cables.

291
00:14:59,315 --> 00:15:00,665
How a backup is done.

292
00:15:00,875 --> 00:15:03,455
Backup is a bit like
a snapshot on the EPS.

293
00:15:03,455 --> 00:15:05,745
There's no magic on our DS that's incre.

294
00:15:05,895 --> 00:15:07,005
Yes, it's incremental.

295
00:15:07,005 --> 00:15:08,565
The data backup is incremental.

296
00:15:08,565 --> 00:15:09,885
But what does it mean incremental?

297
00:15:10,245 --> 00:15:13,545
If your data is spread around your
table is not optimized once in a

298
00:15:13,545 --> 00:15:17,595
while, your data that you modify
every day maybe spread around.

299
00:15:17,595 --> 00:15:21,075
So at the end, your back
daily backup, that incremental

300
00:15:21,075 --> 00:15:23,955
might be a lot of incremental.

301
00:15:24,525 --> 00:15:27,515
So you can see here
that the daily gigabyte.

302
00:15:27,845 --> 00:15:29,525
Month, the usage you have.

303
00:15:29,705 --> 00:15:31,895
I think this one is a month by month view.

304
00:15:32,285 --> 00:15:33,035
Changed a lot.

305
00:15:33,035 --> 00:15:36,215
And those fluctuation and those
increase really depends as well on,

306
00:15:36,395 --> 00:15:40,305
of course on usage, but as well on
optimization done on the tables those

307
00:15:40,305 --> 00:15:42,705
fluctuation is after some optimization.

308
00:15:42,705 --> 00:15:48,345
And when you spend 6,000 euro month
on backup, maybe at 20% saving after

309
00:15:48,345 --> 00:15:52,425
some optimize or significant or one
2000 euro a month, you're saving.

310
00:15:53,145 --> 00:15:54,825
So next one.

311
00:15:55,680 --> 00:15:59,450
Graviton, this a provocative
tweet from Quin, I think

312
00:15:59,450 --> 00:16:00,980
you're all familiar with Cory.

313
00:16:01,430 --> 00:16:04,150
And the point is you're
using a managed database.

314
00:16:04,150 --> 00:16:09,280
Why do I care if he's running a Graviton
or Intel or whatever else behind?

315
00:16:10,090 --> 00:16:12,390
And it's provocative,
but it's a good point.

316
00:16:12,390 --> 00:16:13,800
It's an interesting one actually.

317
00:16:13,800 --> 00:16:17,460
I was a very early adopter of Graviton
and the reason why I was very.

318
00:16:18,315 --> 00:16:26,275
Every adopter of movie from M five Intel
to M six G on RDS for MySQL was that

319
00:16:26,695 --> 00:16:29,305
is with managed is incredibly simple.

320
00:16:29,455 --> 00:16:33,325
You don't have to think about if you need
to change the build the jar, whatever.

321
00:16:33,715 --> 00:16:38,425
Like with Lambda is, you just simply
have to switch in the console and if

322
00:16:38,425 --> 00:16:40,315
the new instance is cheaper, that's it.

323
00:16:40,315 --> 00:16:41,425
Nothing else to be done.

324
00:16:41,995 --> 00:16:43,645
They take care of the engine behind.

325
00:16:44,425 --> 00:16:45,295
Why don't you do it?

326
00:16:45,395 --> 00:16:48,345
You do it, but it's sometimes
it's not that straightforward.

327
00:16:48,605 --> 00:16:51,605
Here's a post that I wrote a few
years ago, how we were managing at

328
00:16:51,755 --> 00:16:56,855
that time, the outer scaling of RD
assistance in al, using a simple

329
00:16:56,855 --> 00:16:58,835
logic using patient command line.

330
00:16:59,135 --> 00:17:03,095
So basically using some matrix and
CloudWatch, we're deciding when was the

331
00:17:03,095 --> 00:17:09,465
time to scale up and down our RDS cluster
and go down according to time of the day.

332
00:17:09,705 --> 00:17:11,595
Memories, users, number of session.

333
00:17:11,625 --> 00:17:13,995
You build your own logic,
some matrix, and you do it.

334
00:17:14,265 --> 00:17:14,805
That's cool.

335
00:17:14,925 --> 00:17:15,735
Everything works.

336
00:17:16,275 --> 00:17:19,575
So now you switch to Graviton and that's.

337
00:17:20,115 --> 00:17:22,665
What I had at that time, you had a crush.

338
00:17:22,695 --> 00:17:22,995
Okay.

339
00:17:22,995 --> 00:17:25,275
If there's a crush,
that's not your problem.

340
00:17:25,305 --> 00:17:28,665
Of course there's a bag in the build,
so you open a ticket, you talk to

341
00:17:28,665 --> 00:17:32,745
Amazon, but at the end, what you
realize is that, yeah, it's true that

342
00:17:32,745 --> 00:17:35,025
moving to Graviton is transparent.

343
00:17:35,025 --> 00:17:35,535
It's free.

344
00:17:35,535 --> 00:17:39,105
But the challenge there was that,
yeah, that was a bug, but the main

345
00:17:39,105 --> 00:17:41,955
issue was that I was running out of
memory and why I was running outta

346
00:17:41,955 --> 00:17:45,315
memory is that because basically
in instances were very different.

347
00:17:45,975 --> 00:17:48,795
The ratio between memory and
number of CPU is different.

348
00:17:48,795 --> 00:17:53,295
So if, for example, you optimize my
questionable parameter, I call them the

349
00:17:53,755 --> 00:17:59,945
your parameter group to get out every
single benefit from your instance.

350
00:18:00,660 --> 00:18:03,810
You might reach the point of, on the
graviton behave slightly different.

351
00:18:04,360 --> 00:18:05,320
Here is an example.

352
00:18:05,440 --> 00:18:07,930
For example, here I optimize
certain things like the

353
00:18:07,930 --> 00:18:09,820
memory, the buffer pool size.

354
00:18:09,940 --> 00:18:12,460
I was a bit more aggressive,
probably is a good idea.

355
00:18:12,820 --> 00:18:17,945
But the message was to say is that what
happened in this scenario to me was that

356
00:18:18,185 --> 00:18:21,095
the optimization had in place for intel.

357
00:18:21,605 --> 00:18:25,025
Was perfectly fine to do my logic
of auto-scaling with the graviton.

358
00:18:25,025 --> 00:18:28,295
What happened day one was that I
reached the crash running outta

359
00:18:28,295 --> 00:18:30,695
memory before being able to scale.

360
00:18:31,005 --> 00:18:31,665
My instance.

361
00:18:31,785 --> 00:18:36,535
So lesson learned was
keep an eye on optimizing.

362
00:18:36,775 --> 00:18:39,775
When you optimize, minimize
changes to your parameter

363
00:18:39,775 --> 00:18:41,035
group, there's a limit between.

364
00:18:41,695 --> 00:18:43,975
Yes, you want to optimize, but
keep in mind that you might need

365
00:18:43,975 --> 00:18:48,115
to change the instance both in
size and class as a minimum.

366
00:18:48,115 --> 00:18:52,915
Keep the variable, keep the
changes you make as variable on the

367
00:18:52,915 --> 00:18:54,655
instances class memory at least.

368
00:18:54,955 --> 00:18:57,325
One more challenge, one
more things you have.

369
00:18:57,325 --> 00:19:02,665
You might think, okay, I want to make
a read from my SQL on RDS to Aurora.

370
00:19:02,815 --> 00:19:04,915
That's something we have all
done and we all love Aurora.

371
00:19:05,680 --> 00:19:06,490
So how do you do it?

372
00:19:06,540 --> 00:19:10,060
According to Amazon, in 10, 20
minutes, you learn how to do it with a

373
00:19:10,060 --> 00:19:14,800
intermediate exper experience, and you
know how to do it without any downtime.

374
00:19:15,040 --> 00:19:16,390
How do you actually do that?

375
00:19:16,720 --> 00:19:20,560
If you go and look at the video and if
you read documentation, the way you do

376
00:19:20,620 --> 00:19:23,650
those things is simply create a replica.

377
00:19:24,170 --> 00:19:27,800
The replica of RDS is an
number of replica, and then

378
00:19:27,800 --> 00:19:28,730
that's when you're ready.

379
00:19:28,730 --> 00:19:31,900
You just promote that is
your new primary easy.

380
00:19:32,400 --> 00:19:33,120
Any challenge here?

381
00:19:33,680 --> 00:19:35,930
The challenge is going
too fast, missing Aurora.

382
00:19:35,990 --> 00:19:38,420
That's what happened to me the
very first time I tried that.

383
00:19:38,450 --> 00:19:43,130
Just for the documentation can upgrade
my, this is an example, a more recent

384
00:19:43,130 --> 00:19:48,380
one from my SQL 8 0 39 to Aurora three.

385
00:19:48,890 --> 00:19:49,760
What's wrong there?

386
00:19:50,430 --> 00:19:54,840
Reality is that you have to think
how muscular or any basis release.

387
00:19:55,365 --> 00:19:56,955
There's a foundation for Postgres.

388
00:19:56,955 --> 00:20:01,155
There's a Oracle for my SQL that
release every once in a while, a

389
00:20:01,155 --> 00:20:02,775
minor version and a major version.

390
00:20:03,135 --> 00:20:06,695
My SQL is every quarter there's
a minor, and after a few

391
00:20:06,695 --> 00:20:08,855
weeks that minor is supported.

392
00:20:08,855 --> 00:20:14,025
Usually if there are no big bugs on
RDS, Aurora may take a bit longer.

393
00:20:14,115 --> 00:20:17,685
Aurora may be a few quarters
later that support that specific.

394
00:20:17,735 --> 00:20:19,115
Venture because that's a fork.

395
00:20:19,715 --> 00:20:24,165
And what you need to keep in mind is
that the replica you can create to

396
00:20:24,165 --> 00:20:31,365
RDS as Aurora need to be at least at
the same level of your primary RDS.

397
00:20:31,365 --> 00:20:36,315
So if you have a primary, it is 8 0 39,
you need our order that's post that.

398
00:20:36,675 --> 00:20:39,825
And if that Aurora is not out
yet, you are not able to migrate.

399
00:20:39,825 --> 00:20:44,865
So if you want to keep your production
database, always the option to migrate

400
00:20:44,985 --> 00:20:47,395
to Aurora to have that safety net.

401
00:20:47,485 --> 00:20:49,255
If you want to grow whatever reason.

402
00:20:49,675 --> 00:20:53,395
Remember, you cannot keep yourself
too close to the latest miner.

403
00:20:53,455 --> 00:20:55,825
You need to keep to the latest
minor supported by Aurora.

404
00:20:56,325 --> 00:20:59,665
Now, let's change topic from,
go from, cP manual release

405
00:20:59,665 --> 00:21:02,275
to RDS and running out iops.

406
00:21:02,635 --> 00:21:06,765
I wrote many blogs many one
that no one wrote, but still

407
00:21:06,765 --> 00:21:08,865
today the most popular blog.

408
00:21:08,865 --> 00:21:13,065
I have a blog post I have on
my own website.com is this one.

409
00:21:13,155 --> 00:21:14,025
RDS is running out.

410
00:21:14,265 --> 00:21:15,255
Iops, what can I do?

411
00:21:15,255 --> 00:21:17,025
I wrote it 68 years ago.

412
00:21:17,385 --> 00:21:20,735
Even if this one is out of,
it's absolutely relevant.

413
00:21:20,735 --> 00:21:22,415
Now, the content is not up to date.

414
00:21:22,565 --> 00:21:25,355
It's still the most popular because
it's a very challenged topic.

415
00:21:25,985 --> 00:21:31,895
So we're doing by running out of iops and
what I learned in this decade, first one,

416
00:21:31,895 --> 00:21:33,785
you tend to always underestimate iops.

417
00:21:33,815 --> 00:21:37,685
You always think you have enough,
you often eat the limit, whatever

418
00:21:37,685 --> 00:21:41,195
during an halter table, a scale
up exchange, optimization of

419
00:21:41,195 --> 00:21:43,765
your table a peak in your usage.

420
00:21:44,335 --> 00:21:47,365
The kind of newish was
not there many years ago.

421
00:21:47,415 --> 00:21:50,505
Total matrix is very useful,
but don't rely just on that one.

422
00:21:50,505 --> 00:21:54,645
The total EOPS is give you a feeling
of, oh, if you think you have 12,000

423
00:21:54,645 --> 00:21:58,955
iops just if to, to that match, you can
have a feeling if you're getting close.

424
00:21:59,705 --> 00:22:01,475
Remember that GP two GP three.

425
00:22:01,865 --> 00:22:05,345
By design, I'm not supposed to guarantee
you a hundred percent of the time.

426
00:22:05,545 --> 00:22:06,265
Those iops.

427
00:22:06,445 --> 00:22:09,985
So 99% is a lot of time, but
there's still, sometimes you

428
00:22:09,985 --> 00:22:11,395
might not eat those numbers.

429
00:22:11,895 --> 00:22:16,065
GP three versus GP two, they
are at the same price on RDS.

430
00:22:16,245 --> 00:22:19,835
So how do you decide they have a
different model in term of iops,

431
00:22:20,405 --> 00:22:24,935
GP three, when you are over 400
gigabyte, you get 12,000 iops.

432
00:22:25,595 --> 00:22:28,505
With GP two, you have three
iops per single gigabyte.

433
00:22:28,555 --> 00:22:33,265
With a basic simple math, up to
four terabyte of storage, GP three

434
00:22:33,265 --> 00:22:37,925
delivers more iops over four terabyte.

435
00:22:38,225 --> 00:22:41,345
GP two is technically provide
by the full more iops.

436
00:22:41,655 --> 00:22:45,185
The difference is you cannot
just choose according to that.

437
00:22:45,455 --> 00:22:48,665
The main difference is that
you cannot change the baseline.

438
00:22:48,665 --> 00:22:51,925
You cannot pay to have
more AOPs on GP two.

439
00:22:52,540 --> 00:22:57,100
While GP three is more flexible, you
can decide how much the throughput

440
00:22:57,190 --> 00:23:00,190
and iops you can configure them
separately from the size of the

441
00:23:00,190 --> 00:23:01,450
disc, and that's really helpful.

442
00:23:01,950 --> 00:23:05,820
This is IO one and IO two, that they are
the provision iops IU one is the very

443
00:23:05,820 --> 00:23:08,010
first provision iops available on RDS.

444
00:23:08,010 --> 00:23:09,390
They've been there for many years.

445
00:23:09,450 --> 00:23:14,620
Last year, IO two Express came out
and the thing, the key point is IO two

446
00:23:14,620 --> 00:23:16,630
is at the same price point of IO one.

447
00:23:17,260 --> 00:23:19,770
But it's better just use
IO two whenever you can.

448
00:23:19,770 --> 00:23:23,660
Not every single business card can
support it, but usually newest one.

449
00:23:23,660 --> 00:23:24,140
Yes.

450
00:23:24,860 --> 00:23:29,450
The key point about provision AOPs, yeah,
it's good to have it, but it's expensive.

451
00:23:29,480 --> 00:23:33,410
And when you think, when you say
that the CPU is overrated think that

452
00:23:33,410 --> 00:23:36,620
yes, of course if you get if you
put provision IOPS on a production

453
00:23:36,620 --> 00:23:38,150
database, it's better not to have them.

454
00:23:38,150 --> 00:23:40,670
But you have to think about
the overall cost of your.

455
00:23:41,105 --> 00:23:42,545
Database solution.

456
00:23:42,935 --> 00:23:45,365
Do you really need them or you
need them temporary because you

457
00:23:45,365 --> 00:23:46,835
have battery designed database?

458
00:23:47,045 --> 00:23:52,025
Maybe sharding the database on
multiple RDS give you 24,000 iops

459
00:23:52,025 --> 00:23:55,775
without having to pay for provision
iops and so on and so forth.

460
00:23:56,045 --> 00:23:59,765
The other, so the lesson is
use them, but be careful.

461
00:23:59,765 --> 00:24:02,675
Think if there a way to improve
your product without having them

462
00:24:02,825 --> 00:24:04,385
almost all on very large database.

463
00:24:04,885 --> 00:24:08,365
And if you use provision apps,
remember to watch out for copies,

464
00:24:08,365 --> 00:24:11,365
replica tests, staging environment,
because when you create from a

465
00:24:11,365 --> 00:24:17,395
snapshot, they by default the storage
the same class as the one you had.

466
00:24:17,635 --> 00:24:22,665
So you don't want to have a provision
database app, staging database

467
00:24:22,695 --> 00:24:28,025
with a lot of IOPS provision
and paid quite expensively.

468
00:24:28,525 --> 00:24:30,655
So I call it blue, green, and purple.

469
00:24:30,685 --> 00:24:31,855
So that's the next lesson.

470
00:24:31,855 --> 00:24:35,095
So previous lesson down storage,
blue, green, purple blue.

471
00:24:35,095 --> 00:24:39,925
Green is the newest nice approach to
change database do changes to database.

472
00:24:40,855 --> 00:24:44,460
Now this screen that I want to
share with you and take a second

473
00:24:44,510 --> 00:24:50,080
about what we have here what
happened between August 25 and 28.

474
00:24:50,330 --> 00:24:53,090
Actually this is a performance
inside and there's no data.

475
00:24:53,150 --> 00:24:56,450
Why does the database is so
low and there's no data before?

476
00:24:56,970 --> 00:25:03,600
Reality is that when I did a bluegreen
switch using A-W-S-R-D-S bluegreen,

477
00:25:04,410 --> 00:25:06,480
my performance inside data is gone.

478
00:25:06,540 --> 00:25:12,570
I have no data Before A was 24th and
the data between August 25 and 28 are

479
00:25:12,570 --> 00:25:16,730
the one from the the deployment that
was the passive one, the green one.

480
00:25:17,230 --> 00:25:21,430
When you check the documentation tells
you that the green, what is the green

481
00:25:21,430 --> 00:25:24,660
environment have, it's a copy of theology
of the production environment, includes

482
00:25:24,660 --> 00:25:28,500
feature used by the instance, for
example, red replica storage, DB snapshot,

483
00:25:28,530 --> 00:25:31,410
automatic backups performance inside.

484
00:25:31,410 --> 00:25:33,270
And so you expect when you use.

485
00:25:34,125 --> 00:25:36,030
Green deployment, everything is there.

486
00:25:36,120 --> 00:25:37,125
Everything is there.

487
00:25:37,125 --> 00:25:39,585
But remember that when
you rename, things change.

488
00:25:39,855 --> 00:25:44,230
So this AWS when I ask them, why don't
I have my old data performance side?

489
00:25:44,230 --> 00:25:48,816
Performance side is there is enabled,
but performance side of the old

490
00:25:48,845 --> 00:25:53,735
blue instance will not be carried
to the new blue instance after the

491
00:25:53,735 --> 00:25:54,995
blue green deployment failover.

492
00:25:55,245 --> 00:25:55,995
Is that an issue?

493
00:25:56,045 --> 00:26:00,435
Usually I love as an engineer
and the operation to be able to

494
00:26:00,435 --> 00:26:02,445
look at my data back months here.

495
00:26:02,445 --> 00:26:07,035
So if you update a miner of a database,
you have to use bluegreen, maybe?

496
00:26:07,035 --> 00:26:07,485
Yes.

497
00:26:07,515 --> 00:26:08,175
Depends.

498
00:26:08,295 --> 00:26:09,765
Or maybe not remember as well.

499
00:26:09,765 --> 00:26:10,275
The drawback.

500
00:26:10,305 --> 00:26:13,905
The drawback is you might lose
certain data is significant because

501
00:26:13,905 --> 00:26:16,425
actually one of the reason after a
blue green deployment, I would like

502
00:26:16,425 --> 00:26:18,465
to compare the data before and after.

503
00:26:18,975 --> 00:26:22,215
If I don't have the data before, that's
a bit of a problem That doesn't apply

504
00:26:22,215 --> 00:26:23,955
to CloudWatch Matrix because they.

505
00:26:24,315 --> 00:26:27,675
Apply to the name, but that apply
to performance inside on only.

506
00:26:28,175 --> 00:26:29,225
Same with backup.

507
00:26:29,255 --> 00:26:32,895
You might have with Bluegreen
30 days you have decide to

508
00:26:32,895 --> 00:26:34,425
have backup retention 30 days.

509
00:26:34,425 --> 00:26:37,425
It might be as well as something you
have by contract with your customer.

510
00:26:37,635 --> 00:26:40,725
You cannot keep the
data more than 30 days.

511
00:26:41,145 --> 00:26:42,015
But what type you do?

512
00:26:42,015 --> 00:26:42,555
Blue, green?

513
00:26:43,305 --> 00:26:44,865
The older distance is there.

514
00:26:45,225 --> 00:26:45,660
You may.

515
00:26:46,320 --> 00:26:48,060
Decide to stop it or delete it.

516
00:26:48,060 --> 00:26:51,720
And when you delete it, it tells you do
you want to keep your old data yes or no?

517
00:26:52,320 --> 00:26:55,680
If you say yes, the data is there,
but it's there for other 30 days.

518
00:26:55,740 --> 00:26:59,600
So retain, automatic backup
are removed by the system.

519
00:26:59,600 --> 00:27:06,710
So what happen is if you use Bluegreen
on any time you kill your instance with

520
00:27:07,130 --> 00:27:11,780
automatic backups, you have to remember
that any retention period you set 30 days.

521
00:27:12,140 --> 00:27:14,570
It's not incremental on every database.

522
00:27:14,570 --> 00:27:18,020
So the backup of 29 days ago
will be deleted tomorrow.

523
00:27:18,080 --> 00:27:22,460
No, all the data backup will be
deleted in 30 days from today.

524
00:27:22,790 --> 00:27:26,480
That have, might have cost implication,
but as well some compliance implications.

525
00:27:26,480 --> 00:27:27,440
So keep that in mind.

526
00:27:27,440 --> 00:27:29,990
You might want to deploy
your own logic to avoid that.

527
00:27:30,380 --> 00:27:35,360
Anyway, the last lesson I want to
share is underestimate time for a

528
00:27:35,360 --> 00:27:36,830
change that I've done many times.

529
00:27:37,330 --> 00:27:39,430
I say before we create a replica.

530
00:27:39,700 --> 00:27:45,570
So I create my replica, and it might take,
you see it here from the Matrix that how

531
00:27:45,570 --> 00:27:47,160
long does it take to create a replica?

532
00:27:47,160 --> 00:27:50,280
If you look at the replica, maybe
after half an hour, the console

533
00:27:50,280 --> 00:27:51,810
say that the replica is available.

534
00:27:52,050 --> 00:27:54,930
But what happened to my replica
is that after he is available.

535
00:27:55,530 --> 00:27:58,680
The lag, the replica keep
growing because my production

536
00:27:58,680 --> 00:27:59,790
database is under heavy load.

537
00:27:59,820 --> 00:28:04,140
So keep growing, because my disc on
this snapshot, there's no magic there.

538
00:28:04,140 --> 00:28:06,540
The replica starts with a cold disc.

539
00:28:07,040 --> 00:28:10,190
It's gonna take time to retrieve
data from S3 and warm up.

540
00:28:11,060 --> 00:28:15,850
At that point, by the time I'm able
to, to have a replica, really, it's

541
00:28:15,850 --> 00:28:20,170
gonna be days or at least hours,
but sometime this is three days.

542
00:28:20,170 --> 00:28:23,650
After three days, I was actually
able to use my replica because until

543
00:28:23,650 --> 00:28:27,010
the replica leg is zero, I cannot
really do any significant attack.

544
00:28:27,110 --> 00:28:29,840
I can stop it and do the al
table, but still, at some

545
00:28:29,840 --> 00:28:31,160
point I will have to catch up.

546
00:28:31,430 --> 00:28:35,030
So remember that the time for a change
is not just the time to have the

547
00:28:35,030 --> 00:28:38,690
replica ready or to have the instance
up and running from a snapshot,

548
00:28:38,690 --> 00:28:40,880
but the time that instance is work.

549
00:28:41,380 --> 00:28:45,160
So if you don't do that, when you
swap between a green and blue,

550
00:28:45,160 --> 00:28:49,600
what you see what happen here
around 15, 10 minutes past 15?

551
00:28:49,660 --> 00:28:51,770
15, 15 what happens there?

552
00:28:51,770 --> 00:28:56,690
That the disc depth explodes and
explodes because my new blue instance

553
00:28:56,870 --> 00:28:58,880
is actually still very cold, the drive.

554
00:28:59,120 --> 00:29:02,720
So what happened is as soon as it's
hit by the load of the production

555
00:29:02,720 --> 00:29:05,300
database, it's taking ages to recover.

556
00:29:05,300 --> 00:29:05,810
So for.

557
00:29:06,605 --> 00:29:07,415
Four hours.

558
00:29:07,415 --> 00:29:11,945
I was basically struggling with a database
that was not, was underperforming.

559
00:29:12,185 --> 00:29:15,785
And the scary part about that is
that you have nothing you can do.

560
00:29:16,085 --> 00:29:17,375
Thus, you can just wait.

561
00:29:17,765 --> 00:29:19,115
You cannot modify the instance.

562
00:29:19,115 --> 00:29:21,695
You cannot do anything that
is significant at that point.

563
00:29:22,195 --> 00:29:25,735
So let's go close with some, what
I call super simple experiment.

564
00:29:25,735 --> 00:29:31,675
I said before, I want to save a
hundred thousand records in a database.

565
00:29:32,065 --> 00:29:33,415
So let's do that experiment.

566
00:29:33,715 --> 00:29:36,145
And that's why I want to do
it because I want to test.

567
00:29:36,145 --> 00:29:41,115
Couple of simple things I want to
say is the Aurora faster than RDS?

568
00:29:41,115 --> 00:29:47,955
For my SQL, is my SQL better than
Maria DB is I one really better

569
00:29:47,955 --> 00:29:49,395
or worse than IO two Express?

570
00:29:49,395 --> 00:29:52,900
I want to do just simple
comparison and to stick.

571
00:29:52,900 --> 00:29:56,950
I decide to use a setup of 400
gigabytes, so I have 12,000 iops on.

572
00:29:57,430 --> 00:29:58,570
GP P three and GP P two.

573
00:29:58,960 --> 00:30:01,750
I use an Insta Co comparable
on Aurora and RDS.

574
00:30:01,750 --> 00:30:04,270
So in this case I use R seven G large.

575
00:30:04,270 --> 00:30:08,480
It is the smallest instance I
could use on my credits that

576
00:30:08,480 --> 00:30:09,835
they want to spend too much.

577
00:30:09,835 --> 00:30:13,615
But you might wonder how you,
let's say, okay, I insert one

578
00:30:13,615 --> 00:30:16,615
meter record or a hundred thousand
records, whatever you want, and I

579
00:30:16,615 --> 00:30:18,355
want to insert one record at a time.

580
00:30:18,355 --> 00:30:19,495
Those are my only rules.

581
00:30:20,125 --> 00:30:22,410
It depends because otherwise you
say it depends how you insert and

582
00:30:22,410 --> 00:30:23,965
you can load 1 million records.

583
00:30:24,175 --> 00:30:25,615
No, I want to insert, I'm using.

584
00:30:26,505 --> 00:30:28,515
Interaction one, one at a time.

585
00:30:28,725 --> 00:30:30,525
I want to use a single thread.

586
00:30:30,675 --> 00:30:35,235
So no, not a pool, nothing fancy, and
I want to still stick to assets, so I'm

587
00:30:35,265 --> 00:30:37,865
not loading my data in a single query.

588
00:30:37,865 --> 00:30:39,925
So you might still say it depends.

589
00:30:39,925 --> 00:30:42,055
It depends on the CPU,
it depends on the table.

590
00:30:42,055 --> 00:30:45,445
It depends on the storage of
memory, on latency, on version,

591
00:30:45,445 --> 00:30:46,690
on which database engine.

592
00:30:47,410 --> 00:30:52,540
You're on the developer how you implement
your logic, so let's even simplify more.

593
00:30:53,020 --> 00:30:54,730
I want to ask you the question otherwise.

594
00:30:55,180 --> 00:31:02,430
So let's say I create a simple table
and my table as simply a data time

595
00:31:02,430 --> 00:31:06,090
and a value, and I just load my a
hundred thousand record because I

596
00:31:06,090 --> 00:31:10,080
don't want to load more than that
because it will take too long or.

597
00:31:10,560 --> 00:31:11,970
Or not, I don't know.

598
00:31:12,510 --> 00:31:13,740
And call the Lord demo.

599
00:31:13,740 --> 00:31:14,460
Why do I do it?

600
00:31:14,460 --> 00:31:15,210
With function?

601
00:31:15,210 --> 00:31:17,220
It's simply, it's a simple experiment.

602
00:31:17,550 --> 00:31:22,140
If I do it with function, the cool
thing is that there's no latency.

603
00:31:22,140 --> 00:31:22,860
There's no nothing.

604
00:31:22,860 --> 00:31:24,000
It's just that function.

605
00:31:24,005 --> 00:31:26,400
So the question I have
is, how long does it take?

606
00:31:26,730 --> 00:31:28,410
Seconds, minutes, many seconds.

607
00:31:28,410 --> 00:31:29,340
I dunno.

608
00:31:29,390 --> 00:31:29,900
Simple.

609
00:31:30,200 --> 00:31:32,510
Let's compare the execution of
this one on the different one.

610
00:31:33,050 --> 00:31:37,670
So I'm using the C large, it's gonna take
milliseconds, hour, seconds, minutes.

611
00:31:37,920 --> 00:31:40,290
We could do a demo, but we
have no time for a demo life.

612
00:31:40,290 --> 00:31:46,110
So here are my results on RDS is 0 39.

613
00:31:46,110 --> 00:31:48,510
It takes five minutes and 49 seconds.

614
00:31:48,510 --> 00:31:51,090
Now, Aurora 2.7 seconds.

615
00:31:51,240 --> 00:31:51,720
What?

616
00:31:52,200 --> 00:31:54,480
2.7 second versus five minutes?

617
00:31:55,170 --> 00:31:55,920
Something wrong there.

618
00:31:56,170 --> 00:31:59,410
I'm just using the full
configuration and I'm doing mostly

619
00:31:59,410 --> 00:32:01,830
a. Experiment makes no sense.

620
00:32:01,880 --> 00:32:07,400
It's, I'm inserting user function, 1
million record from the server anyway.

621
00:32:07,700 --> 00:32:08,660
The difference here is the server.

622
00:32:08,660 --> 00:32:09,620
But is that true?

623
00:32:09,680 --> 00:32:10,850
Yes, it's actually true.

624
00:32:10,850 --> 00:32:15,695
If you do my demo and you look at the
time, you count the record, you have 1

625
00:32:15,695 --> 00:32:19,100
million record, you have a minimum, the
time and a maximum target is different.

626
00:32:19,250 --> 00:32:24,700
So they being inserted one
at a time and, so well, cool.

627
00:32:25,310 --> 00:32:27,770
Any difference between MariaDB and my sql?

628
00:32:28,020 --> 00:32:30,420
Actually no, that's the same time.

629
00:32:30,750 --> 00:32:33,120
And the reason it's pretty
simple, the difference here is

630
00:32:33,120 --> 00:32:34,710
just really the storage layer.

631
00:32:34,770 --> 00:32:38,370
The main difference between Aurora
and RDS is the storage layer.

632
00:32:38,940 --> 00:32:43,400
Will you get the 60 per benefit
using real production workload?

633
00:32:43,760 --> 00:32:44,780
Absolutely not.

634
00:32:44,990 --> 00:32:48,330
The latency and other components
multi try, are gonna make.

635
00:32:48,820 --> 00:32:49,930
Very different result.

636
00:32:50,330 --> 00:32:53,890
The reason I did that experiment was
to show that you really need to be

637
00:32:53,890 --> 00:32:57,850
careful when you trust benchmarks
unless you know who is doing that.

638
00:32:58,100 --> 00:33:02,150
This Maria DB versus you can see the
counter second is similar around the

639
00:33:02,150 --> 00:33:06,410
experiment twice, and that's the,
you can see that the time are very

640
00:33:06,410 --> 00:33:09,370
similar, iops, again, the logic, but.

641
00:33:09,450 --> 00:33:11,400
I say I want to test the third case.

642
00:33:11,580 --> 00:33:14,700
And the third case is IO two.

643
00:33:14,700 --> 00:33:19,290
Block express for me, shown
critical is the new version

644
00:33:19,290 --> 00:33:21,450
of IO two that was announced.

645
00:33:21,700 --> 00:33:22,570
Now, one year ago.

646
00:33:22,820 --> 00:33:23,540
Is that better?

647
00:33:23,540 --> 00:33:26,300
I one, because they say in the
announcement they say something

648
00:33:26,300 --> 00:33:28,980
that is pretty cool that is faster.

649
00:33:29,220 --> 00:33:30,930
So same price.

650
00:33:30,990 --> 00:33:33,750
So if I switch from a one to IO two.

651
00:33:34,140 --> 00:33:36,930
For 1 million record, I go from
five minutes to two minutes

652
00:33:36,930 --> 00:33:38,910
20 for the very same price.

653
00:33:38,970 --> 00:33:41,400
Quite a big difference
considering that as well.

654
00:33:41,400 --> 00:33:44,640
I'm using the same concept, RDS instance.

655
00:33:44,640 --> 00:33:46,560
There's no difference
engine, no difference.

656
00:33:46,560 --> 00:33:47,370
Anything else.

657
00:33:48,000 --> 00:33:50,870
And if you look at the what you
really see that difference, the

658
00:33:50,870 --> 00:33:56,160
number of record per second is, so
what's the key point of this one?

659
00:33:56,160 --> 00:33:56,760
Is that.

660
00:33:57,260 --> 00:34:00,830
Switch from IO one to IU two whenever
you can, because you probably

661
00:34:00,830 --> 00:34:02,870
don't get that two per benefit.

662
00:34:03,520 --> 00:34:07,690
But you definitely see a big difference
on IO one for the same price.

663
00:34:08,680 --> 00:34:12,860
So I'd like to close with a
simple question that I offered.

664
00:34:12,860 --> 00:34:15,755
Are you really noted
database administrator well?

665
00:34:16,525 --> 00:34:22,325
I'm not, but I argue that on many
service on AWS or any cloud provider,

666
00:34:22,355 --> 00:34:23,915
you actually need to be a database.

667
00:34:24,695 --> 00:34:27,455
This is a cool slide that was
shared by Amazon many years ago,

668
00:34:27,455 --> 00:34:28,865
but I still think it's relevant.

669
00:34:29,495 --> 00:34:34,145
The data database message of time spent
on premises is mostly on the platform

670
00:34:34,145 --> 00:34:39,990
access and very little application
level on RDS as a database administrator

671
00:34:39,990 --> 00:34:44,010
spend most of the time looking at
performance Inside cloud was you actually.

672
00:34:44,510 --> 00:34:49,545
Able to help the developer, optimize
the application and as well the database

673
00:34:49,705 --> 00:34:54,490
sche and you do some money, but you
hardly have any, you don't care too much

674
00:34:54,490 --> 00:34:56,470
about the assets and platform level.

675
00:34:56,970 --> 00:34:59,670
So what are the key
takeaways of this session?

676
00:35:00,140 --> 00:35:05,055
First one things I learned the hard
way I allocate RDS storage might

677
00:35:05,055 --> 00:35:06,765
take hours of the plan accordingly.

678
00:35:07,265 --> 00:35:11,495
RDS is a man service, but
logs, performance schema

679
00:35:11,495 --> 00:35:12,905
parameter are all available.

680
00:35:12,965 --> 00:35:17,285
So yeah, it's a man service, but you
can still look under the, you can still

681
00:35:17,285 --> 00:35:20,915
ask, suffer for some help to understand
what's going on behind the scene.

682
00:35:21,415 --> 00:35:24,625
Avoid changing parameter group
setting for short term gain.

683
00:35:24,715 --> 00:35:26,395
You may need to scale your data.

684
00:35:26,395 --> 00:35:28,405
That's what I say about
Graviton, for example, is.

685
00:35:28,945 --> 00:35:30,655
Try not to over optimize.

686
00:35:30,705 --> 00:35:33,075
Yes, it's good to optimize
for your specific use case,

687
00:35:33,075 --> 00:35:34,395
but always think long term.

688
00:35:34,465 --> 00:35:39,735
Those short term optimization, layered
back, validate can stress that you have

689
00:35:40,105 --> 00:35:43,455
you're finding with AWS operating have
as well access to the backend of your

690
00:35:43,515 --> 00:35:47,265
database, not to your data, but how
the database run to the file system.

691
00:35:47,520 --> 00:35:48,660
So that helps a lot.

692
00:35:49,360 --> 00:35:50,980
Warm up your database replica.

693
00:35:50,980 --> 00:35:53,290
Super important before
directing traffic to it.

694
00:35:53,380 --> 00:35:58,690
The storage might still be cold, eh,
cost optimization is important, but don't

695
00:35:58,690 --> 00:36:03,400
focus only on the CP eastern size, but
think as well about backups and storage.

696
00:36:04,360 --> 00:36:09,160
And finally you can get crazy
result doing some simple benchmarks.

697
00:36:09,160 --> 00:36:12,250
So approach any benchmark
cautiously and think.

698
00:36:12,609 --> 00:36:15,279
What's the reason between
behind that matrix and what

699
00:36:15,279 --> 00:36:16,390
message they want to sell you?

700
00:36:16,889 --> 00:36:23,619
But if I have to summarize the entire
presentation in a single message, I will

701
00:36:23,619 --> 00:36:27,299
simply say leverage manage databases.

702
00:36:27,359 --> 00:36:28,649
So take advantage of them.

703
00:36:29,249 --> 00:36:30,659
Resist changes.

704
00:36:30,659 --> 00:36:32,399
So apply them cautiously.

705
00:36:32,459 --> 00:36:37,169
Think that default exists for a
purpose, but almost all try to

706
00:36:37,169 --> 00:36:39,599
understand what runs under the hood.

707
00:36:39,879 --> 00:36:43,509
It's not an excuse that they're
managed to ignore what's happening yet.

708
00:36:43,569 --> 00:36:45,939
There's no magic understanding
what's happening behind.

709
00:36:45,939 --> 00:36:48,759
It's gonna help you have
a successful deployment.

710
00:36:49,359 --> 00:36:52,059
With that one, a big thank you.

711
00:36:52,239 --> 00:36:53,109
It has been a pleasure.

712
00:36:53,889 --> 00:36:54,279
Goodbye.

