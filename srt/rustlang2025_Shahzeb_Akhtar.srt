1
00:00:00,500 --> 00:00:01,340
Hello everyone.

2
00:00:01,670 --> 00:00:05,060
My name is Shay Ter, and I'm
a director at United Lake.

3
00:00:05,870 --> 00:00:09,649
Today I'm excited to talk about a
modern approach to web analytics

4
00:00:09,680 --> 00:00:11,149
and business intelligence.

5
00:00:11,840 --> 00:00:15,049
We are going to dive into how
we can build high performance

6
00:00:15,410 --> 00:00:17,810
user-centric dashboards using Rust.

7
00:00:18,500 --> 00:00:22,280
We will see how Rust can let us
deliver better user experience

8
00:00:22,580 --> 00:00:24,095
through speed and reliability.

9
00:00:24,595 --> 00:00:28,785
Before we get into the technology,
let me give you a quick background on

10
00:00:28,875 --> 00:00:30,765
why I'm passionate about this topic.

11
00:00:31,264 --> 00:00:34,804
I'm the director of IP Strategy
and Technology at United Lakes.

12
00:00:35,254 --> 00:00:38,554
I'm based in Austin, Texas, in
the United States of America.

13
00:00:39,484 --> 00:00:42,934
I lead the IP data science
team where we create innovative

14
00:00:42,934 --> 00:00:47,254
solutions at the intersection of
intellectual property and technology.

15
00:00:47,754 --> 00:00:53,845
I have been included in the I Am Strategy
300, a list of world's top IP strategists.

16
00:00:54,714 --> 00:00:59,099
One of the products that our team
has developed is Vantage for I. It is

17
00:00:59,099 --> 00:01:03,989
a patent intelligence platform that
processes hundreds and thousands of

18
00:01:03,989 --> 00:01:06,149
patents using natural language processing.

19
00:01:06,750 --> 00:01:10,229
It provides competitive
intelligence, evaluates patent

20
00:01:10,229 --> 00:01:15,090
strengths, and uncovers licensing
opportunities amongst other things.

21
00:01:15,090 --> 00:01:20,839
Two of my key focus areas are developing
deep learning models to e evaluate

22
00:01:20,839 --> 00:01:24,979
patents and designing user friendly
platforms to convey those results.

23
00:01:25,479 --> 00:01:29,019
So what exactly are the
challenges with modern dashboards?

24
00:01:29,519 --> 00:01:31,409
I think we all have experienced this.

25
00:01:31,739 --> 00:01:36,359
You open a dashboard with a lot of
data and it's slow, it's sluggish.

26
00:01:36,419 --> 00:01:38,519
It's a frustrating user experience.

27
00:01:39,119 --> 00:01:42,689
The root cause is often a
combination of three key issues.

28
00:01:43,189 --> 00:01:44,599
Performance bottlenecks.

29
00:01:45,050 --> 00:01:48,979
Heavy data processing and calculations
are typically done in JavaScript,

30
00:01:49,399 --> 00:01:51,169
which is an interpreted language.

31
00:01:51,529 --> 00:01:56,149
This leads to slow rendering and
poor user experience, security

32
00:01:56,149 --> 00:02:01,490
risk, JavaScript, dynamic nature can
introduce vulnerabilities, running

33
00:02:01,494 --> 00:02:06,439
complex, and sometimes untrusted code
in a browser opens the application

34
00:02:06,439 --> 00:02:09,440
to various attacks, wasted resources.

35
00:02:09,940 --> 00:02:14,320
Inefficient code and frequent
data transfers create a heavy load

36
00:02:14,590 --> 00:02:19,239
on both the client, CPU and the
server wasting valuable resources.

37
00:02:19,739 --> 00:02:23,549
So the question is, how do we
solve these problems without

38
00:02:23,549 --> 00:02:27,299
sacrificing the flexibility
and richness of the modern web?

39
00:02:27,799 --> 00:02:29,869
The answer is a perfect partnership.

40
00:02:30,369 --> 00:02:30,659
Okay.

41
00:02:31,159 --> 00:02:35,559
The perfect partnership of rest
and was, this is where the magic

42
00:02:35,559 --> 00:02:40,089
happens, an incredible combination
of rest and web assembly or valve.

43
00:02:40,539 --> 00:02:43,689
They work together to address
every one of those challenges.

44
00:02:44,189 --> 00:02:45,749
Let's first talk about rust.

45
00:02:46,319 --> 00:02:50,219
It feels like I'm preaching to the CO
as everyone here is familiar with the

46
00:02:50,219 --> 00:02:52,559
benefit that trust brings to the table.

47
00:02:53,399 --> 00:02:58,010
Yet for the sake of completeness, let
me highlight a few unmatched memory,

48
00:02:58,010 --> 00:03:02,989
safety, rust ownership and borrowing
model eliminates entire classes of

49
00:03:02,989 --> 00:03:05,570
bugs like null pointers and databases.

50
00:03:06,260 --> 00:03:10,040
This isn't just stability,
it's a huge security win.

51
00:03:10,540 --> 00:03:15,674
Zero cost abstractions, rust gives
us powerful high level features like

52
00:03:15,850 --> 00:03:20,320
iterators and closures, but without
the performance overhead, you'd expect.

53
00:03:21,070 --> 00:03:27,750
You get the best of both worlds built
for concurrency, rust type system makes

54
00:03:27,750 --> 00:03:30,510
writing safe, parallel code much easier.

55
00:03:31,020 --> 00:03:34,440
This is a game changer for
processing large data sets.

56
00:03:34,940 --> 00:03:39,650
Now let's take a moment to understand what
web assembly is because it's the bridge

57
00:03:39,650 --> 00:03:41,485
that brings rust power to the browser.

58
00:03:41,985 --> 00:03:46,215
Web assembly isn't a new programming
language, it's a compilation target.

59
00:03:46,755 --> 00:03:49,095
Think of it as the assembly
language of the web.

60
00:03:49,785 --> 00:03:54,525
VSM is a low level binary format
for a stack based virtual machine.

61
00:03:55,155 --> 00:03:59,025
It's what you compile languages
like rust, c plus, or going to.

62
00:03:59,525 --> 00:04:04,835
Vast runs at speed that are almost as
fast as native code, which is a massive

63
00:04:04,835 --> 00:04:06,545
performance jump for computation.

64
00:04:06,545 --> 00:04:11,705
Heavy tasks compared to traditional
JavaScript VA modules run in a

65
00:04:11,705 --> 00:04:13,565
secure, isolated environment.

66
00:04:13,925 --> 00:04:19,055
This is crucial because it means a buggy
or malicious was module can't access the

67
00:04:19,055 --> 00:04:21,575
rest of your webpage or the user system.

68
00:04:22,075 --> 00:04:25,705
So how does we combine these
two technologies in practice?

69
00:04:26,275 --> 00:04:27,685
Let's walk through the workflow.

70
00:04:28,185 --> 00:04:30,645
The workflow is surprisingly
straightforward.

71
00:04:31,125 --> 00:04:34,515
You don't have to rewrite your
entire application In rust.

72
00:04:35,015 --> 00:04:37,475
We can be selective and strategic.

73
00:04:37,975 --> 00:04:39,745
Write the core logic in rust.

74
00:04:40,255 --> 00:04:42,025
This is the most important step.

75
00:04:42,595 --> 00:04:44,575
Identify the performance critical.

76
00:04:45,385 --> 00:04:49,135
Parts of your dashboard, data
aggregation, complex, filtering,

77
00:04:49,165 --> 00:04:55,015
heavy calculations, and write those
specifically in rust compile to M.

78
00:04:55,495 --> 00:04:57,475
Use a tool like Mack.

79
00:04:58,015 --> 00:05:01,795
It's a key part of the process that
handles all the lift heavy lifting,

80
00:05:02,335 --> 00:05:07,255
creating a web assembly file and
a JavaScript glue that allows your

81
00:05:07,255 --> 00:05:09,235
front end to talk to the vast module.

82
00:05:10,150 --> 00:05:13,090
Import and use the existing JavaScript.

83
00:05:13,450 --> 00:05:17,860
Frontend simply imports the vast
module from the JavaScript perspective.

84
00:05:17,890 --> 00:05:22,240
It just another library, but it's a
library that performs computationally

85
00:05:22,240 --> 00:05:24,700
intensive tasks at near native speed.

86
00:05:25,200 --> 00:05:29,880
Visualize with JavaScript existing
UI frameworks like React or View

87
00:05:29,880 --> 00:05:31,950
can still be used for rendering.

88
00:05:32,400 --> 00:05:36,480
The rust valve part is the high
performance engine under the hood.

89
00:05:37,140 --> 00:05:39,600
JavaScript part is the
user interface on top.

90
00:05:40,100 --> 00:05:43,010
This approach leads to a
clear, layered architecture.

91
00:05:43,510 --> 00:05:46,780
We can think of this as a
three layer architecture.

92
00:05:47,170 --> 00:05:50,920
Each layer has a specific job,
and rust plays a key role.

93
00:05:50,920 --> 00:05:53,909
In the first two data
layer is the foundation.

94
00:05:54,495 --> 00:05:59,385
This is where you use rust to connect to
data sources, manage memory efficient data

95
00:05:59,385 --> 00:06:01,845
structures, and build type safe queries.

96
00:06:02,385 --> 00:06:05,565
This ensures data is handled
correctly and quickly from the

97
00:06:05,565 --> 00:06:07,595
very beginning processing layer.

98
00:06:08,225 --> 00:06:11,195
This is where rust power
shine really shines.

99
00:06:12,005 --> 00:06:16,025
This layer handles parallel data
processing, statistical analysis and

100
00:06:16,025 --> 00:06:18,385
data transformation visualization layer.

101
00:06:19,360 --> 00:06:20,500
This is the front end.

102
00:06:21,040 --> 00:06:24,280
This layer uses high speed
output from the processing layer

103
00:06:24,490 --> 00:06:26,170
to render charts and tables.

104
00:06:26,710 --> 00:06:30,370
This is where you can leverage web
assembly for browser rendering on

105
00:06:30,370 --> 00:06:33,550
native visualization for desktop apps,

106
00:06:34,050 --> 00:06:38,400
this layered approach is only possible
because of the incredible rust ecosystem.

107
00:06:38,900 --> 00:06:42,260
Rust community has built an
amazing ecosystem of libraries.

108
00:06:42,650 --> 00:06:46,070
For each layer of our
architecture, there are robust and

109
00:06:46,070 --> 00:06:48,140
well-maintained crates available.

110
00:06:48,640 --> 00:06:53,050
Libraries like SQL X can be used
for database interaction and

111
00:06:53,050 --> 00:06:55,090
polars for fast data frames.

112
00:06:55,590 --> 00:06:59,520
Then libraries like Rayon can
be used for easy parallelism and

113
00:06:59,595 --> 00:07:01,680
NDRA for numerical computation.

114
00:07:02,180 --> 00:07:06,410
VA Mine Gen is the Last Rust
Library designed to facilitate

115
00:07:06,440 --> 00:07:11,750
high level interactions between
VA modules and JavaScript plotters

116
00:07:11,750 --> 00:07:13,820
for generating charts and tari.

117
00:07:13,820 --> 00:07:19,270
If you're building a desktop, applications
theory is great, but look, let's look at

118
00:07:19,270 --> 00:07:21,435
some real world examples of this inaction.

119
00:07:22,315 --> 00:07:26,305
These are not just small projects,
these are major applications.

120
00:07:26,805 --> 00:07:29,685
The challenge for Figma
was real-time multiplayer.

121
00:07:30,555 --> 00:07:34,545
They needed to handle complex
synchronization for multiple users.

122
00:07:35,474 --> 00:07:40,244
While technically not an analytics
dashboard, it has a lot of similarities.

123
00:07:40,364 --> 00:07:44,294
Essentially, it requires processing
real time data and presenting visual

124
00:07:44,294 --> 00:07:45,854
components in a smooth manner.

125
00:07:46,354 --> 00:07:50,884
Their solution was to rewrite their
code multiplayer engine in rust.

126
00:07:51,364 --> 00:07:56,075
The results were astounding, a
3.8 x reduction in memory usage

127
00:07:56,435 --> 00:07:59,134
and six x reduction in CPU usage.

128
00:07:59,585 --> 00:08:03,410
This proves that rust isn't just
for small optimizations, it's

129
00:08:03,575 --> 00:08:05,285
for mission critical code logic.

130
00:08:05,785 --> 00:08:09,715
Our next example is about a
graph visualization, which was

131
00:08:09,715 --> 00:08:13,675
running at less than 10 frames
per second on heavy desktops.

132
00:08:14,175 --> 00:08:18,195
This graph shows the relationship
between different artists on Spotify.

133
00:08:19,125 --> 00:08:22,125
Spotify provides this data
directly from their API.

134
00:08:22,935 --> 00:08:27,435
Users can click on an artist, see
related artist, or drag an artist node

135
00:08:27,435 --> 00:08:29,445
and view other nodes, move together.

136
00:08:29,945 --> 00:08:31,865
The user experience was shareable.

137
00:08:32,365 --> 00:08:36,115
The solution was to move the heavy
calculations to rest and web assembly.

138
00:08:36,715 --> 00:08:41,545
The result, the exact same
visualizations now run at 60 frames

139
00:08:41,605 --> 00:08:44,095
per second, even on mobile devices.

140
00:08:44,605 --> 00:08:46,825
That's a massive difference
for the end user.

141
00:08:47,325 --> 00:08:52,095
Finally, in the world of financial
applications, processing massive data sets

142
00:08:52,095 --> 00:08:54,735
with billions of rows is a common problem.

143
00:08:55,235 --> 00:08:59,855
Data Bento provides real-time and
historical market data to its users.

144
00:09:00,335 --> 00:09:04,565
They were struggling to process and
analyze large data sets with ease, which

145
00:09:04,565 --> 00:09:09,515
would allow for timely and data-driven
decisions in response to market changes.

146
00:09:10,015 --> 00:09:14,275
The solution was polars, a data
frame library written in rust.

147
00:09:14,605 --> 00:09:16,375
Its performance is incredible.

148
00:09:16,585 --> 00:09:17,635
Which benchmarks?

149
00:09:17,635 --> 00:09:23,515
Showing it out outperforms pandas by
eight to 15 x. It's a game changer for

150
00:09:23,515 --> 00:09:25,915
data wrangling and visualizing at scale.

151
00:09:26,415 --> 00:09:31,155
Speaking of visualizations, let's look
at some of rush libraries that you

152
00:09:31,155 --> 00:09:33,465
can use to build these dashboards.

153
00:09:33,965 --> 00:09:38,195
As mentioned earlier, visualization
can continue to be in JavaScript.

154
00:09:38,345 --> 00:09:42,725
However, the ecosystem of Rust
Visualization libraries is growing

155
00:09:43,055 --> 00:09:46,205
and we already have some excellent
choices for visualization.

156
00:09:46,705 --> 00:09:50,215
Plotters is a low level, powerful
library for plotting data.

157
00:09:50,425 --> 00:09:53,010
Its versatile and can
output to various formats.

158
00:09:53,510 --> 00:09:54,950
Charming is a great option.

159
00:09:54,950 --> 00:09:59,420
If you're a fan of Apache Echarts,
it's provide a user-friendly

160
00:09:59,420 --> 00:10:03,980
declarative rust, API on top of the
wok powerful JavaScript library.

161
00:10:04,480 --> 00:10:10,150
Plotly is an option for more scientific
and statistical visualizations, leveraging

162
00:10:10,180 --> 00:10:13,360
the extensive feature set of lead js.

163
00:10:13,860 --> 00:10:15,930
Now that we have covered
the technical side.

164
00:10:16,755 --> 00:10:21,015
Let's remember the most important part
of building a grad grade dashboard.

165
00:10:21,435 --> 00:10:22,095
The user

166
00:10:22,595 --> 00:10:26,045
performance and security are
vital, but a dashboard is only

167
00:10:26,045 --> 00:10:29,015
successful if it's useful and usable.

168
00:10:29,765 --> 00:10:32,990
We have to balance technical
excellence with thoughtful design.

169
00:10:33,490 --> 00:10:35,950
Let's review some of the
key design principles.

170
00:10:36,790 --> 00:10:37,900
Know your audience.

171
00:10:38,575 --> 00:10:40,285
This is the most critical principle.

172
00:10:40,915 --> 00:10:45,055
Before designing anything, you
must understand who the users

173
00:10:45,055 --> 00:10:49,335
are, what their goals are, and
what decisions they need to make.

174
00:10:49,725 --> 00:10:54,165
A CEO's dashboard will look
very different from an analyst.

175
00:10:54,665 --> 00:10:55,475
Keep it simple.

176
00:10:56,135 --> 00:10:58,985
Dashboard should be easy
to understand at a glance.

177
00:10:59,405 --> 00:11:01,985
Avoid clutter and unnecessary visuals.

178
00:11:02,435 --> 00:11:06,305
Use a clear, logical layout and
a consistent visual language.

179
00:11:07,055 --> 00:11:09,755
The users should be able to
find what they need without

180
00:11:09,755 --> 00:11:11,525
extensive searching or training.

181
00:11:12,025 --> 00:11:16,195
Provide context, data points on
their own are often meaningless.

182
00:11:16,675 --> 00:11:20,515
A good dashboard provides context
by showing data against a benchmark,

183
00:11:20,965 --> 00:11:24,505
a time series, or a key performance
indicator with its target.

184
00:11:25,165 --> 00:11:28,345
This help, this helps users
quickly interpret the information

185
00:11:28,585 --> 00:11:30,355
and understand its significance.

186
00:11:30,855 --> 00:11:32,025
Prioritize information.

187
00:11:32,685 --> 00:11:34,605
All data is created equal.

188
00:11:35,355 --> 00:11:39,255
Use visual hierarchy to guide the
user's attention to the most important

189
00:11:39,255 --> 00:11:43,815
information First, this can be achieved
through size, placement, and color.

190
00:11:44,385 --> 00:11:47,985
The most critical metrics should be
front and center, while supporting

191
00:11:47,985 --> 00:11:49,575
data can be placed elsewhere.

192
00:11:50,075 --> 00:11:54,865
Enable customization, give users the
ability to personalize their dashboard.

193
00:11:55,450 --> 00:12:00,940
Allowing them to filter data, change
data ranges, or even rearrange widgets,

194
00:12:01,030 --> 00:12:06,400
empower them and makes the dashboard
more relevant to their specific workflow.

195
00:12:06,900 --> 00:12:10,610
Ensure interactivity dashboards
should not be static images.

196
00:12:11,585 --> 00:12:15,545
Allow users to drill down into
specific data points, power

197
00:12:15,545 --> 00:12:19,355
over charts for more details, or
click to explore underlying data.

198
00:12:19,865 --> 00:12:24,425
This interactivity inter encourages
exploration and deeper understanding.

199
00:12:24,925 --> 00:12:26,365
Choose the right visuals.

200
00:12:26,865 --> 00:12:31,670
Select the chart type that best represents
the data that supports the user's charts.

201
00:12:32,170 --> 00:12:36,070
For example, use a line chart to
show trends over time, a bar chart

202
00:12:36,070 --> 00:12:40,330
to compare categories and a pie chart
for parts to hold relationships.

203
00:12:40,750 --> 00:12:44,940
Using the wrong chart can lead to
misinterpretation, accessibility,

204
00:12:45,510 --> 00:12:47,460
designed with accessibility in mind.

205
00:12:47,880 --> 00:12:51,840
This includes using color palettes
that are accessible to users with

206
00:12:51,840 --> 00:12:57,000
colorblindness, providing clear labels
and ensuring dashboard is navigable

207
00:12:57,000 --> 00:12:58,500
with keyboard or screen reader.

208
00:12:59,000 --> 00:13:03,880
By combining these design principles with
the power of rust and web assembly, we can

209
00:13:03,880 --> 00:13:06,520
have a significant impact on our business.

210
00:13:07,020 --> 00:13:09,090
Let's bring it all home and talk.

211
00:13:09,090 --> 00:13:12,780
Why this is a big deal for our
businesses and our organizations.

212
00:13:13,650 --> 00:13:14,610
Blazing speed.

213
00:13:15,060 --> 00:13:19,590
This isn't just about faster rendering,
it's about delivering an outstanding

214
00:13:19,590 --> 00:13:23,460
user experience, which leads to
better, faster decision making.

215
00:13:24,405 --> 00:13:30,075
Ironclad security memory safety means we
eliminate a huge class of vulnerabilities,

216
00:13:30,075 --> 00:13:34,965
which is critical for handling sensitive
business data and meeting compliance

217
00:13:34,965 --> 00:13:37,685
requirements developer productivity.

218
00:13:38,525 --> 00:13:43,265
Using a type safe language like rust
helps us write correct maintainable

219
00:13:43,265 --> 00:13:47,540
and bulk free code from the start
saving time and money in the long run.

220
00:13:48,040 --> 00:13:53,170
To wrap up, I want to leave you with a few
takeaways and some concrete next steps.

221
00:13:53,670 --> 00:13:55,560
First, the key takeaways.

222
00:13:55,620 --> 00:14:00,360
Remember these three points,
performance transforms, experience.

223
00:14:01,320 --> 00:14:04,780
Safety creates trust,
user-centric design matters.

224
00:14:05,280 --> 00:14:08,175
So what can you do with this information?

225
00:14:08,675 --> 00:14:10,145
I encourage you to start small.

226
00:14:10,760 --> 00:14:16,280
Assess your current bottlenecks,
identify a high impact use case, and

227
00:14:16,280 --> 00:14:18,140
then build a small proof of concept.

228
00:14:18,640 --> 00:14:22,270
Measure the results, and you'll
see the value for yourself.

229
00:14:22,770 --> 00:14:25,200
This brings us to the end
of today's presentation.

230
00:14:25,995 --> 00:14:29,775
While I'm not going into the details
of this infographic, I wanted to

231
00:14:29,775 --> 00:14:32,205
include it as here as a bonus content.

232
00:14:32,895 --> 00:14:37,185
This has helped me often to determine the
right chat type and hope it helps you too.

233
00:14:37,685 --> 00:14:40,265
It was a pleasure to
cover this exciting topic.

234
00:14:40,655 --> 00:14:43,955
If you have any questions or
comments, please reach out

235
00:14:43,955 --> 00:14:45,635
to me on GitHub or LinkedIn.

236
00:14:46,145 --> 00:14:47,645
Have a great rest of your day.

237
00:14:47,975 --> 00:14:48,395
Thank you.

