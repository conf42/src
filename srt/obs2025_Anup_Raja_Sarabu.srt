1
00:00:00,500 --> 00:00:01,520
Hey, good morning everyone.

2
00:00:01,709 --> 00:00:03,000
This is Anbu.

3
00:00:03,569 --> 00:00:05,940
I'm a Senior Technical
Product manager at T-Mobile.

4
00:00:06,310 --> 00:00:09,250
I lead initiatives around large
scale digital commerce systems.

5
00:00:09,680 --> 00:00:13,360
That's millions of customers
across multiple platforms like

6
00:00:13,360 --> 00:00:15,069
web, mobile, and in store.

7
00:00:15,760 --> 00:00:16,180
Today.

8
00:00:16,180 --> 00:00:21,459
I will share how observability is
at core of making async event-driven

9
00:00:21,459 --> 00:00:23,380
commerce systems reliable and scalable.

10
00:00:24,354 --> 00:00:28,224
We will look at how we have approached
this at T-Mobile from architectural

11
00:00:28,224 --> 00:00:32,334
patterns to debugging techniques and the
key lessons we have learned along the way.

12
00:00:32,584 --> 00:00:37,014
Whether you're building distributed
systems, managing reliability, or

13
00:00:37,014 --> 00:00:42,205
designing customer journeys, I hope this
talk gives you practical takeaways you

14
00:00:42,205 --> 00:00:44,544
can apply to your own async environment.

15
00:00:44,795 --> 00:00:49,165
Let me start this with, a statement,
in a world we are living in a world

16
00:00:49,345 --> 00:00:51,865
where milliseconds definitely matter.

17
00:00:52,044 --> 00:00:55,209
What do you, what do is, basically
let's say a customer is shopping

18
00:00:55,239 --> 00:00:58,949
on a website and then while
checking out there's a delay.

19
00:00:59,189 --> 00:00:59,819
And then.

20
00:01:00,149 --> 00:01:03,699
He can decide to abandon
the cart and then, we can

21
00:01:03,699 --> 00:01:05,349
potentially lose that customer.

22
00:01:05,719 --> 00:01:08,989
We live in a world where
conversion rates matter and

23
00:01:09,859 --> 00:01:11,809
observability is no longer optional.

24
00:01:11,839 --> 00:01:12,709
It's foundational.

25
00:01:13,319 --> 00:01:18,499
Let me give you an overview of why
we have to shift to Async, to really

26
00:01:18,629 --> 00:01:20,669
drive the omnichannel demands.

27
00:01:21,419 --> 00:01:25,959
Observability, make observability ob
to, to shift from seeing, to async.

28
00:01:26,059 --> 00:01:29,749
The thing that matters most to me is
the observability, because that's the

29
00:01:29,749 --> 00:01:32,329
key of making the shift sustainable.

30
00:01:32,829 --> 00:01:36,259
Know today, digital shoppers, like I
said, expect everything to be fast,

31
00:01:36,619 --> 00:01:40,729
personalized, and seamless, whether
they're online or in store or mobile.

32
00:01:41,474 --> 00:01:46,814
The level of responsiveness pushes us to
move away from synchronous architectures

33
00:01:46,814 --> 00:01:48,994
that block, or fail under pressure.

34
00:01:49,534 --> 00:01:54,334
The challenge is how do we maintain
visibility and trust when everything

35
00:01:54,334 --> 00:01:56,494
runs asynchronously and independently?

36
00:01:56,944 --> 00:01:59,284
That's where observability
becomes critical.

37
00:01:59,794 --> 00:02:01,804
It's our lens into this complex world.

38
00:02:02,054 --> 00:02:04,304
Synchronous systems are like daisy.

39
00:02:04,814 --> 00:02:08,274
Change, one broken link, then
everything falls or fails.

40
00:02:08,484 --> 00:02:12,954
When we switch to async, we get the scale
of flexibility but at the same time, we

41
00:02:12,954 --> 00:02:15,114
also lose the comfort of linear flows.

42
00:02:15,594 --> 00:02:18,664
Failures don't scream in async
flows, but they just whisper.

43
00:02:19,114 --> 00:02:21,754
And if you're not listening to
the right tools, you miss them.

44
00:02:22,384 --> 00:02:23,194
That's the trade off.

45
00:02:23,204 --> 00:02:24,164
We must solve

46
00:02:24,664 --> 00:02:26,734
rise of asynchronous commerce.

47
00:02:26,734 --> 00:02:30,564
I will, you know what's why are we
shifting from synchronous to asynchronous?

48
00:02:31,014 --> 00:02:35,574
The main reason is the demand, demand
and the personalization, rise of

49
00:02:35,604 --> 00:02:38,454
headless microservices and even brokers.

50
00:02:38,704 --> 00:02:42,574
Omnichannel isn't just a buzzword,
it's how customers behave.

51
00:02:42,574 --> 00:02:44,074
Now, I'll tell you an example.

52
00:02:44,074 --> 00:02:47,674
Someone you know, browses on a
mobile and then adds it to the cart.

53
00:02:48,394 --> 00:02:51,844
Then he walks into the store and then he
wanted to check it out with the agent.

54
00:02:52,325 --> 00:02:55,924
This means our system must be loosely
coupled, but tightly coordinated.

55
00:02:56,915 --> 00:03:00,725
Async communication helps achieve
this thanks to our microservices

56
00:03:00,725 --> 00:03:01,804
and event driven designs.

57
00:03:02,075 --> 00:03:05,434
But now we need visibility
across all those hops.

58
00:03:05,934 --> 00:03:07,015
I'll give you an overview.

59
00:03:07,264 --> 00:03:10,804
I'll just explain a use case that
we have implemented or that we

60
00:03:10,819 --> 00:03:12,034
are going to implement in Tmobile.

61
00:03:12,169 --> 00:03:17,439
At T-Mobile the most busiest time
in T-Mobile is during N-P-I-N-P-I

62
00:03:17,539 --> 00:03:20,809
is basically the new product
launches, especially in September

63
00:03:20,809 --> 00:03:22,609
when Apple launches a device.

64
00:03:22,879 --> 00:03:25,189
We almost get a hundred K orders that day.

65
00:03:25,369 --> 00:03:29,149
That's the most busiest day for us,
then Thanksgiving or Christmas or New

66
00:03:29,149 --> 00:03:34,049
Year, and, in one of the NPIs, I think
last year what happened in the first

67
00:03:34,049 --> 00:03:37,579
15 minutes because of the flush of
orders, the payment system was done.

68
00:03:38,434 --> 00:03:40,894
We were in a state where the
orders were not submitted.

69
00:03:41,404 --> 00:03:45,394
Because today what happens in T-Mobile
is when you build a car, go to check

70
00:03:45,394 --> 00:03:48,304
out, and then once you make the payment,
then only you can submit an order.

71
00:03:49,084 --> 00:03:52,064
But because of it, like we built
substitute breakers, which did

72
00:03:52,064 --> 00:03:53,355
not break the system message.

73
00:03:53,624 --> 00:03:56,044
But what happened was at
least the payment was broken.

74
00:03:56,044 --> 00:03:59,344
And then the customers were struck there
saying, Hey, oops, something went wrong.

75
00:03:59,344 --> 00:04:00,634
And they were not able
to submit the order.

76
00:04:01,114 --> 00:04:04,864
That made us think, do we really
need payments to be synchronous?

77
00:04:05,614 --> 00:04:05,914
There are.

78
00:04:06,544 --> 00:04:08,644
We can definitely go async as well.

79
00:04:09,274 --> 00:04:11,624
That's when we, that's where,
we thought hey let's start.

80
00:04:11,624 --> 00:04:13,844
We all, it's Async is not something new.

81
00:04:13,894 --> 00:04:18,280
Today we already have this Async for Bois,
Bois is bring your own so not bring it on

82
00:04:18,330 --> 00:04:21,030
I'm sorry, is buy online pickup in store.

83
00:04:21,510 --> 00:04:22,890
At T-Mobile we implemented.

84
00:04:23,280 --> 00:04:26,910
Even driven architectures to
support this Bois and Async.

85
00:04:26,970 --> 00:04:29,910
We are designing this and
probably by this NPI, we wanted to

86
00:04:30,160 --> 00:04:31,600
implement this async payment flow.

87
00:04:32,230 --> 00:04:35,960
These flows are unpredictable, a payment,
like I said, a payment may succeed in

88
00:04:35,960 --> 00:04:37,670
three seconds or time out after 30.

89
00:04:38,420 --> 00:04:41,560
And then for Bois inventory is
critical thing 'cause inventory

90
00:04:41,560 --> 00:04:43,330
might change mid transaction.

91
00:04:43,780 --> 00:04:47,090
So what we do for Bo PC is
basically, again, to reserve.

92
00:04:47,095 --> 00:04:48,855
We make a soft reservation call.

93
00:04:49,350 --> 00:04:49,980
For inventory.

94
00:04:50,250 --> 00:04:52,980
And then when customer walks into the
store, we make a hard reservation call.

95
00:04:53,520 --> 00:04:55,770
So all of these calls are tightly coupled.

96
00:04:55,980 --> 00:04:58,290
That's when we thought, hey,
let's do something asing so that

97
00:04:58,290 --> 00:05:00,430
customers can be served in purpose.

98
00:05:00,790 --> 00:05:03,510
And then we had events,
to coordinate all of this.

99
00:05:03,870 --> 00:05:06,330
But it only works if we can see
them happening in real time.

100
00:05:06,580 --> 00:05:08,145
What makes this async hard to.

101
00:05:08,745 --> 00:05:13,045
Observe, regular synchronous calls, we
can log their request response or we can

102
00:05:13,345 --> 00:05:15,565
use lot of tools in Splunk, debug them.

103
00:05:15,565 --> 00:05:20,755
But async flows are, invisible
flows or, we have tools that, that

104
00:05:20,755 --> 00:05:24,175
there, there aren't really many
tools that weren't, that were and

105
00:05:24,175 --> 00:05:26,095
designed to be, to support Async.

106
00:05:26,695 --> 00:05:31,675
Imagine, you imagine trying to follow up
a story where each sentence is told by

107
00:05:31,675 --> 00:05:33,475
a different person at a different time.

108
00:05:33,975 --> 00:05:34,875
That's what it looks like.

109
00:05:34,875 --> 00:05:37,620
Debugging, acing flows, you don't
know, there a lot of events are coming

110
00:05:37,620 --> 00:05:41,460
up and then you listen to the events
and then you process the things.

111
00:05:41,520 --> 00:05:47,130
So the lack of casualty this caused,
that makes traditional monitoring in FHU.

112
00:05:47,580 --> 00:05:51,540
So we need tools to capture relationships,
timing, and internet across systems.

113
00:05:52,040 --> 00:05:55,295
So to me, observability has four pillars.

114
00:05:55,655 --> 00:05:56,645
Distributed caching.

115
00:05:57,365 --> 00:05:58,715
Distributed tracing.

116
00:05:58,985 --> 00:06:01,265
Distributed tracing is something,
you have to, you need to trace events

117
00:06:01,265 --> 00:06:03,485
across services using span correlations.

118
00:06:03,565 --> 00:06:04,465
You need to correlate them.

119
00:06:04,915 --> 00:06:08,295
And then event audits and replay
reconstruct workflows, for

120
00:06:08,295 --> 00:06:09,705
debugging and root corner analysis.

121
00:06:09,705 --> 00:06:12,735
When something goes stronger, you should
be able to reconstruct the workflows

122
00:06:12,735 --> 00:06:14,145
and then debug and find an RCA.

123
00:06:14,595 --> 00:06:17,905
And then consistent monitoring,
validate that business outcomes

124
00:06:17,905 --> 00:06:19,105
are eventually completed.

125
00:06:20,005 --> 00:06:22,885
And we have a lot of domain
dashboards which provide visibility.

126
00:06:23,800 --> 00:06:26,510
Using business centric
metrics and language

127
00:06:27,010 --> 00:06:28,180
in sing systems, right?

128
00:06:28,210 --> 00:06:30,970
Observability isn't about
tracking just technical metrics.

129
00:06:31,360 --> 00:06:34,690
It must reflect the
business journey end to end.

130
00:06:35,140 --> 00:06:37,985
Here's how we approach it
through our four key, four key

131
00:06:37,985 --> 00:06:40,210
pillars, distributed tracing.

132
00:06:40,660 --> 00:06:43,900
We use, in T-Mobile we use tools like
for distributor tracing, we use tools

133
00:06:43,900 --> 00:06:47,900
like open telemetry, to inject trace
context into a request and events.

134
00:06:48,650 --> 00:06:52,880
This lets us correlate
span across microservices.

135
00:06:53,550 --> 00:06:55,170
Even when communication is event based.

136
00:06:55,380 --> 00:06:59,310
When something breaks, we can follow
the trace path and pinpoint the

137
00:06:59,310 --> 00:07:01,080
exact hot way it failed or slow down.

138
00:07:01,680 --> 00:07:03,060
It's a backbone for debugging.

139
00:07:03,150 --> 00:07:08,070
Asy flows, coming to event audits
and replay, async, async flows.

140
00:07:08,070 --> 00:07:10,140
Don't leave a clean lock tray.

141
00:07:10,770 --> 00:07:13,980
So we log constructed events with context.

142
00:07:13,980 --> 00:07:15,480
User id order Id.

143
00:07:16,375 --> 00:07:18,715
Sometimes timestamps
event type, et cetera.

144
00:07:19,315 --> 00:07:21,925
This allows us to replay what
happened during an issue.

145
00:07:22,315 --> 00:07:27,205
Not only does this help with RCA, but
we can also retry failed process without

146
00:07:27,205 --> 00:07:29,125
impacting other parts of the system.

147
00:07:29,375 --> 00:07:33,695
And for consistency monitoring, what
we did was about validating the entire

148
00:07:33,695 --> 00:07:37,625
business transaction was compliant, but
it not just the services are running.

149
00:07:37,745 --> 00:07:40,945
For example, an order placed, you know
what happens when an order is placed?

150
00:07:40,945 --> 00:07:44,665
We reserve an inventory and payment
is confirmed, and then whether

151
00:07:44,665 --> 00:07:46,535
shipment has been initiated or not.

152
00:07:46,685 --> 00:07:51,815
We track the completion of these workflows
across time, services and systems,

153
00:07:52,115 --> 00:07:54,395
even when events are out of order.

154
00:07:54,895 --> 00:07:59,165
Domain dashboards, we build dashboards
that use business language orders.

155
00:07:59,265 --> 00:08:02,475
Whether the pickup is done or not,
whether the payment is in which state,

156
00:08:02,475 --> 00:08:06,255
whether it's in retre or not, whether
inventory check, has been done or not.

157
00:08:06,855 --> 00:08:10,785
These make observability actionable
for non-engineers, like our product

158
00:08:10,785 --> 00:08:13,785
manager is support teams and operations
can understand what's going on

159
00:08:14,055 --> 00:08:15,935
without diving into locks and traces.

160
00:08:16,025 --> 00:08:19,000
So go domain dashboards are really
helpful to, all the team members.

161
00:08:19,500 --> 00:08:23,390
Let me walk you over a book flow,
this is what typically happens

162
00:08:23,390 --> 00:08:24,380
when customer place an order.

163
00:08:24,620 --> 00:08:29,900
What we do is we trigger a, we trigger
an event to validate the inventory, and

164
00:08:29,900 --> 00:08:34,090
then we trigger events to notify store
that, hey, an order is coming up, and then

165
00:08:34,090 --> 00:08:35,740
we trigger an event for pickup children.

166
00:08:36,280 --> 00:08:38,660
These are all independent
services, working in parallel.

167
00:08:39,105 --> 00:08:42,945
Unlike, if it is, if someone logs
into T-Mobile dot com and place

168
00:08:42,945 --> 00:08:44,385
an order, it's all one by one.

169
00:08:44,395 --> 00:08:48,235
Like basically once order is submitted,
then the next step is payment is set, and

170
00:08:48,235 --> 00:08:50,275
then after that it goes to the warehouse.

171
00:08:50,305 --> 00:08:54,115
And then warehouse takes its own
suite time to dispatch the item.

172
00:08:54,265 --> 00:08:59,040
But whereas in case of pop is everything
is async you like right from a payment.

173
00:08:59,160 --> 00:09:00,180
Payment is not acing, sorry.

174
00:09:00,510 --> 00:09:03,410
And the event, the store
notifications are acing.

175
00:09:03,410 --> 00:09:06,600
The validations are acing, and the
pickup sheet, everything is acing, and

176
00:09:06,600 --> 00:09:08,645
for Async and for async payment, right?

177
00:09:08,645 --> 00:09:12,415
Like I mentioned, while customer like
what the main problem that we faced

178
00:09:12,655 --> 00:09:16,285
during last NPA was orders were struck
because the system was done because

179
00:09:16,285 --> 00:09:18,005
of an unexpected volume of orders.

180
00:09:18,484 --> 00:09:21,254
And then what we are
thinking how can we solve it?

181
00:09:21,404 --> 00:09:24,214
What we have been thinking is, retrying
is one option, but when the system is

182
00:09:24,214 --> 00:09:25,894
down, you can't even, that would not help.

183
00:09:26,374 --> 00:09:29,344
So what we're thinking is we
wanted to recouple this payment

184
00:09:29,414 --> 00:09:31,154
processing from the order submission.

185
00:09:31,484 --> 00:09:36,375
So our plan was, when the customer is
present, when a customer does a payment,

186
00:09:36,375 --> 00:09:38,175
since it takes longer than expected.

187
00:09:38,265 --> 00:09:39,585
So we wanted to put on a queue.

188
00:09:40,095 --> 00:09:43,945
Then process it, asing and then
order submission also would be

189
00:09:43,945 --> 00:09:46,555
async only after the payment is
successful, we will process the order.

190
00:09:46,765 --> 00:09:49,295
But let's say if the order is
not successful, if the payment is

191
00:09:49,295 --> 00:09:52,265
not successful, then we want to
trigger a notification to customer,

192
00:09:52,335 --> 00:09:55,275
send a text message or an email
asking to reenter the payment.

193
00:09:55,305 --> 00:09:58,455
And only after the payment is
confirmed, the order would be submitted.

194
00:09:58,545 --> 00:10:02,935
So this way both the payment processing
and the order submission are, as so

195
00:10:02,935 --> 00:10:06,025
we generate an order number and give
it back to customer, like customer is.

196
00:10:06,400 --> 00:10:08,410
Customer doesn't know what's
happening in the background.

197
00:10:08,410 --> 00:10:10,870
He just knows that okay, an order
is submitted, and he wrote an email

198
00:10:10,870 --> 00:10:13,270
saying that, Hey, your order is
submitted and we are working on it.

199
00:10:13,720 --> 00:10:16,540
But in the background, we validate
the payment and if it goes through,

200
00:10:16,540 --> 00:10:17,590
then only we submit the order.

201
00:10:17,890 --> 00:10:19,840
But if the payment doesn't go
through, then we again send a

202
00:10:19,840 --> 00:10:20,980
notification to customer two.

203
00:10:21,320 --> 00:10:22,730
Reenter the cuts.

204
00:10:22,820 --> 00:10:26,090
So this way customers are not
blocked and we are able to capture

205
00:10:26,090 --> 00:10:27,680
the orders and then, process them.

206
00:10:27,930 --> 00:10:31,495
With Async Payments, the best thing
is customers get an instant feedback,

207
00:10:31,915 --> 00:10:34,495
after the order is placed behind
the scenes we are, we check the card

208
00:10:34,495 --> 00:10:36,355
validity, and then we check for fraud.

209
00:10:36,355 --> 00:10:38,185
And we check whether the
card has funds or not.

210
00:10:38,455 --> 00:10:41,805
And if something fails, we fall back
without disrupting the user flow.

211
00:10:42,055 --> 00:10:45,785
Here observability means monitoring
the state excuses, try tracing

212
00:10:45,785 --> 00:10:48,995
failures and ensuring consistency
without sacrificing speed.

213
00:10:49,495 --> 00:10:52,675
So let me, I think we, we spoke
a lot about ing, we really need

214
00:10:52,675 --> 00:10:54,805
tools and techniques through
which we can trace them.

215
00:10:54,860 --> 00:11:00,170
I will go through few tools that we use
at T-Mobile that to track these events.

216
00:11:00,500 --> 00:11:04,760
Open telemetry, open Telemetry is
used to capture and correlate spans

217
00:11:04,820 --> 00:11:06,710
across distributed services and events.

218
00:11:07,160 --> 00:11:09,710
So this is our go-to standard
for distributed tracing.

219
00:11:10,100 --> 00:11:13,520
It allows us to inject trace
series and span context into each

220
00:11:13,520 --> 00:11:14,900
service call and even message.

221
00:11:15,290 --> 00:11:18,290
Even when systems communicate
asynchronously, whether it's an a p

222
00:11:18,290 --> 00:11:22,610
call or an internal microservice call,
or a Kafka message, we tie them all

223
00:11:22,610 --> 00:11:24,470
back to a single customer transaction.

224
00:11:24,950 --> 00:11:28,990
This is critical for our, finding out
what went wrong, especially, in complex

225
00:11:28,995 --> 00:11:30,430
clothes when something goes wrong.

226
00:11:30,930 --> 00:11:34,280
Know, we use a lot of if you want
me, if we have a lot of tools into

227
00:11:34,330 --> 00:11:35,830
the way we monitor open telemetry.

228
00:11:36,020 --> 00:11:40,390
We have SDKs we like in the
web, like in ui we use no Js

229
00:11:40,390 --> 00:11:42,250
and Java, Python, et cetera.

230
00:11:42,640 --> 00:11:46,250
And then at Commerce system
we use data Ho we use Jagger.

231
00:11:46,250 --> 00:11:47,720
We have Grafana.

232
00:11:47,720 --> 00:11:47,960
Grafana is actually.

233
00:11:48,895 --> 00:11:50,945
A lot for our backend
services that we use.

234
00:11:50,975 --> 00:11:54,395
And then sometimes if we, if the service
are hosted on AWS, we use AWS X-ray.

235
00:11:54,905 --> 00:12:00,135
And then for Kafka, like Kafka is actually
central to our async architecture 'cause

236
00:12:00,135 --> 00:12:02,465
it access backbone for event transport.

237
00:12:03,435 --> 00:12:04,485
Here also an observe.

238
00:12:04,845 --> 00:12:06,165
What matters is observability.

239
00:12:06,225 --> 00:12:09,745
So how we monitor, what we monitor,
how we monitor the Q depth, to detect

240
00:12:09,745 --> 00:12:13,525
the backlogs and the consumer lag,
to catch up slow or star services.

241
00:12:13,855 --> 00:12:16,885
And then the throughput, like to
understand how much is a system load.

242
00:12:17,065 --> 00:12:20,745
So what what tools we use here
is, Kafka manager, it manages

243
00:12:20,875 --> 00:12:24,015
the topics, the queues, and also
the clusters, it's deprecated.

244
00:12:24,015 --> 00:12:28,455
I know, but we used to use it
now we also use Grafana, to do a

245
00:12:28,455 --> 00:12:32,475
visualization of Kafka throughput
and partition lag and message drops.

246
00:12:32,625 --> 00:12:36,715
And then we use borough, a consumer lag
monitoring tool for Kafka, error rates for

247
00:12:36,715 --> 00:12:38,885
retrace to catch failing event handlers.

248
00:12:39,035 --> 00:12:42,485
These metrics, help us to detect not
just failures, but also performance

249
00:12:42,485 --> 00:12:45,265
degradation before it impacts users and.

250
00:12:45,515 --> 00:12:47,375
Custom event entry play dashboards.

251
00:12:47,375 --> 00:12:50,425
These dashboards are our internal
dashboards which help to track

252
00:12:50,455 --> 00:12:51,805
and order from end to end, right?

253
00:12:51,805 --> 00:12:56,435
From adding the service to the cart until
it's checked out again, we use Kibana

254
00:12:56,435 --> 00:13:00,805
here, we use Meta Base and then we use
Power bi, and then we use Grafana also.

255
00:13:01,760 --> 00:13:02,930
What are the sources for this?

256
00:13:02,930 --> 00:13:05,780
We use business events that are
business event logs from Kafka

257
00:13:05,780 --> 00:13:07,400
consumers or even gateways.

258
00:13:07,820 --> 00:13:10,960
And then, we use telemetry
systems, all of this.

259
00:13:11,460 --> 00:13:13,200
And how do I measure success?

260
00:13:13,200 --> 00:13:16,300
When I move from sync to async,
how do I measure the success?

261
00:13:16,360 --> 00:13:19,675
The success is basically
today we support the boat.

262
00:13:20,155 --> 00:13:24,865
Like on average we have about 7 million
customers logging into T-Mobile dot com.

263
00:13:25,165 --> 00:13:26,905
Like we registered those
many number of tokens.

264
00:13:27,325 --> 00:13:30,495
But eventually when you look at
the cards so from 7 million, only

265
00:13:30,885 --> 00:13:32,565
one 30 K cards are being created.

266
00:13:33,045 --> 00:13:33,375
Okay?

267
00:13:33,855 --> 00:13:36,715
And all of one 30 k the actual
orders come down to 30 5K.

268
00:13:37,345 --> 00:13:40,875
But when we used asing things, what
we have seen, if you look at the BPI

269
00:13:40,875 --> 00:13:42,735
orders we have seen the checkout rate.

270
00:13:42,735 --> 00:13:46,725
Let's say out of those one 30
k, one 30 K to 30 k, it's almost

271
00:13:46,725 --> 00:13:48,735
one to one inch to four ratio.

272
00:13:49,225 --> 00:13:52,015
But if we look out the BPI
orders are more faster checkout.

273
00:13:52,135 --> 00:13:55,315
Like it's not one inch to four, it's
three to four, like out of let's say we

274
00:13:55,315 --> 00:13:56,785
had, let's say we had a thousand orders.

275
00:13:56,845 --> 00:13:58,825
So the Poppi cards that
are built are only 4,000.

276
00:13:59,095 --> 00:14:01,215
Now this led us to lower abandonment.

277
00:14:01,315 --> 00:14:01,975
The Bois on Bois.

278
00:14:02,725 --> 00:14:05,705
If I see, I can trace that
the card to order conversion

279
00:14:05,705 --> 00:14:07,325
rate is significantly higher.

280
00:14:07,325 --> 00:14:08,165
In case of Bois.

281
00:14:09,095 --> 00:14:11,535
And then we what happened with Async?

282
00:14:11,545 --> 00:14:16,305
We are during the peak time, like
I said NPI we are 97% available.

283
00:14:16,605 --> 00:14:19,665
So even promotional peaks, sometimes
we give promotions saying that, Hey,

284
00:14:19,665 --> 00:14:22,315
buy one, get one, or, to attract
customers saying that, Hey you are

285
00:14:22,315 --> 00:14:23,275
putting in, you get these offer.

286
00:14:23,275 --> 00:14:26,800
So even when we announced those
promotional things tho at that

287
00:14:26,800 --> 00:14:29,650
times also we were almost close
to a hundred percent available.

288
00:14:30,150 --> 00:14:32,370
You see the results
speak themselves faster.

289
00:14:32,370 --> 00:14:34,950
Checkouts mean, higher conversion
and lower abundant rate

290
00:14:34,950 --> 00:14:36,570
shows how we improve trust.

291
00:14:36,960 --> 00:14:40,890
At high uptime during traffic
spikes proves that resilience and

292
00:14:40,890 --> 00:14:44,550
scalability can go ahead, go hand
in hand if observability is right.

293
00:14:44,800 --> 00:14:48,505
I think to, again, you, you have to
when you move from seeing to e right?

294
00:14:49,375 --> 00:14:50,815
You have to do some trade offs.

295
00:14:50,865 --> 00:14:52,905
I hope you all know
what this cap the means.

296
00:14:53,245 --> 00:14:57,225
Cap the means, see for consistency,
every re returns the most recent, right?

297
00:14:57,705 --> 00:14:57,975
Okay.

298
00:14:58,425 --> 00:14:59,055
Availability.

299
00:14:59,295 --> 00:15:03,915
Every request receives a response, and
then partition tolerance system continues

300
00:15:03,915 --> 00:15:05,655
to operate despite network failures.

301
00:15:06,235 --> 00:15:08,485
Yeah, you'll have to trade off,
when you have to be consistent, then

302
00:15:08,485 --> 00:15:10,135
your availability might be lost.

303
00:15:10,135 --> 00:15:13,005
If you're on a syn, synchronous
systems, you'll be consistent.

304
00:15:13,105 --> 00:15:16,250
Because you, you wait for it, it takes
10 seconds or 15 seconds, you'll get that

305
00:15:16,250 --> 00:15:17,870
response back and the customer is present.

306
00:15:18,260 --> 00:15:20,240
So it is very much consistent,
but availability, right?

307
00:15:20,240 --> 00:15:24,345
Like I said, during peak time, gone,
like if you're bombarding it with a lot

308
00:15:24,345 --> 00:15:25,695
of requests, then the system is gone.

309
00:15:26,085 --> 00:15:30,225
But when you move from sync to async,
consistency, I would not say you'll have

310
00:15:30,225 --> 00:15:31,305
to a hundred percent compromise, but.

311
00:15:31,770 --> 00:15:34,920
You might have to make a little
compromise, like I said, right?

312
00:15:35,280 --> 00:15:37,680
So since we do everything
asynchronously, what happens?

313
00:15:37,680 --> 00:15:41,100
Customer I, a device and an accessory,
and then he submit an order, but

314
00:15:41,100 --> 00:15:42,150
by the time he come to the store.

315
00:15:42,750 --> 00:15:46,330
If within the store if there
are no accessories, then you

316
00:15:46,330 --> 00:15:47,200
know, we have to trade off.

317
00:15:47,200 --> 00:15:49,270
Same saying that, hey, you can
only buy a device because it's

318
00:15:49,540 --> 00:15:50,920
access event of out of stock.

319
00:15:51,000 --> 00:15:55,330
It's a little inconsistent, but still,
we try to again keep up the inventory up

320
00:15:55,330 --> 00:15:59,390
to date and make sure that the customer
gets what he pay, what he orders for.

321
00:15:59,540 --> 00:16:02,780
But again, you'll have to trade
off, between availability versus,

322
00:16:02,830 --> 00:16:05,140
consistency and then what we do, right?

323
00:16:05,200 --> 00:16:05,680
What we do.

324
00:16:05,740 --> 00:16:07,990
And in our solution, when we
move from sync to acing, the

325
00:16:08,140 --> 00:16:09,920
important thing is, add potency.

326
00:16:10,230 --> 00:16:14,865
When we, when we make sure if some
failure happens, we have to suppress

327
00:16:14,865 --> 00:16:17,685
this duplicate side effects, let's
say a payment failed, then you

328
00:16:17,685 --> 00:16:20,950
shouldn't continuously charge customer
you should not charge three times.

329
00:16:21,220 --> 00:16:24,490
Make sure that if customer is charged
once, then you don't charge him at all.

330
00:16:25,480 --> 00:16:29,260
And then worsening, tracking changes
and ensuring correct state the solution,

331
00:16:29,770 --> 00:16:31,360
and then compensating transactions.

332
00:16:31,390 --> 00:16:34,225
So if something goes wrong, then we
undo, or mitigate the fail steps.

333
00:16:34,725 --> 00:16:37,805
One of the core, one of the core,
thi one of the core tradeoffs

334
00:16:37,805 --> 00:16:39,965
in distributed systems, is
explained very well by this cap.

335
00:16:39,965 --> 00:16:43,425
The, it tells us, we can only choose
between two of three guarantees.

336
00:16:43,455 --> 00:16:45,795
Like either, cons if you want
to out of these three, right?

337
00:16:45,795 --> 00:16:48,315
The consistency, availability,
partition tolerance, you can only

338
00:16:48,315 --> 00:16:49,815
choose two between sync versus ing.

339
00:16:49,845 --> 00:16:53,045
If it is sync, then it is consistent
and it is partition tolerant.

340
00:16:53,045 --> 00:16:56,045
But if it is asing, then it's
available and then partition tolerant.

341
00:16:56,735 --> 00:17:01,125
And in a high scale event driven commerce
partition tolerance is non-negotiable.

342
00:17:01,275 --> 00:17:02,115
Failures will happen.

343
00:17:02,505 --> 00:17:06,285
So we typically prioritize
availability, meaning we must relax.

344
00:17:06,315 --> 00:17:07,305
Strict consistency.

345
00:17:07,755 --> 00:17:09,645
This leads to eventual consistency.

346
00:17:09,765 --> 00:17:14,765
Data will convert, but not in
instantly to manage this effectively.

347
00:17:14,815 --> 00:17:16,875
We, like I said, we use
a lot of techniques.

348
00:17:17,505 --> 00:17:20,360
We design the services that are I
important so that, repeated events

349
00:17:20,370 --> 00:17:21,520
don't cause duplicate effects.

350
00:17:21,620 --> 00:17:24,280
For example, if payment confirmation
is sent twice we shouldn't

351
00:17:24,280 --> 00:17:25,120
charge the customer again.

352
00:17:25,270 --> 00:17:27,390
We ensure that the RET trays are safe.

353
00:17:27,810 --> 00:17:31,770
And then versioning, we attach
version numbers to entities

354
00:17:31,770 --> 00:17:32,700
like orders of payments.

355
00:17:32,760 --> 00:17:35,370
This helps us detect and
resolve these conditions.

356
00:17:35,760 --> 00:17:39,000
If two systems try to update the same
entities simultaneously, the version

357
00:17:39,000 --> 00:17:40,950
ensures only the correct one is applied.

358
00:17:41,850 --> 00:17:43,350
And then compensating transactions.

359
00:17:43,470 --> 00:17:45,570
We, when things go wrong,
we don't roll back.

360
00:17:45,660 --> 00:17:49,010
We instead, we emit events to
undo the mitigation issues.

361
00:17:49,130 --> 00:17:52,190
For example, if an order was confirmed,
but payment later failed, we aim at a

362
00:17:52,190 --> 00:17:54,230
cancellation event and restore inventory.

363
00:17:54,730 --> 00:17:57,850
Like I said, observability
plays a critical role here.

364
00:17:58,060 --> 00:18:00,310
It alerts us when events fail out of sync.

365
00:18:00,760 --> 00:18:04,090
Tree tray are piling up, or
state transitions don't complete.

366
00:18:04,390 --> 00:18:06,610
Without the availability,
we wouldn't know.

367
00:18:06,640 --> 00:18:10,030
Consistency is broken until
a customer complains with it.

368
00:18:10,090 --> 00:18:13,420
We can react in near real time
and fix issues proactively.

369
00:18:13,920 --> 00:18:14,010
Yeah.

370
00:18:14,010 --> 00:18:16,520
How do we really test the acing systems?

371
00:18:16,850 --> 00:18:20,550
How do we simulate delays, how
do we simulate message losses?

372
00:18:20,560 --> 00:18:22,900
How do we take an action to restart them?

373
00:18:23,790 --> 00:18:27,620
How do we again validate retry,
logic, fallbacks and ency,

374
00:18:28,290 --> 00:18:29,520
focus, again, monitoring.

375
00:18:29,520 --> 00:18:30,780
How do we monitor the Q depth?

376
00:18:30,910 --> 00:18:32,930
How do we monitor, detect the backlogs?

377
00:18:32,930 --> 00:18:35,210
How do we latency, how
do we track the delays?

378
00:18:35,310 --> 00:18:37,890
And then how do we make sure
the events sequencer correct

379
00:18:37,890 --> 00:18:39,990
and complete the testing?

380
00:18:40,020 --> 00:18:43,290
Asynchronous systems is fundamentally
different from traditional applications.

381
00:18:43,740 --> 00:18:46,500
It's not just checking about
individual service or EPAs.

382
00:18:47,190 --> 00:18:49,590
It's about testing the system
behavior over time, under

383
00:18:49,590 --> 00:18:51,360
pressure, and across boundaries.

384
00:18:52,000 --> 00:18:52,630
Let's break it down.

385
00:18:53,245 --> 00:18:54,175
Simulated failures.

386
00:18:54,175 --> 00:18:57,565
We simulate the real world
scenario such as delayed customers.

387
00:18:57,565 --> 00:18:58,915
What happens if a service is slow?

388
00:18:59,365 --> 00:19:01,815
Or if the service is slow
to process a message?

389
00:19:01,995 --> 00:19:03,975
And then what happens
if the message is lost?

390
00:19:03,975 --> 00:19:07,335
What if even never reaches a
destination due to a transit and outage?

391
00:19:07,845 --> 00:19:10,430
And then service, let's say, how
does the system behave when one

392
00:19:10,430 --> 00:19:15,860
component research, media event, this
helps validate our retry, duplicate

393
00:19:15,860 --> 00:19:19,970
duplication, and fallback mechanisms
according, actually work in the practice.

394
00:19:20,130 --> 00:19:22,170
These things work in
practice, but not in theory.

395
00:19:22,920 --> 00:19:23,880
Monitoring essentials.

396
00:19:24,030 --> 00:19:26,865
Asy observability means watching
the systems as connected.

397
00:19:26,865 --> 00:19:28,935
Draft of event flows,
not isolated services.

398
00:19:29,355 --> 00:19:33,220
We focus on Q depth, and where, large
backlogs may indicate low consumers

399
00:19:33,220 --> 00:19:36,040
or broken processs processing latency.

400
00:19:36,310 --> 00:19:39,100
Now, are events being handled
with acceptable time windows?

401
00:19:39,280 --> 00:19:40,720
If not, where's the bottleneck?

402
00:19:41,260 --> 00:19:45,430
Casual chains, we can trace a customer's
order from placement to fulfillment.

403
00:19:45,970 --> 00:19:49,000
Missing links could mean drop
events or unhandled failures.

404
00:19:49,750 --> 00:19:53,230
A common pitfall is thinking a
green dashboard means everything is

405
00:19:53,230 --> 00:19:57,650
okay and in asing systems, services
might be up, but flow is broken.

406
00:19:57,950 --> 00:20:01,100
That's why we don't just, test endpoints,
which as the system end to end,

407
00:20:01,600 --> 00:20:05,900
you know, what lessons we have learned
when we implemented Async, I'll wrap up.

408
00:20:06,000 --> 00:20:09,970
The major lessons that we have learned
from building scaling Async commerce

409
00:20:09,970 --> 00:20:14,955
systems designed for traceability, I. I
always emphasize this, you have to, when

410
00:20:14,955 --> 00:20:18,645
you're building a system, you build the
design on how you want to trace them.

411
00:20:18,945 --> 00:20:21,405
Tracing isn't something
you can bolt on later.

412
00:20:21,505 --> 00:20:24,015
Most of the things we feel that,
we let's implement a design, and

413
00:20:24,015 --> 00:20:25,585
then tracing can be done later.

414
00:20:25,585 --> 00:20:28,255
But for Asing, I would recommend,
first you think of tracing.

415
00:20:28,255 --> 00:20:32,275
How do you want to trace the events
and then it has to be intentional.

416
00:20:32,605 --> 00:20:36,885
This means, using consistent trace IDs,
structural logging, and participating.

417
00:20:37,200 --> 00:20:41,790
And propagating context across services
and event handlers from the start.

418
00:20:42,180 --> 00:20:46,840
If you skip this early, you will struggle,
debug, monitor, and support your systems

419
00:20:46,840 --> 00:20:51,375
as it trust me, it's very hard if you
wanted to think about tracing it then.

420
00:20:51,555 --> 00:20:55,465
So always design, looking at how
you want to trace them, and then

421
00:20:55,585 --> 00:20:59,275
accept and plan for eventual
consistency in distributed systems.

422
00:20:59,725 --> 00:21:02,935
Chasing perfect real consistency will
hurt your availability and scalability.

423
00:21:03,085 --> 00:21:06,595
Instead, we have learned to embrace
eventual consistency and engineer

424
00:21:06,655 --> 00:21:11,365
around it using strategies like
operations, compensating transactions.

425
00:21:11,475 --> 00:21:13,905
Observability is what
keeps us honest there.

426
00:21:14,325 --> 00:21:17,685
It lets us know when consistency breaks
and help us to fix it proactively.

427
00:21:18,185 --> 00:21:21,125
Again, I would say align
metrics to business events.

428
00:21:21,215 --> 00:21:24,395
This is key for making observability
useful beyond engineering.

429
00:21:24,695 --> 00:21:28,025
Developers care about
locks, spans and error, but.

430
00:21:28,760 --> 00:21:32,990
Product managers and support teams care
about orders, not shipping payments,

431
00:21:32,990 --> 00:21:34,700
truck in retre or event or syncing.

432
00:21:34,850 --> 00:21:38,240
So building dashboards and alerts
that helps speak up the language.

433
00:21:38,290 --> 00:21:42,130
It shows how turn it shows, how
you turn observability from a dev

434
00:21:42,130 --> 00:21:43,720
tool into an organizational asset.

435
00:21:44,220 --> 00:21:48,040
I would, I would like to conclude saying
that, as in commerce, architectures

436
00:21:48,130 --> 00:21:51,490
give us what modern demand, scalability,
flexibility, and resilience.

437
00:21:52,180 --> 00:21:55,120
They allow different parts of the
business to move at their own pace.

438
00:21:55,570 --> 00:21:58,570
Orders can be taken while
payments are still processing.

439
00:21:58,720 --> 00:22:02,410
Inventory can update independently,
and notifications can be retried

440
00:22:02,410 --> 00:22:03,430
without blocking the user.

441
00:22:04,000 --> 00:22:04,960
But here's a catch.

442
00:22:05,260 --> 00:22:09,050
What that flexibility comes,
it comes with the complexity.

443
00:22:09,440 --> 00:22:11,660
Things happen in parallel
in different systems.

444
00:22:11,750 --> 00:22:12,770
At unpredictable times.

445
00:22:13,220 --> 00:22:16,400
If we can't see across these
flows, we are flying by it.

446
00:22:17,120 --> 00:22:18,500
That's why observability isn't.

447
00:22:19,055 --> 00:22:20,015
Just the technical layer.

448
00:22:20,075 --> 00:22:21,335
It's a strategic enabler.

449
00:22:22,175 --> 00:22:26,105
It's what allows us to build fast,
recover faster, and continuously

450
00:22:26,105 --> 00:22:28,475
improve when observability is built.

451
00:22:28,895 --> 00:22:32,845
We don't want just to operate, we
understand, when something grow,

452
00:22:33,145 --> 00:22:35,155
wide, grow and what to do next.

453
00:22:35,635 --> 00:22:39,355
That's how we maintain trust in
the customer experience, even

454
00:22:39,355 --> 00:22:40,705
when the backend gets messy.

455
00:22:41,205 --> 00:22:42,615
So as we build asynchronous.

456
00:22:42,960 --> 00:22:44,490
Commerce event driven systems.

457
00:22:44,730 --> 00:22:47,460
Let's make sure observability
stays a first class citizen.

458
00:22:48,030 --> 00:22:51,840
It's the difference between hopping
things work and knowing they do.

459
00:22:52,340 --> 00:22:57,910
And thank you very much for patiently
listening on this, and please let me know,

460
00:22:57,960 --> 00:23:01,140
like when you are building, when you're
building anything acing, I'm happy to.

461
00:23:01,605 --> 00:23:01,935
Help.

462
00:23:02,145 --> 00:23:06,320
And I, I hope decision gives you practical
insights about building and operating

463
00:23:06,320 --> 00:23:08,270
async commerce systems with confidence.

464
00:23:08,840 --> 00:23:12,830
And if you're working on similar
architectures or facing any challenges, I

465
00:23:12,830 --> 00:23:14,420
would love to continue this conversation.

466
00:23:14,540 --> 00:23:17,690
Feel free to reach me via email
or connect me on LinkedIn.

467
00:23:18,190 --> 00:23:18,610
Thank you.

468
00:23:18,940 --> 00:23:19,330
Bye-bye.

469
00:23:19,600 --> 00:23:20,110
Have a good day.

