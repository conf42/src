1
00:00:00,500 --> 00:00:01,190
Hello everyone.

2
00:00:01,549 --> 00:00:05,180
Welcome to Con 42, rust Plan 2025.

3
00:00:06,140 --> 00:00:10,219
My name is Vin Kana and I'm thrilled to be
here to talk about something I have been

4
00:00:10,219 --> 00:00:15,080
personally passionate about combining the
power of Rust with AWS Cloud services.

5
00:00:15,830 --> 00:00:20,060
Over the next several minutes, we will
explore how rust performance, safety,

6
00:00:20,210 --> 00:00:24,590
efficiency, make it a great choice
for building cloud native applications

7
00:00:24,590 --> 00:00:28,820
that scaled reliably instead of just
theory, we'll walk through our flowing.

8
00:00:29,165 --> 00:00:31,084
Example system step by step.

9
00:00:31,084 --> 00:00:35,824
So you live with a clear mental model
of how this can apply to a real world.

10
00:00:35,944 --> 00:00:36,635
Workloads

11
00:00:37,135 --> 00:00:42,085
when you build on AWS scale is
always central applications may

12
00:00:42,085 --> 00:00:45,205
need to handle millions of events,
thousands of concurrent requests

13
00:00:45,205 --> 00:00:49,495
and unpredictable workloads at that
level, every milliseconds of latency

14
00:00:49,495 --> 00:00:52,105
and every MB of memory counts.

15
00:00:52,605 --> 00:00:57,075
Rust combines predictable performance
similar to c RC plus with compiled and

16
00:00:57,075 --> 00:01:02,175
guarantees that eliminates common runtime
issues for Lambda functions or ECS tasks.

17
00:01:02,445 --> 00:01:09,795
Small binaries reduce cold start star
types and lean memory uses cut cuts costs.

18
00:01:10,785 --> 00:01:16,095
This blend of performance and safety
makes rust an excellent choice when you

19
00:01:16,215 --> 00:01:18,645
care about efficiency and reliability.

20
00:01:19,145 --> 00:01:22,055
Let's compare rust agonist
to other popular languages.

21
00:01:22,205 --> 00:01:29,815
In AWS Go is a strong for Lambda and
containers, thanks to go routines, but

22
00:01:29,905 --> 00:01:32,245
it, its runtime is bigger than rust.

23
00:01:32,755 --> 00:01:36,985
Java has massive ecosystem, but coal
starts and memory overheads are costly.

24
00:01:37,495 --> 00:01:42,024
No JS offers fast development, but
struggles with CPU bound workloads.

25
00:01:42,475 --> 00:01:46,345
Python is unbeatable for
prototyping and ML libraries.

26
00:01:47,065 --> 00:01:52,195
Though it slows down at scale, c
plus delivers raw power, but manual

27
00:01:52,225 --> 00:01:57,975
memory makes it error prone rust
balances performance near c plus with

28
00:01:57,975 --> 00:02:03,765
safety and compiled and guarantees
that combine that combination makes

29
00:02:03,825 --> 00:02:06,075
rust stand out for cloud workloads.

30
00:02:06,574 --> 00:02:09,574
Where does rust shame for Lambda?

31
00:02:09,574 --> 00:02:13,295
Small binaries equal for or
equal faster cold starts.

32
00:02:14,179 --> 00:02:19,869
The borrow checker enforces memory safety,
preventing bugs before develop deployment.

33
00:02:20,649 --> 00:02:25,030
With Tokyo, you can run thousands
of async calls to AWS services

34
00:02:25,030 --> 00:02:26,560
without overwhelming threats.

35
00:02:27,060 --> 00:02:33,180
That reduces CPU and memory lowering
costs In loan Lambda, ECS and EKS, strong

36
00:02:33,180 --> 00:02:36,960
typing issues, requests are valid at
compiled, preventing misconfigurations

37
00:02:36,990 --> 00:02:39,120
from ever reaching production.

38
00:02:39,620 --> 00:02:41,239
But rust isn't perfect.

39
00:02:41,739 --> 00:02:43,179
Compiled times can be long.

40
00:02:43,269 --> 00:02:48,820
In large projects, ownership and
lifetimes have a steep learning curve.

41
00:02:49,179 --> 00:02:54,160
The ecosystem is maturing, but Java and
Python have more polished libraries.

42
00:02:54,670 --> 00:02:57,940
Tooling for Lambda is improving,
but Python and Node still offer more

43
00:02:57,940 --> 00:03:04,209
templates and rust favors explicitness
over dynamic meta programming.

44
00:03:04,779 --> 00:03:08,200
Which is safer but less
flexible for quick experiments.

45
00:03:08,700 --> 00:03:13,230
Being aware of these trade offs
makes adoption decision realistic.

46
00:03:13,730 --> 00:03:16,910
The A-W-S-S-D-K for Rust
provides strong support.

47
00:03:17,410 --> 00:03:22,600
Each service is its own create,
so you input only what you need.

48
00:03:22,900 --> 00:03:28,150
Shared configuration handles, credentials
and regions securely built on Tokyo.

49
00:03:28,390 --> 00:03:30,250
It's first making it.

50
00:03:30,715 --> 00:03:32,274
Efficient for input output.

51
00:03:33,114 --> 00:03:37,225
With retries, ation and streaming
built in, developers can focus on

52
00:03:37,225 --> 00:03:39,204
value rather than boiler plate.

53
00:03:39,704 --> 00:03:43,724
To make this concrete, let's
build a file ingestion pipeline.

54
00:03:44,224 --> 00:03:50,404
A user uploads to S3 and even flows
through event bridge into SQS.

55
00:03:50,884 --> 00:03:54,664
Rust worker workers process,
it DynamoDB storage results

56
00:03:54,934 --> 00:03:56,494
and observability keeps watch.

57
00:03:57,319 --> 00:03:58,339
This example matters.

58
00:03:58,339 --> 00:04:00,019
Real world patterns and highlights.

59
00:04:00,409 --> 00:04:01,489
Russ value at each step.

60
00:04:01,989 --> 00:04:03,819
Step one, upload files.

61
00:04:04,319 --> 00:04:07,259
With Russ STK, you gain compiled time.

62
00:04:07,259 --> 00:04:12,419
Assurance that requests are valid,
I think lets you upload many files

63
00:04:12,419 --> 00:04:13,679
concurrently without blocking.

64
00:04:14,339 --> 00:04:19,799
This builds confidence that what you
send to AWS S3 is correct and efficient.

65
00:04:20,299 --> 00:04:21,649
Next triggering process.

66
00:04:21,649 --> 00:04:24,704
C, even Bridge sends S3 events into SQS.

67
00:04:24,909 --> 00:04:30,299
Trust workers consume messages safely
DC realizing them with third, A sync

68
00:04:30,359 --> 00:04:34,289
workers scale out efficiently, letting
you process hundreds of events in

69
00:04:34,289 --> 00:04:35,849
parallel without adding threats.

70
00:04:36,209 --> 00:04:39,419
This is where Rust, A sync runtime shines.

71
00:04:39,899 --> 00:04:42,839
For compute, we'd apply to Lambda Rust.

72
00:04:42,839 --> 00:04:45,659
Binaries are small,
giving faster cold stocks.

73
00:04:46,079 --> 00:04:47,584
Execution is predictable and efficient.

74
00:04:47,864 --> 00:04:53,084
With As think a single function can manage
multiple tasks compared to Java or T

75
00:04:53,324 --> 00:04:58,024
net Runtimes, rust Lambda are lighter,
cheaper, and faster After processing,

76
00:04:58,294 --> 00:05:02,094
we persist results in Dynamo DB Rust.

77
00:05:02,094 --> 00:05:05,844
Builders enforce correctness at
compiler as think queries let you

78
00:05:06,204 --> 00:05:07,884
scale to thousands of operations.

79
00:05:08,004 --> 00:05:09,474
The system stays responsive.

80
00:05:09,534 --> 00:05:12,944
Even under heavy load
observability is essential.

81
00:05:13,349 --> 00:05:18,359
With the tracing crate, you add
structured spans into a sync workflows

82
00:05:18,809 --> 00:05:23,219
pair with open telemetry and metrics
stream into CloudWatch for errors.

83
00:05:23,399 --> 00:05:29,759
Anyhow, are the errors capture
detailed context together, this makes

84
00:05:29,759 --> 00:05:32,009
debugging faster and operations.

85
00:05:32,509 --> 00:05:37,519
No, AWS system is complete Without
security and deployment use IAM

86
00:05:37,519 --> 00:05:38,869
with the least privileged role.

87
00:05:38,929 --> 00:05:44,179
And KMS to encrypt sensitive data for
Lambda Cross compiled to muzzle for

88
00:05:44,179 --> 00:05:46,819
small static binaries in containers.

89
00:05:46,819 --> 00:05:51,979
Multi-stage builds, strip unnecessary
dependencies, shrinking image

90
00:05:51,979 --> 00:05:53,569
size, and improving security.

91
00:05:54,069 --> 00:05:56,769
To recap, rust compile time.

92
00:05:56,769 --> 00:06:01,989
Safety prevents runtime bug,
I think first makes it perfect

93
00:06:01,989 --> 00:06:03,579
for input output workload.

94
00:06:04,014 --> 00:06:08,184
The modular SDK is easy to adapt and
end-to-end patterns map naturally

95
00:06:09,144 --> 00:06:10,434
compared to other languages.

96
00:06:10,464 --> 00:06:13,074
Rust blend of performance
and safety is unique.

97
00:06:13,574 --> 00:06:15,704
In closing, rust is ready for cloud.

98
00:06:16,424 --> 00:06:21,914
It combines system level performance with
strong safety guarantees, makes making

99
00:06:21,914 --> 00:06:24,254
it ideal for AWS workloads at scale.

100
00:06:24,524 --> 00:06:29,324
The SDK provides the tools and our
example showed rust across AWS landscape.

101
00:06:29,824 --> 00:06:33,694
If you're building next generation
cloud native apps, rust is not just

102
00:06:33,694 --> 00:06:35,284
experimental, it's production ready.

103
00:06:36,274 --> 00:06:40,899
Thank you and I hope this inspires
you to try Rust in your AWS projects.

104
00:06:41,399 --> 00:06:41,519
I.

