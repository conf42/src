1
00:00:00,000 --> 00:00:00,840
Hello everyone.

2
00:00:01,170 --> 00:00:07,500
Today I'm excited to share my thoughts on
migrating monolithic SaaS to serverless

3
00:00:07,560 --> 00:00:12,660
achieving scalability, cost reduction,
and development agility on AWS.

4
00:00:13,160 --> 00:00:16,340
Hi, I'm Stricker Kampala,
a senior software engineer.

5
00:00:16,340 --> 00:00:20,840
With over 13 years of experience, I've
dedicated my career to crafting innovative

6
00:00:20,869 --> 00:00:23,600
and scalable software solutions.

7
00:00:23,660 --> 00:00:26,869
If you have any questions
about this presentation.

8
00:00:27,214 --> 00:00:31,205
Or anything related to migrating
monolithic to SaaS in general,

9
00:00:31,655 --> 00:00:36,815
please reach out to me at
reach ryker compala@gmail.com.

10
00:00:37,315 --> 00:00:38,935
So let's start.

11
00:00:39,145 --> 00:00:41,845
Why choose Golan for
serverless architecture?

12
00:00:41,935 --> 00:00:46,615
Golan stands align exceptionally well
with the demands of service computing.

13
00:00:47,005 --> 00:00:51,175
High performance goal line compile
nature results in rapid execution

14
00:00:51,175 --> 00:00:53,125
speeds and minimal latency.

15
00:00:53,635 --> 00:00:57,085
Crucial in serverless environments
where costs are directly tied to

16
00:00:57,085 --> 00:01:01,105
the execution time benchmarking
consistently shows goal line functions.

17
00:01:01,135 --> 00:01:06,565
Outperforming interpreted languages like
Python in AWS, and Lambda scenarios often

18
00:01:06,565 --> 00:01:08,695
exhibiting significantly lower latency.

19
00:01:09,265 --> 00:01:15,384
This translates to reduced execution
duration and consequently lower cost.

20
00:01:15,865 --> 00:01:20,995
Efficient memory management goes
Optimized garbage collector is designed

21
00:01:20,995 --> 00:01:22,764
for concurrency and no latency.

22
00:01:22,824 --> 00:01:25,525
Essential for scalable
serverless applications.

23
00:01:25,884 --> 00:01:30,025
Its efficient memory footprint,
minimizes resource consumption.

24
00:01:30,085 --> 00:01:34,285
Further contributing to cost
effectiveness in serverless functions

25
00:01:34,315 --> 00:01:36,655
where memory allocation impacts pricing.

26
00:01:36,715 --> 00:01:39,925
Goal line efficiency provides
a tangible advantage.

27
00:01:40,405 --> 00:01:41,485
Concurrent programming.

28
00:01:42,130 --> 00:01:46,090
Golang core routines provide a
lightweight and efficient way

29
00:01:46,150 --> 00:01:47,890
to handle concurrent operations.

30
00:01:48,040 --> 00:01:51,910
This allows Lambda functions to process
numerous parallel requests without

31
00:01:51,910 --> 00:01:53,680
complexities of traditional threading.

32
00:01:54,100 --> 00:01:58,390
This especially beneficial for
applications dealing with high

33
00:01:58,390 --> 00:02:00,850
volumes of concurrent events.

34
00:02:01,435 --> 00:02:04,795
For instance, in event driven
architectures, Golan concurrency

35
00:02:04,795 --> 00:02:08,785
model enables rapid and efficient
processing of incoming events.

36
00:02:09,205 --> 00:02:13,435
Benchmarking has also shown that due
to the efficiency of quarantines, that

37
00:02:13,435 --> 00:02:19,255
Golan is able to handle a larger number
of concurrent requests other than.

38
00:02:19,625 --> 00:02:23,915
then other languages such as Python,
given the same memory constraints.

39
00:02:24,245 --> 00:02:28,204
In a sense, Golan performance,
efficiency, and concurrency

40
00:02:28,204 --> 00:02:32,825
capabilities make it a strong tender
for building a cost effective and

41
00:02:32,880 --> 00:02:34,829
highly scalable service applications.

42
00:02:35,329 --> 00:02:40,760
Now combining Golan with AWS, that's
a purposeful serverless synergy.

43
00:02:41,270 --> 00:02:44,510
Lambda function, support
and reduced cold starts.

44
00:02:44,780 --> 00:02:48,830
AWS Na Lambda's Native support
for coal Lamb allows developers

45
00:02:48,830 --> 00:02:52,280
to build highly scalable and
cost-effective service applications.

46
00:02:52,760 --> 00:02:58,210
Golans, compile nature and small boundary
size, translate to significantly reduced

47
00:02:58,210 --> 00:03:02,535
cold start times compared to interpreted
languages like python and or chase.

48
00:03:03,035 --> 00:03:04,495
In real world benchmarks.

49
00:03:04,780 --> 00:03:09,700
GoLine Lambda functions often exhibit a
cold circulations in tens of milliseconds.

50
00:03:10,045 --> 00:03:13,645
Minimizing latency and improving
user experience, especially for

51
00:03:13,645 --> 00:03:15,175
latency sensor applications.

52
00:03:15,685 --> 00:03:20,000
For example, in a test using AWS
Lambda Golan called start times were

53
00:03:20,240 --> 00:03:21,880
measured to be 10 to 20 milliseconds.

54
00:03:21,880 --> 00:03:24,295
While Python called start
times were measured to be a

55
00:03:24,295 --> 00:03:25,765
hundred to 200 milliseconds.

56
00:03:26,095 --> 00:03:31,450
Were, when performing the same task, cost
efficiency through optimized footprint.

57
00:03:32,110 --> 00:03:36,575
Golans compiled binary like
release are notably smaller, than

58
00:03:36,575 --> 00:03:37,599
those of interpret languages.

59
00:03:38,084 --> 00:03:41,355
this results in faster deployment
times, reducing the time spent on

60
00:03:41,355 --> 00:03:43,605
uploading, function packages to S3.

61
00:03:43,905 --> 00:03:48,465
Moreover, the reduced to binary size
translates to lower storage costs on S3.

62
00:03:48,855 --> 00:03:52,125
Combined with coal lines
optimized execution speed, which

63
00:03:52,125 --> 00:03:53,625
minimizes the Lambda runtime.

64
00:03:53,655 --> 00:03:56,925
This leads to significant cost
savings in service en environment,

65
00:03:57,315 --> 00:03:59,595
seamless integration and performance.

66
00:03:59,970 --> 00:04:04,975
Golan integrates seamlessly with
core AWS services like Dyod, dp,

67
00:04:04,980 --> 00:04:07,740
SD API, gateway and CloudWatch.

68
00:04:08,160 --> 00:04:13,180
This natively, this NATO compatibility,
ensures scalability without

69
00:04:13,180 --> 00:04:15,130
introducing performance bottlenecks.

70
00:04:15,399 --> 00:04:19,599
Golan concurrency model and low
latency execution are particularly

71
00:04:19,599 --> 00:04:23,650
beneficial when interacting with these
services, enabling efficient data

72
00:04:23,650 --> 00:04:25,599
processing, and real time even handling.

73
00:04:25,614 --> 00:04:30,264
For instance, a GoLine Lambda function
triggered by an S3 event can process

74
00:04:30,264 --> 00:04:35,004
and store data in Dymo DB with
minimal overhead and high throughput.

75
00:04:35,574 --> 00:04:40,014
Benchmarking has also shown that
GoLine Lambda functions can achieve

76
00:04:40,014 --> 00:04:44,374
significantly higher throughput when
interacting with Dymo db, compared to

77
00:04:44,464 --> 00:04:48,759
Python or no JS functions due to its
efficiency of coal and concurrency model

78
00:04:48,904 --> 00:04:51,359
and native integration with A-W-S-S-D-K.

79
00:04:51,859 --> 00:04:57,369
Now let's talk about why Golan and
Golan, with other versus other languages.

80
00:04:57,369 --> 00:04:59,889
So performance and efficiency showed up.

81
00:05:00,389 --> 00:05:04,499
Overall performance, Golan
consistently outperforms Java,

82
00:05:04,799 --> 00:05:07,049
Python, no JS in AWS and environment.

83
00:05:07,199 --> 00:05:11,489
This is primarily due to its
compiled nature, resulting in faster

84
00:05:11,489 --> 00:05:15,484
execution speeds and significantly
reduced cold stack names.

85
00:05:16,124 --> 00:05:19,904
Benchmarks frequently demonstrate
that coal line functions can achieve

86
00:05:19,904 --> 00:05:24,284
execution times several execution
times, several times faster than their

87
00:05:24,284 --> 00:05:26,144
counterparts in digital languages.

88
00:05:26,444 --> 00:05:31,724
This translates to global latency
in improve user experience and cost,

89
00:05:31,824 --> 00:05:33,924
reduced cost in service applications.

90
00:05:34,344 --> 00:05:34,974
Java.

91
00:05:35,094 --> 00:05:35,124
Okay.

92
00:05:35,814 --> 00:05:40,104
Java offers robust nets and reach
ecosystem, but it suffers from a

93
00:05:40,104 --> 00:05:44,484
longer code of start times and in
serverless environment, especially the

94
00:05:44,484 --> 00:05:49,674
JVM initialization overhead introduced
a significant latency, especially

95
00:05:49,674 --> 00:05:51,684
for infrequently invoked functions.

96
00:05:51,984 --> 00:05:57,174
This increased latency directly impacts
impact cost due to longer execution times,

97
00:05:57,174 --> 00:06:02,664
and can lead to poor user experiences
in latency sensitive applications.

98
00:06:03,084 --> 00:06:03,894
No js.

99
00:06:04,614 --> 00:06:04,914
No.

100
00:06:04,914 --> 00:06:08,184
JC is a popular for serverless
due to its Java, skip familiarity

101
00:06:08,634 --> 00:06:10,434
and event driven architecture.

102
00:06:10,465 --> 00:06:15,414
However, it underperforms coal and in CCP
intensive tasks and concurrent processing.

103
00:06:15,804 --> 00:06:19,104
Its single threaded nature can become
a bottleneck when handling numerous

104
00:06:19,314 --> 00:06:22,794
panel requests leading to increase
latency and potential performance

105
00:06:22,794 --> 00:06:27,955
degradation Benchmarks indicate that
Golan can handle significantly more

106
00:06:28,014 --> 00:06:30,049
concurrent requests than node js.

107
00:06:30,669 --> 00:06:34,149
Under the same memory constraints,
particularly in the scenarios

108
00:06:34,149 --> 00:06:39,039
involving heavy competition or
input output operations, Python.

109
00:06:39,489 --> 00:06:44,919
Python is excellent for rapid development
and offers a vast library ecosystem

110
00:06:44,919 --> 00:06:46,869
making it popular choice for servers.

111
00:06:46,899 --> 00:06:52,269
However, Golans compile nature delivers
faster execution and lower resource

112
00:06:52,269 --> 00:06:57,279
consumption, enhancing the production
scalability in high throughput and

113
00:06:57,340 --> 00:06:59,259
or low latency critical applications.

114
00:06:59,889 --> 00:07:02,909
Where performance, advantage
becomes more crucial.

115
00:07:03,599 --> 00:07:07,890
While Python excels in the use of
development and speed goal and sufficiency

116
00:07:07,890 --> 00:07:11,789
in terms of memory, usage and execution
times makes it more suitable choice for

117
00:07:11,789 --> 00:07:16,349
production environments where scalability
and cost effectiveness are paramount.

118
00:07:16,849 --> 00:07:21,620
When compact to goal line, Python often
consumes more memory and has higher

119
00:07:21,620 --> 00:07:23,659
execution times for the same task.

120
00:07:24,050 --> 00:07:28,610
Especially when dealing with large
data sets or complex algorithms.

121
00:07:29,060 --> 00:07:33,735
By incorporating these data points and
contextual insights, the comparison

122
00:07:33,805 --> 00:07:38,300
between Golang and other languages
become more compelling and informative,

123
00:07:38,690 --> 00:07:43,610
highlighting the specific advantage
of Golang in serverless architectures.

124
00:07:44,110 --> 00:07:47,700
Now, why migrate to
serverless architecture?

125
00:07:47,800 --> 00:07:51,190
We've seen cost reductions up to 80%.

126
00:07:51,610 --> 00:07:52,330
Serverless.

127
00:07:52,390 --> 00:07:54,670
A pay for execution
model is a game changer.

128
00:07:54,760 --> 00:07:57,125
Unlike traditional
servers that incur costs.

129
00:07:57,745 --> 00:08:03,135
When even idle serverless charges only
for, the compute time consumed, the,

130
00:08:03,165 --> 00:08:07,245
this is particularly beneficial for
applications with fluctuating workloads

131
00:08:07,245 --> 00:08:10,065
or those in experiencing infrequent usage.

132
00:08:10,485 --> 00:08:15,425
The, 80% suggest, that a, it is
a significant potential for cost

133
00:08:15,455 --> 00:08:19,055
savings, but the actual percentage
will vary depending on the specific

134
00:08:19,055 --> 00:08:20,705
application and usage patterns.

135
00:08:21,365 --> 00:08:26,075
This cost reduction allows companies to
invest in more resources into development

136
00:08:26,105 --> 00:08:32,405
and innovation rather than infrastructure
maintenance, faster deployment up to 70%.

137
00:08:33,335 --> 00:08:35,825
Serverless architectures enable
faster deployment cycles.

138
00:08:35,825 --> 00:08:39,905
Through streamlined pipelines, developers
can deploy individual functions

139
00:08:39,905 --> 00:08:41,585
or microservices independently.

140
00:08:42,110 --> 00:08:45,670
Reducing the risk of, impact,
impacting the entire application.

141
00:08:46,090 --> 00:08:50,810
The 70%, improvement indicates a
notable improvement in the deployment

142
00:08:50,810 --> 00:08:55,100
speed, which is crucial for staying
competitive in today's fast paced market.

143
00:08:55,760 --> 00:09:00,990
This agility allows, for rapid duration
and faster time to market features and

144
00:09:00,990 --> 00:09:04,170
updates improved scalability up to 60%.

145
00:09:04,260 --> 00:09:07,790
Serverless platforms automatically
scaled resources based on demand

146
00:09:07,790 --> 00:09:10,970
and eliminating the need for manual
provisioning or capacity planning.

147
00:09:11,270 --> 00:09:16,370
This ensures that the applications
can handle certain traffic spikes

148
00:09:16,430 --> 00:09:18,960
without, the performance degradation.

149
00:09:19,320 --> 00:09:22,741
The 60% highlights are, that
the significant, benefits of the

150
00:09:22,746 --> 00:09:27,465
serverless, enabling applications to
handle unpredictable loads with ease.

151
00:09:27,960 --> 00:09:31,530
This auto-scaling capability ensures
a consistent user experience.

152
00:09:31,560 --> 00:09:37,820
Even during PQSH periods, operational
gains of, over 50% serverless

153
00:09:37,820 --> 00:09:42,650
platforms handle infrastructure
management, including the server

154
00:09:42,650 --> 00:09:44,930
maintenance, patching and scaling.

155
00:09:45,320 --> 00:09:49,340
This free sub development teams
to focus more on building and

156
00:09:49,340 --> 00:09:52,790
improving applications rather
than managing the infrastructure.

157
00:09:52,790 --> 00:09:53,120
The fifth.

158
00:09:53,675 --> 00:09:57,365
This represents the reduction in
operational overhead, allowing the

159
00:09:57,365 --> 00:10:02,705
development teams to concentrate on
innovation and core business objectives.

160
00:10:03,035 --> 00:10:06,845
This reduction in maintenance allows
for a quicker updates and less downtime.

161
00:10:07,745 --> 00:10:11,765
Now let's take a look at the
code AWS servers technologies.

162
00:10:11,885 --> 00:10:13,865
Like AWS Lambda.

163
00:10:14,315 --> 00:10:16,625
Lambda is the compute
engine of serverless.

164
00:10:16,655 --> 00:10:18,740
It allows, us to run the code.

165
00:10:19,190 --> 00:10:21,350
Without provisioning or managing servers.

166
00:10:21,380 --> 00:10:25,070
Lambda functions are triggered
by events from other AWS services

167
00:10:25,340 --> 00:10:30,381
or external sources such as API
Gateway, SD DynamoDB, CloudWatch.

168
00:10:30,860 --> 00:10:34,250
So the, there are a
large number of benefits.

169
00:10:34,400 --> 00:10:37,070
It is no server not managed by servers.

170
00:10:37,400 --> 00:10:40,655
It frees up developers from
infrastructure tasks, automatic scaling.

171
00:10:41,465 --> 00:10:45,635
Scales automatically based on
demand pay, execution model.

172
00:10:45,935 --> 00:10:48,555
You're charged only for the
commute, compute, time that we

173
00:10:48,555 --> 00:10:53,685
consume, cost effective I for,
and even intermittent workloads.

174
00:10:54,375 --> 00:10:58,800
Now, DynamoDB is a fully managed
no SQL database pro, and it

175
00:10:58,800 --> 00:11:03,510
provides a consistent single digit
millisecond latency at any scale.

176
00:11:04,080 --> 00:11:09,240
It automatically scales to handle
virtually unlimited data and

177
00:11:09,240 --> 00:11:14,400
traffic supports both document
and key value data models.

178
00:11:15,030 --> 00:11:19,020
It offers built-in fault
tolerance and high availability.

179
00:11:19,380 --> 00:11:23,680
It is ideal for applications
requiring, high throughput, low

180
00:11:23,680 --> 00:11:25,700
latency, and flexible, data models.

181
00:11:26,200 --> 00:11:28,530
Now let's take a look at API gateway.

182
00:11:28,580 --> 00:11:32,180
the core function of it is it acts
as a front door of applications to

183
00:11:32,180 --> 00:11:36,260
access backend services, including
lambda functions and NO db.

184
00:11:36,920 --> 00:11:40,910
The key features of API
gateway are API management.

185
00:11:40,940 --> 00:11:45,210
It simplifies the creation and
publishing, maintenance, monitoring

186
00:11:45,210 --> 00:11:48,900
and security of APIs, protocol support.

187
00:11:49,875 --> 00:11:53,045
Pro, IT support restful
and web socket APIs.

188
00:11:53,795 --> 00:12:00,035
It provides both built-in authorization
authentication and API key management.

189
00:12:00,455 --> 00:12:04,445
The traffic management, it offers
throttling, caching and request,

190
00:12:04,755 --> 00:12:06,375
transformation capabilities.

191
00:12:06,735 --> 00:12:11,185
The use cases are it enabled,
building scalable and secure APIs

192
00:12:11,185 --> 00:12:14,075
for me, mobile and IOT applications.

193
00:12:14,960 --> 00:12:19,190
Now let's take a look at
enhancing operational efficiency

194
00:12:19,190 --> 00:12:21,725
with AWS S3 and CloudWatch.

195
00:12:22,225 --> 00:12:28,870
when we dive deep into AWS S3, S3 is
a centralized storage, like S3 access,

196
00:12:28,870 --> 00:12:33,880
s central repository for various types
of data, including application data,

197
00:12:33,880 --> 00:12:36,910
backups, logs, images, everything.

198
00:12:37,410 --> 00:12:41,100
This simplifies data management
and ensures data consistency.

199
00:12:41,475 --> 00:12:42,975
It's cost effectiveness.

200
00:12:43,005 --> 00:12:48,855
S3 is a pay as you go pricing model,
which makes it a very cost effective

201
00:12:48,855 --> 00:12:53,805
solution for large storage volumes
of data, especially for applications

202
00:12:53,805 --> 00:12:55,455
with fluctuating storage needs.

203
00:12:55,875 --> 00:12:58,125
It's integration with Lambdas.

204
00:12:58,185 --> 00:13:03,110
Seamless integration with AWS Lambda
enables developers to perform data

205
00:13:03,160 --> 00:13:07,425
operations directly from their
Lambda functions without managing

206
00:13:07,455 --> 00:13:09,435
underlying infrastructure, for example.

207
00:13:09,840 --> 00:13:15,150
Lambda functions can be triggered by S3
events such as file uploads or deletions.

208
00:13:15,630 --> 00:13:25,470
The extreme durability of S3 99.9 9
9 9 9 9 9 9 9, so a lot of 9 99 0.9

209
00:13:25,470 --> 00:13:31,120
nines ensures the data is protected
against, the data loss making

210
00:13:31,120 --> 00:13:32,680
suitable for critical applications.

211
00:13:33,180 --> 00:13:34,110
Now AWS CloudWatch.

212
00:13:34,610 --> 00:13:39,515
CloudWatch is mainly used for logging
metric collection and observability.

213
00:13:40,325 --> 00:13:43,990
Cloud CloudWatch provides real time
monitoring and insights, into the

214
00:13:43,990 --> 00:13:46,150
performance of serverless applications.

215
00:13:46,390 --> 00:13:50,500
This allows developers to identify
and resolve issues quickly.

216
00:13:50,890 --> 00:13:55,420
Log in metric collection, CloudWatch
collects logs and metrics from various

217
00:13:55,420 --> 00:13:57,995
AWS services, including AWS Lambda.

218
00:13:58,480 --> 00:14:00,250
Dyod DB and EC2.

219
00:14:00,280 --> 00:14:05,200
This provides a comprehensive view of
the application's health and performance.

220
00:14:05,620 --> 00:14:07,270
Customizable dashboards.

221
00:14:07,630 --> 00:14:11,500
CloudWatch dashboards enable developers
to create custom visualizations

222
00:14:11,860 --> 00:14:13,620
of their, application metrics.

223
00:14:13,620 --> 00:14:16,800
This helps in identifying
trends, detecting anomalies,

224
00:14:16,830 --> 00:14:18,930
and optimizing performance.

225
00:14:19,230 --> 00:14:23,010
Proactive monitoring CloudWatch
allows you to set up alarms and

226
00:14:23,010 --> 00:14:24,210
notifications to you a potential.

227
00:14:24,710 --> 00:14:26,690
issues before they impacted users.

228
00:14:27,540 --> 00:14:31,700
now let's talk about, migration
strategy, decomposition of it.

229
00:14:32,210 --> 00:14:36,590
Identifying these, responds
domain driven design.

230
00:14:36,620 --> 00:14:41,380
This step emphasizes the importance of
understanding the business domain and,

231
00:14:41,410 --> 00:14:43,180
identifying the logical boundaries.

232
00:14:43,210 --> 00:14:46,570
Between two different
parts of the application.

233
00:14:46,780 --> 00:14:50,460
The domain event, design helps
in, creating a clear map of the

234
00:14:50,460 --> 00:14:53,910
business and aligning them with
minimal service boundaries.

235
00:14:54,300 --> 00:14:57,420
Minimal coupling, starting with
the components that are minimal

236
00:14:57,600 --> 00:15:01,860
dependencies on other parts of the
system, allows for easier extraction

237
00:15:01,860 --> 00:15:06,000
and reduce the risks of unintended
consequences during the migration.

238
00:15:06,645 --> 00:15:11,265
prioritization This step highlights
the need for strategic planning and

239
00:15:11,265 --> 00:15:15,855
prioritizing components for migration
based on the complexity and impact.

240
00:15:16,355 --> 00:15:21,455
Now the second step is extracting the
microservices, which mainly includes

241
00:15:21,455 --> 00:15:26,105
refactoring the step inwards, breaking
down monolithic applications into

242
00:15:26,165 --> 00:15:28,775
smaller, independent microservices.

243
00:15:28,805 --> 00:15:33,625
Each microservices, microservice has
should have its own dedicated data store

244
00:15:33,625 --> 00:15:36,115
to ensure data isolation and independence.

245
00:15:36,475 --> 00:15:40,405
API gateway using API gateway
to create version APIs.

246
00:15:40,610 --> 00:15:45,770
For Interservice Communications provides
a standardized and controlled way for

247
00:15:45,830 --> 00:15:47,720
microservices to interact with each other.

248
00:15:48,140 --> 00:15:51,730
This also enables you, easier
versioning and management of APIs

249
00:15:52,360 --> 00:15:54,310
dependent independent deployment.

250
00:15:54,990 --> 00:15:58,455
Microservices can be deployed
independently, allowing for faster

251
00:15:58,455 --> 00:16:00,135
development and deployment cycles.

252
00:16:00,675 --> 00:16:06,795
Now, the third step is implementing
serverless functions, Lambda functions.

253
00:16:06,795 --> 00:16:09,875
This step in, involves in
con, converting the extracted

254
00:16:10,055 --> 00:16:11,735
microservices into Lambda functions.

255
00:16:12,095 --> 00:16:16,205
Each lambda function should be
designed with a single responsibility,

256
00:16:16,475 --> 00:16:20,005
allowing, aligning with the
specific business operation.

257
00:16:20,675 --> 00:16:22,355
triggers and optimization.

258
00:16:22,355 --> 00:16:26,675
Lambda function should be triggered
by app appropriate events using

259
00:16:26,675 --> 00:16:32,075
A-A-P-I-K two events, S3 events, dymo
events, even cloud bridge, event.

260
00:16:32,615 --> 00:16:37,085
optimizing execution by minimizing
dependencies and, reducing execution

261
00:16:37,085 --> 00:16:38,975
time is crucial for cost effectiveness.

262
00:16:39,455 --> 00:16:42,815
Adhering to the single
responsibility principles ensures

263
00:16:42,815 --> 00:16:44,285
that each Lambda function.

264
00:16:45,125 --> 00:16:47,425
Is fo is focused and manageable.

265
00:16:48,085 --> 00:16:54,055
Now, when we move to transitioning
the traffic gradually, we

266
00:16:54,055 --> 00:16:55,795
can use a triangular pattern.

267
00:16:56,245 --> 00:17:00,265
This pattern involves gradually
replacing the functionality in the

268
00:17:00,265 --> 00:17:04,090
monolithic application with new
microservice all Lambda functions.

269
00:17:04,590 --> 00:17:08,700
We could use the concept of feature
lines, which allows enabling us,

270
00:17:08,700 --> 00:17:12,000
enabling or disabling new functionality
without deploying new code.

271
00:17:12,360 --> 00:17:16,080
This provides control over the
rollout process and allows for

272
00:17:16,080 --> 00:17:19,280
easy rollbacks canary deployments.

273
00:17:19,610 --> 00:17:23,480
Candid deployments involve in
routing a small percentage of traffic

274
00:17:23,480 --> 00:17:25,040
to the new service components.

275
00:17:25,370 --> 00:17:28,730
This allows for testing in a
production like environment

276
00:17:28,790 --> 00:17:30,680
and identifying any issues.

277
00:17:31,055 --> 00:17:35,915
Before a full rollout, monitoring and
metrics, closely monitoring metrics

278
00:17:35,915 --> 00:17:40,175
during the transition is essential
for detecting issues and ensuring a

279
00:17:40,175 --> 00:17:44,045
smooth migration, quick rollbacks,
should be enabled if necessary.

280
00:17:44,545 --> 00:17:48,670
Now let's dive into the event
driven architecture design.

281
00:17:48,670 --> 00:17:50,725
So this involves, event production.

282
00:17:51,515 --> 00:17:56,095
events are generated, when a service or
component, experiences a stake change.

283
00:17:56,305 --> 00:17:59,635
This could be anything from
user interaction to a database.

284
00:17:59,725 --> 00:18:06,385
Update services publish these events to
an event bus or MSHQ, the stake couple.

285
00:18:06,385 --> 00:18:11,185
See event producer from the
even consumer event processing.

286
00:18:11,725 --> 00:18:13,225
Asynchronous processing.

287
00:18:13,285 --> 00:18:17,995
Lambda functions are triggered by the
events and process them as synchronously.

288
00:18:18,505 --> 00:18:21,625
This means that event producer
doesn't have to wait for

289
00:18:21,625 --> 00:18:23,065
the event to be processed.

290
00:18:23,575 --> 00:18:27,355
Lambda functions are ideal for
event driven architectures because

291
00:18:27,355 --> 00:18:30,985
they're stateless and can scale
automatically based on the demand.

292
00:18:31,705 --> 00:18:36,975
State transformations, updating
systems state based on the data or

293
00:18:37,005 --> 00:18:39,435
in the event system state is updated.

294
00:18:39,435 --> 00:18:44,825
This could involve, updating databases,
caching systems, or other services.

295
00:18:45,215 --> 00:18:46,565
Data consistency.

296
00:18:46,565 --> 00:18:50,945
Ensuring the data consistency
across different services is crucial

297
00:18:51,005 --> 00:18:52,625
in event driven architectures.

298
00:18:53,465 --> 00:18:59,105
Now the ca footstep is cascading
events, triggering new events.

299
00:18:59,105 --> 00:19:03,485
The state change result from
event processing can trigger new

300
00:19:03,485 --> 00:19:06,515
events, creating a chain reaction.

301
00:19:06,575 --> 00:19:11,945
This allows for complex workflows and
business process to be implemented.

302
00:19:12,445 --> 00:19:15,595
managing the flow of events and
ensuring they're processed in the

303
00:19:15,595 --> 00:19:18,715
correct order is essential for
maintaining the system integrity.

304
00:19:19,405 --> 00:19:24,365
Even architecture reduces service
coupling in general, enabling independent

305
00:19:24,365 --> 00:19:26,985
scaling and autonomous deployment.

306
00:19:27,015 --> 00:19:30,225
This approach aligns perfectly
with Lambda stateless execution

307
00:19:30,230 --> 00:19:32,085
model and pay by use pricing.

308
00:19:33,015 --> 00:19:36,975
Now let's take a look at the
database migration concentration.

309
00:19:36,990 --> 00:19:42,395
So MySQL to MySQL or push
K, SQL to Aurora Serverless.

310
00:19:42,775 --> 00:19:48,660
Aurora Serverless offers auto-scaling
capabilities and is compatible with

311
00:19:48,750 --> 00:19:53,220
my MySQL and push K SQL, making
it relatively straightforward.

312
00:19:53,220 --> 00:19:55,470
Migration path for these databases.

313
00:19:55,800 --> 00:19:59,800
Suitable for applications that require,
relational database functionality

314
00:19:59,800 --> 00:20:05,553
with, automatic scaling Oracle,
PSQL or SQL server to DynamoDB.

315
00:20:05,865 --> 00:20:10,455
In combination with Aurora sql,
this migration path offers cost

316
00:20:10,455 --> 00:20:12,255
saving and improved performance.

317
00:20:12,555 --> 00:20:16,155
DynamoDB is used for high throughput,
low data, and sea data access,

318
00:20:16,155 --> 00:20:20,425
while Aurora can be for more
complex relational queries, ideal

319
00:20:20,515 --> 00:20:23,815
for applications, that require high
performance and cost optimizations,

320
00:20:24,745 --> 00:20:29,810
but may require a hybrid approach,
MongoDB to document, DB or dymo db.

321
00:20:30,310 --> 00:20:36,280
So join document DB and NO DB offer
managed services and scalability by

322
00:20:36,280 --> 00:20:40,479
simplifying the database management
and, allowing for autoscale.

323
00:20:41,090 --> 00:20:45,359
so these are suitable for,
applications that require no SQL

324
00:20:45,359 --> 00:20:49,109
database with high scalability
and minimal operational overhead.

325
00:20:49,739 --> 00:20:54,915
Redis, mem cache the Redis or mem C to
Elastic Cache or, Dak. elastic Cache,

326
00:20:54,965 --> 00:20:59,554
and Dax provide a caching layer, reducing
the latency and improving the performance

327
00:20:59,554 --> 00:21:04,655
ideal for applications that require fast
data access and caching capabilities.

328
00:21:05,085 --> 00:21:07,635
database migration is the
most crucial challenge in

329
00:21:08,025 --> 00:21:09,534
serverless, trans transitions.

330
00:21:09,895 --> 00:21:13,445
When converting monolithic,
databases to service architectures,

331
00:21:13,445 --> 00:21:18,455
organizations must analyze data access
patterns and usage requirements.

332
00:21:18,860 --> 00:21:22,504
DynamoDB offers high throughput and
low latency performance, but requires

333
00:21:22,504 --> 00:21:27,784
shifting from relational ski mass to
an access pattern driven approach.

334
00:21:28,405 --> 00:21:32,315
let's, take a look at the
hybrid deployment models.

335
00:21:32,585 --> 00:21:38,514
So we identified the services, we
have decoupled them and we have

336
00:21:38,514 --> 00:21:41,320
returned the new services in AWS Now.

337
00:21:41,844 --> 00:21:44,064
How to perform the deployment model.

338
00:21:44,574 --> 00:21:47,995
Now, if you take a look at the
serverless functions, lambda's

339
00:21:47,995 --> 00:21:52,505
ideal, they ideal for even, stateless
and highly scalable, workloads.

340
00:21:52,785 --> 00:21:56,515
they reduce the operational overhead,
enabling us to go automatic scaling

341
00:21:56,515 --> 00:21:58,555
and paper execution, pricing.

342
00:21:58,975 --> 00:22:02,785
We could use, services such as,
econ container services, NAS,

343
00:22:02,785 --> 00:22:06,775
which are ECS, elastic Container
Service and EKS Elastic Service.

344
00:22:07,275 --> 00:22:07,995
services.

345
00:22:07,995 --> 00:22:12,757
These services are, suitable for stateful
con, complex microservices that require

346
00:22:13,265 --> 00:22:15,005
containerization and orchestration.

347
00:22:15,485 --> 00:22:20,965
The, these provides, benefits
of portability, scalability, and

348
00:22:20,965 --> 00:22:22,585
efficient resource utilization.

349
00:22:23,215 --> 00:22:28,375
You could also use managed services like
RDS, ElastiCache, open Search, et cetera.

350
00:22:28,855 --> 00:22:33,205
So these are designed for specific data
needs, such as relational databases,

351
00:22:33,255 --> 00:22:35,865
caching and search functionalities.

352
00:22:36,225 --> 00:22:39,585
The benefits of it has simplified
management, high availability and

353
00:22:39,585 --> 00:22:44,545
performance optimization, traditional
infrastructure, like easy to necessary

354
00:22:44,545 --> 00:22:48,595
for, resource intensive or legacy
workloads that cannot be easily migrated.

355
00:22:48,940 --> 00:22:52,570
To other models, we could
still use EC2 to achieve them.

356
00:22:53,020 --> 00:22:56,260
These offer benefits, such as
flexibility and control over

357
00:22:56,260 --> 00:22:57,670
the underlying infrastructure.

358
00:22:58,240 --> 00:23:03,420
So effective migration strategies in
general combine serverless components

359
00:23:03,420 --> 00:23:08,760
with the containers and traditional
infrastructure to optimize each service

360
00:23:08,760 --> 00:23:13,530
based on specific requirement, rather
than forcing a singular architectural

361
00:23:13,530 --> 00:23:15,330
pattern across all the components.

362
00:23:16,075 --> 00:23:20,035
specialized workloads with
unique needs, they require, such

363
00:23:20,035 --> 00:23:22,015
as the long running process.

364
00:23:22,345 --> 00:23:27,415
GPU acceleration memory tends to,
operations or legacy components can still

365
00:23:27,415 --> 00:23:32,275
remain on EC2 while new features like
leveraging serverless technologies can mu

366
00:23:32,725 --> 00:23:37,165
yes, this incremental approach, delivers
immediate benefits while maintaining the

367
00:23:37,165 --> 00:23:39,925
system stability throughout the migration.

368
00:23:40,555 --> 00:23:41,095
Now.

369
00:23:41,515 --> 00:23:45,325
Let's talk about the DevOps
integration and the continuous,

370
00:23:45,575 --> 00:23:47,865
improvement, and continuous deployment.

371
00:23:48,315 --> 00:23:53,775
So infrastructure as a code, Terraform
or AWS Cloud formations are highlighted

372
00:23:54,135 --> 00:23:58,855
as a tools for codifying infrastructure
ensures, so these ensures, the

373
00:23:58,855 --> 00:24:01,195
consistent and, repeatable deployment.

374
00:24:01,705 --> 00:24:06,625
They also offer version control
of infrastructure, allowing for

375
00:24:06,625 --> 00:24:08,785
tracking changes and rollbacks.

376
00:24:09,530 --> 00:24:13,250
these facilitate, collaboration among
team members throughout the code

377
00:24:13,250 --> 00:24:17,480
Reviews and shared infrastructure
definitions automates the infrastructure,

378
00:24:17,540 --> 00:24:18,830
provisioning and management.

379
00:24:19,330 --> 00:24:23,209
Now continuous integration
to, AWS code build.

380
00:24:23,409 --> 00:24:29,409
our and GitHub actions are mentioned
as tools for automated testing unit as

381
00:24:29,409 --> 00:24:33,249
integration tests and infrastructure
violation that emphasized as essential

382
00:24:33,249 --> 00:24:35,050
components for continuous integration.

383
00:24:35,955 --> 00:24:42,345
they offer a variety of benefits such
as early shoe detection, improved

384
00:24:42,435 --> 00:24:45,465
code quality, faster code feedback.

385
00:24:45,965 --> 00:24:48,965
Now let's take a look at
deployment automation.

386
00:24:49,024 --> 00:24:53,405
So AWS Code pipeline is highlighted
as a tool for orchestrating serverless

387
00:24:53,435 --> 00:24:55,185
and, serverless deployments.

388
00:24:55,360 --> 00:24:58,690
And basically you could use
any other internal tools.

389
00:24:58,720 --> 00:25:02,950
they are, most of the tools should
be compatible with AWS in general.

390
00:25:03,670 --> 00:25:07,360
deployment strategies, cannery
releases and blueprint deployments I

391
00:25:07,360 --> 00:25:10,690
mentioned as strategies for reducing
risk and maintaining availability.

392
00:25:11,515 --> 00:25:16,615
Automated deployments, automates the
deployment process and, by reducing

393
00:25:16,615 --> 00:25:20,985
manual effort and errors, candidate
releases blue green deployments, minimize

394
00:25:21,030 --> 00:25:23,265
the impact, of deployment failures.

395
00:25:23,815 --> 00:25:25,105
monitoring and observability.

396
00:25:25,605 --> 00:25:29,585
CloudWatch, x-rays and specialist
tools are recommended for

397
00:25:29,585 --> 00:25:31,085
monitoring and observability.

398
00:25:31,415 --> 00:25:35,595
So logging, distributor tracing and
letting are emphasized as crucial

399
00:25:35,595 --> 00:25:37,575
for detecting and resolving issues.

400
00:25:37,905 --> 00:25:42,555
These offer benefits such as real
domain sites, proactive issue detection,

401
00:25:42,915 --> 00:25:47,705
enabling, proactive detection and
resolution of issues before the impact.

402
00:25:47,755 --> 00:25:51,190
they will impact users, and
they also offer the benefit of

403
00:25:51,190 --> 00:25:54,750
improved troubleshooting simplifies
the troubleshooting, through

404
00:25:54,750 --> 00:25:57,040
logging and distributed, tracing.

405
00:25:57,540 --> 00:26:02,590
when we talk about how do we overcome
these migration challenges, there

406
00:26:03,040 --> 00:26:07,580
are some, highlighted issues which we
usually see with migrations such as

407
00:26:07,580 --> 00:26:12,290
cold start latency, cold start occur
when a lambda function is invoke for

408
00:26:12,290 --> 00:26:16,520
the first time after the period of
inactivity leading to increase latency.

409
00:26:16,940 --> 00:26:19,940
a couple of solutions are
provision concurrency, pre lambda

410
00:26:20,660 --> 00:26:22,190
function, reduce cold start times.

411
00:26:22,535 --> 00:26:27,435
Scheduled warming regularly working the
lambda, functions to keep them active.

412
00:26:27,705 --> 00:26:31,025
Code optimization, reduce,
function, size and dependence

413
00:26:31,025 --> 00:26:32,795
to minimize initialization time.

414
00:26:33,365 --> 00:26:37,770
lightweight run times in Java and
dotnet uses optimized track times to

415
00:26:37,770 --> 00:26:42,575
reduce the initialization overhead
distributed system complexity.

416
00:26:42,905 --> 00:26:47,435
Cha Serverless Architect Architecture
often involved in a distributed systems

417
00:26:47,435 --> 00:26:51,215
where can be com, where it can be
complex to manage and troubleshoot.

418
00:26:51,885 --> 00:26:55,555
a couple of ways to overcome this
is, comprehensive observability.

419
00:26:55,915 --> 00:27:00,775
We're using the X-ray and Cloud
Watch provides end to end tracing and

420
00:27:00,775 --> 00:27:02,725
monitoring for distributed systems.

421
00:27:03,055 --> 00:27:08,245
Eventual consistency design systems
to handle eventual consistency rather

422
00:27:08,245 --> 00:27:10,375
than relying on strong consistency.

423
00:27:10,915 --> 00:27:14,365
Using circuit breakers,
preventing cascading failures

424
00:27:14,365 --> 00:27:19,445
by isolating, failing components
and using, back of ex strategies.

425
00:27:19,495 --> 00:27:22,795
implementing retry mechanisms
with exponential back costs

426
00:27:22,795 --> 00:27:25,045
to handle transition errors.

427
00:27:25,555 --> 00:27:26,515
Legacy code refactoring.

428
00:27:27,015 --> 00:27:29,235
This is the third step challenge.

429
00:27:29,625 --> 00:27:33,135
The challenge that what we see
is migrating the legacy code.

430
00:27:33,135 --> 00:27:37,185
Serverless can be challenging
due to high, coupled dependencies

431
00:27:37,245 --> 00:27:38,955
and monolithic architectures.

432
00:27:39,415 --> 00:27:43,505
a couple of ways to overcome these,
incremental refractory breaks down

433
00:27:43,505 --> 00:27:47,195
the monolithic application in those
smaller independent components.

434
00:27:47,565 --> 00:27:50,145
identifying boundaries and
isolating dependencies.

435
00:27:50,775 --> 00:27:53,745
Identifying the logical
boundaries and dependencies.

436
00:27:53,745 --> 00:27:57,085
To facilitate refactor, we could
use something called a strangler

437
00:27:57,145 --> 00:28:01,375
pattern, gradually placing the,
monolithic functions, with serverless

438
00:28:01,500 --> 00:28:03,030
equal while maintaining the system.

439
00:28:03,030 --> 00:28:03,660
Stability.

440
00:28:04,170 --> 00:28:07,550
Now the first of, the last
and much important point as

441
00:28:07,550 --> 00:28:09,260
the security concentrations.

442
00:28:09,530 --> 00:28:15,650
So service architectures require careful
security considerations, including access,

443
00:28:15,650 --> 00:28:18,170
control, and vulnerability management.

444
00:28:18,610 --> 00:28:22,820
a couple of solutions, to handle security
would be implementing function level.

445
00:28:23,000 --> 00:28:27,650
Im permissions implement, implementing
the least privileged principles by

446
00:28:27,650 --> 00:28:32,920
granting, only necessary permissions
to lambda functions, AWS security hub.

447
00:28:32,980 --> 00:28:37,230
And you could use, other services
like AWS Security Hub, Amazon

448
00:28:37,230 --> 00:28:42,020
Inspector, and, service, security
scanners to identify vulnerabilities.

449
00:28:42,935 --> 00:28:45,355
Even before deployment, right?

450
00:28:45,415 --> 00:28:49,435
So in the next, let's take
a look at a case study of an

451
00:28:49,435 --> 00:28:51,415
e-commerce, platform migration.

452
00:28:51,775 --> 00:28:56,035
So the initial in, during the initial
assessment, the platform experience,

453
00:28:56,035 --> 00:28:59,875
significant performance, degradation
during peak seasons, with the,

454
00:29:00,120 --> 00:29:03,195
transaction process slowing down by 400%.

455
00:29:04,020 --> 00:29:08,310
While performing an analysis, the
bottlenecks were identified in the

456
00:29:08,310 --> 00:29:11,880
monolithic architecture leading
to prioritization of inventory

457
00:29:11,880 --> 00:29:13,950
and payment systems for migration.

458
00:29:14,490 --> 00:29:19,870
One of the key insights that was outcome
is the phase, the phase insights,

459
00:29:19,920 --> 00:29:23,610
the, this phase, like basically
initial assessment phase insight,

460
00:29:23,970 --> 00:29:26,425
the importance of, going through a.

461
00:29:26,925 --> 00:29:29,775
Thorough analysis and
prioritization before even

462
00:29:29,775 --> 00:29:32,645
embarking on a migration database.

463
00:29:32,695 --> 00:29:37,890
transition, the product catalog
was migrated from MySQL to

464
00:29:38,130 --> 00:29:42,235
DynamoDB, a NoSQL database
without optimized access patterns.

465
00:29:42,695 --> 00:29:48,405
for this, a dual right approach, was used
to ensure zero downtime, migration, and

466
00:29:48,405 --> 00:29:50,925
maintain data consistency across system.

467
00:29:51,405 --> 00:29:57,015
So the, this database transition phase,
demonstrate the importance of choosing

468
00:29:57,015 --> 00:30:02,145
the right database technology and
implementing a robust migration strategy.

469
00:30:02,645 --> 00:30:07,475
So the next comes the first migration
phase, the payment processing

470
00:30:07,475 --> 00:30:12,245
system, which was extracted into
Lambda functions with API gateway

471
00:30:12,515 --> 00:30:14,885
using an event driven architecture.

472
00:30:14,915 --> 00:30:21,695
This resulted in 30% reserve reduction in
infrastructure cost, and a 50% improvement

473
00:30:21,695 --> 00:30:24,250
data, response times during peak traffic.

474
00:30:25,000 --> 00:30:30,160
The key insights of this phase,
it highlights the tangible

475
00:30:30,160 --> 00:30:34,470
benefits of migrating critical
component to serverless complete.

476
00:30:34,590 --> 00:30:38,030
The fourth point is like the
complete serverless architecture.

477
00:30:38,550 --> 00:30:42,575
the complete serverless implementation
achieved an 80% cost reduction during

478
00:30:42,575 --> 00:30:47,045
normal operations and enable the
platform to handle 10 times the traffic

479
00:30:47,045 --> 00:30:48,965
surges without performance issues.

480
00:30:49,425 --> 00:30:50,295
the development cycles.

481
00:30:50,785 --> 00:30:56,005
IMP improve from monthly release
to multiple daily deployments.

482
00:30:56,185 --> 00:31:02,335
with this key phase demonstrates the
transformation, impact of a complete

483
00:31:02,335 --> 00:31:07,760
serverless migration on performance,
cost, and development agility.

484
00:31:08,260 --> 00:31:14,860
Now we could, take a look at the roadmap
for successful serverless migration.

485
00:31:14,995 --> 00:31:19,015
The key would be assess and
plan, analyzing the existing

486
00:31:19,015 --> 00:31:22,615
architecture to identify suitable
candidates for migration.

487
00:31:23,185 --> 00:31:28,645
Then mapping dependencies between services
to understand the impact of migration,

488
00:31:29,455 --> 00:31:36,005
prioritizing migration candidates,
based on business value and risk.

489
00:31:36,595 --> 00:31:41,305
this is to create a clear
understanding of the current state

490
00:31:41,305 --> 00:31:42,925
and develop migration strategy.

491
00:31:43,615 --> 00:31:49,945
The, during the initial pilot implemented
POC with a non-critical isolated

492
00:31:49,945 --> 00:31:55,355
service, expertise, building, build,
internal expertise in server as,

493
00:31:55,395 --> 00:31:59,835
technologies established architectural
patterns for server development.

494
00:32:00,195 --> 00:32:03,945
The whole goal of this initial
pilot is to validate migration

495
00:32:03,945 --> 00:32:05,355
approach, and build confidence.

496
00:32:06,300 --> 00:32:07,920
Expand and refine.

497
00:32:08,290 --> 00:32:13,240
gradually scale the migration to critical
workloads, refine the architectural

498
00:32:13,540 --> 00:32:16,270
patterns based on experience and feedback.

499
00:32:16,660 --> 00:32:22,420
The goal, of the expanding and refining
is to ensure a smooth transition of

500
00:32:22,420 --> 00:32:28,180
core business services to serverless
enterprise transformation, adopt

501
00:32:28,510 --> 00:32:30,555
serverless as a standard for development.

502
00:32:31,415 --> 00:32:35,345
embrace a cloud native culture,
restructuring teams around business

503
00:32:35,345 --> 00:32:37,805
domains rather than technology silos.

504
00:32:38,375 --> 00:32:41,985
The goal of this, enterprise
transformation is to fully leverage

505
00:32:41,985 --> 00:32:45,195
the benefits of serverless, transform,
serverless and transform the organization.

506
00:32:45,675 --> 00:32:48,185
So overall, what we could, if it take.

507
00:32:48,775 --> 00:32:51,325
If you consolidate these into two
couple of points, it's beginning

508
00:32:51,325 --> 00:32:56,205
with the, begin with the thorough
assessment by mapping the dependencies

509
00:32:56,594 --> 00:33:00,614
and prioritizing migration candidates
based on business value and risk.

510
00:33:00,945 --> 00:33:06,014
Launch a pilot with a bounded
non-critical service to build expertise

511
00:33:06,014 --> 00:33:08,205
and establish architectural patterns.

512
00:33:08,604 --> 00:33:13,134
methodically expand to core
business services while refining

513
00:33:13,134 --> 00:33:14,304
implementation patterns.

514
00:33:14,694 --> 00:33:19,764
Finally transform your organization
by adopting serverless as a

515
00:33:19,764 --> 00:33:23,874
standard for new development and
restructuring teams around business

516
00:33:23,874 --> 00:33:26,364
domains rather than technology silos.

517
00:33:26,864 --> 00:33:32,984
In conclusion, we have explored the
significant advantages of migrating

518
00:33:32,984 --> 00:33:38,534
a serverless architecture on AWS from
cost reduction and improved scalability.

519
00:33:38,879 --> 00:33:43,679
To enhancing, enhanced develop
agility, the benefits are very clear.

520
00:33:44,279 --> 00:33:47,189
Remember, this journey is
more about just technology.

521
00:33:47,429 --> 00:33:51,209
It's about transforming how we
build and deliver applications.

522
00:33:51,419 --> 00:33:55,349
By embracing serverless, we are
positioning ourselves to innovate

523
00:33:55,349 --> 00:34:00,239
faster, respond to market changes
more effectively, and ultimately

524
00:34:00,749 --> 00:34:03,239
provide greater value to our users.

525
00:34:03,629 --> 00:34:09,329
The future of cloud computing is
serverless, and I encourage you to explore

526
00:34:09,629 --> 00:34:12,599
how it can empower your organization.

527
00:34:13,169 --> 00:34:13,949
Thank you all.

528
00:34:14,069 --> 00:34:14,789
Thank you so much.

