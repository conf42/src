1
00:00:00,140 --> 00:00:00,820
Hello, everyone.

2
00:00:00,890 --> 00:00:03,979
My name is Mikkel Mark Heine and I'm
here to introduce you to SpinCube.

3
00:00:04,479 --> 00:00:07,449
SpinCube is an open source project
which streamlines developing,

4
00:00:07,449 --> 00:00:10,140
deploying and operating WebAssembly
workloads in Kubernetes.

5
00:00:10,990 --> 00:00:16,390
It is a collaboration between Microsoft,
LiquidReply, SUSE, and Fermion.

6
00:00:16,850 --> 00:00:20,359
Fermion is the company I represent,
and I'm the head of product at Fermion.

7
00:00:20,859 --> 00:00:24,109
SpinQube is part of the Spin
framework, together with Spin.

8
00:00:24,559 --> 00:00:27,719
Both of these are open source projects,
which are in the process of being

9
00:00:27,719 --> 00:00:30,749
donated to Cloud Native Computing
Foundation, where they've both

10
00:00:30,749 --> 00:00:32,869
been accepted as sandbox projects.

11
00:00:33,769 --> 00:00:36,830
Spin is the development tool that
you can use to build WebAssembly

12
00:00:36,859 --> 00:00:40,660
microservices and web application
using a serverless application model.

13
00:00:41,410 --> 00:00:44,860
And with Spin Cube, you are able
to run spin applications really

14
00:00:44,860 --> 00:00:48,800
efficiently inside of Kubernetes
because they're powered by WebAssembly.

15
00:00:49,300 --> 00:00:52,929
So Spin Cube has already seen adoption
where, for instance, size has been

16
00:00:52,929 --> 00:00:57,190
using Spin Cube with Microsoft's
Azure Kubernetes service to create

17
00:00:57,220 --> 00:01:01,610
really fast, scalable, applications
that can run a high density.

18
00:01:02,019 --> 00:01:06,200
While still, making it more easy
to operate these applications.

19
00:01:06,929 --> 00:01:11,214
So they've actually done proof of
concepts and have been running,

20
00:01:11,545 --> 00:01:15,405
applications where they're able to
put, to bring down the compute cost

21
00:01:15,405 --> 00:01:19,045
with 60 percent without any doing trade
offs in terms of their performance.

22
00:01:19,815 --> 00:01:23,315
So let's maybe unpack how all
of this works and what can

23
00:01:23,324 --> 00:01:25,145
lead to these amazing results.

24
00:01:25,645 --> 00:01:29,895
So to give you an overview of how these
things fit together, I mentioned that

25
00:01:29,895 --> 00:01:33,905
Spin is the open source project that you
would use for developing applications.

26
00:01:34,740 --> 00:01:38,940
Now, when you have a Spin application
created using Spin, you can run

27
00:01:38,940 --> 00:01:42,230
these things like Kubernetes using
SpinCube as a free open source project.

28
00:01:42,730 --> 00:01:46,290
Fermion also provides, some
hosted, options using Fermion

29
00:01:46,310 --> 00:01:47,590
Cloud that's fully managed.

30
00:01:47,960 --> 00:01:51,740
And we also have an enterprise, a set
of enterprise features around SpinQube

31
00:01:51,769 --> 00:01:53,219
called Platform for Kubernetes.

32
00:01:53,730 --> 00:01:56,210
Part of that being that you can
achieve in higher densities of

33
00:01:56,210 --> 00:01:57,410
what we have with Kubernetes.

34
00:01:57,839 --> 00:01:59,200
But we're not going to
get into that today.

35
00:01:59,200 --> 00:02:02,120
We'll mainly focus on SpinQube
as an open source project.

36
00:02:02,620 --> 00:02:06,250
So SpinQube consists of
four different pieces.

37
00:02:06,520 --> 00:02:12,330
There is an operator to help,
translate the application model,

38
00:02:12,330 --> 00:02:17,040
or application framework that Spin
is, into a Kubernetes, language.

39
00:02:17,040 --> 00:02:22,290
So basically, Spin applications ends up
running as, pods, and through deployments,

40
00:02:22,290 --> 00:02:25,960
and having services, all these native
Kubernetes resources that we all know.

41
00:02:26,850 --> 00:02:30,660
But we have the spin operator sitting
as a wrapper around all of this that

42
00:02:30,660 --> 00:02:34,770
enables you to easily translate between
the concepts you use in a spin application

43
00:02:34,860 --> 00:02:36,360
and the concepts inside of spin.

44
00:02:36,860 --> 00:02:40,320
It's actually optional to use the
spin operator and you can just create

45
00:02:40,320 --> 00:02:44,410
your deployments, yourself referencing
spin applications as OCI images.

46
00:02:44,985 --> 00:02:48,685
But as we start to unpack all of this,
and you'll see some details in a live

47
00:02:48,685 --> 00:02:51,955
demo, you'll get a better understanding
of how these things fit together.

48
00:02:52,455 --> 00:02:57,775
The runtime that enables us to run spin
applications really efficiently inside

49
00:02:57,775 --> 00:03:01,925
of Kubernetes is part of a container
D shim called container D shim spin.

50
00:03:02,925 --> 00:03:08,245
So basically, at the container D,
the container runtime layer, install,

51
00:03:08,385 --> 00:03:13,610
install the shim on your node that So
we are able to cont, to tell container

52
00:03:13,610 --> 00:03:17,560
D that in the case that we want to
run a spin application, a web assembly

53
00:03:17,560 --> 00:03:21,010
application, we are actually not gonna
use your regular container runtime.

54
00:03:21,300 --> 00:03:24,385
We are gonna use a different shim,
for running the web assembly.

55
00:03:24,885 --> 00:03:27,505
Which means that you won't see your
regular C groups and all of that on

56
00:03:27,505 --> 00:03:30,475
your nodes as you run the WebAssembly,
and part of this is how we can get

57
00:03:30,475 --> 00:03:33,865
to higher density in some of those
scenarios inside of Kubernetes.

58
00:03:34,365 --> 00:03:36,015
There's also the Runtime Class Manager.

59
00:03:36,395 --> 00:03:39,215
Really, the Runtime Class Manager
is here to help ease up the

60
00:03:39,215 --> 00:03:40,965
configuration set of Container D.

61
00:03:41,305 --> 00:03:44,625
So in particular, if you have Kubernetes
clusters where you rely on auto

62
00:03:44,625 --> 00:03:48,725
scaling, and adding extra nodes into
your cluster, having a, configured

63
00:03:48,725 --> 00:03:53,075
runtime class manager enables you to
set up your nodes, dynamically, to

64
00:03:53,075 --> 00:03:54,685
be able to run the Spin applications.

65
00:03:55,185 --> 00:03:57,935
And the final piece of all of
this is the SpinKube plugin.

66
00:03:58,345 --> 00:04:01,415
So part of the Spin, developer
tool, there is a CLI.

67
00:04:01,755 --> 00:04:05,425
And basically the SpinCube plugin
makes it really easy to transition

68
00:04:05,425 --> 00:04:08,735
from local development, scaffolding
YAML to pushing your spin

69
00:04:08,735 --> 00:04:10,689
applications into OCI registries.

70
00:04:11,330 --> 00:04:13,800
And we'll get to see that again
once we get into the demo.

71
00:04:14,090 --> 00:04:17,280
let's try this out and let's take
a look at, how this all works.

72
00:04:17,600 --> 00:04:20,790
And I'll start by basically
creating a small application.

73
00:04:21,340 --> 00:04:22,730
so let's transition over here.

74
00:04:23,230 --> 00:04:23,440
Okay.

75
00:04:23,725 --> 00:04:27,195
Let me just give you a few references
as we go along, so you have those.

76
00:04:27,495 --> 00:04:29,925
Spin Framework has its
own GitHub organization.

77
00:04:30,335 --> 00:04:33,075
we're still in the process of moving
everything over from where these

78
00:04:33,085 --> 00:04:37,675
things, were previously, as part of
all this, the contribution into CNCF.

79
00:04:38,175 --> 00:04:42,365
But you can see you have, Spin, the
development tool, as one repository, and

80
00:04:42,365 --> 00:04:44,895
then you have some of these components
that I talked about, like the Spin

81
00:04:44,895 --> 00:04:48,845
operator that contain a DCM Spin, Runtime
Class Manager, and then there are various

82
00:04:48,845 --> 00:04:51,245
SDKs for Spin that are also part of this.

83
00:04:52,110 --> 00:04:54,460
So SpinFramework is a good
place to go in GitHub.

84
00:04:54,960 --> 00:04:58,940
SpinCube has its own
documentation, which is spincube.

85
00:04:58,980 --> 00:04:59,950
dev or website.

86
00:05:00,760 --> 00:05:01,740
So basically spincube.

87
00:05:01,740 --> 00:05:04,320
dev contains all the
documentation you would need.

88
00:05:04,320 --> 00:05:07,500
There are a few blog posts in here
as well for certain scenarios.

89
00:05:08,010 --> 00:05:10,610
And we'll get back to some of
these as we walk through building

90
00:05:10,610 --> 00:05:11,840
an application with SpinCube.

91
00:05:12,340 --> 00:05:15,309
And when you need to build an
application with SpinCube, you

92
00:05:15,690 --> 00:05:16,900
need to go to developerferment.

93
00:05:17,050 --> 00:05:19,440
com for now, which is where
the spin applications are.

94
00:05:20,010 --> 00:05:23,580
The spin application, sorry, the
spin documentation is to be found.

95
00:05:23,930 --> 00:05:27,030
And the reason why I'm saying for now is
because again, part of the transitioning

96
00:05:27,050 --> 00:05:31,290
and contribution into CNCF, these
things may move around a little bit, but

97
00:05:31,790 --> 00:05:35,400
Definitely stay on Spin Framework GitHub
and we'll be able to guide you there.

98
00:05:35,420 --> 00:05:39,210
You'll also be able to find both Spin
and SpinCube channels inside of the

99
00:05:39,210 --> 00:05:43,900
CNCF Slack, where you can reach out
and interact with maintainers and other

100
00:05:43,900 --> 00:05:45,100
people that are part of the community.

101
00:05:45,600 --> 00:05:50,230
Okay, so with all of that in place,
let's actually try and With this,

102
00:05:50,480 --> 00:05:54,900
built in application that we can
run inside of a Kubernetes cluster.

103
00:05:55,590 --> 00:06:00,710
So the few things that I have prepared
here is I already have a cluster running.

104
00:06:00,710 --> 00:06:03,480
This is a local K3D
cluster that I've created.

105
00:06:04,050 --> 00:06:07,590
if you want to run this in Microsoft
AKS, there is a marketplace offering

106
00:06:07,590 --> 00:06:09,930
where you can easily configure SpinCube.

107
00:06:10,460 --> 00:06:16,010
And on the, SpinCube documentation,
there are a lot of, guides in terms of

108
00:06:16,010 --> 00:06:20,080
how to get these running on, Kubernetes
clusters and micro caves, Azure, Ranger

109
00:06:20,080 --> 00:06:24,840
desktop, and just in general, how
you can install spinQube with Helm.

110
00:06:25,320 --> 00:06:29,720
And if we really quickly want to run
through this, we rely on cert manager.

111
00:06:30,110 --> 00:06:35,780
In order for Spin Cube to run and
then we install the runtime class.

112
00:06:36,630 --> 00:06:38,340
Previously K was operator.

113
00:06:38,840 --> 00:06:42,680
that's the one the runtime class manager
enable us to, to install container D.

114
00:06:43,180 --> 00:06:46,680
And then, we can go and get some CDs in.

115
00:06:46,680 --> 00:06:50,500
There are a few custom resources we need
for the spin operator, the Spin Runtime

116
00:06:50,500 --> 00:06:53,850
classes and the Spin app executor and.

117
00:06:54,540 --> 00:06:57,660
Finally, there's a Helm's Yard to
basically install the spin operator,

118
00:06:58,520 --> 00:07:01,240
and I guess that should be it.

119
00:07:01,350 --> 00:07:05,030
Now we got to the point where we upgrade
and uninstall, but let's not do that now.

120
00:07:05,040 --> 00:07:06,350
We want to try this out first.

121
00:07:06,480 --> 00:07:09,670
So hopefully you get this idea that
even though there are a few things

122
00:07:09,670 --> 00:07:14,060
you need to set up, all of these are
regular things you would expect from

123
00:07:14,560 --> 00:07:19,090
Adding this kind of, frameworks and
functionality into a Kubernetes cluster.

124
00:07:19,590 --> 00:07:24,720
So I have already done all of that,
and if I can find my, cluster again,

125
00:07:24,750 --> 00:07:28,760
you can see, beyond CertManager, what
I have is I have the spin operator

126
00:07:28,760 --> 00:07:32,590
installed down here, and I also have,
Jaeger installed, so I can, maybe we

127
00:07:32,590 --> 00:07:34,370
can look at some traces as we go along.

128
00:07:34,870 --> 00:07:37,500
Okay, so that's all that I have
inside of my cluster for now.

129
00:07:38,270 --> 00:07:41,650
so before we get into how this all
works inside of Kubernetes, let's just

130
00:07:41,940 --> 00:07:43,810
quickly create a spin application.

131
00:07:44,060 --> 00:07:47,790
the way that you create a spin application
is basically, there's a spin new command.

132
00:07:48,620 --> 00:07:51,080
you use the template
to create applications.

133
00:07:51,080 --> 00:07:52,714
In this case, I'm using a template.

134
00:07:52,955 --> 00:07:57,625
that will, that is set up to take HTTP
requests and is written in TypeScript.

135
00:07:57,865 --> 00:07:59,635
let's just call this HTTPS.

136
00:07:59,655 --> 00:08:01,725
We're going to name
the application CONF42.

137
00:08:02,225 --> 00:08:06,615
And, let's go into the directory and
let's take a look at what we have.

138
00:08:07,545 --> 00:08:09,035
a few things got created for us.

139
00:08:09,085 --> 00:08:10,145
Main thing is the spin.

140
00:08:10,145 --> 00:08:12,545
toml file which describes our application.

141
00:08:12,620 --> 00:08:16,270
I think the main thing to be, to
take a note of here is you have this

142
00:08:16,270 --> 00:08:19,070
concept of HTTP paths or triggers.

143
00:08:19,080 --> 00:08:23,980
So there is a wildcard route, meaning all
HTTP requests coming to this application,

144
00:08:24,410 --> 00:08:28,950
is being handled by this one WebAssembly
component here that is named CON42.

145
00:08:29,680 --> 00:08:34,750
And CON42 is basically a WASM
file, so a WebAssembly binary file.

146
00:08:35,700 --> 00:08:38,290
I'm not going to spend time going
more into the details of the

147
00:08:38,290 --> 00:08:41,510
whole JavaScript to WebAssembly
and how these other things works.

148
00:08:41,620 --> 00:08:45,279
you can find a wealth of
information on Fermion's Spintube.

149
00:08:45,560 --> 00:08:46,410
Sorry, Spintube.

150
00:08:46,980 --> 00:08:48,580
On Fermion's YouTube channel.

151
00:08:49,070 --> 00:08:52,480
where, we have a lot of videos that
sort of help you understand even the

152
00:08:52,480 --> 00:08:53,740
WebAssembly part and all of that.

153
00:08:53,740 --> 00:08:57,190
So if you want to dive more into the
development pieces and how this all works,

154
00:08:57,190 --> 00:08:59,020
I highly recommend go and check those out.

155
00:08:59,520 --> 00:09:03,890
All that is just interesting, to
know here is that Spin has a concept

156
00:09:03,890 --> 00:09:06,580
of this application manifest, which
is what I'm showing you right now.

157
00:09:07,130 --> 00:09:10,160
the other thing that we have is
then obviously our JavaScript.

158
00:09:10,960 --> 00:09:17,760
And just for the sake of making this
a bit easier to, grok, let's do this.

159
00:09:18,215 --> 00:09:22,755
I'm just going to run an npm
install, so that I get my,

160
00:09:23,255 --> 00:09:27,105
all the, the npm packages that I need,
in this case, I need this router.

161
00:09:27,705 --> 00:09:30,215
to give you an idea of how these spin
applications, like we talk about them as

162
00:09:30,215 --> 00:09:35,595
serverless, but basically what this means
is that we have a, an event listener,

163
00:09:35,665 --> 00:09:39,635
in this case, an HTTP listener that
you implement here, and in the case of

164
00:09:39,635 --> 00:09:44,190
using, this idi router, But basically
what we do is you can set up various

165
00:09:44,190 --> 00:09:48,980
functions that reply to various HTTP
requests based on the routes being called.

166
00:09:49,330 --> 00:09:51,620
So basically in the case that
we call a route, we're just

167
00:09:51,620 --> 00:09:52,990
going to say, hello, universe.

168
00:09:53,930 --> 00:10:00,130
Actually change that to CONF42, and let's
make the capsulization of that correct.

169
00:10:00,640 --> 00:10:04,540
So if we'll send an HTTP request to the
route, we'll just say, hello, CONF, and we

170
00:10:04,540 --> 00:10:07,880
will say, slash, hello, slash, something.

171
00:10:07,890 --> 00:10:11,050
We will reply with hello to
whatever we passed in on that path.

172
00:10:11,150 --> 00:10:14,920
All of this is just stuff that happens in
this IDI router, which is a JavaScript,

173
00:10:15,120 --> 00:10:19,250
library that you can use, but I hope it
gives you a sense that spin applications

174
00:10:19,250 --> 00:10:23,390
are meant to, they're basically
triggered by HTTP event, they're going

175
00:10:23,390 --> 00:10:26,410
to do their thing, they're going to
shut down again, and we will see how

176
00:10:26,410 --> 00:10:29,220
we can use that in terms of scaling
things and so on a little bit later.

177
00:10:29,985 --> 00:10:31,785
Okay, so this is
basically our application.

178
00:10:32,365 --> 00:10:36,425
Let's try this out by
using a spin build command.

179
00:10:36,555 --> 00:10:42,545
So now what is happening is we're going
to take the JavaScript and through a set

180
00:10:42,545 --> 00:10:48,125
of build tools, we will have a WebAssembly
WASM file coming out on the other end.

181
00:10:48,540 --> 00:10:50,930
Which gives us a lot of the
benefits of portability.

182
00:10:50,930 --> 00:10:54,820
They're small, they're secure, because
they're run inside of sandboxes,

183
00:10:54,890 --> 00:10:56,180
and they start up really fast.

184
00:10:56,870 --> 00:11:00,670
And we can see that if we do spin
up, which actually loads our,

185
00:11:01,120 --> 00:11:05,730
spin application, and now we can
call the spin application locally.

186
00:11:06,300 --> 00:11:12,760
And you can see, hello con 42, and if we
do hello there, you can see hello there.

187
00:11:13,020 --> 00:11:13,280
Okay.

188
00:11:13,710 --> 00:11:15,120
So that's pretty straightforward.

189
00:11:15,140 --> 00:11:17,460
We actually have a small,
spin application now.

190
00:11:18,115 --> 00:11:21,465
Powered by WebAssembly, it can
reply to a few different, paths.

191
00:11:22,435 --> 00:11:25,155
Okay, we want now to get
this into Kubernetes.

192
00:11:25,305 --> 00:11:29,065
usually what we would do with containers,
and the workflow is similar, because,

193
00:11:29,915 --> 00:11:35,395
really one of the core, objectives in
terms of how we wanted to design SpinQube

194
00:11:35,425 --> 00:11:40,415
was to just make it, make sure that
WebAssembly became You could say a first

195
00:11:40,415 --> 00:11:42,285
class citizen inside of Kubernetes.

196
00:11:42,915 --> 00:11:47,195
So when you want to, which means
that, when we need to distribute

197
00:11:47,195 --> 00:11:51,115
this application, for instance,
we rely on OCI to do that.

198
00:11:51,175 --> 00:11:54,575
So if you have an OCI registry
already today, that will be

199
00:11:54,575 --> 00:11:58,575
compatible with moving the spin
applications into Kubernetes clusters.

200
00:11:58,955 --> 00:12:01,585
And you'll see that once we get a
little bit further down in terms of

201
00:12:01,585 --> 00:12:03,125
how the CIDs and all of this work.

202
00:12:03,625 --> 00:12:07,545
Okay, so now we want to use the
SpinCube plugin, so I just want to

203
00:12:07,545 --> 00:12:11,465
make sure again that I build the
latest version of my spin application.

204
00:12:11,965 --> 00:12:15,635
I'm just doing that because I've sometimes
forgotten how to do that, forgotten that

205
00:12:15,635 --> 00:12:17,685
I wanted, sometimes I forgot to do that.

206
00:12:18,665 --> 00:12:21,615
Okay, then we're going to use a
command called spin registry push.

207
00:12:21,645 --> 00:12:25,985
So basically now I can push the spin
application into a container registry.

208
00:12:26,820 --> 00:12:32,260
And I am going to use, let's do
this, I'm going to use TTLSH.

209
00:12:32,320 --> 00:12:37,290
This is an ephemeral publicly
available container registry or OCI

210
00:12:37,320 --> 00:12:40,860
registry, which is really nice when
you want to do demos like this.

211
00:12:41,615 --> 00:12:45,475
So what is happening now is Spin is
going to take my WebAssembly application,

212
00:12:46,235 --> 00:12:50,815
the manifest that were created, and any
configuration that I may have, package

213
00:12:50,815 --> 00:12:55,835
those as three individual layers into an
OCI image, and push it to this registry.

214
00:12:56,335 --> 00:12:58,555
What's really important here is
that's the only thing we're pushing.

215
00:12:58,755 --> 00:13:03,535
we're not, We're not creating
filesystem, whole layers of filesystems.

216
00:13:03,535 --> 00:13:06,435
Dependencies are not brought in
because they're already compiled

217
00:13:06,435 --> 00:13:07,895
into the web or simply binary.

218
00:13:08,325 --> 00:13:11,465
So if we go ahead and
actually inspect the image.

219
00:13:11,965 --> 00:13:17,855
That we have inside of, inside of, our
registry, we should be able to see that

220
00:13:17,925 --> 00:13:22,685
the only thing in here, I'm just going
to move up so you can see, there's a

221
00:13:22,685 --> 00:13:26,435
bunch of annotations, oh, I even got
my name in there, which is nice, and

222
00:13:26,435 --> 00:13:28,225
you can see there's a small config.

223
00:13:28,225 --> 00:13:33,885
json, which is 209 bytes, then we have
our WebAssembly, which in this case is 12

224
00:13:33,905 --> 00:13:38,745
megabyte, we can strip and we can compress
this even further, but it's only a 12

225
00:13:38,775 --> 00:13:42,885
megabyte binary that we're moving in and
then some, the actual spin application,

226
00:13:42,985 --> 00:13:45,825
manifest as well, which is 534 bytes.

227
00:13:45,825 --> 00:13:47,305
That was the toml file that I showed you.

228
00:13:48,190 --> 00:13:49,940
that's really all that there is there.

229
00:13:49,950 --> 00:13:53,460
there isn't a bunch of layers with,
with, dependencies and other things

230
00:13:53,460 --> 00:13:54,630
that I need to bring us along.

231
00:13:55,000 --> 00:13:56,450
And this is all that we're
going to move around.

232
00:13:56,450 --> 00:13:59,290
And this is one of these things where
WebAssembly is super interesting in terms

233
00:13:59,290 --> 00:14:03,110
of having smaller images, and having,
fixed binaries that we actually move.

234
00:14:03,610 --> 00:14:07,190
Okay, now the next thing I'm going
to do is I'm going to use, command

235
00:14:07,220 --> 00:14:09,470
to easily create my, my deployment.

236
00:14:10,300 --> 00:14:14,630
So in this case, I'm going to say,
spinkube scaffold, so basically scaffold

237
00:14:14,650 --> 00:14:20,450
the YAML that I need, use the container
image, path that I just created, that I,

238
00:14:21,110 --> 00:14:22,660
which I pushed to and put this in an app.

239
00:14:22,680 --> 00:14:23,400
yaml file.

240
00:14:23,960 --> 00:14:27,760
So if we look at this file, you can
see we have a Kubernetes YAML where

241
00:14:27,760 --> 00:14:31,015
we are using the spinkube dev API.

242
00:14:31,125 --> 00:14:34,965
So this is part of the custom resource
that are being created as we deploy it.

243
00:14:35,055 --> 00:14:37,785
we created the custom resource
before that this is part of the whole

244
00:14:37,785 --> 00:14:41,025
SpinQ project, where we actually
have a SpinApp resource in here.

245
00:14:41,755 --> 00:14:47,015
this very much looks like how you would
create a, container, or deployment.

246
00:14:47,795 --> 00:14:51,835
More actually, in terms of we have
replicas in here, and I think I mentioned

247
00:14:51,885 --> 00:14:57,215
earlier on, you can consider this spin
app resource to be a way to try and

248
00:14:57,215 --> 00:14:58,985
easily translate what we saw in the spin.

249
00:14:59,095 --> 00:15:03,025
toml file, because we'll do that a little
bit later by adding variables in here.

250
00:15:03,325 --> 00:15:06,455
there is a, there's an easy transition
between these two, but they're all end

251
00:15:06,465 --> 00:15:08,085
up just being deployments and containers.

252
00:15:08,695 --> 00:15:10,865
deployments and pods, sorry, containers.

253
00:15:11,675 --> 00:15:16,425
Okay, so now that I have this,
let's move over and give this app a

254
00:15:16,465 --> 00:15:18,155
YAML file to a Kubernetes cluster.

255
00:15:18,955 --> 00:15:21,525
And what we'll see is, first of
all, we can go and take a look

256
00:15:21,525 --> 00:15:25,375
at the spin app, where we now
have this con42 spin app created.

257
00:15:25,535 --> 00:15:27,455
So this is the spin app
resource I'm looking for.

258
00:15:27,925 --> 00:15:30,735
We want to have two, and we can
see two of those already now.

259
00:15:31,475 --> 00:15:33,455
we can see the description
in here, basically.

260
00:15:33,975 --> 00:15:37,775
What we expected, or what you can also see
is there's actually a deployment created.

261
00:15:38,315 --> 00:15:40,645
So again, we're creating
a real deployment.

262
00:15:40,665 --> 00:15:43,415
We could have chosen to really just
create the deployment if we wanted to.

263
00:15:43,845 --> 00:15:46,205
But that sort of takes the spin
operator out of the picture.

264
00:15:46,555 --> 00:15:48,995
And there are various things that
we use the spin operator for.

265
00:15:49,005 --> 00:15:52,985
For instance, here I'm able to
have a cluster wide OTIL endpoint.

266
00:15:53,315 --> 00:15:56,645
That I create, which means that I
now have a Jaeger instance in here.

267
00:15:56,645 --> 00:15:59,985
So all my spin apps will automatically
adopt that hotel configuration.

268
00:15:59,995 --> 00:16:02,485
So there's some benefits you
can get from all of these.

269
00:16:03,155 --> 00:16:06,165
so yes, highly recommend using
the operator and using the spin

270
00:16:06,165 --> 00:16:07,895
app resource for doing this.

271
00:16:08,695 --> 00:16:10,965
we also have a service
that's set up for us.

272
00:16:11,005 --> 00:16:14,245
So what we can try and do in
here is we can go ahead and

273
00:16:14,285 --> 00:16:16,155
port forward to our service.

274
00:16:16,165 --> 00:16:17,755
Let's do 80, 80, because.

275
00:16:18,255 --> 00:16:20,115
That's the way, that's what I normally do.

276
00:16:20,155 --> 00:16:21,855
And if I don't, something will go wrong.

277
00:16:22,415 --> 00:16:27,125
We've now created this port forward, which
means we can go back here, and we can then

278
00:16:27,285 --> 00:16:35,305
curl to 8080, and you can see helloConf,
and we can do hello there, and I just

279
00:16:35,305 --> 00:16:36,815
need to get my spelling There you go.

280
00:16:37,125 --> 00:16:41,265
And now we have hello there, and
hello here, so on and so forth.

281
00:16:41,285 --> 00:16:43,835
We can see this all works
as it works locally.

282
00:16:44,825 --> 00:16:45,265
So that's it.

283
00:16:45,275 --> 00:16:49,185
We've actually taken a spin
application that we created, from

284
00:16:49,185 --> 00:16:54,595
scratch, used TypeScript, and saw
we can run this locally, easily,

285
00:16:55,175 --> 00:16:57,635
and compiled this into WebAssembly.

286
00:16:58,220 --> 00:17:01,500
We created an OCI image that
we pushed, created the spin

287
00:17:01,500 --> 00:17:03,330
app resource inside Kubernetes.

288
00:17:03,420 --> 00:17:05,780
And there it is, and there it is running.

289
00:17:06,280 --> 00:17:10,410
Let me go back and just, I
want to do, let me check.

290
00:17:10,550 --> 00:17:13,500
Oh, we can see there are actually
two pods behind this, right?

291
00:17:13,540 --> 00:17:16,320
You can see there are the two pods
being created in here, and this is also

292
00:17:16,320 --> 00:17:18,040
where we can go ahead and find our logs.

293
00:17:18,460 --> 00:17:19,640
There's an open telemetry error.

294
00:17:19,640 --> 00:17:22,350
Let's just not think about that,
but you can actually see that we

295
00:17:22,350 --> 00:17:25,660
did hit the, we did hit the spin
application in one of these pods.

296
00:17:26,210 --> 00:17:29,500
I think one thing that I wanted to show
you around the Jaeger instance is that I

297
00:17:29,500 --> 00:17:32,320
have Jaeger set up in my cluster as well.

298
00:17:33,150 --> 00:17:37,660
And if I go ahead and just look at,
something that Spin is doing for me,

299
00:17:37,660 --> 00:17:41,410
we can see that, not that long ago,
we were actually hitting the Spin

300
00:17:41,410 --> 00:17:45,070
application, and you can see we have the
whole OTIL configuration being in here.

301
00:17:45,700 --> 00:17:48,990
We were getting the, there
was an HTTP GET request.

302
00:17:49,370 --> 00:17:54,930
for the root and what happened is
that SpinCube then executed this

303
00:17:54,940 --> 00:17:56,630
awesome component called Conv42.

304
00:17:56,630 --> 00:18:01,580
So just to give you an idea again of
how much work that's actually been

305
00:18:01,599 --> 00:18:06,330
put into make it really easy to give
a lot of the stuff that you say, these

306
00:18:06,330 --> 00:18:07,560
are just like table stakes today.

307
00:18:07,560 --> 00:18:10,190
You want to have a hotel, you want to
have all of these things, and it's really

308
00:18:10,190 --> 00:18:13,570
easy to get this set up and running
with SpinCube and your Spin application.

309
00:18:14,070 --> 00:18:15,840
Okay, moving ahead from that.

310
00:18:15,890 --> 00:18:18,790
actually, let's just do a quick
recap of what happened here.

311
00:18:18,830 --> 00:18:21,820
So we did spin new to create
a new application, spin

312
00:18:21,820 --> 00:18:23,350
build, created a WebAssembly.

313
00:18:23,935 --> 00:18:25,635
Registry push this into OCI.

314
00:18:25,645 --> 00:18:27,345
You can use any OCI image you want.

315
00:18:27,355 --> 00:18:32,595
If you have a private registry, which I
hope you have, I think it's spinregistry.

316
00:18:32,595 --> 00:18:32,874
login.

317
00:18:32,875 --> 00:18:35,485
And then you would basically be able
to log into that before you push.

318
00:18:35,815 --> 00:18:40,595
And all of these can easily
be run in a CI setup as well.

319
00:18:40,865 --> 00:18:43,155
There are actually GitHub actions
that exist out there to do

320
00:18:43,155 --> 00:18:44,235
all of these things with Spin.

321
00:18:45,115 --> 00:18:48,455
And then we did kubescaffold as a
nice little tool to scaffold our

322
00:18:48,455 --> 00:18:50,785
YAML and applied that to our cluster.

323
00:18:51,755 --> 00:18:53,385
What happened when we
applied it to the cluster?

324
00:18:53,405 --> 00:18:57,225
the resource was being put
into the API server as a, as

325
00:18:57,225 --> 00:18:58,605
a spin app custom resource.

326
00:18:58,915 --> 00:19:02,135
The operator picked that one up,
created deployments and services, and

327
00:19:02,135 --> 00:19:03,515
now we have that spin app running.

328
00:19:04,140 --> 00:19:07,880
in a pod, but in the pod, the
runtime class managed to make

329
00:19:07,880 --> 00:19:09,350
sure the container DCM is there.

330
00:19:09,350 --> 00:19:12,750
So we are actually executing using
the container DCM spin and not

331
00:19:12,760 --> 00:19:14,450
using the regular container runtime.

332
00:19:14,950 --> 00:19:16,590
And, and yes, that's it.

333
00:19:16,599 --> 00:19:18,990
I was just thinking about how we
can actually, I don't think there's

334
00:19:18,990 --> 00:19:20,650
an easy way for me to show that.

335
00:19:20,759 --> 00:19:21,799
but that is how that works.

336
00:19:22,299 --> 00:19:25,889
I think what we can see, actually,
if we did a, if we looked at the

337
00:19:25,889 --> 00:19:31,449
actual part, we should be able
to see in here that, lemme check.

338
00:19:31,949 --> 00:19:33,059
You can see the runtime class.

339
00:19:33,059 --> 00:19:34,919
We use this wast time spin we two.

340
00:19:34,919 --> 00:19:39,269
And basically that runtime class is what
informs container D that we want to use.

341
00:19:39,269 --> 00:19:43,559
The spin runtime wasnt Time is part
of, is wrapped inside of spin, but

342
00:19:43,559 --> 00:19:47,204
we only use the spin, V two version
of the runtime to actually run this.

343
00:19:48,114 --> 00:19:49,924
It's not being run, in a normal container.

344
00:19:50,424 --> 00:19:56,404
Okay, let me go back and showcase
another scenario we have.

345
00:19:56,904 --> 00:20:02,814
We have this application now, and
let's just try and see how this,

346
00:20:02,844 --> 00:20:06,394
again, how having an application
like this, using something as simple

347
00:20:06,394 --> 00:20:09,254
as providing a variable to our
application, how all of that works,

348
00:20:09,354 --> 00:20:11,454
with a regular, Kubernetes, workflow.

349
00:20:11,984 --> 00:20:15,384
What I would do in a spin application
to begin with is that I need to

350
00:20:15,424 --> 00:20:17,904
add a variable into my, spin file.

351
00:20:18,754 --> 00:20:22,824
So basically what I'm going to do in
here is I'm going to say that I have

352
00:20:22,884 --> 00:20:26,974
a variable, for my spin application
called myVar, and there's a default

353
00:20:27,004 --> 00:20:28,954
value to that, which is cont42.

354
00:20:29,944 --> 00:20:35,324
Then the other thing I can do inside of
spin is I can say as part of my component

355
00:20:35,324 --> 00:20:40,314
down here, so the Hello, it's not
called HelloCount42, it's just Count42.

356
00:20:40,814 --> 00:20:44,894
Part of this component variables, there's
a variable that I want to pass on to my

357
00:20:44,894 --> 00:20:50,034
component, and the variable that, or the
string that I want to use for this, comes

358
00:20:50,034 --> 00:20:52,394
from the MyBar that is created up here.

359
00:20:53,184 --> 00:20:57,574
So basically what this enables is
inside of Spin, I can now go to

360
00:20:57,604 --> 00:21:01,214
my file, and I can do two things.

361
00:21:01,324 --> 00:21:08,014
I can import, if I get the import correct,
a way to get variables using the spin SDK.

362
00:21:08,804 --> 00:21:11,194
And then the other thing that
I've done in here is I've just

363
00:21:11,194 --> 00:21:13,244
prepared a small piece of code.

364
00:21:13,744 --> 00:21:20,744
Let me do this, and I think I will need to
do an npm install to get the package in.

365
00:21:21,244 --> 00:21:25,024
And let me just check what's
going on, get rid of that one.

366
00:21:25,524 --> 00:21:31,014
Okay, so what I did in here in my code,
iterated as I eat this, I imported the

367
00:21:31,014 --> 00:21:35,664
variables from the spin SDK, and now I'm
setting up another path in the router

368
00:21:35,714 --> 00:21:40,764
saying if someone calls me on slash bar,
I will basically private my bar is, and

369
00:21:40,764 --> 00:21:44,524
then I'm going to get my variables from
the my component bar, which is the one

370
00:21:44,524 --> 00:21:46,454
that we just added into the tomo file.

371
00:21:46,954 --> 00:21:53,324
And now that we have this created here,
let's go back and do a spin build.

372
00:21:53,654 --> 00:21:55,114
We're going to rebuild our application

373
00:21:55,614 --> 00:21:58,664
and then we can do a spin up again.

374
00:21:58,784 --> 00:22:00,714
So basically run this application.

375
00:22:00,744 --> 00:22:01,564
And if we.

376
00:22:02,064 --> 00:22:08,094
let's do 3000 and then var, you can see we
get the default value, which was cont42.

377
00:22:08,804 --> 00:22:15,054
I can also set this var by using
spin underscore var basically.

378
00:22:15,114 --> 00:22:18,334
If I set that environment variable
when I run spin up, I've now

379
00:22:18,334 --> 00:22:22,014
provided, the variable and you can
see my var is now something else.

380
00:22:22,969 --> 00:22:26,449
That was the local story, to get an
idea of how these things, work together.

381
00:22:27,109 --> 00:22:30,979
Now, what I want to do is I want to push
this into my cluster, so I'm just going

382
00:22:30,979 --> 00:22:32,469
to make sure I have the latest build.

383
00:22:32,969 --> 00:22:35,979
Once I have that, we
can do a registry push.

384
00:22:36,049 --> 00:22:37,209
Let's do version 2.

385
00:22:37,709 --> 00:22:42,019
So we're going to push the new
compiled WebAssembly, the new, spin.

386
00:22:42,019 --> 00:22:45,649
toml that still has that
default value in it, CON42.

387
00:22:45,700 --> 00:22:48,720
but what we will do is we'll just
bypass that for now, and then we'll

388
00:22:48,720 --> 00:22:49,890
actually provide a configuration.

389
00:22:50,390 --> 00:22:52,790
through the, the app YAML that we have.

390
00:22:52,800 --> 00:22:54,660
So we don't need to create this again.

391
00:22:54,750 --> 00:23:03,610
We can basically just go in here and we
can variables as easy as, oops, as this.

392
00:23:03,620 --> 00:23:05,650
So let's say we have variables.

393
00:23:06,110 --> 00:23:10,890
And we have a variable called
myvar and oops, I just want to

394
00:23:10,890 --> 00:23:12,370
make sure we get indents right.

395
00:23:12,870 --> 00:23:15,310
Let's say the value is kubernetes
because we're in kubernetes action.

396
00:23:15,320 --> 00:23:16,560
Let's say the value is spinq.

397
00:23:16,950 --> 00:23:18,880
that's more nice than
what we're doing here.

398
00:23:19,800 --> 00:23:22,420
you need to remember
to update the version.

399
00:23:22,920 --> 00:23:26,840
Okay, so basically we now have updated the
spin application, the spin app resource

400
00:23:26,840 --> 00:23:31,320
definition to pull in the new version of
the image, and we provide variables, so if

401
00:23:31,320 --> 00:23:37,660
we do buy this, we can go back and we can
see that we have new containers creating,

402
00:23:38,380 --> 00:23:41,354
and we should soon be able to see that it.

403
00:23:41,355 --> 00:23:48,435
The previous versions being taken
down and so at least I think we have,

404
00:23:48,905 --> 00:23:53,195
this was the new version, let's check,
yeah, we have one which is version two

405
00:23:53,195 --> 00:23:58,965
of our image and we should have two,
oh, that was refreshing, yes, we now

406
00:23:58,965 --> 00:24:02,105
have two of the new versions running,
so we got those quickly deployed.

407
00:24:02,980 --> 00:24:06,190
let's go and check if our
forward is still set up.

408
00:24:06,210 --> 00:24:12,470
It's not, let's do this forward to the
service once again, and we can go over

409
00:24:12,470 --> 00:24:19,870
here and we can now curl an 8080 and we
would expect to see five hours spin queue.

410
00:24:20,370 --> 00:24:20,740
Okay.

411
00:24:20,890 --> 00:24:27,080
So that was one scenario where
basically, again, wanted to show how,

412
00:24:27,110 --> 00:24:29,070
variables can be added and other things.

413
00:24:29,070 --> 00:24:32,150
You can obviously have the variable
being pulled from a secret.

414
00:24:33,060 --> 00:24:36,970
if we take a quick look
at the API documentation.

415
00:24:37,520 --> 00:24:41,810
for the spin app, you can, actually,
instead of doing that, let's

416
00:24:41,810 --> 00:24:44,430
just look at an example because
I think that's more interesting.

417
00:24:44,930 --> 00:24:45,860
it's easier to see.

418
00:24:46,030 --> 00:24:47,040
assigning variables.

419
00:24:47,360 --> 00:24:50,790
in this scenario, basically, this is
part of the spin configuration for

420
00:24:50,790 --> 00:24:52,230
the example that's going through here.

421
00:24:52,230 --> 00:24:53,140
what we did in the spin.

422
00:24:53,140 --> 00:24:53,920
toml file.

423
00:24:54,570 --> 00:24:58,390
But basically, what you can see down
here is, how you can use both config

424
00:24:58,440 --> 00:25:00,720
maps and secrets to provide this.

425
00:25:01,100 --> 00:25:04,050
And then this would be what
the spin app would look like.

426
00:25:04,050 --> 00:25:08,410
So you have, this is what I did, an
inline variable, but we could also

427
00:25:08,410 --> 00:25:12,550
have the variable be, from a config map
reference or from a secret reference.

428
00:25:12,880 --> 00:25:17,040
And all of this would look very familiar
to how you would do this normally in

429
00:25:17,040 --> 00:25:19,340
deployments, when working with containers.

430
00:25:19,810 --> 00:25:21,760
regular containers inside
of the Kubernetes cluster.

431
00:25:22,260 --> 00:25:29,970
Okay, let's actually do check on this
one because we did see, you can see

432
00:25:29,970 --> 00:25:32,970
this was the trace from where we were
actually using the get, so you can

433
00:25:32,970 --> 00:25:37,460
see spin is fully, instrumented and
then we can see we're actually calling

434
00:25:37,460 --> 00:25:41,450
another, method inside of the spin
SDK to actually get the variable.

435
00:25:41,690 --> 00:25:44,370
which was pretty quick in terms
of how that variable's gotten.

436
00:25:44,920 --> 00:25:48,410
And if we want to dive even
further into this, because why not?

437
00:25:49,090 --> 00:25:53,380
What we can see is that the way
that all of this sort of ends up

438
00:25:53,380 --> 00:25:59,300
being set up is that the actual
pod, I am, let me just check.

439
00:25:59,360 --> 00:26:00,400
We're looking at the pod right now.

440
00:26:00,670 --> 00:26:04,840
The actual pod has the,
let's see if we did the YAML.

441
00:26:05,340 --> 00:26:09,210
The actual pod has that spin variable
myvar set up as an environment

442
00:26:09,210 --> 00:26:13,900
variable, which is the same way that
I got this environment, this variable

443
00:26:13,930 --> 00:26:15,690
injected when I ran things locally.

444
00:26:15,890 --> 00:26:19,840
So again, gives you an idea of how
the operator works and what value it

445
00:26:19,880 --> 00:26:21,500
adds inside of the whole stack here.

446
00:26:22,000 --> 00:26:25,940
Okay, let's try something a little bit
more fancy because part of the, part of

447
00:26:25,940 --> 00:26:29,700
the benefits we get from using WebAssembly
rather than containers is how quickly

448
00:26:29,720 --> 00:26:34,260
they can scale because the small size,
how quickly we can pull them in, but also

449
00:26:34,260 --> 00:26:35,920
how fast they will actually start up.

450
00:26:36,565 --> 00:26:39,605
so a good scenario would be
something like combining this

451
00:26:39,625 --> 00:26:42,445
with, scaler, inside of Kubernetes.

452
00:26:43,015 --> 00:26:47,605
So what I will be doing now is I, let
me just check because I think, yeah, we

453
00:26:47,605 --> 00:26:49,585
already have KEDA running in our cluster.

454
00:26:50,435 --> 00:26:54,845
I think what we can, so what I
will do is based on the tutorial

455
00:26:54,845 --> 00:26:56,125
that you're able to find.

456
00:26:56,955 --> 00:27:02,655
over here in the SpinCube site, which
is, called Scaling SpinApps with

457
00:27:03,235 --> 00:27:04,495
Kubernetes Event Driven Autoscaling.

458
00:27:04,495 --> 00:27:05,405
So basically using KEDA.

459
00:27:06,085 --> 00:27:09,825
this is an example that walk you through
how basically there is an application

460
00:27:09,825 --> 00:27:11,875
that, that creates a lot of CPU load.

461
00:27:11,925 --> 00:27:17,095
But obviously using KEDA, you can scale
based on CPU load, you can scale based

462
00:27:17,095 --> 00:27:20,585
on observing, queues or other things.

463
00:27:20,925 --> 00:27:24,025
I think even object stores, there's a
whole bunch of stuff that KEDA can do.

464
00:27:24,290 --> 00:27:28,540
but again, because everything at
SpinCube is so integrated into how

465
00:27:28,540 --> 00:27:32,940
Kubernetes works, most of the Kubernetes,
ecosystem and most of those projects

466
00:27:32,940 --> 00:27:36,290
that are out there will actually just
work out of the box with SpinCube.

467
00:27:37,270 --> 00:27:41,340
so what I've done is I've created,
I've added KEDA into my cluster right

468
00:27:41,340 --> 00:27:44,560
now, and all of that is something you
can do inside of this, this article.

469
00:27:44,650 --> 00:27:48,340
So what I'm going to do now is I'm just
going to apply this, KEDA scaled object.

470
00:27:48,340 --> 00:27:51,750
Basically, this is KEDA's way of saying,
Oh, actually, this is the application.

471
00:27:51,750 --> 00:27:55,050
Sorry, I'm going to add the application
to begin with, and then I'm going to

472
00:27:55,050 --> 00:27:59,290
create a kitter scaled object, which
basically is the one that is monitoring

473
00:27:59,290 --> 00:28:03,710
the spin app, changing it between
one and 20 replicas based on CPU

474
00:28:03,740 --> 00:28:05,590
and based on 50 percent utilization.

475
00:28:05,620 --> 00:28:07,820
So that's the threshold for
when we add another replica

476
00:28:07,850 --> 00:28:09,050
when we take down a replica.

477
00:28:09,980 --> 00:28:12,990
So the few things that we
need to do here to make this

478
00:28:12,990 --> 00:28:16,040
work is to go to our terminal.

479
00:28:17,000 --> 00:28:19,910
And first thing we're going to
do is we're going to apply the.

480
00:28:20,455 --> 00:28:25,475
The sample application and the next
thing I am going to do is I am going to.

481
00:28:26,170 --> 00:28:30,030
By the scaled object, so if we
quickly go over here, we can

482
00:28:30,030 --> 00:28:32,580
see we now have a Keda spin app.

483
00:28:33,450 --> 00:28:34,740
we actually had minimum one.

484
00:28:35,520 --> 00:28:38,160
I believe we could change this to zero.

485
00:28:38,660 --> 00:28:39,530
We'll try that.

486
00:28:40,030 --> 00:28:41,690
We have outer scaling set to true.

487
00:28:42,190 --> 00:28:43,460
readability curve is one.

488
00:28:43,960 --> 00:28:48,580
I think we would have
to Whoops, we got stuck.

489
00:28:48,810 --> 00:28:49,490
Let's get out of here.

490
00:28:50,440 --> 00:28:52,090
this one says minimum one.

491
00:28:52,590 --> 00:28:53,830
Anyways, let's not do this now.

492
00:28:53,830 --> 00:28:55,560
Maybe we can play around
with it a little bit later.

493
00:28:55,710 --> 00:28:59,370
I just got myself all excited about
whether we could actually, whether

494
00:28:59,370 --> 00:29:00,340
we could actually do that or not.

495
00:29:00,340 --> 00:29:02,270
Anyways, let's go back
and monitor the spin app.

496
00:29:02,290 --> 00:29:03,020
We have that here.

497
00:29:03,650 --> 00:29:07,270
I think if I do ctrl R,
that will be refreshing.

498
00:29:07,270 --> 00:29:10,250
So we can see we have one of the
Keda spin apps running already,

499
00:29:10,320 --> 00:29:11,490
translated into one part.

500
00:29:12,130 --> 00:29:15,340
So what I'm going to go do now
is I'm just going to create some

501
00:29:15,340 --> 00:29:16,930
requests to the application.

502
00:29:17,430 --> 00:29:20,600
Before I can do that, I need
to set up a port forward.

503
00:29:20,890 --> 00:29:23,610
So let's set up a port
forward to the service.

504
00:29:24,110 --> 00:29:31,010
let's do 8081 and back and
take a look at the spin app.

505
00:29:31,380 --> 00:29:39,210
We have it and then we can go over here
and now we have load and we should fairly

506
00:29:39,210 --> 00:29:46,230
quickly start seeing that more parts needs
to be spin up of the data application.

507
00:29:46,730 --> 00:29:52,270
Let's go and take a look at The pods
over here, we can see CPUs at 429.

508
00:29:52,770 --> 00:29:53,300
Oh, there you go.

509
00:29:53,330 --> 00:29:53,670
Okay.

510
00:29:53,800 --> 00:29:55,420
Now things are starting to happen.

511
00:29:55,580 --> 00:29:57,260
We got a bunch more of the cater apps.

512
00:29:57,760 --> 00:29:59,910
and if we come back, we
can see we're now at 4.

513
00:30:00,430 --> 00:30:03,130
And we should gradually see this changing.

514
00:30:03,170 --> 00:30:07,220
Let's just go back and stop
some of these HTTP requests.

515
00:30:08,190 --> 00:30:09,560
we got nine responses back.

516
00:30:09,940 --> 00:30:11,790
This is not a case of performing.

517
00:30:11,790 --> 00:30:13,970
This is just a case of
showing how these things work.

518
00:30:14,400 --> 00:30:16,330
And you can see that this all works.

519
00:30:16,360 --> 00:30:17,310
We got extra parts.

520
00:30:17,310 --> 00:30:20,700
We got more of these spin apps running,
inside of our Kubernetes cluster.

521
00:30:20,710 --> 00:30:24,020
And I don't quite recall whether
the app will actually ever stop

522
00:30:24,020 --> 00:30:25,780
again or will just keep increasing.

523
00:30:25,880 --> 00:30:30,810
but at one point we should see that the
number would cool down and we'll then

524
00:30:30,820 --> 00:30:35,400
have a fewer of the spin application
instances of the web application.

525
00:30:35,920 --> 00:30:41,100
that was a few examples of how you can
get started, looking at, using variables

526
00:30:41,120 --> 00:30:46,190
and other things, and also how this
works really well with other projects

527
00:30:46,210 --> 00:30:51,640
like OpenTelemetry Stacks, Jaeger in
this case is what we saw, we saw, and

528
00:30:51,650 --> 00:30:53,820
even Kubernetes Event Driven Autoscaler.

529
00:30:54,520 --> 00:30:58,770
we might actually see, yeah, this
is the CPU load, but we can see a

530
00:30:58,770 --> 00:31:00,140
bunch of those coming in as well.

531
00:31:00,150 --> 00:31:03,060
I don't know whether those will
actually ever complete or not.

532
00:31:03,610 --> 00:31:05,630
a few resources to go for, spincube.

533
00:31:05,780 --> 00:31:06,160
dev.

534
00:31:06,670 --> 00:31:08,200
And you can get to learn
a lot about SpinCube.

535
00:31:09,060 --> 00:31:09,870
developerfirmian.

536
00:31:09,910 --> 00:31:14,900
com is a good place to get some spin
documentation and Spin Framework

537
00:31:14,960 --> 00:31:18,400
on GitHub is the place that you
go and take a look for this.

538
00:31:18,900 --> 00:31:24,229
Okay, so hopefully along the way
I've, you've got the idea that,

539
00:31:24,289 --> 00:31:28,719
SpinCube like just easily flows into
your regular, way of working with

540
00:31:28,759 --> 00:31:33,319
Kubernetes and your workflows you
have around CI, CD and all the other

541
00:31:33,319 --> 00:31:34,829
things you can do around Kubernetes.

542
00:31:35,329 --> 00:31:38,099
There's obviously the question of
why do we need spin WebAssembly

543
00:31:38,099 --> 00:31:39,329
applications in Kubernetes.

544
00:31:39,979 --> 00:31:44,189
And I think there are, four, four very
particular things that you want to,

545
00:31:44,379 --> 00:31:47,839
want to consider, and why I think this
is super relevant, and why I think this

546
00:31:47,839 --> 00:31:52,844
is a way that we can, bring even more
value and then so on into Kubernetes.

547
00:31:53,624 --> 00:31:57,074
first of all, as I showed you, the
spin applications are really small.

548
00:31:57,224 --> 00:31:59,944
So comparing to a lot of containers
where you potentially bring in a lot

549
00:31:59,944 --> 00:32:03,064
of dependencies and all of these,
you have a single binary that needs

550
00:32:03,064 --> 00:32:05,504
to bring and you potentially have
some configuration and maybe you have

551
00:32:05,504 --> 00:32:06,724
some data that you bring as well.

552
00:32:07,324 --> 00:32:10,894
But a hello world spin application
that's not written in JavaScript,

553
00:32:10,934 --> 00:32:14,334
but written in Rust, could be as
small as a few hundred kilobytes.

554
00:32:14,684 --> 00:32:17,304
that's the OCI artifact that
we need to juggle around.

555
00:32:18,029 --> 00:32:21,189
So this gives us a lot of great
opportunities in terms of, if we need

556
00:32:21,189 --> 00:32:24,699
to run these things and we want to use
Kubernetes as a workload manager or

557
00:32:24,699 --> 00:32:29,899
scheduler, even in environments that
have little compute capacity and power,

558
00:32:30,649 --> 00:32:34,829
this is something that can potentially
make that work with Kubernetes, so

559
00:32:34,829 --> 00:32:36,319
you don't have to rely on containers.

560
00:32:36,819 --> 00:32:39,749
Another part of this is that
the WebAssembly components start

561
00:32:39,749 --> 00:32:40,909
in less than a millisecond.

562
00:32:41,359 --> 00:32:46,299
um, the way, actually the execution
model, we haven't really talked about

563
00:32:46,299 --> 00:32:50,259
it, but the execution model in this,
in, in the world of, of spin and

564
00:32:50,259 --> 00:32:55,029
WebAssembly is that the component, and
maybe we want to go back and look at

565
00:32:55,029 --> 00:32:58,209
this file just to give you a, you have.

566
00:32:58,709 --> 00:33:01,049
What I mean, let's look at this.

567
00:33:01,549 --> 00:33:04,969
So you can see that there is this,
the way that a spin application is

568
00:33:04,969 --> 00:33:09,489
defined in here, we have this idea of,
or this concept of a component, right?

569
00:33:09,489 --> 00:33:11,699
So we have an HTTP trigger
that maps to a component.

570
00:33:11,709 --> 00:33:13,129
The component is the WebAssembly file.

571
00:33:13,759 --> 00:33:16,639
So I can easily create applications where
I have multiple of these components.

572
00:33:16,719 --> 00:33:20,219
So each WebAssembly file represents,
a different path on the route or

573
00:33:20,219 --> 00:33:22,139
a different set of functionality
inside this application.

574
00:33:22,639 --> 00:33:27,359
Whenever a request hits our application,
what happens inside of the runtime is

575
00:33:27,359 --> 00:33:29,299
that the WebAssembly binary is loaded.

576
00:33:29,459 --> 00:33:32,299
The request is handed over in
memory from the host to the guest.

577
00:33:32,339 --> 00:33:34,229
The guest in this case
being your application.

578
00:33:34,729 --> 00:33:37,849
It's handing the request and then we're
unloading the WebAssembly module again.

579
00:33:38,039 --> 00:33:41,169
Which means that if you had four or
five different WebAssembly modules in

580
00:33:41,169 --> 00:33:44,359
here, for each request, only the mod,
only the modules that needs, or the

581
00:33:44,649 --> 00:33:46,679
components that needs to be loaded are
the ones that are going to be loaded.

582
00:33:47,344 --> 00:33:52,184
And that we will use, for this, which
also means that as soon as the work

583
00:33:52,184 --> 00:33:54,404
is done, the WebAssembly is unloaded.

584
00:33:54,644 --> 00:34:01,164
So it's only the host runtime that
takes up memory on your Kubernetes node.

585
00:34:01,164 --> 00:34:04,634
And this is where the density that
we can get from running WebAssembly

586
00:34:04,634 --> 00:34:08,544
actually comes from is that
there's a very low, minimum, memory

587
00:34:09,044 --> 00:34:10,534
assumption that is taking place.

588
00:34:11,344 --> 00:34:14,054
And there are even ways, and this
is where some of the enterprise.

589
00:34:14,404 --> 00:34:16,994
Add ons that we built at Fermion
come into place where we can get

590
00:34:17,644 --> 00:34:19,284
fully rid of the memory footprint.

591
00:34:19,414 --> 00:34:23,294
so basically truly scale to
zero, as part of, as part of

592
00:34:23,294 --> 00:34:24,744
this, as part of how these run.

593
00:34:25,384 --> 00:34:28,884
But that's another very, important
thing and a lot of value that I think

594
00:34:28,884 --> 00:34:32,444
SpinWebAssembly applications will
bring into Kubernetes through SpinQube.

595
00:34:32,944 --> 00:34:34,824
And there's the third thing,
which is that sandbox.

596
00:34:34,824 --> 00:34:38,254
So this is the security part of this
WebAssembly component is a sandbox

597
00:34:38,274 --> 00:34:41,254
and is denied access to resources
on the system, which means that it

598
00:34:41,264 --> 00:34:43,034
does not have access to file system.

599
00:34:43,054 --> 00:34:47,974
It does not have access to memory outside
of its own memory, linear memory that's

600
00:34:47,974 --> 00:34:50,234
provided by the host at, when it's loaded.

601
00:34:50,774 --> 00:34:55,804
Also, you have to explicitly grant
access to HTTP endpoints or other network

602
00:34:55,804 --> 00:34:57,514
endpoints that you want to access.

603
00:34:57,774 --> 00:34:59,494
So there's a way inside the spin.

604
00:34:59,494 --> 00:35:04,224
toml file where you provide access to
particular API endpoints, whether that's

605
00:35:04,224 --> 00:35:10,949
a SQL database, a Postgres database,
a Redis endpoint, a Valkey endpoint.

606
00:35:11,299 --> 00:35:14,639
an HTTP endpoint, you have
to do that explicitly.

607
00:35:15,129 --> 00:35:18,589
So this is a nice operational
runtime decision that you can make

608
00:35:18,619 --> 00:35:21,269
of, which endpoints are available
for the actual application.

609
00:35:22,129 --> 00:35:25,989
And finally, you have the portability,
cross processing, architectures and

610
00:35:25,989 --> 00:35:28,999
operating systems, which means you can
swap out the underlying node processing

611
00:35:28,999 --> 00:35:33,179
architecture without having to produce
separate pipelines and deploy artifacts,

612
00:35:33,439 --> 00:35:39,279
meaning that the same OCI image Could
run across X 64 and ARM 64 devices.

613
00:35:39,639 --> 00:35:43,689
so if you're able to use some of
those in your at cloud environment

614
00:35:43,749 --> 00:35:47,009
or other environments where you
run, Kubernetes, you don't need to

615
00:35:47,009 --> 00:35:50,249
deal with multi arc images and all
these multiple build pipelines.

616
00:35:50,759 --> 00:35:52,769
The same Web MD binary, we actually.

617
00:35:53,404 --> 00:35:57,554
In one compilation would run across all
of these processes and architectures.

618
00:35:57,554 --> 00:36:03,764
So again, it dramatically simplifies,
I guess the scenario would be if you

619
00:36:03,774 --> 00:36:07,574
have a workload where you can utilize
things like spot instances, or what

620
00:36:07,574 --> 00:36:13,204
they're called in cloud, you can really
subscribe to spot instances provided

621
00:36:13,204 --> 00:36:15,704
as ARM instances, x64 instances.

622
00:36:15,744 --> 00:36:19,214
There's a lot of opportunities there to
also have some cost savings associated.

623
00:36:19,714 --> 00:36:23,994
So with that being said, I hope
this gave you a good idea of what

624
00:36:23,994 --> 00:36:28,294
SpinCube is, how it works, its
relationship to Spin, and some of the

625
00:36:28,294 --> 00:36:30,014
benefits you'll get from using this.

626
00:36:30,054 --> 00:36:32,204
So I highly recommend go
and check out spincube.

627
00:36:32,204 --> 00:36:32,674
dev.

628
00:36:33,184 --> 00:36:34,714
Spin documentation is on firmware.

629
00:36:34,714 --> 00:36:35,994
com slash spin for now.

630
00:36:36,594 --> 00:36:38,544
And thank you so much for listening.

631
00:36:39,154 --> 00:36:39,694
Have a great day.

