1
00:00:00,240 --> 00:00:00,930
Hello everyone.

2
00:00:01,380 --> 00:00:01,920
Welcome.

3
00:00:02,730 --> 00:00:04,530
This is LaMi.

4
00:00:05,010 --> 00:00:05,250
Today.

5
00:00:05,250 --> 00:00:08,010
In this conference, I wanna talk
about building mission critical

6
00:00:08,010 --> 00:00:09,390
emergency response systems.

7
00:00:09,390 --> 00:00:09,810
In rush.

8
00:00:10,310 --> 00:00:13,995
I'm a highly experienced cloud DevOps
lead with our 13 years experience

9
00:00:13,995 --> 00:00:18,225
in IT industry, currently selling at
conent, I'm specialized in cloud native

10
00:00:18,255 --> 00:00:22,815
architectures, con container orchestration
and infrastructure automation.

11
00:00:23,160 --> 00:00:28,200
I have extensive experience in AWS Amazon
Web Services and Azure Cloud platforms,

12
00:00:28,590 --> 00:00:31,590
Kubernetes, Docker, and continuous
indication, continuous delivery,

13
00:00:31,590 --> 00:00:35,760
continuous deployment implementation,
using tools like Jenkins and configuration

14
00:00:35,760 --> 00:00:37,815
management through Ansible and Terraform.

15
00:00:38,790 --> 00:00:41,700
I have master's degree in cover
science from University of

16
00:00:41,700 --> 00:00:45,415
Houston, clear Lake, which combines
strong technical capabilities.

17
00:00:45,915 --> 00:00:48,975
Leadership skills, having LED
cloud migration projects and

18
00:00:49,035 --> 00:00:52,215
jobs in transformations at
T-Mobile, AudioPro and conent.

19
00:00:52,905 --> 00:00:57,555
This experience spans both traditional
middleware administration and modern

20
00:00:57,555 --> 00:01:01,964
cloud native technologies, making
me a cloud technology provisional,

21
00:01:01,964 --> 00:01:06,675
who consistently delivers resilient,
scalable infrastructure solutions,

22
00:01:07,175 --> 00:01:09,580
building mission critical
emergency response systems in rush.

23
00:01:10,080 --> 00:01:14,040
In an emergency, whether it is
a natural disaster or a chemical

24
00:01:14,040 --> 00:01:18,180
spill or mask casualty event,
systems can't effort to fail.

25
00:01:18,870 --> 00:01:20,250
Every millisecond matters.

26
00:01:20,750 --> 00:01:26,210
Today I'll showing how Rust can GA
a game changer for building life

27
00:01:26,210 --> 00:01:30,080
critical applications while performance
and safety are non-negotiable.

28
00:01:30,580 --> 00:01:33,960
Imagine a major earthquake
hits a city within minutes.

29
00:01:34,050 --> 00:01:39,180
Emergency calls, call volumes
spike 800% systems must process

30
00:01:39,300 --> 00:01:42,630
over a hundred thousand messages
a second without missing a beat.

31
00:01:43,130 --> 00:01:44,660
These systems don't get a chance.

32
00:01:44,750 --> 00:01:46,490
Second chance to respond.

33
00:01:47,000 --> 00:01:49,010
The operational environment is extreme.

34
00:01:49,510 --> 00:01:50,980
We aim for 99%.

35
00:01:51,400 --> 00:01:55,695
99.9% uptime even when infrastructure
is collapsing around us.

36
00:01:55,985 --> 00:01:58,255
These are not just
performance requirements.

37
00:01:58,325 --> 00:01:59,815
They are survival requirements.

38
00:02:00,315 --> 00:02:02,935
The critical challenges
of life saving systems,

39
00:02:03,435 --> 00:02:05,445
traditional tech tax fails here.

40
00:02:05,945 --> 00:02:10,415
The average response delay in some
legacy setups is 17 seconds for

41
00:02:10,415 --> 00:02:12,035
long, too long, which is too long.

42
00:02:12,545 --> 00:02:16,205
84% of critical failures trace
back to memory safety issues.

43
00:02:16,205 --> 00:02:17,525
In C or CPS space.

44
00:02:18,005 --> 00:02:22,955
Java brings garbage collection, pauses
with sometimes to 35 seconds delay,

45
00:02:23,345 --> 00:02:26,315
right when you need instant responses.

46
00:02:27,005 --> 00:02:30,005
Problems with which
can't in public safety.

47
00:02:30,505 --> 00:02:32,665
Why rest for emergency response systems?

48
00:02:33,165 --> 00:02:35,895
Rush gives us memory safety
without a runtime cost.

49
00:02:36,435 --> 00:02:40,725
Thanks to ownership and borrowing, we
get zero cost abstractions, fearless

50
00:02:40,725 --> 00:02:43,575
concurrency, and deterministic
cleanup without GC pauses.

51
00:02:43,935 --> 00:02:49,125
In fact, these our Rush implementation
delivered 42% faster response times

52
00:02:49,155 --> 00:02:51,645
and 35% memory usage compared to.

53
00:02:52,145 --> 00:02:56,495
Java Systems rushed illness critical
weaknesses while keeping speed.

54
00:02:56,995 --> 00:03:00,055
Zero cost abstractions,
maintain readability scalability

55
00:03:00,085 --> 00:03:01,375
without content penalties.

56
00:03:01,705 --> 00:03:08,300
The fearless concurrency, which helps
data elevated compiled time, which you

57
00:03:08,330 --> 00:03:12,955
42% concurrency faster response times,
and that if it percent lower memory

58
00:03:13,005 --> 00:03:14,475
usage compared to Java equivalent.

59
00:03:14,975 --> 00:03:18,360
Last ownership model making
invalid states and representable

60
00:03:18,860 --> 00:03:21,590
ownership rules sound
simple, but they're powerful.

61
00:03:21,590 --> 00:03:21,800
One.

62
00:03:22,460 --> 00:03:26,385
One per value, exclusive or share
differences are no inval differences.

63
00:03:26,885 --> 00:03:32,015
This means there are no leaks, no race
conditions, no null differences, even at

64
00:03:32,015 --> 00:03:34,235
a high concurrency in emergency systems.

65
00:03:34,235 --> 00:03:37,685
This means we remove anti classes
of bugs before they even exist.

66
00:03:38,185 --> 00:03:39,835
This leads to emergency systems.

67
00:03:40,165 --> 00:03:43,225
Invalid systems can't happen
even at extreme concurrency.

68
00:03:43,725 --> 00:03:47,055
I want to provide analogy here,
like strict airport security.

69
00:03:47,115 --> 00:03:49,785
Nothing unsafe gets through
the airport security.

70
00:03:50,285 --> 00:03:53,555
To case study based
emergency dispatch system,

71
00:03:54,055 --> 00:03:55,770
real system, real results.

72
00:03:56,639 --> 00:04:01,109
Our dispatch system uses asynchronous a
eight for non rocking Ivo input output.

73
00:04:01,350 --> 00:04:06,210
Tokyo for tasks, scheduling Kafka for
real reliable event streaming and web

74
00:04:06,210 --> 00:04:08,280
assembly for secure edge computing.

75
00:04:09,090 --> 00:04:13,559
We process real-time reports with
machine learning models at 90 93 0.7.

76
00:04:13,559 --> 00:04:18,809
Accuracy and rush guarantees mean zero
catastrophic failures in production.

77
00:04:19,740 --> 00:04:23,460
I wanna discuss in detail about
the architecture of the systems.

78
00:04:23,960 --> 00:04:27,860
The first component is as Synchron I
wait for non-blocking input output.

79
00:04:28,580 --> 00:04:31,850
I want to compare this with
traditional back blocking IO model

80
00:04:32,150 --> 00:04:33,800
in traditional blocking IO model.

81
00:04:34,070 --> 00:04:36,440
A third makes a network or file request.

82
00:04:36,920 --> 00:04:40,640
Then the voice operating systems
OS puts the thread to sleep

83
00:04:40,670 --> 00:04:42,425
until data arrive the third.

84
00:04:42,425 --> 00:04:44,255
Can't do anything else
while it is waiting.

85
00:04:44,885 --> 00:04:48,155
If you have thousands of requests
waiting on input output, Ivo.

86
00:04:49,025 --> 00:04:52,325
You need thousands of threads,
which is memory heavy and

87
00:04:52,325 --> 00:04:54,035
slow due to context switching.

88
00:04:54,535 --> 00:04:57,415
The asynchronous heavy process
approach is totally different.

89
00:04:57,915 --> 00:05:01,515
A function can pause when it's waiting
for IO without blocking the thread.

90
00:05:02,055 --> 00:05:05,295
While the function is waiting, the
thread can run other ready tasks

91
00:05:05,295 --> 00:05:08,405
while the completes the runtime.

92
00:05:08,435 --> 00:05:11,195
The Tokyo resumes the function
exactly where it left off.

93
00:05:11,645 --> 00:05:13,265
I want to provide an analogy here.

94
00:05:13,685 --> 00:05:14,590
Think of a chef in a kitchen.

95
00:05:15,090 --> 00:05:19,050
In blocking Iwo, the chef starts
boiling pasta and stands there

96
00:05:19,050 --> 00:05:20,850
staring at the pot until it is done.

97
00:05:21,350 --> 00:05:25,100
In asynchronous Iwo, the chef starts
boiling pasta, sets a timer and

98
00:05:25,100 --> 00:05:27,040
moves on to a prepad while waiting.

99
00:05:27,130 --> 00:05:29,530
The moment that timer rings,
they return to finish.

100
00:05:29,530 --> 00:05:33,980
The pasta how it works in the and
a synchronous function, returns a

101
00:05:33,980 --> 00:05:36,680
feature, a value representing this work.

102
00:05:36,770 --> 00:05:38,210
This work will complete later.

103
00:05:39,185 --> 00:05:41,555
If this feature is not
done yet, pass here.

104
00:05:41,585 --> 00:05:44,465
Give control back to runtime
and resume me when it's ready.

105
00:05:44,965 --> 00:05:48,625
The Tokyo Runtime pulls these features
and schedules them efficiently.

106
00:05:49,125 --> 00:05:52,485
Coming to Next Component is
a, Tokyo is the most wide user

107
00:05:52,605 --> 00:05:53,895
asynchronous runtime for Rush.

108
00:05:54,075 --> 00:05:57,615
It's combination of task
scheduler, Ivo, even two timer

109
00:05:57,615 --> 00:05:59,145
system asynchronous utilities.

110
00:05:59,775 --> 00:06:02,390
A task scheduler decides
when asynchronous task run.

111
00:06:02,700 --> 00:06:07,590
The I even group reacts to network
file timer events without blocking

112
00:06:07,890 --> 00:06:12,710
the timer system for delays,
timeouts intervals coming to Kafka

113
00:06:12,710 --> 00:06:15,440
for streaming events, which is the
next component to this architecture.

114
00:06:16,100 --> 00:06:19,925
Apache Kafka is a distributed fault,
tolerant and even streaming platform.

115
00:06:19,925 --> 00:06:23,270
It is used to send store
and process streams.

116
00:06:23,330 --> 00:06:25,250
Our data at scale.

117
00:06:25,750 --> 00:06:28,780
It works like durable
message bus, durable message.

118
00:06:28,780 --> 00:06:32,890
Bus producers send events, consumers
read them and Kafka keeps them in

119
00:06:32,890 --> 00:06:35,080
topics or for set retention period.

120
00:06:35,580 --> 00:06:39,410
The core concepts are topic,
a name channel for events.

121
00:06:40,400 --> 00:06:43,250
Partition is split off
topic for scalability.

122
00:06:43,730 --> 00:06:45,500
Events in partition are strictly ordered.

123
00:06:45,800 --> 00:06:48,800
The producer application
then writes events to Kafka.

124
00:06:49,790 --> 00:06:53,330
A P Service publishing user actions,
the consumer that tweets even from

125
00:06:53,330 --> 00:06:58,660
Kafka, the broker Kafka, serves
the stores topic per partitions,

126
00:06:58,690 --> 00:07:00,760
multiple brokers from Kafka's cluster.

127
00:07:01,260 --> 00:07:02,610
Why use Kafka streaming?

128
00:07:03,150 --> 00:07:07,260
After discussing the core concepts like
topic, partition, what is partition,

129
00:07:07,260 --> 00:07:09,270
what is producer, what is consumer?

130
00:07:09,570 --> 00:07:12,810
We discuss about what the main
users of Kafka are streaming.

131
00:07:13,310 --> 00:07:18,290
The high throughput can handle multiple
millions of events it at the same time.

132
00:07:18,290 --> 00:07:20,720
Kafka gives durability.

133
00:07:21,230 --> 00:07:24,200
Events are persistent to disk
and replicate across blockers.

134
00:07:24,830 --> 00:07:28,595
It's scalable as partitions of
parallel process and it's real

135
00:07:28,595 --> 00:07:32,525
time consumers can read data at is
arrives and enabling low pipelines,

136
00:07:32,615 --> 00:07:34,085
and it also provides decoupling.

137
00:07:34,415 --> 00:07:37,745
Producers and consumers don't
need to know about each other.

138
00:07:37,805 --> 00:07:40,055
They just read right or write to topics.

139
00:07:40,555 --> 00:07:44,595
How it works in architecture, producer
services receive events from clients,

140
00:07:45,135 --> 00:07:49,575
then they serialize the data and
publish it to Kafka topics and Kafka.

141
00:07:49,575 --> 00:07:53,115
Brokers store these events durably
and replicate them for fall tolerance.

142
00:07:53,985 --> 00:07:56,115
Consumer services
subscribe to these topics.

143
00:07:56,655 --> 00:07:58,935
Some do enrichment of transformation.

144
00:07:59,625 --> 00:08:01,635
Others update materialized
views in database.

145
00:08:02,055 --> 00:08:05,535
Some might forward even to web assembly
edge modules for policy-based routing.

146
00:08:06,035 --> 00:08:10,315
So consumer fails, another in the
same consumer group takes over.

147
00:08:10,315 --> 00:08:12,290
Continuing from the last complete offset

148
00:08:12,790 --> 00:08:17,560
benefits of this context, it provides
loose coupling a PL layer and analytics

149
00:08:17,560 --> 00:08:19,350
don't depend on each other as uptime.

150
00:08:19,850 --> 00:08:23,060
Process historical events by
replaying from an earlier offset

151
00:08:23,390 --> 00:08:24,620
and it provides scalability.

152
00:08:24,680 --> 00:08:28,220
Add more partitions, consumers
to increase throughput, and it

153
00:08:28,220 --> 00:08:29,630
also provides fault tolerance.

154
00:08:30,130 --> 00:08:33,760
Data is replicated and consumers
can resume after crashes.

155
00:08:34,270 --> 00:08:38,320
Next, coming to next component, we
assembly to secure edge components.

156
00:08:38,820 --> 00:08:42,210
Web assembly is binary instruction
format that can run in its sandbox

157
00:08:42,240 --> 00:08:47,040
environment, built for browsers, but now
used for widely used for out of them.

158
00:08:47,490 --> 00:08:52,110
You can write coding languages like
rust, C, c plus, go and compile.

159
00:08:52,860 --> 00:08:57,450
It is designed to small to be small, fast
and secure ideal for edge deployments.

160
00:08:57,840 --> 00:08:59,340
Why use at the Edge?

161
00:08:59,430 --> 00:09:04,500
Edge means running core and servers that
are geographically close to the end user.

162
00:09:05,490 --> 00:09:07,610
Benefits of running web assembly.

163
00:09:08,110 --> 00:09:11,350
It provides low latency, the which
can be processed locally instead

164
00:09:11,350 --> 00:09:13,330
of traveling to a central server.

165
00:09:13,810 --> 00:09:15,400
It also provides SEC security.

166
00:09:15,760 --> 00:09:18,580
Strong sandbox model web assembly.

167
00:09:18,580 --> 00:09:20,670
Can't access the host o directly.

168
00:09:20,670 --> 00:09:22,225
It only uses a lot of APAs.

169
00:09:22,725 --> 00:09:23,175
Portability.

170
00:09:23,385 --> 00:09:26,645
Some web assembly module can run
on different edge providers without

171
00:09:26,705 --> 00:09:32,415
rewriting, and it also provides fast cold
starts, modules load almost instantly.

172
00:09:32,415 --> 00:09:34,300
And compared to countless of VMs,

173
00:09:34,800 --> 00:09:40,065
ENC coding data domain safety in rush
type system with rust, we can encode

174
00:09:40,065 --> 00:09:41,415
domain rules directly into types.

175
00:09:41,915 --> 00:09:43,805
Patient ID is just not an inte.

176
00:09:44,555 --> 00:09:47,245
Just an integer isn't just an inte.

177
00:09:47,305 --> 00:09:50,155
It's type that can only be
visible Validly constructed.

178
00:09:50,515 --> 00:09:53,545
This vari by construction
approach moves error detection

179
00:09:53,545 --> 00:09:54,895
from unpredictable runtime.

180
00:09:54,895 --> 00:09:57,505
Failure to predictable compar time checks.

181
00:09:58,405 --> 00:10:01,315
This is where the business
rules bake into the compiler.

182
00:10:01,815 --> 00:10:06,115
Coming to zero cost abstractions for
iot sensor integration for environmental

183
00:10:06,115 --> 00:10:09,010
monitoring, to traffic surveillance
to building integrity checks.

184
00:10:09,190 --> 00:10:13,240
Rush trade system uses zero cost
abstractions with we integrate

185
00:10:13,240 --> 00:10:17,170
varied iot hardware without runtime
penalties, which is vital when

186
00:10:17,170 --> 00:10:18,760
processing live data under load.

187
00:10:19,375 --> 00:10:22,645
The real world Examples like environmental
monitoring for hazard hazards,

188
00:10:22,645 --> 00:10:24,175
traffic surveillance for accidents.

189
00:10:24,175 --> 00:10:28,395
Structural integrity monitoring
for buildings result are examples

190
00:10:29,265 --> 00:10:30,885
of the realtime scenarios.

191
00:10:31,385 --> 00:10:34,920
These traits allow hardware diversity
without runtime penalty crucial

192
00:10:35,060 --> 00:10:36,965
in realtime data environments.

193
00:10:37,775 --> 00:10:43,745
The core message of Euro cost abstractions
for iot sensor integration is DI sensor.

194
00:10:43,955 --> 00:10:45,035
Same reliability,

195
00:10:45,535 --> 00:10:47,245
web assembly support for edge computing.

196
00:10:47,745 --> 00:10:51,770
With web assembly, we detect hazards 70
minutes faster than centralized systems

197
00:10:52,185 --> 00:10:54,105
we keep running during network outages.

198
00:10:54,375 --> 00:10:58,515
Product privacy by processing local leak
and cut bandwidth in cus crisis surges.

199
00:10:59,400 --> 00:11:01,410
In disaster edge means survival

200
00:11:01,910 --> 00:11:03,140
benefits continue.

201
00:11:03,140 --> 00:11:06,290
W working offline keeps sense.

202
00:11:06,290 --> 00:11:08,270
Two, data local and
reduces search bandwidth.

203
00:11:08,630 --> 00:11:11,810
The core message of web assembly
for edge computing is resilience.

204
00:11:12,200 --> 00:11:13,940
When central infrastructure fails

205
00:11:14,440 --> 00:11:18,865
coming to performance benchmarks
we compare trust rest versus.

206
00:11:19,365 --> 00:11:23,735
Traditional systems we, in this graph
you can see the response times memory,

207
00:11:23,735 --> 00:11:26,135
UC utilization, and worst case pause.

208
00:11:26,315 --> 00:11:28,865
That is GC pauses, garbage
correction, pauses.

209
00:11:29,365 --> 00:11:33,385
The Benchmark Show Rush delivers
near C plus per near C plus Cs

210
00:11:33,385 --> 00:11:37,105
with but without its memory risks
and it all performance Java while

211
00:11:37,105 --> 00:11:39,175
avoiding garbage collection pauses.

212
00:11:39,385 --> 00:11:43,345
For us, this means no compromise
between speed and safety.

213
00:11:43,675 --> 00:11:47,205
The core message is Rush proves a
performance press safety equation.

214
00:11:47,705 --> 00:11:50,050
A synchronous await for
non-blocking emergency processing.

215
00:11:50,550 --> 00:11:53,270
Here it is a real emergency call flow.

216
00:11:53,770 --> 00:11:58,300
In the rest, we geo geolocate the
caller pull their info query historical

217
00:11:58,300 --> 00:12:03,520
incidents, and all concurrently then a
machine learning model, res resources, and

218
00:12:03,520 --> 00:12:09,075
dispatches triggered rush asynchronous syn
uses concurrency without call back help.

219
00:12:09,575 --> 00:12:12,245
Patterns for fall, fall
tolerant distributed systems.

220
00:12:12,245 --> 00:12:12,605
In rush,

221
00:12:13,105 --> 00:12:16,765
the implementation of circuit breakers
that automatically isolate failing

222
00:12:16,765 --> 00:12:21,715
components prevents ca cascading failures
that might otherwise disable anti-system

223
00:12:22,215 --> 00:12:24,105
while fallback mechanisms ensure that.

224
00:12:24,765 --> 00:12:28,875
Critical operations continue even when
o optimal performance is impossible.

225
00:12:28,875 --> 00:12:32,295
These approaches have prevent
essential for maintaining emergency

226
00:12:32,535 --> 00:12:35,325
surveys functionality during
infrastructure disruptions.

227
00:12:35,565 --> 00:12:40,785
While traditional systems often experience
complete outages when key components fail,

228
00:12:41,285 --> 00:12:44,075
lessons from deploying
rushed in public safety.

229
00:12:44,575 --> 00:12:49,255
In 18 months of operation, we had zero
memory related caches, strong performance,

230
00:12:49,585 --> 00:12:53,775
co, easier compliance, and cost savings
and reduced infrastructure costs.

231
00:12:54,675 --> 00:13:00,500
The challenges are the developer learning
curve, some missing legacy integrations

232
00:13:00,520 --> 00:13:04,575
and longer compar times all solvable
with training and ecosystem growth.

233
00:13:05,075 --> 00:13:08,105
The core message is successes
outweigh the challenges.

234
00:13:08,605 --> 00:13:12,315
The key takeaways, lush ownership
model prevents catastrophic bugs.

235
00:13:12,435 --> 00:13:16,725
It delivers C performance,
safety type driven design,

236
00:13:16,725 --> 00:13:18,735
illness and type error classes,

237
00:13:19,235 --> 00:13:20,615
and web assembly readable.

238
00:13:21,115 --> 00:13:22,935
Edge computing in count.

239
00:13:23,435 --> 00:13:26,705
We can the right response,
right choice for mission.

240
00:13:27,205 --> 00:13:27,625
Thank you.

