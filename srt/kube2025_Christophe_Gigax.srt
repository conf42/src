1
00:00:00,500 --> 00:00:03,949
Okay, so hello everyone and
thank you for watching my

2
00:00:03,949 --> 00:00:05,960
session about the perfect time.

3
00:00:06,470 --> 00:00:09,910
I am Christoph Gig, a cloud
search architect at Hagi Group,

4
00:00:09,910 --> 00:00:11,950
and also I'm MVP Microsoft.

5
00:00:12,450 --> 00:00:19,065
Before going deep into, at that point in
time, let me just remind remind me, remind

6
00:00:19,065 --> 00:00:22,005
us what is a microservices architecture?

7
00:00:22,005 --> 00:00:25,785
Why do we often choose a
microservices architecture?

8
00:00:26,444 --> 00:00:30,794
First, we want our microservices
to be focused on a specific

9
00:00:30,794 --> 00:00:32,804
business aspect of our solution.

10
00:00:33,134 --> 00:00:34,965
This allow us to gain.

11
00:00:35,554 --> 00:00:38,254
More autonomy, flexibility,
and scalability.

12
00:00:38,554 --> 00:00:44,635
And it allows also the teams to be
more flexible independent into the

13
00:00:44,635 --> 00:00:46,344
development and the deployment.

14
00:00:46,915 --> 00:00:51,184
In summary, what we want smaller
services, but more efficient.

15
00:00:51,934 --> 00:00:55,414
Of course, this comes also
with some difficulties.

16
00:00:55,414 --> 00:00:57,949
So for example, the debugging
process and the testability.

17
00:00:58,449 --> 00:01:04,739
For example, you want to debug a
feature or a fix a bug that implies a

18
00:01:04,739 --> 00:01:06,899
lot of services of your architecture.

19
00:01:06,899 --> 00:01:10,979
You have to run all your services
in your local environment.

20
00:01:11,759 --> 00:01:16,250
This increase the complexity of
your architecture and, you also

21
00:01:16,250 --> 00:01:21,440
have some difficulties with the, in
interdependencies of your service.

22
00:01:21,650 --> 00:01:26,000
At the end, you just doesn't
understand what is going on in

23
00:01:26,000 --> 00:01:31,930
your solution and also you don't
master and you can manage properly

24
00:01:31,930 --> 00:01:33,880
the flows inside your application.

25
00:01:34,380 --> 00:01:38,590
To summarize this, it's difficult
to migrate from a monolithic block

26
00:01:38,590 --> 00:01:40,480
to a microservices architecture.

27
00:01:40,929 --> 00:01:44,980
And today the languages and the
framework that you use are not

28
00:01:45,070 --> 00:01:51,189
natively oriented for microservices
at the end, about hosting model.

29
00:01:51,599 --> 00:01:55,979
It's not so much true today,
but application tied to a

30
00:01:55,979 --> 00:01:57,359
specific infrastructure.

31
00:01:58,064 --> 00:02:01,694
Platform with limited
portability to cloud or Edge.

32
00:02:02,194 --> 00:02:04,984
And that's why Dapper
comes to the landscape.

33
00:02:05,034 --> 00:02:11,065
Dapper is the acronym for distributed
Application Runtime, and it's it's

34
00:02:11,124 --> 00:02:15,024
portable, even driven runtime for
building distributed application.

35
00:02:15,385 --> 00:02:17,974
And you can run it in
the cloud or in the edge.

36
00:02:18,474 --> 00:02:24,515
Dapper comes with very specific objectives
for you and for developer teams.

37
00:02:25,084 --> 00:02:28,174
It comes with best practices
and some building blocks.

38
00:02:28,745 --> 00:02:33,324
So for example if you install dapper
on the local machines, it'll on the

39
00:02:33,355 --> 00:02:38,304
shelf comes with some blocks that you
can already use for your applications.

40
00:02:39,130 --> 00:02:41,539
We will go through it
just a little bit later.

41
00:02:42,019 --> 00:02:45,170
You can use any language or
framework that you want with dapper.

42
00:02:45,759 --> 00:02:49,719
And it's C Driven, it's a
non-commercial initiative and it's

43
00:02:49,779 --> 00:02:52,249
into the CNCF ecosystem today.

44
00:02:53,229 --> 00:02:54,279
It'll allow us.

45
00:02:54,474 --> 00:02:58,374
To adapt some standards
into our architecture.

46
00:02:58,534 --> 00:03:00,424
I will come to it just later also.

47
00:03:00,934 --> 00:03:05,154
And it's built on a consistent
portable and open APIs.

48
00:03:05,544 --> 00:03:09,094
That means that you can very easily
interact with the run time if you want to.

49
00:03:09,879 --> 00:03:12,159
It's platform agnostic from cloud to edge.

50
00:03:12,159 --> 00:03:16,839
That's because it's built on
containers technology and it's really

51
00:03:16,839 --> 00:03:18,939
sensible with pluggable components.

52
00:03:19,009 --> 00:03:22,769
Today they are more than a hundred
components that you can use on the

53
00:03:22,769 --> 00:03:27,089
shell with de but of course you
can create your own components with

54
00:03:27,089 --> 00:03:30,169
the extensible aspect of dapper.

55
00:03:30,669 --> 00:03:32,529
About the basis of dapper.

56
00:03:32,669 --> 00:03:38,949
First you have to understand that
dapper implements the sidecar pattern.

57
00:03:39,399 --> 00:03:43,599
That means that when you launch
your service automatically,

58
00:03:43,809 --> 00:03:49,589
dapper sidecar will come in live
just aside of your service and.

59
00:03:50,089 --> 00:03:55,759
With this side care partner, that means
that every interaction that you do outside

60
00:03:55,789 --> 00:03:58,219
of your service will be handled by dapper.

61
00:03:59,119 --> 00:04:03,709
That means that your code only
knows about dapper as an external

62
00:04:03,709 --> 00:04:05,629
dependencies, and that's.

63
00:04:06,229 --> 00:04:08,039
That's only that your call will know.

64
00:04:08,819 --> 00:04:12,869
For example, when you want to invoke
another service or you want to

65
00:04:12,869 --> 00:04:18,479
store some data in the database, you
will go through Dapper to perform

66
00:04:18,479 --> 00:04:20,169
this action and your call will.

67
00:04:20,599 --> 00:04:26,059
Your code will be agnostic from
the the technical implementation

68
00:04:26,149 --> 00:04:27,769
of the component and the end.

69
00:04:28,489 --> 00:04:30,559
For example, we have here two example.

70
00:04:31,189 --> 00:04:36,419
You can interact with Daer through H TT
P or GRPC, and the first example will

71
00:04:36,419 --> 00:04:41,249
tell Daer to store some data into the
state that you mentioned into the URL.

72
00:04:41,579 --> 00:04:42,574
So you tell the pro.

73
00:04:42,899 --> 00:04:47,799
To store the data and dapper will
take care of the implementation

74
00:04:47,799 --> 00:04:50,049
details of the database at the end.

75
00:04:50,559 --> 00:04:55,369
It depend, in fact it's everything
about configuration into dapper about

76
00:04:55,369 --> 00:04:57,049
the component you have at the end.

77
00:04:57,889 --> 00:05:00,799
The second example is service
to service invocation.

78
00:05:00,799 --> 00:05:06,379
So here the example it said that I
want to invoke the service, my app

79
00:05:06,499 --> 00:05:08,629
and the method new order in that.

80
00:05:09,609 --> 00:05:13,779
In that service, that's mean that
dapper will automatically perform a

81
00:05:13,779 --> 00:05:20,719
service discovery process and it'll
automatically also call that method in

82
00:05:20,719 --> 00:05:22,919
the right declared service into dapper.

83
00:05:23,419 --> 00:05:27,979
Like I said, you can use any languages
or framework you want with Dapper

84
00:05:27,979 --> 00:05:29,869
because it built on ER technology.

85
00:05:30,229 --> 00:05:35,899
And then you will call some H-T-T-P-A-P-I
or G-R-P-C-A-P-I to perform some

86
00:05:36,229 --> 00:05:42,169
external interaction that you could
needs to perform for you business logic.

87
00:05:42,169 --> 00:05:42,949
So you can do.

88
00:05:43,659 --> 00:05:47,619
Service to service, invocation,
state management, pop sub resource

89
00:05:47,619 --> 00:05:51,959
binding and triggers and actors
pattern if you want to distributed

90
00:05:51,959 --> 00:05:54,089
tracing and the secrets and so on.

91
00:05:54,589 --> 00:05:59,289
So what you need to keep in mind is
that dapper his a set cap pattern.

92
00:06:00,214 --> 00:06:04,844
And when you want to perform some
external operation, you will go

93
00:06:04,844 --> 00:06:06,764
through dapper to perform that action.

94
00:06:07,064 --> 00:06:12,874
So you code, your code will only focus on
the business aspects of your solutions.

95
00:06:13,624 --> 00:06:17,509
And everything else will be handled
by by dapper all the external Interac.

96
00:06:18,009 --> 00:06:20,859
So here is an example of the
sidecar model I just mentioned.

97
00:06:20,859 --> 00:06:26,969
So when you have one service, one
sidecar will appear just aside of your

98
00:06:26,969 --> 00:06:32,749
application, and then you will call
some API to perform some some action on

99
00:06:32,749 --> 00:06:38,269
the, so you can invoke another method
in another application you can store.

100
00:06:38,624 --> 00:06:43,939
Or retrieve some states stored in a
database that you configure into daper.

101
00:06:44,359 --> 00:06:48,079
You can publish a message, so you can
publish and receive messages with Daper,

102
00:06:48,859 --> 00:06:53,709
and you can retrieve some secrets that
are stored and handled by by dapper.

103
00:06:54,209 --> 00:07:00,949
For example here is a local example of
a very simple architecture with daper.

104
00:07:00,949 --> 00:07:06,799
So I have a service A and a service
B, and each of those services ha

105
00:07:06,849 --> 00:07:11,209
has a side car, a dapper sidecar
just aside of tool service.

106
00:07:11,989 --> 00:07:15,309
And then after that, I
will configure dapper.

107
00:07:15,809 --> 00:07:21,769
About the state store I want to use, or
the event broker I want to use, and so on.

108
00:07:21,769 --> 00:07:25,479
For example, for the state store,
you could use a DBE or Cosmo

109
00:07:25,479 --> 00:07:27,699
DB or Redis for the purpose.

110
00:07:27,879 --> 00:07:30,489
You could use Arabic MQ
service Boost what you want.

111
00:07:30,789 --> 00:07:38,319
So the implementation details is only
into the dapper configuration, but your

112
00:07:38,319 --> 00:07:41,049
service doesn't know about this detail.

113
00:07:41,549 --> 00:07:45,059
It only knows about how
to interact with dapper.

114
00:07:45,559 --> 00:07:49,789
And I can just show an example of of that.

115
00:07:50,289 --> 00:07:52,439
So we'll just switch to my vs.

116
00:07:52,439 --> 00:07:54,449
Code editor and then.

117
00:07:54,949 --> 00:08:01,010
Here I opened one of the repository
GitHub repository of Daper, which

118
00:08:01,010 --> 00:08:02,859
is the QuickStarter repository.

119
00:08:02,889 --> 00:08:09,709
And inside of it you have a lot of example
that you can reproduce for you solution.

120
00:08:10,209 --> 00:08:14,260
Here, what I will show you is
a very simple example so that

121
00:08:14,330 --> 00:08:16,100
you can understand how it works.

122
00:08:16,600 --> 00:08:19,470
For example, here I have
an not GS application.

123
00:08:19,530 --> 00:08:24,630
That not GS application expose a
very simple a i to get an order

124
00:08:24,630 --> 00:08:26,870
and to create here a new order.

125
00:08:27,370 --> 00:08:32,990
In for the application to get the
data, it'll store a new order and get

126
00:08:32,990 --> 00:08:35,690
a new order from a particular database.

127
00:08:36,050 --> 00:08:40,145
But here the application
doesn't know about the database.

128
00:08:40,655 --> 00:08:43,355
It only knows about Daper.

129
00:08:43,475 --> 00:08:47,885
So here with the URL, we will
use to store and retrieve.

130
00:08:48,385 --> 00:08:48,925
Do data.

131
00:08:49,265 --> 00:08:52,135
We are working locally,
so we will use local host.

132
00:08:52,525 --> 00:08:57,215
The DA Power is by
default 3000 and, oh no.

133
00:08:57,325 --> 00:09:00,380
3000, sorry, is for the
no GS application port.

134
00:09:00,890 --> 00:09:06,000
It'll use 3,500 ports for the
for the port for Daper, in fact.

135
00:09:06,180 --> 00:09:12,665
And then I will use here the statue RL
and I give to Daper a name of the state.

136
00:09:13,220 --> 00:09:19,300
That was configured for Daper so that he
will know that this particular database is

137
00:09:19,360 --> 00:09:26,080
tied to a particular name, and that's what
I will use in my code to store the data.

138
00:09:26,580 --> 00:09:27,840
In order to launch the.

139
00:09:28,340 --> 00:09:32,870
The application with dapper,
I will use the dapper CLI.

140
00:09:32,900 --> 00:09:37,820
So first you have to install the
dapper CLI in your local machine.

141
00:09:38,600 --> 00:09:41,000
Everything is explained
on the documentation.

142
00:09:41,080 --> 00:09:41,390
I will not.

143
00:09:42,100 --> 00:09:45,520
Deep dive into it because it,
it's really simple and everything

144
00:09:45,570 --> 00:09:46,860
is explained on the website.

145
00:09:47,490 --> 00:09:51,910
And then you have to launch the
dapper in it common line in order

146
00:09:51,910 --> 00:09:55,190
to install everything you need
on your local machine for dapper.

147
00:09:55,190 --> 00:09:57,550
So I've already done it in the past.

148
00:09:58,090 --> 00:10:04,480
So then when everything is set
up, you can use the Dapper Run.

149
00:10:04,690 --> 00:10:07,000
Command with the app ID option.

150
00:10:07,420 --> 00:10:13,140
This tells dapper what is your ID
of this particular service into

151
00:10:13,140 --> 00:10:15,380
your microservices ecosystem.

152
00:10:16,070 --> 00:10:18,980
And this ID should be unique
per service, of course.

153
00:10:19,480 --> 00:10:23,350
So here I will use the option
with the Node app value.

154
00:10:24,160 --> 00:10:27,960
The app is like I said 3000.

155
00:10:28,460 --> 00:10:32,560
And I will, just to be sure,
I will use this option to tell

156
00:10:32,560 --> 00:10:34,570
us which poor Daper will use.

157
00:10:35,110 --> 00:10:38,170
So Daper, HTT, PPOR.

158
00:10:38,670 --> 00:10:44,490
And at the end, I will just tell Daer
which command he need to use in order

159
00:10:44,490 --> 00:10:46,490
to launch my no just application.

160
00:10:46,490 --> 00:10:50,265
So to launch a no J application,
I will just use node.

161
00:10:50,765 --> 00:10:54,385
App es So this is the
command I need to use.

162
00:10:54,665 --> 00:10:58,065
I'm just not in the right
in the right folder.

163
00:10:58,215 --> 00:11:02,535
So let me just jump into the right folder.

164
00:11:03,075 --> 00:11:04,545
Hello world,

165
00:11:05,045 --> 00:11:05,700
and no.

166
00:11:06,200 --> 00:11:07,585
So I will just copy past.

167
00:11:08,085 --> 00:11:13,200
The common line, so dapper
run up Id upper and not ab Bs.

168
00:11:13,700 --> 00:11:17,370
When you launch that command
you have a lot of logs.

169
00:11:17,430 --> 00:11:21,900
In fact I will not go into everything,
but just to show you what the portal

170
00:11:21,900 --> 00:11:24,400
tells when you launch the runtime.

171
00:11:24,400 --> 00:11:28,650
So first you have in blue
the logs of your application.

172
00:11:28,650 --> 00:11:30,715
So for example, here I can see that my.

173
00:11:31,135 --> 00:11:35,595
Applications is correctly
running on the, on this port.

174
00:11:36,465 --> 00:11:43,265
And then about the dapper logs, you can
see that it's loading a lot of components.

175
00:11:43,265 --> 00:11:48,905
So the state store components here, we
have a Redis component, which will be

176
00:11:48,905 --> 00:11:51,845
used by the example to store my orders.

177
00:11:52,840 --> 00:11:56,980
What you need to know actually is when
you launch dapper the first time, it'll,

178
00:11:57,520 --> 00:12:02,660
when you launch an install dapper the
first time, it'll install some container

179
00:12:02,720 --> 00:12:08,505
images on your local machine, and it'll
in fact install a Redis container.

180
00:12:09,230 --> 00:12:10,450
In in your machine.

181
00:12:10,660 --> 00:12:15,190
And when you launch the dapper or
runtime, it'll automatically launch a

182
00:12:15,190 --> 00:12:20,890
new container, a new Redis container,
and that's what is configured by default.

183
00:12:21,040 --> 00:12:26,320
When you launch dapper and by default,
this will use the Redis State Store.

184
00:12:27,010 --> 00:12:31,860
So here is the component for the state
store, and by default, there is also

185
00:12:31,860 --> 00:12:34,440
another configuration into Daper for.

186
00:12:34,960 --> 00:12:35,980
Pop sub component.

187
00:12:35,980 --> 00:12:37,330
And this is also release.

188
00:12:37,960 --> 00:12:44,750
So if I check the log, I can see
that everything works correctly.

189
00:12:45,250 --> 00:12:51,620
Application discovered on this pro
not app, everything sh sounds okay.

190
00:12:52,010 --> 00:12:53,840
Daper initialized that you running.

191
00:12:53,870 --> 00:12:54,110
Okay.

192
00:12:54,500 --> 00:12:56,810
So apparently everything is good.

193
00:12:57,530 --> 00:12:58,760
I will just show you.

194
00:12:59,030 --> 00:13:00,830
Something else.

195
00:13:00,930 --> 00:13:03,900
Yeah, I will create a new terminal here.

196
00:13:04,860 --> 00:13:07,340
And what does that sample do is?

197
00:13:07,700 --> 00:13:11,780
So we have one microservices
in in in no gs, and we have

198
00:13:11,780 --> 00:13:14,000
another one in Python here.

199
00:13:14,690 --> 00:13:20,030
This Python is only a simple client
for the node node application.

200
00:13:20,825 --> 00:13:25,275
And it'll only create new
order in a loop infinitely.

201
00:13:25,395 --> 00:13:26,025
Indefinitely.

202
00:13:26,525 --> 00:13:32,255
And this will use Daper as a sidecar
for the patent application in order

203
00:13:32,255 --> 00:13:34,415
to call the nudges application.

204
00:13:34,415 --> 00:13:38,855
So the patent application
doesn't know or doesn't call

205
00:13:38,915 --> 00:13:40,895
directly the no G application.

206
00:13:41,375 --> 00:13:41,585
It'll.

207
00:13:42,215 --> 00:13:48,435
Only called dapper and dapper will
forward the request to the right service.

208
00:13:48,985 --> 00:13:52,255
I will launch that, that
that application too.

209
00:13:52,435 --> 00:13:52,825
So

210
00:13:53,325 --> 00:13:59,855
tutorial hello word,
Python, and also for Python.

211
00:14:00,005 --> 00:14:07,435
I will also use the Dapper Run app
id Python app, and then I will just

212
00:14:07,435 --> 00:14:11,885
tell Dapper which command will he
should use to launch the application.

213
00:14:12,245 --> 00:14:14,975
So Python app from pi.

214
00:14:15,475 --> 00:14:19,985
Like I said this is just an infinite
loop that call the API in no Gs.

215
00:14:20,285 --> 00:14:25,175
And then I can see that in my log from the
NO GS application, the Python application

216
00:14:25,205 --> 00:14:30,705
correctly reach the no GS application
to create new order in the loop.

217
00:14:30,915 --> 00:14:32,225
So that's really easy.

218
00:14:32,705 --> 00:14:38,705
So let, as you can see, my code is really
clean in term of external dependencies.

219
00:14:39,205 --> 00:14:43,425
I only use Daper with standard API.

220
00:14:43,425 --> 00:14:48,785
So here it's HTTP and when I want to
perform some external action service

221
00:14:48,785 --> 00:14:54,125
to service invocation State store for
the Knowledges application, I only use

222
00:14:54,275 --> 00:15:00,385
Daper and I don't know implementation
detail of my infrastructure dependencies.

223
00:15:00,885 --> 00:15:07,420
Okay, so I will just stop this and
then we can go again to the slide.

224
00:15:07,920 --> 00:15:12,480
This is just a recap of
the the demo I just showed.

225
00:15:13,110 --> 00:15:16,970
So we have a frontend application
and a backend application.

226
00:15:16,970 --> 00:15:23,725
Both has their own side card app and
when I want to invoke one service from.

227
00:15:24,410 --> 00:15:26,260
From the first microservice.

228
00:15:26,260 --> 00:15:32,800
So for example, the front end I call
dapper through a standard a PA, and then

229
00:15:32,800 --> 00:15:37,160
dapper will automatically forward the
request to the right microservice behind.

230
00:15:38,130 --> 00:15:40,285
That's how the service invocation works.

231
00:15:40,785 --> 00:15:41,355
Of course.

232
00:15:41,415 --> 00:15:46,170
At the end, the ultimate goal is
to deploy in production DAPER.

233
00:15:46,530 --> 00:15:50,100
And then the recommended
way is to use Kubernetes.

234
00:15:50,760 --> 00:15:55,660
So when you initialize DAPER on
Kubernetes, it'll install four

235
00:15:55,850 --> 00:15:59,010
system pods into Kubernetes.

236
00:15:59,525 --> 00:16:00,415
So I won't go.

237
00:16:01,105 --> 00:16:06,205
In deep details into each pod because it's
well explained into the documentation and

238
00:16:06,595 --> 00:16:11,355
it's not the the goal of this session,
but you have the actor placement pod.

239
00:16:11,355 --> 00:16:13,845
The sidecar injector po the century.

240
00:16:14,175 --> 00:16:16,515
This is for security and operator.

241
00:16:16,695 --> 00:16:22,005
For example, the sidecar injector
will handle all the injection of

242
00:16:22,095 --> 00:16:24,280
the sidecar pattern into each po.

243
00:16:24,940 --> 00:16:28,370
Of of your microservices architecture.

244
00:16:28,370 --> 00:16:31,650
So each each container that he's deployed.

245
00:16:32,150 --> 00:16:33,140
Into Kubernetes.

246
00:16:33,800 --> 00:16:39,980
It'll be added to a pod, and that pod
will have a new sidecar instantiated

247
00:16:40,070 --> 00:16:42,260
into the pod with your container.

248
00:16:42,530 --> 00:16:46,710
And then when you have this setup
you just have to configure Daper

249
00:16:46,710 --> 00:16:48,350
like you will do in the local mode.

250
00:16:48,710 --> 00:16:50,200
You configure Daper to tell.

251
00:16:50,655 --> 00:16:53,925
Which infrastructure component
you want to use for the resource

252
00:16:53,925 --> 00:16:58,815
binding state store and so on, and
you code into your microservice.

253
00:16:59,335 --> 00:17:02,095
We only talk to dapper into your cluster.

254
00:17:02,635 --> 00:17:06,235
In order to perform some
external external operation.

255
00:17:06,735 --> 00:17:10,415
And then with that architecture,
you can deploy Daper and your

256
00:17:10,415 --> 00:17:12,270
service everywhere you want.

257
00:17:12,690 --> 00:17:17,340
It could be Azure, double ES, or
on the Edge OnPrem as you want.

258
00:17:17,840 --> 00:17:19,530
So about dapper components.

259
00:17:19,580 --> 00:17:24,030
So we have plenty of component for
each category that dapper supports.

260
00:17:24,530 --> 00:17:31,010
The configuration is done through ML
file files, and you will put here every

261
00:17:31,010 --> 00:17:36,760
details, in fact, every implementation,
details that dapper needs to needs to

262
00:17:36,860 --> 00:17:39,440
to get to connect to those components.

263
00:17:39,440 --> 00:17:44,120
So you have a dedicated DML file
for state store, for purpose

264
00:17:44,270 --> 00:17:46,670
broker, binding SE store, and so on.

265
00:17:47,090 --> 00:17:53,180
And for example, for State store, if
you choose A SDW db you have one YML

266
00:17:53,180 --> 00:17:59,120
file that will handle or will get all
the connection details to in order in

267
00:17:59,120 --> 00:18:01,760
order for Daer to connect to that db.

268
00:18:02,715 --> 00:18:08,015
It's the exact same principle for
everything about daper components.

269
00:18:08,515 --> 00:18:11,740
Here is an example of a
pop pattern with Daper.

270
00:18:11,740 --> 00:18:14,820
So here I have three microservices.

271
00:18:15,560 --> 00:18:21,170
That needs to exchange messages
between those microservices.

272
00:18:21,560 --> 00:18:26,830
So first on the left, your application
will post a new message or publish

273
00:18:26,830 --> 00:18:29,025
a new message here to Daper.

274
00:18:29,600 --> 00:18:31,040
Daper will forward.

275
00:18:31,820 --> 00:18:38,040
The message to the correct broker
that is configured with the YAML file.

276
00:18:38,120 --> 00:18:43,310
So here is, it's already c
and then all the service that

277
00:18:43,410 --> 00:18:45,300
listen to that particular.

278
00:18:46,105 --> 00:18:47,785
Topic will get the message.

279
00:18:48,455 --> 00:18:54,895
How it works is in that way your service
a b will expose an a p that Daper will

280
00:18:54,955 --> 00:19:00,365
call when he when he when it receive
a new message that, how it works.

281
00:19:00,755 --> 00:19:06,525
So it'll push a message to a
particular API declared in in taper.

282
00:19:07,025 --> 00:19:11,425
For the telemetry, it's mostly
the same the same principle.

283
00:19:11,605 --> 00:19:15,625
So dapper implements the
open telemetry standard.

284
00:19:15,745 --> 00:19:21,535
So all the tools that that
implement that standard a site,

285
00:19:21,560 --> 00:19:23,555
Datadog premises and so on.

286
00:19:24,385 --> 00:19:26,725
You can use any component you want.

287
00:19:27,505 --> 00:19:30,145
Link it, linked it to to Daper.

288
00:19:30,645 --> 00:19:36,505
And you can just, in your application
log what you want in your call, in your

289
00:19:36,505 --> 00:19:41,215
code, and DAPER will gather the log
and send it automatically to your tool.

290
00:19:41,275 --> 00:19:46,115
So it's and then with that principle,
you can change the tool whenever

291
00:19:46,115 --> 00:19:49,475
you want, because you have that
standard open telemetry in the middle.

292
00:19:49,975 --> 00:19:53,845
Just to finish this session,
just a reminder about the

293
00:19:53,845 --> 00:19:55,885
projects in the CNCF context.

294
00:19:55,895 --> 00:20:01,845
DAPER was accepted as a graduated
CNCF project in November, 2024.

295
00:20:02,145 --> 00:20:06,705
And as you can see, the community
is very big and a lot of big

296
00:20:06,705 --> 00:20:08,775
company already added this.

297
00:20:08,990 --> 00:20:13,640
Technology in their stacks and
already using it in production.

298
00:20:13,670 --> 00:20:20,280
So it's a very big project today
and very solid and reliable in

299
00:20:20,280 --> 00:20:22,280
term of cloud deployment today.

300
00:20:22,780 --> 00:20:26,650
If you have any question or
feedbacks, don't hesitate to reach me.

301
00:20:27,040 --> 00:20:28,750
On Blue Sky or on LinkedIn.

302
00:20:29,250 --> 00:20:34,600
I'm very open to, to question about
dapper and I really encourage you

303
00:20:34,600 --> 00:20:40,350
to check the GitHub repository
and the community around dapper.

304
00:20:41,090 --> 00:20:46,470
And why not make some contribution
or use it in production for

305
00:20:46,470 --> 00:20:48,150
your microservices architecture.

306
00:20:48,810 --> 00:20:50,970
Thank you for watching
and have a nice day.

307
00:20:51,030 --> 00:20:51,450
Thank you.

