1
00:00:00,000 --> 00:00:00,840
Hey everyone.

2
00:00:01,140 --> 00:00:05,190
Welcome to Com 42 site Reliability
Engineering conference.

3
00:00:05,250 --> 00:00:09,570
My name is Peter Deten and I'm gonna
walk you through Azure Load Testing.

4
00:00:09,690 --> 00:00:13,350
Now, before diving into the actual
topic, let me share a bit about myself.

5
00:00:13,710 --> 00:00:18,180
So Peter Deten, originally from Belgium,
but moved to the Redmond area about

6
00:00:18,180 --> 00:00:23,460
three years ago, where I'm working as a
Microsoft technical trainer at Microsoft.

7
00:00:24,195 --> 00:00:28,305
I think it's still one of the easiest
job titles within Microsoft, because

8
00:00:28,305 --> 00:00:33,345
what I'm doing is providing technical
training on our Microsoft Azure platform,

9
00:00:33,345 --> 00:00:39,465
primarily to our top customers across
the globe using virtual online workshops.

10
00:00:39,965 --> 00:00:44,645
My career started about 30 years ago
as a physical technical engineer,

11
00:00:44,645 --> 00:00:48,395
literally building physical data
centers, the cabling, the cooling.

12
00:00:48,755 --> 00:00:53,885
And then gradually, as part of my career
moved up the solution stack, you could

13
00:00:53,885 --> 00:00:58,985
say, all the way from that physical data
center, networking, storage servers,

14
00:00:59,225 --> 00:01:04,595
and then gradually moving up to cloud,
where around 2013, picked up Azure for

15
00:01:04,595 --> 00:01:09,125
the full a hundred percent, and then
moved a bit from cloud engineering to

16
00:01:09,125 --> 00:01:13,625
cloud, architecting a lot of DevOps
automation and gradually developing

17
00:01:13,625 --> 00:01:15,425
N AI over the last three years.

18
00:01:15,980 --> 00:01:20,000
You got all my contact details here,
and feel free, I would say to reach

19
00:01:20,000 --> 00:01:23,539
out if you should have any questions
while watching the session, or

20
00:01:23,539 --> 00:01:27,380
obviously if you're watching this
later on as a recording, then more than

21
00:01:27,380 --> 00:01:29,420
happy to provide you with an answer.

22
00:01:29,510 --> 00:01:35,179
Now, the starting point is what is
SRE right now, knowing that the core

23
00:01:35,570 --> 00:01:39,980
topic of the conference today is all
about site reliability, engineering.

24
00:01:40,355 --> 00:01:43,325
Now, where does my Azure load testing fit?

25
00:01:43,745 --> 00:01:47,855
So to me, SRE, if you think about
what you're doing, and again, don't

26
00:01:47,855 --> 00:01:51,695
feel personally attacked about this,
it might be totally different in your

27
00:01:51,695 --> 00:01:56,585
case, but to me, site reliability
engineering means you gonna spend a

28
00:01:56,585 --> 00:01:59,465
huge amount of time on stress testing.

29
00:02:00,095 --> 00:02:01,145
Why stress testing?

30
00:02:01,145 --> 00:02:06,425
Because your goal as an SRE is making
sure that your environment, your workload.

31
00:02:06,845 --> 00:02:11,285
Within Azure, outside of Azure, AWS,
Google Cloud on-prem, not important.

32
00:02:11,285 --> 00:02:15,245
Where the workload is running,
your goal is making it as high

33
00:02:15,245 --> 00:02:17,195
available, redundant as possible.

34
00:02:17,555 --> 00:02:22,594
The way to do that is typically hammering
your environment using low testing.

35
00:02:22,925 --> 00:02:27,274
So to be the perfect example to
talk about low testing in Azure

36
00:02:28,175 --> 00:02:30,065
as part of the SRE conference.

37
00:02:30,485 --> 00:02:31,834
So what is low testing?

38
00:02:31,834 --> 00:02:32,495
First of all?

39
00:02:33,185 --> 00:02:37,784
This is a sort of, I think formal
definition that I found online.

40
00:02:38,174 --> 00:02:42,194
Load testing is a type of performance
testing that determines the

41
00:02:42,194 --> 00:02:46,754
performance of a system, a software,
an application, or a full workload if

42
00:02:46,754 --> 00:02:49,124
you want under, and that's important.

43
00:02:49,394 --> 00:02:54,404
Real life, real workload based
load conditions, which typically

44
00:02:54,404 --> 00:02:56,114
would be the number of users.

45
00:02:56,489 --> 00:02:59,549
Number of sessions, maybe
the amount of traffic.

46
00:02:59,759 --> 00:03:04,439
If you have a lot of streaming data,
like a Netflix maybe, or something

47
00:03:04,439 --> 00:03:09,179
similar streaming media, where all of
a sudden the traffic could become more

48
00:03:09,179 --> 00:03:11,639
important than actual number of users.

49
00:03:12,539 --> 00:03:15,749
From here, we move into
Azure load testing.

50
00:03:16,499 --> 00:03:20,459
So obviously the assumption here is
that you're gonna run your workload.

51
00:03:20,819 --> 00:03:25,679
On top of the Azure platform, where
now we have a service in the platform,

52
00:03:25,679 --> 00:03:28,259
managed service called Azure Load Testing.

53
00:03:28,289 --> 00:03:32,669
Yes, every now and then Azure
service names actually do make sense.

54
00:03:33,149 --> 00:03:38,639
Azure load testing is a managed service
that can be used to, again, simulate load.

55
00:03:39,449 --> 00:03:43,439
Preferably, I would say you're gonna run
this against your production environment

56
00:03:43,709 --> 00:03:48,959
or even more so you're gonna run this in
your test acceptance staging environment.

57
00:03:49,484 --> 00:03:53,554
Because you don't want to impact your
production all the way from there,

58
00:03:53,554 --> 00:03:58,654
you're gonna target application user
interface, like an app service, a

59
00:03:58,654 --> 00:04:00,784
web application or a virtual machine.

60
00:04:01,264 --> 00:04:03,574
And why not API Endpoints?

61
00:04:03,724 --> 00:04:09,124
As long as you can target you,
your backend using A-C-T-P-S,

62
00:04:09,124 --> 00:04:10,894
you're actually good to go.

63
00:04:11,854 --> 00:04:14,704
Now there's one part two testing,
like going in the portal.

64
00:04:15,439 --> 00:04:16,099
No surprise.

65
00:04:16,099 --> 00:04:20,469
I'm gonna walk you through some
live demos there where we have

66
00:04:20,469 --> 00:04:21,789
an application up and running.

67
00:04:22,029 --> 00:04:26,319
You're gonna integrate Azure load testing,
you're gonna use the Azure portal for now.

68
00:04:26,409 --> 00:04:28,779
You're gonna click around and
then you're gonna build your test.

69
00:04:29,274 --> 00:04:33,774
But that's like a one-time shot
or a manual shot out of SRE.

70
00:04:33,864 --> 00:04:39,144
I guess we can all agree that a big part
of your job is also automating your tasks.

71
00:04:39,264 --> 00:04:42,174
So that's where the second bullet
point becomes quite important.

72
00:04:42,594 --> 00:04:45,864
You're gonna build your tests
initially manual and then gradually

73
00:04:45,864 --> 00:04:47,694
automating the whole process.

74
00:04:47,904 --> 00:04:51,804
And the good news is you can
run trigger Azure load testing

75
00:04:52,284 --> 00:04:54,294
as part of your CICD pipelines.

76
00:04:54,794 --> 00:04:58,484
A lot of flexibility where you're gonna
define test criteria, and I'll show

77
00:04:58,484 --> 00:05:00,254
you again in a demo how that works.

78
00:05:00,344 --> 00:05:05,264
And then also crucial to mention here
is that initially, two years ago,

79
00:05:05,654 --> 00:05:10,514
low testing in Azure was based on the
Apache Open Source J Meter framework.

80
00:05:11,174 --> 00:05:15,584
In meantime, it also supports Locust
where you're gonna hear about some

81
00:05:15,584 --> 00:05:17,864
differences between the both scenarios.

82
00:05:18,254 --> 00:05:21,374
But the cool thing is you
manage the Azure environment.

83
00:05:21,434 --> 00:05:25,994
You're gonna bring in one of the two
options to really configure your testing.

84
00:05:26,494 --> 00:05:30,994
Next to that, what do we need as
part of our load testing definitions?

85
00:05:31,234 --> 00:05:33,454
I call this here, the
load testing components.

86
00:05:33,934 --> 00:05:37,834
You need a load testing resource,
literally a top level resource

87
00:05:37,834 --> 00:05:41,194
providing you centralized
place to view your testing.

88
00:05:41,494 --> 00:05:46,204
What it means is go to Azure load testing
as the service, and that's becoming your

89
00:05:46,204 --> 00:05:48,604
dashboard for all testing scenarios.

90
00:05:49,234 --> 00:05:52,234
Next to that, obviously you need
a test, you need a test run.

91
00:05:52,594 --> 00:05:54,904
A test means it's a technical definition.

92
00:05:54,964 --> 00:05:56,674
The run means we actually gonna.

93
00:05:57,604 --> 00:05:58,744
Execute the test.

94
00:05:59,404 --> 00:06:03,094
The test engine is the compute
infrastructure in the backend.

95
00:06:03,124 --> 00:06:05,134
This could be your target instance.

96
00:06:05,464 --> 00:06:07,924
And then last, you need
an application component.

97
00:06:08,044 --> 00:06:12,874
Again, any possible HCTP, htt,
PS reachable backend from within

98
00:06:12,874 --> 00:06:14,944
Azure would be a possible scenario.

99
00:06:15,444 --> 00:06:18,594
Next, we have load testing test itself.

100
00:06:18,684 --> 00:06:20,814
So again, URL based is one option.

101
00:06:20,814 --> 00:06:22,254
The easiest one I'll show you.

102
00:06:22,599 --> 00:06:26,769
As the starting point of my demo,
give me your RL and I'm gonna simulate

103
00:06:26,769 --> 00:06:31,129
testing, obviously not anything that's
running outside of your control.

104
00:06:31,999 --> 00:06:36,289
Second option to maybe make it a little
bit more standardized or maybe even a

105
00:06:36,289 --> 00:06:41,239
bit more advanced if you want, is using
that Apache J meter testing script.

106
00:06:41,509 --> 00:06:46,729
You're gonna build your testing typically
offline, not really using the Azure.

107
00:06:47,059 --> 00:06:49,039
Portal anymore, or why not?

108
00:06:49,069 --> 00:06:53,239
Maybe you have a mixed environment across
different clouds, but also on-prem.

109
00:06:53,509 --> 00:06:55,999
But now you're gonna rely
on that JMeter framework.

110
00:06:56,569 --> 00:07:00,019
Now, the JMeter framework has
some specific characteristics

111
00:07:00,019 --> 00:07:02,149
to it, like the GMX files.

112
00:07:02,149 --> 00:07:07,069
You need like A XML YAML
alike scenario where you.

113
00:07:07,654 --> 00:07:11,404
You gonna provide all the elements
like the controllers, the timing

114
00:07:11,754 --> 00:07:14,844
the assumptions as assertations
and listeners that you wanna

115
00:07:14,844 --> 00:07:16,404
use as part of your testing.

116
00:07:17,364 --> 00:07:22,364
Now the second option, or the third
actually, is using Locust as a, I would

117
00:07:22,364 --> 00:07:24,854
say, popular testing framework as well.

118
00:07:25,424 --> 00:07:28,934
The big difference between J Meter
and Locus is obviously it's not an

119
00:07:28,934 --> 00:07:32,984
Apache framework, but next to that
it also relies on Python and coating.

120
00:07:33,794 --> 00:07:35,744
Instead of the GMX files.

121
00:07:35,774 --> 00:07:38,504
So same concept, slightly
different framework.

122
00:07:38,564 --> 00:07:40,094
That's the summarization of it.

123
00:07:40,964 --> 00:07:45,764
And then what I also mentioned during
the introduction is now we have our

124
00:07:45,764 --> 00:07:47,324
tests and we're gonna automate it.

125
00:07:47,534 --> 00:07:51,674
Where the good news is that at least out
of the Microsoft DevOps solutions, which

126
00:07:51,674 --> 00:07:57,994
means Azure DevOps, or GitHub actions,
you can integrate your Azure load testing.

127
00:07:58,369 --> 00:08:02,819
Scenarios as part of an already
pre-built marketplace component.

128
00:08:03,449 --> 00:08:08,069
You build your pipelines in the exact
same way as you already have CI or cd.

129
00:08:08,069 --> 00:08:09,179
Why not combining?

130
00:08:09,629 --> 00:08:13,109
And in Azure DevOps, you're gonna
bring in a pre-built marketplace

131
00:08:13,109 --> 00:08:17,939
component called Azure Load Test if
you're no longer using Azure DevOps.

132
00:08:17,969 --> 00:08:20,339
But it's all happening on the GitHub side.

133
00:08:20,729 --> 00:08:22,709
That's where you're gonna
bring in GitHub actions.

134
00:08:22,769 --> 00:08:24,479
And again, no surprise, you have.

135
00:08:24,944 --> 00:08:30,554
A GitHub actions marketplace component
called Azure Forward slash Load Testing,

136
00:08:30,734 --> 00:08:32,684
and for now it's still version one.

137
00:08:33,314 --> 00:08:36,094
And then you go okay, Peter
we're not using Azure DevOps,

138
00:08:36,094 --> 00:08:38,344
we're not using GitHub actions.

139
00:08:38,884 --> 00:08:39,994
What are the options?

140
00:08:40,024 --> 00:08:43,984
Good news is since Azure load
testing is just another service.

141
00:08:44,345 --> 00:08:48,515
In the Azure platform, it means you
can target it, you can trigger it

142
00:08:48,694 --> 00:08:51,395
using traditional rest API comps.

143
00:08:51,755 --> 00:08:55,835
I might not have enough time in this
session to show you all three options.

144
00:08:56,285 --> 00:09:00,334
But at least I'm gonna shift to
the next part, and that's really

145
00:09:00,334 --> 00:09:02,765
showing you how all this works.

146
00:09:02,944 --> 00:09:05,344
I'm gonna start with
deploying load testing.

147
00:09:05,525 --> 00:09:09,425
I'm gonna show you one of my sample
backends at just a web app, and

148
00:09:09,425 --> 00:09:13,805
then from there, triggering a manual
test or configuring and triggering a

149
00:09:13,805 --> 00:09:19,145
manual test showing you the J meter
option as well as the locust framework

150
00:09:19,324 --> 00:09:21,275
to give you some touching points.

151
00:09:21,425 --> 00:09:24,964
And then again, if time allows, I'm gonna
show you how you could integrate it.

152
00:09:25,155 --> 00:09:28,635
As part of your DevOps
solutions, see you back in a bit.

153
00:09:29,135 --> 00:09:34,955
So here I'm in my Azure portal where
I'm gonna use the Azure load testing.

154
00:09:35,135 --> 00:09:38,465
Now again, I call this a managed
service, which means you don't

155
00:09:38,465 --> 00:09:39,935
have to install anything.

156
00:09:39,965 --> 00:09:43,055
It's already available within
your Azure environment.

157
00:09:43,555 --> 00:09:46,435
You could obviously create a
new load testing from here.

158
00:09:46,435 --> 00:09:50,455
But to speed up the demo a little bit, I'm
going to use the one that I already have.

159
00:09:51,240 --> 00:09:54,960
If you're a bit into Azure, which
I assume you are, it just like any

160
00:09:54,960 --> 00:09:58,440
other Azure resource, you define
the location, you provide a name,

161
00:09:58,470 --> 00:10:00,720
a resource group, and off you go.

162
00:10:01,290 --> 00:10:03,300
So that's mainly what I did here.

163
00:10:03,800 --> 00:10:08,240
Once we have our load testing service
configured, that's where we're

164
00:10:08,240 --> 00:10:10,520
gonna use some of its capabilities.

165
00:10:11,060 --> 00:10:13,790
You can start with a couple
of different scenarios.

166
00:10:13,790 --> 00:10:19,220
The first one I'll use is over here
where I'm gonna add HCTP requests.

167
00:10:19,730 --> 00:10:23,360
So I'm gonna select, create a
new test, and this is now what

168
00:10:23,360 --> 00:10:25,700
we call the URL based test.

169
00:10:26,210 --> 00:10:29,300
I can provide a name, I'm just
gonna accept the defaults, or

170
00:10:29,330 --> 00:10:36,000
let's call this one the live URL
Test A description live URL Test.

171
00:10:36,060 --> 00:10:37,080
How hard can it be?

172
00:10:37,560 --> 00:10:42,000
Run the test right after creation
and if you want, you can see here

173
00:10:42,000 --> 00:10:43,800
debuting mode, which gonna give you.

174
00:10:44,715 --> 00:10:46,785
Access to debug logging.

175
00:10:46,785 --> 00:10:50,025
If a test is running but it's failing,
it's not doing what it needs to do,

176
00:10:50,685 --> 00:10:52,855
then I would say please enable this.

177
00:10:53,725 --> 00:10:58,255
Enable advanced settings is just gonna
give you access to more options down here.

178
00:10:59,185 --> 00:11:00,835
Let's move on to the next step.

179
00:11:01,105 --> 00:11:04,765
I'm gonna add a new request, and again,
later on, if this is no longer the

180
00:11:04,765 --> 00:11:09,355
first test you're creating or you know
how the Apache framework is working,

181
00:11:09,715 --> 00:11:11,605
then you could also start from it.

182
00:11:12,005 --> 00:11:14,725
Input data input data file.

183
00:11:15,595 --> 00:11:17,425
I'm gonna create a new request.

184
00:11:17,875 --> 00:11:21,385
I'm gonna accept all the defaults because
it's not all that important for now.

185
00:11:21,715 --> 00:11:23,965
And I'm gonna use input in a ui.

186
00:11:24,055 --> 00:11:26,245
What this means is my request name.

187
00:11:26,245 --> 00:11:33,465
So this would be let's say
homepage, HTTP get, and my URL is.

188
00:11:33,965 --> 00:11:41,215
My website, I'm gonna use my production
blog website, oh seven fff learning.com,

189
00:11:41,715 --> 00:11:43,665
and what is the A CTP method.

190
00:11:44,235 --> 00:11:48,645
Now, from here, I'm gonna take a
minute to highlight a few things.

191
00:11:49,275 --> 00:11:51,435
Right here I'm connecting to the homepage.

192
00:11:51,525 --> 00:11:55,875
Now if, let's say your homepage
is your product retail catalog, or

193
00:11:55,875 --> 00:11:57,765
my, in my case, my blog website.

194
00:11:58,680 --> 00:12:01,920
It might all be fine, but what
if I wanna go to a lower level?

195
00:12:02,099 --> 00:12:04,890
Then from here you could
actually add the subset.

196
00:12:04,890 --> 00:12:08,760
Like in my case, I have a section
on my blog that talks about the

197
00:12:08,760 --> 00:12:10,290
books that I wrote in the past.

198
00:12:11,040 --> 00:12:16,260
And I wanna run a test against my
book subsection and not the homepage.

199
00:12:16,760 --> 00:12:20,480
From here, I could move on
like the default would be a get

200
00:12:20,690 --> 00:12:25,070
comment, but as you can see, we're
respecting all rest API codes.

201
00:12:25,670 --> 00:12:29,210
Imagine you have, again, like a
product retail, you wanna test

202
00:12:29,570 --> 00:12:33,530
the performance impact when you're
uploading products, when you're

203
00:12:33,530 --> 00:12:37,670
ordering products, when you trigger a
payment, when you're making changes.

204
00:12:38,345 --> 00:12:39,575
To decide and so on.

205
00:12:39,605 --> 00:12:44,435
That's what you can define here, but
I'm not gonna make it that complex in

206
00:12:44,435 --> 00:12:50,885
my demo scenario, so I'm gonna trigger,
again, you can fine tune query parameters,

207
00:12:50,915 --> 00:12:53,135
like injecting specific variables.

208
00:12:53,435 --> 00:12:57,635
You can tune the headers and maybe
even looking into response variables.

209
00:12:58,205 --> 00:13:00,065
Again, just showing you the options.

210
00:13:00,095 --> 00:13:04,655
What are all the capabilities, and we
can make this super straightforward.

211
00:13:05,155 --> 00:13:07,615
Super easy or rather complex.

212
00:13:08,115 --> 00:13:10,875
Nothing blocks you from
combining multiple tests.

213
00:13:10,875 --> 00:13:17,765
So I could do second URL request, where
now I could go back to the same endpoint

214
00:13:17,915 --> 00:13:21,195
or why not going to a different endpoint.

215
00:13:21,645 --> 00:13:27,485
So this could be my sample, Azure
web app, azure websites.net.

216
00:13:27,980 --> 00:13:32,795
'cause what if my website homepage
has dependencies on websites and

217
00:13:32,795 --> 00:13:38,505
again, using some other URL rest
API call here and then building up

218
00:13:38,595 --> 00:13:41,235
a flow of tests on the request site.

219
00:13:41,265 --> 00:13:43,635
It's gonna run the first
request, the second or third,

220
00:13:43,815 --> 00:13:45,375
how many you want to add into it.

221
00:13:45,375 --> 00:13:46,185
That's up to you.

222
00:13:46,685 --> 00:13:50,250
Clicking next onto the next cycle
where we can define different

223
00:13:50,250 --> 00:13:54,910
parameters, environment variables,
hopefully pretty obvious based on a

224
00:13:54,910 --> 00:14:00,130
variable, this could be dev and test
staging production using secrets.

225
00:14:00,130 --> 00:14:03,910
Imagine that you wanna connect, like
again, the retail example I mentioned.

226
00:14:04,300 --> 00:14:08,020
Maybe you wanna connect to a database,
you wanna interact with Key Vault, you

227
00:14:08,020 --> 00:14:09,970
want to interact with connection strings.

228
00:14:10,300 --> 00:14:13,510
You can define it here, and
obviously the same for certificates.

229
00:14:14,010 --> 00:14:17,435
If you interact with Key
Vault, our Azure Secret Store.

230
00:14:17,960 --> 00:14:23,420
The idea is obviously that your testing
framework, your running test now also

231
00:14:23,420 --> 00:14:27,890
needs permissions to interact with
key vault, and that's what down here.

232
00:14:28,100 --> 00:14:31,070
We're preferably following
Microsoft best practice.

233
00:14:31,670 --> 00:14:35,940
We're expecting you to
define managed identity.

234
00:14:36,900 --> 00:14:40,620
Define role-based access
for this specific test.

235
00:14:40,620 --> 00:14:45,270
Getting the necessary permissions to
hook can to key vault at the same time.

236
00:14:45,270 --> 00:14:50,670
It's not only locking down permissions,
but it's also defining them in a granular,

237
00:14:51,420 --> 00:14:53,550
zero trust approach, you could say.

238
00:14:54,420 --> 00:14:58,770
Moving on to the next, that's where we're
gonna define the actual load simulation.

239
00:14:59,270 --> 00:15:03,800
Number of instances, like how many
simulations, but also how much

240
00:15:03,860 --> 00:15:07,820
compute, and that's where the scaling
details here would be beneficial.

241
00:15:08,690 --> 00:15:14,240
Each and every engine allows you
to run up to 250 user sessions.

242
00:15:14,570 --> 00:15:19,790
So if you have I wanna simulate thousand
users, it means you need four instances.

243
00:15:20,330 --> 00:15:23,990
I'm quite limited, although technically
I could move this up, but my

244
00:15:23,990 --> 00:15:26,120
subscription doesn't allow me to do this.

245
00:15:26,795 --> 00:15:28,175
Physically or technically.

246
00:15:28,445 --> 00:15:30,335
So I'm gonna stay with two.

247
00:15:30,785 --> 00:15:34,325
I'm gonna move up my numbers to 350.

248
00:15:34,825 --> 00:15:37,255
When now it tells my go, wait
a minute, it can only be two

249
00:15:37,255 --> 00:15:39,385
50, so that's a bit confusing.

250
00:15:39,835 --> 00:15:42,385
Two 50 here means two instances.

251
00:15:42,385 --> 00:15:44,815
I'm still gonna simulate 500 users.

252
00:15:44,935 --> 00:15:47,965
So just trying to clarify
the portal a little bit.

253
00:15:48,775 --> 00:15:50,185
I want linear growth.

254
00:15:50,185 --> 00:15:54,535
I want a step by step growth, and you
can see that the parameters are changing.

255
00:15:54,805 --> 00:16:00,085
And you could also simulate Spike
where we start with 250 concurrent

256
00:16:00,085 --> 00:16:06,955
users and then gradually spiking like
a simulating, literally a CPU spike.

257
00:16:07,345 --> 00:16:12,745
Or a user spike, like we got more users
coming in because we offer like some

258
00:16:12,745 --> 00:16:17,935
online food ordering platform, and it's
between six and seven we see a spike For

259
00:16:17,935 --> 00:16:23,335
breakfast, it's between 1130 and one, we
see a spike for lunch ordering coming in.

260
00:16:23,695 --> 00:16:26,005
That's the scenario you
could simulate here.

261
00:16:26,545 --> 00:16:29,935
I'm gonna keep the default of linear
and that should be good enough.

262
00:16:30,835 --> 00:16:32,875
Do you want to integrate monitoring?

263
00:16:33,460 --> 00:16:37,090
What this means here is that we
provide you monitoring dashboard,

264
00:16:37,420 --> 00:16:41,030
but now you could actually hook
into other Azure scenarios.

265
00:16:41,450 --> 00:16:45,260
You could use application insights,
storing data in there, you could

266
00:16:45,260 --> 00:16:48,170
configure some other options
and you can see it from here.

267
00:16:48,670 --> 00:16:54,400
Moving on, where now we can define
even more specific test criteria.

268
00:16:54,790 --> 00:16:57,910
You can define the conditions, like if.

269
00:16:58,435 --> 00:17:02,215
For this specific metric, like
response time, there's an aggregation.

270
00:17:02,215 --> 00:17:04,675
If the condition is
true, do this, do that.

271
00:17:04,675 --> 00:17:09,925
So again, showing you more options,
more granular configuration parameters.

272
00:17:10,375 --> 00:17:12,955
The baseline technically
would be the same thing.

273
00:17:13,825 --> 00:17:18,175
All that summarized in the last
overview, and we're gonna create our

274
00:17:18,175 --> 00:17:24,475
test now, although I started from the
A-C-T-P-U-R-L based, you can see that now.

275
00:17:24,895 --> 00:17:27,895
By design, it's using a JMeter script.

276
00:17:28,315 --> 00:17:31,285
What it's technically doing
here is transforming all my

277
00:17:31,285 --> 00:17:35,785
settings from the portal into
that JMeter framework language.

278
00:17:36,745 --> 00:17:41,115
It's gonna take a couple of seconds
to actually create a test, and

279
00:17:41,115 --> 00:17:45,435
once it's done, we're gonna move
over and we have our testing ready.

280
00:17:46,065 --> 00:17:51,335
So to speed up my demo again a little
bit, I already have one from two days ago.

281
00:17:51,605 --> 00:17:52,835
As you can see here.

282
00:17:53,225 --> 00:17:56,225
I got my test, I got
all my scheduling done.

283
00:17:56,435 --> 00:18:01,405
I'm not scheduling anything, but that
could be another SRE trick here to

284
00:18:01,645 --> 00:18:06,235
build a test, run a test, but then also
scheduling the test, run this every

285
00:18:06,235 --> 00:18:08,635
hour, run this overnight and whatnot.

286
00:18:09,085 --> 00:18:12,685
And then last here, we are
gonna run our test itself.

287
00:18:13,185 --> 00:18:16,665
When we run the test, this is
already done because it's gonna

288
00:18:16,665 --> 00:18:20,175
typically take five minutes, 20
minutes, depending on the timeline

289
00:18:20,175 --> 00:18:22,215
of the testing you wanna go through.

290
00:18:22,695 --> 00:18:25,905
This was a pretty short one, only two
minutes because I don't want to wait

291
00:18:25,905 --> 00:18:27,945
for it to just show you some results.

292
00:18:27,995 --> 00:18:31,685
And what it gives me here is
that linear growth, so this one

293
00:18:31,685 --> 00:18:36,635
was a bit smaller, move up to 50
users, start small, gradually.

294
00:18:37,160 --> 00:18:40,130
Move up and then hammer my platform.

295
00:18:40,580 --> 00:18:45,830
I used HTTP get, and then it's gonna
show me the outcomes of it response time.

296
00:18:45,830 --> 00:18:50,480
In this case, the number of requests,
and then obviously the go-to scenario

297
00:18:50,870 --> 00:18:55,640
would be to add an additional level
of tests, changing the parameters.

298
00:18:56,150 --> 00:18:58,730
Maybe running the test
again with a different app,

299
00:18:58,730 --> 00:19:00,590
service backend and whatnot.

300
00:19:01,220 --> 00:19:04,880
And then it also shows me
some service side metrics, but

301
00:19:04,970 --> 00:19:06,710
this has not been configured.

302
00:19:07,250 --> 00:19:10,310
What I would need to do here
is what I showed you before,

303
00:19:10,520 --> 00:19:12,770
enabling application insights.

304
00:19:13,340 --> 00:19:18,050
Application insights is where you're
gonna hook into Azure Log Analytics,

305
00:19:18,110 --> 00:19:22,760
allowing you to store all the metric
data, not only visible in the portal,

306
00:19:22,820 --> 00:19:28,190
but actually storing the actual telemetry
information and allowing you to again,

307
00:19:28,340 --> 00:19:31,890
do data mining data viewing out of that.

308
00:19:32,190 --> 00:19:36,030
And that's where the server side
metric comes in because it's relying

309
00:19:36,030 --> 00:19:37,860
on some other framework there.

310
00:19:38,360 --> 00:19:43,460
Next to that, I can download my
input file, the logs, the results.

311
00:19:43,700 --> 00:19:45,350
I'm gonna show you the input file.

312
00:19:45,350 --> 00:19:45,770
Why?

313
00:19:45,830 --> 00:19:51,670
Because this is what I need to
show you that JMeter framework.

314
00:19:52,170 --> 00:19:55,800
It's not the best tool, but
I'm gonna use it for now.

315
00:19:56,010 --> 00:20:01,090
Just opening an easy notepad
document and then I could normally.

316
00:20:01,590 --> 00:20:02,520
Not drag and drop.

317
00:20:02,520 --> 00:20:05,450
Obviously not because it's
what am I doing, notepad?

318
00:20:05,450 --> 00:20:07,340
No, Peter, you don't need notepad.

319
00:20:07,340 --> 00:20:09,260
You need Visual Studio Code to do this,

320
00:20:09,760 --> 00:20:11,170
and then I guess I can drop it.

321
00:20:11,670 --> 00:20:13,140
It is in my downloads.

322
00:20:13,640 --> 00:20:17,570
It looks a bit weird, but eventually
it shows up as we expect it.

323
00:20:18,080 --> 00:20:20,420
So this is the J meter config file.

324
00:20:20,420 --> 00:20:21,890
So it has the display name.

325
00:20:21,950 --> 00:20:23,270
What kind of test plan?

326
00:20:23,550 --> 00:20:27,900
And as you can see here, there's
a pointer to the actual JSO file.

327
00:20:28,770 --> 00:20:33,570
It's what you see here looks a little
bit awkward because for some reason

328
00:20:33,570 --> 00:20:39,390
it's not respecting the JSO layout, but
you can see that it has that syntax.

329
00:20:39,450 --> 00:20:43,590
And then the last one
is the actual GMX file.

330
00:20:44,090 --> 00:20:44,720
Oh, there we go.

331
00:20:44,720 --> 00:20:47,060
We could do actually
notepad, but that's fine.

332
00:20:47,560 --> 00:20:51,070
And this is that XML structure
that I talked about before.

333
00:20:51,490 --> 00:20:53,620
So it's gonna show you
like all the details.

334
00:20:53,670 --> 00:20:59,120
Let's see if I can find some of the
settings from my configuration here.

335
00:20:59,420 --> 00:21:02,030
So it's a CTP, that's what we picked.

336
00:21:02,030 --> 00:21:03,380
We had a CTP get.

337
00:21:03,440 --> 00:21:04,160
That's fine.

338
00:21:04,660 --> 00:21:10,030
And this is where I would say go into
the documentation of the Apache J Meter.

339
00:21:10,480 --> 00:21:15,910
The nice thing again is that now since we
exported this, I could technically close

340
00:21:15,910 --> 00:21:17,740
this because I don't need it anymore.

341
00:21:18,220 --> 00:21:22,450
I could now go in and
actually upload a new test.

342
00:21:22,660 --> 00:21:28,020
So if I take one step back, create new
test, upload a script, it's gonna ask me

343
00:21:28,020 --> 00:21:30,330
like, okay, where do you have your files?

344
00:21:30,570 --> 00:21:31,680
It's JMeter.

345
00:21:31,890 --> 00:21:34,230
It's in my local file system.

346
00:21:34,230 --> 00:21:35,310
It's in my repos.

347
00:21:35,310 --> 00:21:36,870
It's anywhere you wanna store it.

348
00:21:37,245 --> 00:21:40,395
And then you don't have to go
through the portal anymore.

349
00:21:40,905 --> 00:21:45,855
So URL Test JMeter, it's
technically almost the same thing.

350
00:21:46,245 --> 00:21:51,405
I would say use that JMeter scenario for
the more advanced configuration options.

351
00:21:52,155 --> 00:21:55,365
The other example we have is Locust.

352
00:21:55,455 --> 00:21:57,195
So again, what is Locust?

353
00:21:57,465 --> 00:21:58,575
It's what down here.

354
00:21:58,635 --> 00:22:00,705
I got another little demo that I built.

355
00:22:01,205 --> 00:22:04,265
Everything that I talked to you
through is exactly the same thing.

356
00:22:04,355 --> 00:22:06,785
I'm selecting a test, I'm running a test.

357
00:22:07,205 --> 00:22:11,285
The main difference here, it's
using a different framework.

358
00:22:12,005 --> 00:22:15,275
The nice thing again, is that
within our Azure load testing,

359
00:22:15,515 --> 00:22:20,585
it's using the same Azure approach
to give you that capability.

360
00:22:21,155 --> 00:22:26,675
Same testing, same ease of use, same
advanced configuration, more granular

361
00:22:26,675 --> 00:22:29,375
options, just using a different framework.

362
00:22:29,930 --> 00:22:34,550
You might have used JMeter in
another cloud, in an on-prem world,

363
00:22:34,610 --> 00:22:36,800
you might standardize on locust.

364
00:22:36,950 --> 00:22:38,660
That's the philosophy behind it.

365
00:22:39,410 --> 00:22:40,970
What is the main difference?

366
00:22:40,970 --> 00:22:42,890
I would say it's the configuration.

367
00:22:43,390 --> 00:22:49,150
This is my Locust Python script that I
used for this test, and as you can see

368
00:22:49,150 --> 00:22:56,080
here, it's using Python scripting language
to define the details of your scripting.

369
00:22:56,590 --> 00:22:57,610
It's connecting.

370
00:22:57,985 --> 00:23:00,385
Two, my workload, it's a get workload.

371
00:23:00,385 --> 00:23:04,975
It's pulling up a to-do item, and
then it's reading out a response to

372
00:23:04,975 --> 00:23:09,565
validate if the response was 200,
retrieve the response, and so on.

373
00:23:10,195 --> 00:23:14,815
Using Python, traditional
ping scripting language.

374
00:23:15,315 --> 00:23:20,205
Running the test, seeing the output of
the test is the exact same experience,

375
00:23:20,265 --> 00:23:23,625
so loading 500, about 500 users.

376
00:23:23,970 --> 00:23:26,820
Four or five minutes and
then reading out the results.

377
00:23:27,120 --> 00:23:30,360
And again, the dashboarding views
are technically the same thing.

378
00:23:30,860 --> 00:23:34,995
Next I talked about using DevOps mindset.

379
00:23:35,445 --> 00:23:39,315
So the example I have here
is connecting to DevOps.

380
00:23:39,675 --> 00:23:42,765
I could show you GitHub
actions as well, but I'm still.

381
00:23:43,260 --> 00:23:47,850
A lot more into Azure DevOps, I guess
out of my background, been playing

382
00:23:47,850 --> 00:23:50,580
with DevOps for I dunno, 10, 15 years.

383
00:23:50,850 --> 00:23:53,820
So Team Foundation
server was my playground.

384
00:23:54,540 --> 00:23:59,280
I got my to-do items, the one
that I published in my pipeline.

385
00:23:59,550 --> 00:24:00,840
And then in here,

386
00:24:01,340 --> 00:24:04,670
what's relevant, apart from the
fact that it didn't run successful,

387
00:24:04,670 --> 00:24:07,520
but it's because I didn't
configure the correct permissions.

388
00:24:08,020 --> 00:24:10,300
This is one single stage.

389
00:24:10,990 --> 00:24:14,200
So this would be part of your
CI build pipeline, right?

390
00:24:15,190 --> 00:24:18,990
Where you're gonna ci ICD pipeline,
sorry, where you're gonna define

391
00:24:19,080 --> 00:24:21,300
the service connection into Azure.

392
00:24:21,600 --> 00:24:23,880
What is the name of the load test?

393
00:24:24,090 --> 00:24:25,590
What is the resource group?

394
00:24:25,650 --> 00:24:31,340
And then from there you're gonna use
this pre-built Azure load test concept.

395
00:24:31,910 --> 00:24:36,500
It needs a load testing config
file, so the YAML file from JMeter

396
00:24:36,740 --> 00:24:39,170
as I showed you the resource group.

397
00:24:39,260 --> 00:24:42,560
And then from there, not
really needing anything else.

398
00:24:43,250 --> 00:24:44,660
Super straightforward.

399
00:24:44,690 --> 00:24:46,970
How can you install this extension?

400
00:24:47,030 --> 00:24:50,950
You go into the Visual Studio marketplace.

401
00:24:51,450 --> 00:24:54,300
I think it's marketplace
dot visual studio.com.

402
00:24:54,360 --> 00:24:54,930
There we go.

403
00:24:55,430 --> 00:24:58,910
And you're gonna search
for Azure load testing.

404
00:24:59,330 --> 00:25:02,360
It's gonna ask you like, where
do you want to install this?

405
00:25:02,450 --> 00:25:05,450
As part of what Azure DevOps organization.

406
00:25:05,870 --> 00:25:09,290
You download it, you install it, and
that's where it becomes available.

407
00:25:09,890 --> 00:25:12,890
If you go okay, that's all
cool, but can you show me how

408
00:25:12,890 --> 00:25:14,960
to do this in GitHub actions?

409
00:25:15,460 --> 00:25:20,910
Although I don't have it up and running
configured, you would go into repo,

410
00:25:21,410 --> 00:25:27,700
you would go into actions, and then
here you would search for load testing.

411
00:25:27,850 --> 00:25:32,090
I think it's one word maybe
to load what happened here.

412
00:25:32,090 --> 00:25:32,600
Load.

413
00:25:33,100 --> 00:25:34,690
Oh, it's not the full action.

414
00:25:34,690 --> 00:25:38,310
Obviously, it's a component
within, it should be here,

415
00:25:38,810 --> 00:25:40,520
Azure load testing,

416
00:25:41,020 --> 00:25:44,520
and then picking the right
version or the latest version.

417
00:25:44,970 --> 00:25:45,870
That's up to you.

418
00:25:46,320 --> 00:25:50,610
And then as you can see from my slides,
Azure load testing and then asking

419
00:25:50,610 --> 00:25:56,060
again for the same configuration data,
the JM Max file, the YAML file, the

420
00:25:56,060 --> 00:26:01,370
config file in JSON format, which
most probably is already part of your

421
00:26:01,420 --> 00:26:06,520
repo anyway, and then running your
pipeline just like any other component.

422
00:26:07,180 --> 00:26:09,615
The last scenario we have.

423
00:26:10,115 --> 00:26:16,975
I have it somewhere on the site is
running it using traditional rest API

424
00:26:16,975 --> 00:26:23,465
calls, and I'm just gonna grab the
little sample code that I have for that.

425
00:26:23,965 --> 00:26:26,005
Just give me a second here.

426
00:26:26,065 --> 00:26:28,855
That's what happens when
you do all this live, right?

427
00:26:29,355 --> 00:26:30,975
It would look a little bit like this.

428
00:26:31,035 --> 00:26:34,755
So first you're gonna authenticate
into Azure Next, it's gonna

429
00:26:34,755 --> 00:26:37,275
create that authentication token.

430
00:26:37,695 --> 00:26:43,635
And from there, traditional rest, API curl
post get anything you wanna do with it.

431
00:26:44,415 --> 00:26:45,735
HT TP, oh, sorry.

432
00:26:45,735 --> 00:26:48,225
This is obviously the post
because you're triggering.

433
00:26:48,595 --> 00:26:55,015
The load testing itself point to your load
testing endpoint using the token and then

434
00:26:55,045 --> 00:27:01,285
defining the header and the actual details
where again, it's pointing to your script.

435
00:27:01,315 --> 00:27:02,335
GMX file.

436
00:27:02,425 --> 00:27:04,925
In this case, it's a JMeter example.

437
00:27:05,735 --> 00:27:10,655
And then running the actual
test is again running curl post.

438
00:27:10,655 --> 00:27:13,685
And then you're gonna run
the actual test cycle here.

439
00:27:14,675 --> 00:27:19,085
Three different scenarios, three
different options, pretty much anything.

440
00:27:19,175 --> 00:27:22,355
I wanted to talk about in
this 30 minute session.

441
00:27:23,135 --> 00:27:27,755
Looking at the clock, I can see that
I'm almost running out of time, so I'm

442
00:27:27,755 --> 00:27:32,615
gonna switch back to the presentation and
closing with the last couple of words.

443
00:27:32,990 --> 00:27:33,440
Awesome.

444
00:27:33,440 --> 00:27:34,850
So that worked pretty fine.

445
00:27:34,970 --> 00:27:39,920
Now we're close to the end of my session,
but allow me to actually fine tune or

446
00:27:40,100 --> 00:27:44,660
close my session with a couple of last
words where one of the last things I

447
00:27:44,660 --> 00:27:50,000
wanna highlight here is that Azure Load
testing is only one of, I would say,

448
00:27:50,000 --> 00:27:52,550
our Azure mission critical components.

449
00:27:53,090 --> 00:27:56,960
The second option, as you can see
here, is Azure Chaos Studio, allowing

450
00:27:56,960 --> 00:28:01,010
you to do chaos engineering against
your Azure running workloads.

451
00:28:01,430 --> 00:28:04,820
If you wanna find more details about
how this technically works, what are

452
00:28:04,820 --> 00:28:09,530
the Microsoft guidelines, the best
practices on building out this sort

453
00:28:09,530 --> 00:28:11,780
of mission critical workload scenario?

454
00:28:12,020 --> 00:28:15,950
I would say go to this GitHub link
where you find all documentation,

455
00:28:15,950 --> 00:28:21,290
including samples, including sample
testing and chaos experiments.

456
00:28:21,635 --> 00:28:24,635
With that, I'm at the end
of my session time for now.

457
00:28:24,665 --> 00:28:25,985
So thank you for watching.

458
00:28:25,985 --> 00:28:28,025
Thank you for being here again.

459
00:28:28,115 --> 00:28:30,965
Enjoy the rest of the SRE
conference here today.

460
00:28:31,295 --> 00:28:34,775
If you've got any questions, don't
hesitate reaching out by email

461
00:28:34,775 --> 00:28:38,675
on Twitter, maybe on LinkedIn
if you wanna stay in touch and

462
00:28:38,675 --> 00:28:40,445
enjoy the rest of the conference.

463
00:28:40,565 --> 00:28:44,105
Thank you for now and see you
again at some other com 42

464
00:28:44,525 --> 00:28:46,295
conference in the near future.

465
00:28:46,805 --> 00:28:48,005
Enjoy the rest of your day.

