1
00:00:00,930 --> 00:00:01,590
Hello everyone.

2
00:00:02,580 --> 00:00:03,480
Thank you for joining.

3
00:00:04,230 --> 00:00:08,340
My name is Nish Kumar ti and
I'm currently a senior cloud and

4
00:00:08,340 --> 00:00:09,570
application security engineer.

5
00:00:10,260 --> 00:00:14,730
Over the past decade, I've been deeply
involved in securing enterprise scale

6
00:00:14,730 --> 00:00:22,710
systems across AWS Azure and GCP with the
focus on integrating security directly

7
00:00:22,710 --> 00:00:27,690
into the development and deployment
process, what we now call DevSecOps.

8
00:00:28,410 --> 00:00:29,405
I worked on building.

9
00:00:30,075 --> 00:00:34,965
And implementing security pipelines
that perform compliance checks,

10
00:00:35,144 --> 00:00:39,375
vulnerability scanning, and real
time threat detection for everything

11
00:00:39,375 --> 00:00:43,785
from traditional applications to
modern serverless workloads like

12
00:00:43,785 --> 00:00:45,705
AWS Lambda and Azure functions.

13
00:00:46,205 --> 00:00:49,375
I have led migrations from
traditional security platforms

14
00:00:49,375 --> 00:00:54,855
like Prisma Cloud to more advanced
solutions like VIS IO closing gaps

15
00:00:54,855 --> 00:00:56,350
in container and server security.

16
00:00:56,850 --> 00:01:02,940
I have designed CSCD integrations
that block insecure bills

17
00:01:02,940 --> 00:01:05,400
before the reach production.

18
00:01:06,000 --> 00:01:11,750
Combining tools like VCLI, fortify
and AWS Inspector, I'm also involved

19
00:01:11,750 --> 00:01:18,710
in a PS security with nsec defining
sensitive data handling strategies

20
00:01:18,890 --> 00:01:22,940
and onboarding PCA and non PCA
workloads for continuous monitoring.

21
00:01:23,440 --> 00:01:28,030
Today's talk, building memory
Safe DevSecOps at Enterprise

22
00:01:28,030 --> 00:01:32,560
Scale is about a challenge I've
seen repeatedly over the years.

23
00:01:32,649 --> 00:01:34,390
I've seen a recurring challenge.

24
00:01:35,199 --> 00:01:40,360
Many security tools stem cells are
returning memory unsafes languages

25
00:01:40,360 --> 00:01:45,440
like CC plus, which means the
tools designed to protect us can

26
00:01:45,440 --> 00:01:46,970
introduce new vulnerabilities.

27
00:01:47,720 --> 00:01:48,980
That's what led me to.

28
00:01:49,480 --> 00:01:50,560
Explore rust.

29
00:01:50,710 --> 00:01:54,700
A language that eliminates
entire categories of memory

30
00:01:54,700 --> 00:01:57,370
safety issues at compile time.

31
00:01:58,120 --> 00:02:02,940
Today, I wanna share with you how
rust memory, safety, performance

32
00:02:03,270 --> 00:02:09,300
integration flexibility can help us
build safe security tools we can trust,

33
00:02:10,050 --> 00:02:14,310
and how we can practically bring rust
into our existing security pipelines.

34
00:02:14,820 --> 00:02:16,800
Without starting from scratch.

35
00:02:17,430 --> 00:02:21,000
So that's a bit about who I am
and why this topic matters to me.

36
00:02:21,329 --> 00:02:24,630
Let's take a quick look at what
we will cover today and so you

37
00:02:24,630 --> 00:02:27,360
know exactly what we are headed.

38
00:02:27,860 --> 00:02:29,910
Okay, here is what we will cover.

39
00:02:30,630 --> 00:02:32,370
First, we will look at rust.

40
00:02:32,895 --> 00:02:37,785
Memory safety advantage how its
ownership model eliminates entire

41
00:02:37,785 --> 00:02:42,525
classes of vulnerabilities leading to
up to 40% fewer security incidents.

42
00:02:43,245 --> 00:02:47,445
Next, we will explore technical
implementations, real world examples

43
00:02:47,445 --> 00:02:52,215
like static analysis tools that block
insecure code before it compiles

44
00:02:52,845 --> 00:02:54,780
lightning fast container scanners.

45
00:02:55,280 --> 00:02:58,760
Cryptographic pipelines that
stop supply chain attacks and

46
00:02:58,760 --> 00:03:00,680
memory safe policy engines.

47
00:03:01,250 --> 00:03:06,410
Then we will review performance benchmarks
showing how rust tools can ramp 10

48
00:03:06,410 --> 00:03:11,450
next faster than go or Python language
using 60% less memory with examples

49
00:03:11,450 --> 00:03:13,520
from CloudFlare Dropbox and discard.

50
00:03:14,030 --> 00:03:18,080
Finally, we will discover integration
strategies so you can bring rust into

51
00:03:18,080 --> 00:03:21,910
your DevOp DevOps workflows, whether it's
a Gate hooks Kubernetes administration

52
00:03:21,910 --> 00:03:22,960
controllers, or API gateways.

53
00:03:23,665 --> 00:03:24,835
Without major disruptions.

54
00:03:24,885 --> 00:03:30,105
Before we dive into RAs, let's first
understand the problem we are solving.

55
00:03:30,735 --> 00:03:36,255
The memory safety crisis that's
affecting almost every modern systems.

56
00:03:36,755 --> 00:03:38,645
The memory safety crisis.

57
00:03:39,145 --> 00:03:44,795
From memory, safety flaws are still
top cause of critical security issues.

58
00:03:45,275 --> 00:03:46,895
The Microsoft reports.

59
00:03:47,315 --> 00:03:54,245
That 70% of its cvs come from memory
safety bug problems like use after

60
00:03:54,245 --> 00:04:00,695
free buffer overflows, databases,
plug plague C, like C plus because

61
00:04:00,695 --> 00:04:05,075
developers how to manually manage
memory, traditional scanner detect

62
00:04:05,645 --> 00:04:07,385
these only after code is written.

63
00:04:07,595 --> 00:04:11,795
And runtime monitoring can slow down
applications here, for example, in

64
00:04:11,795 --> 00:04:14,135
a real world case, a buffer flow.

65
00:04:14,635 --> 00:04:19,915
NAC plus based API gateway allowed
attackers to arrive session

66
00:04:19,915 --> 00:04:23,155
data, gaining admin level access.

67
00:04:23,665 --> 00:04:31,545
This is issues that cost millions to fix
and damages trust, and it's exactly the

68
00:04:31,545 --> 00:04:34,215
type of risk rust is designed to prevent.

69
00:04:34,715 --> 00:04:39,095
Now we, now that we know the
scale of the problem, here is

70
00:04:39,095 --> 00:04:40,335
what rust changes the game.

71
00:04:40,835 --> 00:04:45,215
It makes the whole categories of these
vulnerabilities impossible by design.

72
00:04:45,715 --> 00:04:50,655
Rust memory safety guarantees, and
that changes the game by making

73
00:04:50,655 --> 00:04:54,435
entire categories of vulnerabilities
impossible at compile time.

74
00:04:55,245 --> 00:04:56,415
It enforces ownership.

75
00:04:57,150 --> 00:05:00,450
So every piece of data has only one owner.

76
00:05:01,170 --> 00:05:04,320
Notable, freeze boring rules and safe.

77
00:05:04,530 --> 00:05:08,370
Ensure safe freeze and rights
without corrupting memory.

78
00:05:08,870 --> 00:05:09,440
Lifetime.

79
00:05:09,440 --> 00:05:12,760
Make sure and nothing out lives.

80
00:05:12,760 --> 00:05:14,950
Its valid scope and fearless.

81
00:05:15,450 --> 00:05:17,100
Concurrency means no data.

82
00:05:17,400 --> 00:05:19,629
S even in multi multi-threaded code.

83
00:05:20,020 --> 00:05:24,280
If you build a container scanner or an a
PA gateway, you are not just protecting

84
00:05:24,280 --> 00:05:29,319
applications, you are ensuring the
tool itself is not a new attack vector.

85
00:05:29,439 --> 00:05:29,950
Vector.

86
00:05:30,609 --> 00:05:34,814
This is why companies like
Dropbox have reported zero memory

87
00:05:34,814 --> 00:05:36,969
safety bug in rust based modules.

88
00:05:37,689 --> 00:05:39,340
And this is not just theory.

89
00:05:39,999 --> 00:05:44,679
When organizations switch to
RAs, they see real world results.

90
00:05:45,099 --> 00:05:48,819
Let's talk about the
measurable impact it's having.

91
00:05:49,319 --> 00:05:54,109
Enterprise impacts the name, the
number speaks for themselves.

92
00:05:54,109 --> 00:05:59,414
Enterprise migrating critical
components from CC plus to rust have

93
00:05:59,414 --> 00:06:01,214
seen a 40% drop in security incident.

94
00:06:01,714 --> 00:06:07,324
Properly, a written rust code has
zero memory safety bucks, static

95
00:06:07,324 --> 00:06:12,364
analysis tools and rust can reach 95%
detection accuracy with fewer false

96
00:06:12,364 --> 00:06:18,754
positives, meaning security teams
spend less time chasing more noise

97
00:06:18,754 --> 00:06:21,244
and more time fixing real issues.

98
00:06:21,304 --> 00:06:26,454
For example, one of financial
services, from I worked with Saudi

99
00:06:26,454 --> 00:06:30,234
vulnerability backlog, dropped
by 30% in three months after

100
00:06:30,594 --> 00:06:32,574
introducing rust based scanning tools.

101
00:06:32,874 --> 00:06:36,654
So how do we actually put rust to work?

102
00:06:36,714 --> 00:06:42,294
Let's start with the static analysis,
catching unsafe core practice patterns

103
00:06:42,894 --> 00:06:45,114
before they ever reach production.

104
00:06:45,614 --> 00:06:47,294
Static analysis tooling.

105
00:06:47,794 --> 00:06:48,084
Russ.

106
00:06:48,584 --> 00:06:52,754
Passing libraries, select
Sim and Pro Marker two.

107
00:06:53,254 --> 00:06:57,449
Pro Max two Make it perfect for
building static analysis tools.

108
00:06:57,449 --> 00:07:01,559
You can scan code at and compile
times spots, SQL injections

109
00:07:01,559 --> 00:07:06,779
patterns and block in secure
commits before they hit the ripple.

110
00:07:07,229 --> 00:07:13,169
Compared to go based scanners,
rust tools run three times faster

111
00:07:13,559 --> 00:07:16,034
and compared to Python based
tools, they are 10 times more.

112
00:07:16,859 --> 00:07:18,869
Reliable in a security pipeline.

113
00:07:18,869 --> 00:07:24,959
That means you can scan huge code
base in seconds without bottlenecks.

114
00:07:25,259 --> 00:07:29,519
Imagine CI build that rejects
the vulnerable API endpoint

115
00:07:29,519 --> 00:07:31,019
before it even deploys.

116
00:07:31,559 --> 00:07:35,699
Starting analysis protects code
before it's built, but what about

117
00:07:35,699 --> 00:07:37,859
the things we package and ship?

118
00:07:38,549 --> 00:07:41,219
That's where container scanning comes in.

119
00:07:41,219 --> 00:07:42,809
Rust really shines there.

120
00:07:43,309 --> 00:07:44,389
What is container?

121
00:07:44,509 --> 00:07:47,569
Let's start from the basis basics.

122
00:07:48,199 --> 00:07:55,399
A container is a lightweight, portable
package that includes an application

123
00:07:55,459 --> 00:07:59,599
and everything it needs to run the code.

124
00:07:59,779 --> 00:08:04,879
Libraries, runtime, environment
variables and configuration files.

125
00:08:05,379 --> 00:08:06,069
Think of it.

126
00:08:06,569 --> 00:08:09,689
Think of it as a shipping
container for software.

127
00:08:10,559 --> 00:08:18,059
It does not matter if the ship
is AWS Azure, GCP, or on-prem.

128
00:08:18,559 --> 00:08:20,509
The container runs the same way.

129
00:08:21,049 --> 00:08:25,489
Docker and Kubernetes have made
the containers the backbone of

130
00:08:25,489 --> 00:08:26,839
modern application deployment.

131
00:08:27,169 --> 00:08:30,669
The benefit containers are fast to start.

132
00:08:31,434 --> 00:08:34,014
Easy to replicate and scalable.

133
00:08:34,224 --> 00:08:39,144
But the flip side is you view package
vulnerabilities inside your container.

134
00:08:39,144 --> 00:08:41,634
You are scaling those
vulnerabilities everywhere.

135
00:08:42,134 --> 00:08:48,514
Why containers need security scanning,
a typical container image can meet up

136
00:08:48,579 --> 00:08:53,909
of dozen of dozens of layers, often
pulled from public repositories.

137
00:08:54,149 --> 00:08:58,604
This means, you are potentially narrating
vulnerabilities from someone else.

138
00:08:58,604 --> 00:09:05,454
Score common container risks includes
outdated base images using open two or 16

139
00:09:05,454 --> 00:09:10,564
version, or that's reached end of life,
and embedded secrets, like API, keys,

140
00:09:10,564 --> 00:09:15,659
passwords, lifting, some environment
variables, vulnerable libraries

141
00:09:15,659 --> 00:09:17,894
like log four J everyone knows that.

142
00:09:17,894 --> 00:09:19,214
And or OpenSSL.

143
00:09:20,144 --> 00:09:24,344
Misconfigurations, insecure
file permissions, et cetera.

144
00:09:25,094 --> 00:09:30,734
Real world example, in, in 2021,
attackers com compromised Kubernetes

145
00:09:30,734 --> 00:09:36,074
clusters by exploiting containers
running outdated alpine Linx images.

146
00:09:36,104 --> 00:09:40,154
That's why scanning containers
before deployment is non-negotiable.

147
00:09:40,654 --> 00:09:45,064
How traditionally scanning
works traditionally scanners

148
00:09:45,454 --> 00:09:46,564
pass the container image.

149
00:09:47,064 --> 00:09:52,165
Extract the file systems, layers
and com compare and style packages

150
00:09:52,165 --> 00:09:56,124
like against known vulnerabilities
database like NVD or vendor advisors.

151
00:09:56,454 --> 00:10:01,854
The problem with some existing tools,
performance bottlenecks, scanning hundreds

152
00:10:01,854 --> 00:10:04,910
of images can take hours, memory leaks.

153
00:10:05,410 --> 00:10:08,889
Scanners in unsafe languages
can themselves be exploited,

154
00:10:09,780 --> 00:10:12,574
false to use, noisy results.

155
00:10:12,574 --> 00:10:15,295
You know that wastes security team time.

156
00:10:16,029 --> 00:10:23,349
In CSCD, slow or unlevel scans lead to
a tough trade off speed versus security.

157
00:10:23,619 --> 00:10:26,289
And then that's where Rust
gives us a breakthrough.

158
00:10:26,589 --> 00:10:32,139
Coming to rust based container scanning,
rust is designed let us built continuous

159
00:10:32,139 --> 00:10:35,609
channels that are fast, safe and accurate.

160
00:10:36,109 --> 00:10:41,539
The improvements rust brings
are like zero copy passing.

161
00:10:42,039 --> 00:10:49,419
Parallel scanning, async reporting zero
copy parsing with creates like bias.

162
00:10:49,419 --> 00:10:52,959
The scanners can read container
layers directly from disk without

163
00:10:52,959 --> 00:10:54,429
duplicating data in memory.

164
00:10:54,939 --> 00:10:59,179
This means faster performance and
no unnecessary memory use parallel

165
00:10:59,179 --> 00:11:05,799
scanning using, rion or we can use,
we can scan 10,000 plus images per

166
00:11:05,799 --> 00:11:07,449
minute without breaking his feet.

167
00:11:07,949 --> 00:11:08,149
Sing.

168
00:11:08,649 --> 00:11:13,949
Reporting libraries like Tokyo let
us send scan results to dashboards

169
00:11:13,949 --> 00:11:18,319
or security tools without blocking
the scanner process end-to-end.

170
00:11:18,419 --> 00:11:19,919
Let's walk through end-to-end.

171
00:11:19,999 --> 00:11:24,964
Use case in in, in DevSecOps
pipeline developer pushes code.

172
00:11:25,464 --> 00:11:32,759
That triggers the build pipeline
Docker image built a base image

173
00:11:33,749 --> 00:11:38,899
plus an application code or packaged
into your container, and then

174
00:11:38,899 --> 00:11:45,699
rust based scanner runs before the
image pushed into the registry.

175
00:11:46,449 --> 00:11:48,669
The scanner analyze each layer.

176
00:11:49,169 --> 00:11:56,609
Checks, installed packages against
CVE databases, flags, outdated O waste

177
00:11:56,609 --> 00:11:58,949
components or insecure configurations.

178
00:11:59,039 --> 00:12:05,139
Detect secrets left in code or
environment variables and scan results.

179
00:12:05,639 --> 00:12:09,629
Evaluated if critical vulnerabilities
are found, the pipeline blocks the

180
00:12:09,629 --> 00:12:13,659
deployment and sends results to,
however integration has happened.

181
00:12:13,659 --> 00:12:19,139
It may be ServiceNow or Slack with
xera image push to registry only clean.

182
00:12:19,319 --> 00:12:25,769
Ensuring production gets only safe,
verified continuous by embedding the

183
00:12:25,769 --> 00:12:29,799
Rust Scanner here, you are shifting,
security left, stopping vulnerability

184
00:12:29,799 --> 00:12:31,629
before they ever touch production.

185
00:12:32,589 --> 00:12:37,779
So in short, containers are powerful,
but without scanning, they are high speed

186
00:12:37,779 --> 00:12:39,549
delivery systems for vulnerabilities.

187
00:12:40,329 --> 00:12:43,359
Speed is great, but
trust is non-negotiable.

188
00:12:43,359 --> 00:12:47,204
A scanner written memory,
unsafe language can be exploited

189
00:12:48,024 --> 00:12:50,564
via the very images in it.

190
00:12:50,564 --> 00:12:55,244
Inspects rust memory model
makes entire classes of parser.

191
00:12:55,884 --> 00:12:59,904
And current concurrency
bugs impossible by design.

192
00:12:59,904 --> 00:13:02,634
So that tools is not a new attacker phase.

193
00:13:02,844 --> 00:13:07,524
Restless as built scanners that are
both faster, safer than a traditional

194
00:13:07,524 --> 00:13:11,634
tools, making it possible to secure
containerized replications at enterprise

195
00:13:11,634 --> 00:13:14,214
scale without slowing in innovation.

196
00:13:14,664 --> 00:13:18,234
Now we have scanned the container
vulnerabilities, but how do we

197
00:13:18,234 --> 00:13:21,344
ensure no one has tampered with it?

198
00:13:21,494 --> 00:13:23,264
Between build and deploy.

199
00:13:23,879 --> 00:13:28,339
That's where cryptographic
validation steps in cryptographic

200
00:13:28,369 --> 00:13:29,509
pipeline validation.

201
00:13:30,009 --> 00:13:32,259
Supply chain attacks are on the rise.

202
00:13:32,259 --> 00:13:36,509
So everything so verifying your
build artifacts is critical.

203
00:13:36,569 --> 00:13:41,069
Rust ring and results libraries
give your memory safe.

204
00:13:41,074 --> 00:13:43,374
Cryptographic P use, avoiding the.

205
00:13:44,184 --> 00:13:49,319
Pitfalls of C based open SSL, you can sign
and verify artifacts without unnecessary

206
00:13:49,319 --> 00:13:56,479
data copies using the risk of time
of check to time of use at x discord

207
00:13:56,479 --> 00:14:00,859
implemented a rust based cryptographic
verification and si a hundred percent

208
00:14:01,039 --> 00:14:03,649
drop in certain supply chain at accidents.

209
00:14:03,979 --> 00:14:07,874
And finally, even the, within the
security measures we need to control.

210
00:14:08,504 --> 00:14:09,944
What runs in your environment?

211
00:14:09,944 --> 00:14:13,574
Let's see how RUS can power,
memory, safe policy engines.

212
00:14:14,074 --> 00:14:19,744
Policy engines decide what's allowed
in your systems and if they are

213
00:14:20,374 --> 00:14:23,459
compromised, you are in trouble with rust.

214
00:14:23,459 --> 00:14:24,929
You can compile policies on.

215
00:14:25,619 --> 00:14:29,849
Web assembly offered sandbox
executions or ensuring they're

216
00:14:29,849 --> 00:14:31,529
run safely across platforms.

217
00:14:31,739 --> 00:14:35,309
You can validate configurations without
risking buffer workflows or even

218
00:14:35,639 --> 00:14:37,799
hard swab policies without restarts.

219
00:14:37,799 --> 00:14:42,749
For example in Kubernetes, you
could enforce that only signed

220
00:14:42,749 --> 00:14:46,964
images or deployed and updated the
policy in amply without downtime.

221
00:14:47,564 --> 00:14:49,124
We are seeing the technical side.

222
00:14:49,124 --> 00:14:50,534
Now let's talk numbers.

223
00:14:51,434 --> 00:14:57,104
How much faster, safer, and more
efficient or rust based tools

224
00:14:57,314 --> 00:14:58,844
compared to traditional ones.

225
00:14:59,344 --> 00:15:05,624
If you look at the slide here
across real deployments at Dropbox,

226
00:15:05,624 --> 00:15:10,454
discord, and CloudFlare, rust
based tools can morph faster.

227
00:15:10,874 --> 00:15:16,424
I use less memory and produce fewer
false positive than go our Python.

228
00:15:17,114 --> 00:15:25,084
Equal XA numbers three to 10 times
faster scans, 60% less memory

229
00:15:25,084 --> 00:15:31,315
use lower false positive rates,
all without s sacrificing safety.

230
00:15:31,435 --> 00:15:33,805
That's the definition
of security at scale.

231
00:15:34,075 --> 00:15:38,005
Of course, none of this matters
it if it's too hard to adapt.

232
00:15:38,065 --> 00:15:42,620
The good news is you can integrate RA
base tools into your workflows without.

233
00:15:43,444 --> 00:15:43,834
Major

234
00:15:44,334 --> 00:15:45,825
integration strategies.

235
00:15:46,325 --> 00:15:50,284
You don't have to rewrite your
stack to benefit from rust.

236
00:15:50,584 --> 00:15:56,435
You can integrate a gradually pre-commit
hooks to block, bad code add GitLab ca,

237
00:15:56,435 --> 00:16:01,685
jobs of and automated scanning Kubernetes
admission controllers for runtime

238
00:16:01,685 --> 00:16:06,814
policy enforcement, and API gateway mill
middleware for live request validation.

239
00:16:07,314 --> 00:16:08,124
Key takeaways.

240
00:16:08,244 --> 00:16:11,814
Rust eliminates entire classes of
vulnerabilities at compile time.

241
00:16:11,844 --> 00:16:15,744
It delivers faster performance, lower
memory use, and higher detection

242
00:16:15,744 --> 00:16:17,574
accuracy than traditional tools.

243
00:16:17,874 --> 00:16:23,094
You can start small dependency scanning
with cargo, audit container scanning

244
00:16:23,094 --> 00:16:27,984
with rest based tools and grow from
the grow from there, the future.

245
00:16:28,879 --> 00:16:31,819
Of secure infrastructure is not
just better detection, it's making

246
00:16:31,819 --> 00:16:33,589
certain vulnerabilities impossible.

247
00:16:33,589 --> 00:16:35,899
Rust delivers on that promise.

248
00:16:36,560 --> 00:16:37,010
Thank you.

249
00:16:37,040 --> 00:16:37,069
Okay.

