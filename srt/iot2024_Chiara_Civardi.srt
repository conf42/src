1
00:00:00,280 --> 00:00:05,890
Hi, I am Chiara, and welcome to
this session at the Confo 42 IoT.

2
00:00:06,390 --> 00:00:10,880
Together with me is my speaker,
is my co speaker, Peter.

3
00:00:11,380 --> 00:00:11,830
Hello.

4
00:00:12,330 --> 00:00:16,599
Today we'll be talking about creating
advanced robotic application, the

5
00:00:16,600 --> 00:00:23,380
leverage, edge computing, and cloud
computing to create next level IoT.

6
00:00:23,880 --> 00:00:29,245
So before we start, I know I cannot see
you, but I'm going to ask you all that

7
00:00:29,355 --> 00:00:31,945
are attending this talk a question.

8
00:00:32,675 --> 00:00:35,285
Can you imagine a robot?

9
00:00:35,455 --> 00:00:38,115
What do you think is the
most common robot right now?

10
00:00:39,085 --> 00:00:43,235
Is it a humanoid, so with
like human like features?

11
00:00:44,025 --> 00:00:48,604
Is it a droid, so perhaps it has
weird shapes and functionalities?

12
00:00:49,104 --> 00:00:54,534
Or is it more like an exoskeleton,
thinking like Iron Man, for example?

13
00:00:55,034 --> 00:00:58,294
And now from here I'm probably going
to disappoint all of you because the

14
00:00:58,294 --> 00:01:06,094
most common type of robot currently
is just a robotic arm or a delta arm.

15
00:01:06,594 --> 00:01:12,724
So these have different axes that can
move, they don't look like a human,

16
00:01:12,724 --> 00:01:16,244
they don't look like a droid, and
they're definitely not exoskeletons.

17
00:01:16,994 --> 00:01:21,054
but they are the most common and just
to give you some facts and figures.

18
00:01:21,554 --> 00:01:27,344
Just to give you some stats in 2023,
there were over 541, 000 robots

19
00:01:27,344 --> 00:01:29,344
installed in factories worldwide.

20
00:01:30,134 --> 00:01:36,274
With a robot density of 162
units every 10, 000 employees.

21
00:01:37,154 --> 00:01:41,064
Now, the robot density is just
a sort of barometer to track the

22
00:01:41,064 --> 00:01:45,244
degree of automation adoption in the
manufacturing industry around the world.

23
00:01:45,245 --> 00:01:45,544
for listening.

24
00:01:46,044 --> 00:01:47,924
where are these robots?

25
00:01:48,314 --> 00:01:54,454
most of these, 500, 000 units, they
are in two sectors, the automotive and

26
00:01:54,464 --> 00:02:00,484
the electronics, which make almost 50
percent of industrial robot installations.

27
00:02:01,024 --> 00:02:07,984
Now, why, the automotive industry mostly
deals with very heavy pieces of equipment

28
00:02:07,994 --> 00:02:10,374
that needs to be assembled at high speed.

29
00:02:11,079 --> 00:02:13,609
of course, robots are perfect for that.

30
00:02:13,999 --> 00:02:16,879
Whereas in the electronic industries,
the components are much, much

31
00:02:16,879 --> 00:02:20,759
smaller, but they are also highly
sensitive to contamination.

32
00:02:20,819 --> 00:02:24,329
robots are perfect for
clean room environments.

33
00:02:24,829 --> 00:02:30,939
And With all these robots, I'm going
to share another very sad fact.

34
00:02:31,439 --> 00:02:32,929
They rarely see a cloud.

35
00:02:32,939 --> 00:02:36,889
All these 541, 000 robots
rarely see a cloud.

36
00:02:37,179 --> 00:02:41,849
And here, of course, I'm not talking
about real clouds, but digital cloud.

37
00:02:42,769 --> 00:02:45,019
Now, why should robots see the cloud?

38
00:02:45,029 --> 00:02:47,149
Why should they send data to the cloud?

39
00:02:47,799 --> 00:02:53,859
To gain additional insights, pretty
much, and to improve operations.

40
00:02:54,509 --> 00:03:00,869
by having robots send some of
their information to the cloud, the

41
00:03:00,869 --> 00:03:05,299
nation can access them at any time
to check for their performance,

42
00:03:05,319 --> 00:03:11,379
identify issues, as well as take any
preventative step to avoid downtime.

43
00:03:11,514 --> 00:03:14,134
Or to resolve downtime
as quickly as possible.

44
00:03:14,634 --> 00:03:20,414
basically you can monitor and analyze in
a near real time data, what the robots

45
00:03:20,414 --> 00:03:24,214
are doing remotely from anywhere in the
world, even if you're not in the plant.

46
00:03:25,134 --> 00:03:25,634
so what.

47
00:03:25,694 --> 00:03:29,884
What happens is that technicians
can detect potential issues before

48
00:03:29,884 --> 00:03:31,814
they escalate into major problems.

49
00:03:32,604 --> 00:03:34,744
this supports, of course,
proactive maintenance.

50
00:03:35,584 --> 00:03:40,244
by identifying early signs of failure,
technicians can schedule maintenance

51
00:03:40,244 --> 00:03:46,054
activities during planned downtime, and
this reduces unscheduled downtime and

52
00:03:46,054 --> 00:03:48,744
improves overall machine reliability.

53
00:03:49,244 --> 00:03:55,054
But also what you can do is then support
more advanced predictive maintenance

54
00:03:55,064 --> 00:04:00,714
strategies because you can analyze data
from multiple robots across your factory

55
00:04:00,714 --> 00:04:05,674
floor, for example, or across multiple
manufacturing facilities, and you can

56
00:04:05,694 --> 00:04:11,094
compare performance across different
time periods to gain key insights, for

57
00:04:11,094 --> 00:04:13,494
example, into potential improvements.

58
00:04:13,769 --> 00:04:17,249
and make more informed
data driven decisions.

59
00:04:17,969 --> 00:04:24,859
And also, because you can leverage then,
AI or machine learning algorithm, you

60
00:04:24,859 --> 00:04:31,649
can process the data, for example, on
maintenance or failures to predict,

61
00:04:31,649 --> 00:04:36,289
machine failure before they actually occur
based on the historical data available.

62
00:04:37,064 --> 00:04:42,714
And of course, this means that you don't
need to have a friend, almost random

63
00:04:42,724 --> 00:04:48,594
scheduled maintenance activities, but
you can take preemptive measures like

64
00:04:48,594 --> 00:04:53,944
replacing worn out components only when
it's needed, minimizing again, downtime

65
00:04:53,984 --> 00:04:55,874
and improving cost effectiveness.

66
00:04:56,374 --> 00:04:59,084
Now, why aren't robots
sending data to the cloud?

67
00:04:59,424 --> 00:05:03,694
the first point is there are way too
many data generated on the shop floor

68
00:05:03,704 --> 00:05:06,434
by robots, their controllers, etc.

69
00:05:06,474 --> 00:05:07,774
And way too quickly.

70
00:05:08,484 --> 00:05:12,384
And most of the data that are produced
on the factory floor for these

71
00:05:12,754 --> 00:05:16,754
automated operations, Is very fast.

72
00:05:16,814 --> 00:05:22,774
it's a lot of data and, so of course,
we need to consider that we still

73
00:05:22,784 --> 00:05:28,404
want the robots and the industrial
automation processes to operate.

74
00:05:28,714 --> 00:05:30,284
We don't want to.

75
00:05:30,519 --> 00:05:35,019
impact these operation because we
want to do additional analytics.

76
00:05:35,929 --> 00:05:41,869
of course, yes, the cloud can process
this data, but it probably cannot

77
00:05:41,899 --> 00:05:47,099
compete with the current capabilities
of, for example, industrial Ethernet

78
00:05:47,449 --> 00:05:50,029
for industrial automation processes.

79
00:05:50,529 --> 00:05:55,399
Now, For example, generally for
industrial automation networks, we

80
00:05:55,399 --> 00:05:59,779
are talking about a bandwidth with,
100 megabit per second or one gigabit

81
00:06:00,279 --> 00:06:02,099
per second, in terms of bandwidth.

82
00:06:02,599 --> 00:06:08,109
And if the data, this time sensitive
data are not transmitted, what happens

83
00:06:08,119 --> 00:06:11,329
is that the entire operation stops.

84
00:06:11,949 --> 00:06:17,949
So cloud computing here could
be a potential issue because it

85
00:06:17,959 --> 00:06:19,899
doesn't process data that quickly.

86
00:06:19,909 --> 00:06:22,669
It cannot probably handle
that volume of data.

87
00:06:22,959 --> 00:06:26,439
And also the cost can
be extremely elevated.

88
00:06:26,729 --> 00:06:30,649
so of course, using cloud computing
could potentially overwhelm

89
00:06:30,689 --> 00:06:33,529
your, IT and shop floor system.

90
00:06:33,559 --> 00:06:34,489
And you don't want that.

91
00:06:35,029 --> 00:06:39,679
in addition, what we also need
to consider is that, there are

92
00:06:39,679 --> 00:06:43,629
cyber security and visibility
issue that need to be considered.

93
00:06:44,019 --> 00:06:49,009
typically, shop floor are, have been
isolated with their industrial Ethernet

94
00:06:49,199 --> 00:06:54,409
because the access to the internet and the
cloud could potentially open up ways for

95
00:06:54,409 --> 00:07:00,824
cyber criminals and hackers to, access,
the equipment and potentially, stop all

96
00:07:00,834 --> 00:07:02,784
operation on the, manufacturing plant.

97
00:07:03,284 --> 00:07:07,274
in addition, related to the previous
issues, we don't want any latency.

98
00:07:07,594 --> 00:07:11,874
and finally, industrial automation
operation, because they tend to have

99
00:07:12,014 --> 00:07:18,294
extremely long service lives for their
equipment of about 25 years, they need

100
00:07:18,324 --> 00:07:23,494
to rely on standardized, So to ensure
backward compatibility in particular.

101
00:07:23,994 --> 00:07:26,864
So how can we connect robots to the cloud?

102
00:07:27,344 --> 00:07:30,184
The simple answer is
through edge computing.

103
00:07:30,664 --> 00:07:34,354
edge computing means processing
power is at the periphery of your

104
00:07:34,354 --> 00:07:36,334
industrial automation network.

105
00:07:36,744 --> 00:07:38,064
So close to the source.

106
00:07:38,064 --> 00:07:40,454
for example, in this
case, close to the robots.

107
00:07:40,884 --> 00:07:45,844
instead of sending All the data to the
cloud, so what you can do is filter.

108
00:07:45,854 --> 00:07:49,964
What data do you actually want to
send to the cloud for processing?

109
00:07:49,964 --> 00:07:52,874
Because you probably don't want
all the communication between the

110
00:07:52,874 --> 00:07:56,774
robot and its controller, but you
just want, for example, sensors,

111
00:07:57,024 --> 00:07:59,254
to identify anywhere and tear.

112
00:07:59,754 --> 00:08:03,634
So basically, what you have is a
separation, cloud computing would be the

113
00:08:03,634 --> 00:08:08,404
place where you develop the knowledge,
whereas edge computing is where you, put

114
00:08:08,404 --> 00:08:13,124
the knowledge into action almost so that
cloud computing is not just a massive

115
00:08:13,144 --> 00:08:18,824
storage space, which makes it, not really
cost effective and also that the insight

116
00:08:18,824 --> 00:08:22,384
that you can generate are then limited
because there's just way too many data.

117
00:08:22,404 --> 00:08:27,424
But you use edge computing as a
way to filter data and to specify

118
00:08:27,454 --> 00:08:28,874
which one needs to be processed.

119
00:08:29,374 --> 00:08:33,014
So this can support
then a timely reaction.

120
00:08:33,154 --> 00:08:36,954
So you're not overwhelming the
system, but also system resilience.

121
00:08:37,854 --> 00:08:42,714
Now, how can we move to the
edge and beyond to the cloud?

122
00:08:43,484 --> 00:08:49,894
Basically, if we implement edge
computing, or, if we expand the industrial

123
00:08:49,894 --> 00:08:54,334
automation network, so include edge
computing and then the cloud, you need

124
00:08:54,394 --> 00:08:58,324
a number of, systems and applications.

125
00:08:58,784 --> 00:09:02,184
And all, This needs to run somewhere.

126
00:09:02,184 --> 00:09:07,554
You need middleware to support this
data request, data exchange, etc.

127
00:09:07,874 --> 00:09:10,184
So application servers, are needed.

128
00:09:10,994 --> 00:09:14,344
Now when it comes to application
servers, you can either create

129
00:09:14,344 --> 00:09:17,904
your own solution or rely on
something that is already available.

130
00:09:18,524 --> 00:09:23,814
And, just like I doubt that, any,
manufacturing facility would develop

131
00:09:23,814 --> 00:09:28,634
its own robot, here, also in this
case, it might be best just to rely on

132
00:09:28,634 --> 00:09:30,754
existing application server technology.

133
00:09:31,294 --> 00:09:34,894
And, for a number of reasons,
you just don't want to.

134
00:09:35,394 --> 00:09:40,844
Put additional workload on your existing
team, which might not have the expertise,

135
00:09:41,194 --> 00:09:46,964
might not be able to rely on support,
but also the cost and time resource time

136
00:09:46,964 --> 00:09:49,274
and resources would be extraordinary.

137
00:09:49,774 --> 00:09:55,124
So here, I just wanted to show you what
a sort of a potential, diagram of a

138
00:09:55,124 --> 00:09:59,554
network where robots then communicate
to the edge and the cloud look like.

139
00:09:59,954 --> 00:10:05,754
this is based on a recent study and,
now, my colleague Peter will talk

140
00:10:05,764 --> 00:10:10,094
you a bit more about application
servers and the application platforms.

141
00:10:10,594 --> 00:10:11,234
Thank you, Tiara.

142
00:10:11,774 --> 00:10:15,614
so now we are, going to
application platform, what it

143
00:10:15,614 --> 00:10:17,494
is and why we should, about it.

144
00:10:18,044 --> 00:10:23,224
when we, develop an application,
you, realize that you need, to access

145
00:10:23,224 --> 00:10:27,964
lots of, various resources, organize
them, introduce some configuration

146
00:10:28,354 --> 00:10:33,439
and later you get into issues like
Horizontal scaling and load balancing,

147
00:10:33,959 --> 00:10:39,599
you will need to, ensure some level
of security and of course compliance.

148
00:10:39,889 --> 00:10:44,719
And this all functionality is something
that can be just provided by application

149
00:10:44,719 --> 00:10:49,269
platform and not necessarily to be
developed by every single application.

150
00:10:49,769 --> 00:10:54,629
So basically the, the role of the
application platform is simplify

151
00:10:54,679 --> 00:10:57,079
the development of applications.

152
00:10:57,449 --> 00:11:02,489
It provides, lots of, services,
to the developers and, do

153
00:11:02,489 --> 00:11:03,739
these, these, functionalities.

154
00:11:04,239 --> 00:11:10,379
It provides management of resources
if it is, threat to pools, database

155
00:11:10,379 --> 00:11:15,429
connection pools, the whole, stuff
around security, set up it's,

156
00:11:15,429 --> 00:11:17,619
done by the resource management.

157
00:11:18,129 --> 00:11:22,899
if there is necessary to, connect
to some other, middleware, the

158
00:11:22,899 --> 00:11:29,439
service usually provide, plugins
to, To connect to these services.

159
00:11:29,439 --> 00:11:33,979
So if you want to be informed, if
something happens, if you want to

160
00:11:33,989 --> 00:11:40,619
be informed in some teams channel or
some select channel, it's possible

161
00:11:40,659 --> 00:11:43,089
if you need to integrate this.

162
00:11:43,974 --> 00:11:47,814
Messaging systems, you can
send messages just using the

163
00:11:47,844 --> 00:11:50,164
existing, plugins platforms.

164
00:11:50,414 --> 00:11:55,754
Very typically do care about failing
and provide, support for code balancing.

165
00:11:55,764 --> 00:12:00,624
So usually it's, Pretty easy
to, scale to some level, just

166
00:12:00,624 --> 00:12:02,304
automatically on the platform.

167
00:12:02,314 --> 00:12:06,994
Not to the level which provides
cloud, but, to some higher level,

168
00:12:07,524 --> 00:12:12,419
several, machines or at least, or to
level of several tens of machines.

169
00:12:12,919 --> 00:12:20,219
And of course, security is a natural
part of the platform, and the

170
00:12:20,699 --> 00:12:28,609
servers are certified and verified,
so they are much easier to be

171
00:12:28,639 --> 00:12:31,529
compliant with the company policies.

172
00:12:32,029 --> 00:12:37,009
If the application is developed
with a platform, There is no need

173
00:12:37,059 --> 00:12:42,459
to self assembly all the necessary
libraries and parts together.

174
00:12:42,559 --> 00:12:44,199
It's provided by the platform.

175
00:12:44,649 --> 00:12:45,949
They all work together.

176
00:12:46,009 --> 00:12:48,389
They provide versioned,
versioned, runtime.

177
00:12:48,469 --> 00:12:57,149
So it's, Easy to upgrade because every
time you upgrade a new version, you are

178
00:12:57,149 --> 00:12:59,919
sure that all the parts work together.

179
00:13:00,309 --> 00:13:06,049
So the upgrade of one part
doesn't break the whole setup.

180
00:13:06,549 --> 00:13:08,399
The security is built in.

181
00:13:08,479 --> 00:13:10,039
so it's easy to.

182
00:13:10,484 --> 00:13:16,094
to implement it, the platforms typically,
provide monitoring, health checking,

183
00:13:16,594 --> 00:13:19,044
high availability, scalability.

184
00:13:19,544 --> 00:13:23,724
So the development can just focus
on the application and not to take

185
00:13:23,734 --> 00:13:27,094
care of all the fun piece around it.

186
00:13:27,174 --> 00:13:33,524
it, works as a managed software supply
chain, just part of the libraries.

187
00:13:33,524 --> 00:13:33,604
That's it.

188
00:13:34,104 --> 00:13:40,454
How to choose the right framework,
for, yes, it's important to, have,

189
00:13:40,524 --> 00:13:45,874
open and, backward compatible,
technologies because they allow

190
00:13:45,974 --> 00:13:49,174
to be flexible if you don't like.

191
00:13:49,274 --> 00:13:55,044
One, platform you can very easily to start
using another, especially in the case

192
00:13:55,044 --> 00:13:57,714
of Jakarta, the service are compatible.

193
00:13:57,764 --> 00:14:03,544
they are interchange interchangeable
to a big level and, they,

194
00:14:03,644 --> 00:14:05,954
provide long, big compatibility.

195
00:14:05,984 --> 00:14:11,674
So the programs which are
developed years or 20 years ago,

196
00:14:11,674 --> 00:14:13,954
they are still able to run today.

197
00:14:14,454 --> 00:14:20,814
It's, easy to use, systems which support
IOT because, plug plugins to the platform.

198
00:14:20,824 --> 00:14:24,094
provide for example NM QTP, support.

199
00:14:24,094 --> 00:14:27,324
So it's something that's
already done for vendors.

200
00:14:28,229 --> 00:14:35,859
the broader, broader language, range of
devices is supported by the platform.

201
00:14:36,359 --> 00:14:43,129
And, also, because, usage of a
standardized platform, means, standard

202
00:14:43,129 --> 00:14:48,559
using standards like JMS, messaging
systems, it's, possible to, cooperate with

203
00:14:48,559 --> 00:14:54,609
other industry players on this standard
level and why we chose Jakarta ee.

204
00:14:55,449 --> 00:15:00,279
This specific platform provides
huge vendor neutrality.

205
00:15:00,549 --> 00:15:07,509
The, the standard is, agreed among
big players in the industry, and,

206
00:15:07,759 --> 00:15:10,449
all the servers must, pass, tests.

207
00:15:10,949 --> 00:15:16,909
The same test, so the same application,
they'll run against each of the,

208
00:15:16,959 --> 00:15:18,509
servers from various vendors.

209
00:15:18,509 --> 00:15:24,859
So the customer only chooses some
additional, some additional values of the

210
00:15:24,859 --> 00:15:31,159
server or regard, or, takes care who is
providing them, to what's the reliability

211
00:15:31,279 --> 00:15:36,869
of the servers, other features, but
it's possible to change the vendors.

212
00:15:36,869 --> 00:15:36,929
Thanks.

213
00:15:37,679 --> 00:15:38,979
There is no vendor locking.

214
00:15:39,919 --> 00:15:45,129
The specifications are open, so it's
very easy to, to check, what the,

215
00:15:45,629 --> 00:15:49,889
what the functionality should do and
what are the expectations and, what

216
00:15:49,889 --> 00:15:52,879
is the level of, service and details.

217
00:15:53,379 --> 00:15:58,589
the parts of Jakarta ee cooperate
together, so the specification,

218
00:15:58,639 --> 00:16:03,449
work together, without any issue
and, the service, are able to

219
00:16:03,449 --> 00:16:04,889
cooperate between themselves.

220
00:16:05,099 --> 00:16:06,479
For example, the JMS.

221
00:16:07,074 --> 00:16:07,764
In a simple way.

222
00:16:08,264 --> 00:16:08,534
Okay.

223
00:16:08,534 --> 00:16:13,244
The Jakarta is, driven by
development, by community.

224
00:16:13,544 --> 00:16:20,014
There is, board across the big,
players in, and, they agree on the

225
00:16:20,164 --> 00:16:25,474
new features, and, changes in the
function of the, in the, in the global

226
00:16:25,474 --> 00:16:28,064
direction, where the development goals.

227
00:16:28,564 --> 00:16:33,024
The huge advantage is stability,
backward compatibility.

228
00:16:33,024 --> 00:16:37,704
So application written 15 years
ago, they are still working.

229
00:16:38,234 --> 00:16:43,914
there is only one problem with the
package renaming in the, Java world.

230
00:16:44,854 --> 00:16:49,564
this, and for this, there are
tools which help to, which

231
00:16:49,564 --> 00:16:52,064
help, to, upgrade the sources.

232
00:16:52,589 --> 00:16:53,779
in a very fast way.

233
00:16:54,369 --> 00:17:01,649
So the same program is able to the
program written in 2008 is able to run

234
00:17:01,679 --> 00:17:04,769
on the on today's servers very quickly.

235
00:17:04,869 --> 00:17:08,539
there are very few backward
incompatible changes.

236
00:17:09,039 --> 00:17:17,699
Also, the servers, support multiple,
multiple platforms from Java versions.

237
00:17:18,209 --> 00:17:22,729
there are always several versions
of LTS Javas, which are supported

238
00:17:23,179 --> 00:17:25,979
and, also from operating systems.

239
00:17:26,594 --> 00:17:32,424
So it's possible to run the server
on an operating system you want in

240
00:17:32,564 --> 00:17:35,374
various code environments if necessary.

241
00:17:36,084 --> 00:17:41,644
And, the, simply Jakarta E servers
run everywhere from huge server

242
00:17:41,644 --> 00:17:44,924
to the smallest ARM machines.

243
00:17:45,024 --> 00:17:47,859
we, we deliver, arm image.

244
00:17:47,859 --> 00:17:51,999
So if, there is a application for
that, we can run on, on a planning

245
00:17:51,999 --> 00:17:54,509
arm machine ante is, modular.

246
00:17:54,719 --> 00:18:00,799
plenty of components and, if, you
want, you can choose the needed one.

247
00:18:00,829 --> 00:18:04,699
And there are simpler servers,
simpler versions of the servers.

248
00:18:05,629 --> 00:18:09,469
Which, which, start faster
and, are less demanding.

249
00:18:09,969 --> 00:18:14,549
API is robust, as it is
developed for a long time.

250
00:18:14,729 --> 00:18:20,649
It, provides full, full functionality
required from specific domains.

251
00:18:21,149 --> 00:18:26,009
And if, there is a request to run in
cloud, there is no problem with it.

252
00:18:26,589 --> 00:18:32,999
the platforms, based on Jakarta EE
usually provide auto scaling and

253
00:18:33,239 --> 00:18:36,659
they are easily running in, in cloud.

254
00:18:37,159 --> 00:18:43,539
The model of Jakarta EE, as you
see, The Jakarta EE is based

255
00:18:43,919 --> 00:18:49,419
on the set of specifications
which provide various features.

256
00:18:50,299 --> 00:18:56,739
From that, support, connection pools, the
database connection pools, monitoring,

257
00:18:57,269 --> 00:19:00,219
logging, messaging, and so on.

258
00:19:00,719 --> 00:19:05,389
And this is all provided
by the Jakarta E Server.

259
00:19:06,069 --> 00:19:11,399
We also support MicroProfile, which is
an additional set of specifications.

260
00:19:12,014 --> 00:19:15,264
especially for cloud uses,
but usages, but, they are very

261
00:19:15,634 --> 00:19:17,564
handy also in, in one server.

262
00:19:18,444 --> 00:19:20,194
You will see example of it in the demo.

263
00:19:20,694 --> 00:19:25,764
And, the only missing part in this,
model is actually your application.

264
00:19:26,454 --> 00:19:29,464
And, so it doesn't need to
take care of any service.

265
00:19:29,964 --> 00:19:30,854
It's all provided.

266
00:19:31,354 --> 00:19:34,664
The set of specification is pretty big.

267
00:19:35,294 --> 00:19:39,804
they are, they are, upgraded,
roughly around every two years.

268
00:19:39,834 --> 00:19:41,424
There is a big new version.

269
00:19:41,754 --> 00:19:47,179
So this is the description
of the upcoming Jakarta 11.

270
00:19:47,549 --> 00:19:51,819
the blue specifications are the
ones which have a new version.

271
00:19:52,409 --> 00:19:56,629
there is also one, completely new,
specification, Jakarta Data, which

272
00:19:56,629 --> 00:20:00,569
provides, easier access to, SQL databases.

273
00:20:01,069 --> 00:20:07,299
And, in the preparation it will be also,
providing data to NoSQL, databases.

274
00:20:07,799 --> 00:20:12,069
So the question is, what's
behind, every one specification?

275
00:20:12,069 --> 00:20:12,329
for listening.

276
00:20:12,909 --> 00:20:17,699
It's composed from three,
actually four parts.

277
00:20:17,959 --> 00:20:19,929
The first one is the specification itself.

278
00:20:20,499 --> 00:20:24,919
It, describes, it is documentation
of, all the features, which are

279
00:20:24,919 --> 00:20:26,819
provided by one specification.

280
00:20:27,789 --> 00:20:32,599
All the behavior of, each class
in the specification and, what are

281
00:20:32,619 --> 00:20:34,579
the expectation, expected outputs.

282
00:20:35,079 --> 00:20:41,759
Next, there, there is, API Java, API,
with interfaces, mostly interfaces,

283
00:20:42,449 --> 00:20:48,759
providing that, API to, to the
specification and a set of, tests.

284
00:20:49,379 --> 00:20:54,909
Technology compatibility kit is a huge
set of tests which verify that every

285
00:20:54,909 --> 00:21:00,059
implementation of this specification
is behaving exactly the same way.

286
00:21:01,009 --> 00:21:03,859
And this is the fourth
part, implementation.

287
00:21:04,504 --> 00:21:11,104
there are several implementation of each
of the specifications and the servers pick

288
00:21:11,174 --> 00:21:18,104
the implementations, put them there and
make, the platform working all together.

289
00:21:18,104 --> 00:21:22,034
So the developers don't need to
care about what implementation

290
00:21:22,084 --> 00:21:24,044
is used, what is the version.

291
00:21:24,344 --> 00:21:26,044
It all works together.

292
00:21:26,254 --> 00:21:28,334
There is no need to take care of this.

293
00:21:28,994 --> 00:21:30,524
It's just working.

294
00:21:31,024 --> 00:21:35,524
There are a few things which go
beyond the list of specifications

295
00:21:35,614 --> 00:21:37,324
like performance and monitoring.

296
00:21:37,894 --> 00:21:43,804
Every server provides some,
some control over performance

297
00:21:43,804 --> 00:21:45,064
and provides some monitoring.

298
00:21:45,474 --> 00:21:50,789
For example, in the concurrency,
it's possible to choose, to

299
00:21:50,789 --> 00:21:54,039
configure, the size of the trap pool.

300
00:21:54,639 --> 00:21:57,899
Also, there are many other features
which control its behavior.

301
00:21:58,509 --> 00:22:03,429
And also, it's possible to choose
which types of threads are used there.

302
00:22:03,939 --> 00:22:08,229
typically, there are the platform threads,
which are not from Java very well.

303
00:22:08,909 --> 00:22:14,059
But it's possible to use farm join
threads, which is specific to Para.

304
00:22:14,559 --> 00:22:20,019
Or it's possible to use web threats,
which is the new feature in Java, 21

305
00:22:20,319 --> 00:22:25,449
released last year, and it's part of the,
upcoming, Jakarta level and everything

306
00:22:25,449 --> 00:22:27,789
is just configurable on the server.

307
00:22:27,789 --> 00:22:33,719
so the, confi the person who co
configures the server can choose,

308
00:22:33,759 --> 00:22:35,549
which, threats are the best.

309
00:22:36,019 --> 00:22:40,049
version, best set up for
the particular use case.

310
00:22:40,669 --> 00:22:44,479
Of course, it's possible that it's,
specified by a program, whatever can

311
00:22:44,479 --> 00:22:50,349
override it, just on the size, for
example, amount of memory or power of

312
00:22:50,349 --> 00:22:55,199
the CPU or number of CPUs, which are
available on the particular server.

313
00:22:55,469 --> 00:22:59,939
So the behavior can change,
just, without the code change.

314
00:23:00,664 --> 00:23:05,774
And just based on, based on
configuration, my profile

315
00:23:05,774 --> 00:23:11,504
provides two nice, specifications
for, the use case for on edge.

316
00:23:11,514 --> 00:23:14,644
It's a metrics on health, which are just.

317
00:23:15,024 --> 00:23:21,564
Just, part of the platform, there is
nothing necessary to do, and they provide

318
00:23:21,604 --> 00:23:26,664
endpoints for Prometheus, and we will see
how to, how this can be displayed later

319
00:23:26,694 --> 00:23:28,944
in, in Grafana in a nice graphical way.

320
00:23:29,444 --> 00:23:34,994
PAR also provides, a tool called
Monitoring Console, which Also to display

321
00:23:34,994 --> 00:23:37,944
simple graphs directly in the server.

322
00:23:37,964 --> 00:23:42,334
So there is even not need and
external tools just built in.

323
00:23:42,974 --> 00:23:48,464
And of course, there are some other
ways how to monitor the server.

324
00:23:49,144 --> 00:23:49,724
Oh, good.

325
00:23:49,724 --> 00:23:50,784
JMX.

326
00:23:50,824 --> 00:23:55,504
There are some other connectors,
plugins, which are able to

327
00:23:55,514 --> 00:23:58,664
send messages and measurements.

328
00:23:59,174 --> 00:24:02,174
to the, to other, third party tools.

329
00:24:02,354 --> 00:24:08,634
And of course, there is also specific
rest, which allows to, display some

330
00:24:09,034 --> 00:24:12,394
additional internal information
if they are needed for monitoring.

331
00:24:12,894 --> 00:24:13,904
That's all from me.

332
00:24:13,964 --> 00:24:15,264
we are returning back to Chiara.

333
00:24:15,764 --> 00:24:16,414
Thank you, Peter.

334
00:24:16,904 --> 00:24:22,439
So now we looked at why Jakarta
EE platform Could be the ideal

335
00:24:22,649 --> 00:24:28,709
underlying technology to create edge
computing and in particular edge

336
00:24:28,769 --> 00:24:34,069
applications that support additional
insights into industrial robots.

337
00:24:34,699 --> 00:24:39,509
Now among all the Jakarta EE
compatible solutions, here we

338
00:24:39,509 --> 00:24:41,219
are using the Payara platform.

339
00:24:41,279 --> 00:24:42,439
So why is that?

340
00:24:43,249 --> 00:24:46,559
First, because it's highly
committed to Jakarta EE.

341
00:24:47,149 --> 00:24:52,249
and it's a, a main solutions for Jakarta
E developers because after all the

342
00:24:52,249 --> 00:24:55,469
platform is a Jakarta E first, solution.

343
00:24:55,969 --> 00:25:00,669
in particular, we, Payara Services,
so the company behind Payara Platform

344
00:25:00,679 --> 00:25:05,349
is a contributor of the Eclipse
Foundation, which is behind Jakarta Yi.

345
00:25:06,159 --> 00:25:10,089
It's a strategic members of the
Jakarta Yi Working Group and

346
00:25:10,129 --> 00:25:11,839
other associated working groups.

347
00:25:12,489 --> 00:25:16,899
In addition, when it comes to profile, we
are members of the micro profile working

348
00:25:16,899 --> 00:25:21,489
group, and we are part of the project
management committee for Jakarta EE.

349
00:25:21,829 --> 00:25:24,899
So we are really committed to this
platform and we believe this is

350
00:25:24,899 --> 00:25:28,909
the right solution for industrial
automation applications of the future.

351
00:25:29,409 --> 00:25:34,589
Now, Let's have a closer look at
what the Payara platform can offer

352
00:25:34,649 --> 00:25:36,299
for such specific application.

353
00:25:36,299 --> 00:25:42,349
We said that, stability, resilience, and
security were extremely important because,

354
00:25:42,349 --> 00:25:44,754
of course, we don't want to accumulate.

355
00:25:44,874 --> 00:25:50,134
Expose our robots to, additional
risk and vulnerable vulnerabilities,

356
00:25:50,134 --> 00:25:51,904
just to get some additional insights.

357
00:25:52,314 --> 00:25:57,664
So the Payara platform is stable and
fully supported, it's designed for

358
00:25:57,674 --> 00:25:59,884
mission critical production environments.

359
00:26:00,864 --> 00:26:06,394
With a long, software like cycle of
a minimum of 10 years, so that, for

360
00:26:06,394 --> 00:26:13,044
example, industrial automation plants,
with, robots at different stages of

361
00:26:13,044 --> 00:26:16,224
their life cycle can, be supported.

362
00:26:16,634 --> 00:26:22,234
There are security alerts and patches
with a monthly, release, so it complies

363
00:26:22,254 --> 00:26:28,694
with regulatory bodies, and, Users can
benefit from migration project support

364
00:26:28,744 --> 00:26:33,654
as well as full engineering support
that is available either 24 seven or

365
00:26:33,654 --> 00:26:38,684
ten four five, depending on what the
team needs and within the play our

366
00:26:38,684 --> 00:26:43,034
platform, users can benefit from the
pay our server, which is the, let's say,

367
00:26:43,094 --> 00:26:47,994
traditional application server, as well
as pay our micro that is, a bit more

368
00:26:47,994 --> 00:26:53,374
tailored for, Cloud applications, and
then we've got, Payara Cloud that is a

369
00:26:53,374 --> 00:26:55,494
bit beyond the scope of today's talk.

370
00:26:55,534 --> 00:26:59,674
it's a fully managed, application
runtime for cloud deployments.

371
00:27:00,254 --> 00:27:04,684
Now, here the Payara platform is
really designed for deployments

372
00:27:04,684 --> 00:27:09,074
that are, leveraging IoT, edge
computing, and cloud computing.

373
00:27:09,074 --> 00:27:11,094
So what we are talking exactly today.

374
00:27:11,164 --> 00:27:16,309
And just to have a closer look,
Basically, the Pajaro platform can

375
00:27:16,339 --> 00:27:18,249
help you build intelligent servers.

376
00:27:18,729 --> 00:27:25,279
And, this is because, for example, the
IOT devices can send data over MQTT cloud

377
00:27:25,279 --> 00:27:30,799
connector, with MQTT being pretty much
the de facto standard in the industry.

378
00:27:31,209 --> 00:27:36,269
and basically they can send this
data, on the edge, and then,

379
00:27:36,279 --> 00:27:40,139
Business logic, aggregate, and
data analysis can be performed.

380
00:27:40,749 --> 00:27:45,009
then if you look at what happens in the
cloud, for example, you may think to

381
00:27:45,009 --> 00:27:50,179
have Pyara Micro as your go to solution
because it is optimized to work in

382
00:27:50,189 --> 00:27:54,279
containerized environments, while being
lightweight, of course, and compact so

383
00:27:54,289 --> 00:27:57,879
that it doesn't use a lot of resources
and it's ideal for cloud deployments.

384
00:27:58,379 --> 00:28:04,049
So here, of course, when, if we
are really tackling a, industrial

385
00:28:04,059 --> 00:28:08,559
automation application, of course, it
is recommended for any potential user

386
00:28:08,559 --> 00:28:12,539
to rely on the Enterprise Edition,
which offer exactly the full support.

387
00:28:12,969 --> 00:28:17,799
And is suitable for, mission critical
application in production environments.

388
00:28:18,299 --> 00:28:24,009
Now, Peter prepared a very nice
demo showcasing how we can, use,

389
00:28:24,009 --> 00:28:29,219
the platform and Jakarta E of
course, to, send robotic data.

390
00:28:29,859 --> 00:28:30,679
To the cloud.

391
00:28:31,179 --> 00:28:31,989
Thank you, Chiara.

392
00:28:32,659 --> 00:28:40,839
So now we are going to a pretty simple
demo of how such edge computing can

393
00:28:41,029 --> 00:28:44,299
look like and how to do an easy way.

394
00:28:44,659 --> 00:28:46,589
What on the screen is.

395
00:28:47,219 --> 00:28:53,379
monitoring of the edge computer,
it shows how the data is processed.

396
00:28:53,389 --> 00:28:58,089
We will go through everything during
the demo and on the right side,

397
00:28:58,089 --> 00:29:00,719
you see the simulation of robots.

398
00:29:00,999 --> 00:29:03,849
This is running on a separate computer.

399
00:29:03,849 --> 00:29:08,129
So so it properly simulates
sending remote requests.

400
00:29:08,604 --> 00:29:14,734
The data is, sent from, from, re,
from files with, recorded, real data.

401
00:29:15,274 --> 00:29:21,374
And they are processed in the, they are
stored and eventually can be filtered

402
00:29:21,434 --> 00:29:23,884
and, pre processed on the Edge computer.

403
00:29:24,564 --> 00:29:28,634
And then they are sent further
for the next processing, as Chiara

404
00:29:28,634 --> 00:29:32,634
mentioned, for some, analysis, some
data mining on top of the data.

405
00:29:32,634 --> 00:29:32,774
Thank you.

406
00:29:33,274 --> 00:29:37,214
And, we don't care about this part,
in this presentation, we assume that

407
00:29:37,224 --> 00:29:42,684
there is some cluster of computers,
or, that can be, more powerful computer

408
00:29:42,684 --> 00:29:44,974
or just a cloud with load balancer.

409
00:29:44,974 --> 00:29:47,294
So we will just send data somewhere else.

410
00:29:47,794 --> 00:29:51,994
So let's start with the whole, procedure.

411
00:29:52,324 --> 00:29:55,264
Now, the data which we are using.

412
00:29:55,844 --> 00:30:04,204
There are various sets of, data and,
there are various, examples of, samples

413
00:30:04,264 --> 00:30:11,454
of from one, one source and, this is
the format of the data time, position

414
00:30:11,454 --> 00:30:13,869
of the arm temperature and voltage.

415
00:30:14,769 --> 00:30:19,119
And there are, lots of the data
like three and a half thousand,

416
00:30:19,659 --> 00:30:21,549
measurements in, in one set.

417
00:30:21,939 --> 00:30:30,199
And once this set is, sent to the, to the
edge computer, it's considered one cycle.

418
00:30:30,239 --> 00:30:33,409
so the clients, the machine says.

419
00:30:34,234 --> 00:30:41,924
And now I finished, and the Edge computer,
sends the whole set for further analysis

420
00:30:42,064 --> 00:30:44,374
somewhere, for the, for the processing.

421
00:30:44,854 --> 00:30:47,374
what do we need to start?

422
00:30:48,119 --> 00:30:54,599
Is we need on the, on the remote
machine, which is this one.

423
00:30:55,099 --> 00:30:57,559
We need to start the edge computer.

424
00:30:58,059 --> 00:31:01,079
So this is this machine.

425
00:31:01,109 --> 00:31:06,869
Usually it starts with the application
with the start of the server.

426
00:31:07,469 --> 00:31:07,989
Okay.

427
00:31:08,789 --> 00:31:11,519
And we also start monitoring.

428
00:31:12,019 --> 00:31:14,769
We use Prometheus and Grafana configured.

429
00:31:15,319 --> 00:31:18,379
to the, to the sources we have.

430
00:31:18,879 --> 00:31:26,099
Also, we need to run the, the simulator
of, of, the data mining and processes.

431
00:31:26,099 --> 00:31:29,212
So we run on different
computer this thing.

432
00:31:29,212 --> 00:31:30,919
And we are ready.

433
00:31:30,919 --> 00:31:37,019
We are ready to start, to
start the data generator.

434
00:31:37,399 --> 00:31:40,809
We will just verify that everything works.

435
00:31:41,569 --> 00:31:43,539
So here is the edge computer.

436
00:31:44,039 --> 00:31:47,209
It tells us that nothing happened so far.

437
00:31:47,219 --> 00:31:48,339
It's fine.

438
00:31:48,839 --> 00:31:54,627
And we will, we should
look at the graphical data.

439
00:31:55,127 --> 00:31:56,687
graphical representation.

440
00:31:57,412 --> 00:31:58,622
So the server is up.

441
00:31:59,142 --> 00:32:00,462
No data is processed.

442
00:32:01,392 --> 00:32:02,852
Uptime is a minute.

443
00:32:03,102 --> 00:32:04,382
Classes were loaded.

444
00:32:05,142 --> 00:32:08,742
there is almost no, memory used so far.

445
00:32:09,242 --> 00:32:11,262
And everything's fine.

446
00:32:11,762 --> 00:32:12,372
Okay.

447
00:32:12,892 --> 00:32:17,627
for the servers, we provide
also, graphical interface.

448
00:32:18,127 --> 00:32:22,227
Which, can control the whole,
configuration of the server.

449
00:32:22,727 --> 00:32:28,497
So here we see this is the machine
which contains the data miner.

450
00:32:28,997 --> 00:32:33,477
And the data miner has very simple, UI.

451
00:32:34,057 --> 00:32:38,882
Okay, so now we can start
with, the processing of, data.

452
00:32:39,742 --> 00:32:42,252
So here we start, with the processors.

453
00:32:42,787 --> 00:32:49,124
As it is simulation, we will
start with just 10, 10 sources of

454
00:32:49,124 --> 00:32:50,710
the data to send to the server.

455
00:32:51,210 --> 00:32:55,840
A short compilation of the sources to
verify that we are on the latest version.

456
00:32:56,340 --> 00:32:57,490
And we start.

457
00:32:57,990 --> 00:32:59,850
So you see there are 10 servers.

458
00:33:00,575 --> 00:33:06,585
Sending, depending on the size of
the, dataset they are sending, data.

459
00:33:06,765 --> 00:33:13,025
And, also, there are various, cycles
depending on the speed of the processing.

460
00:33:13,525 --> 00:33:22,505
So we can easily, we can quickly review,
the data in our, measurement to see that.

461
00:33:23,015 --> 00:33:33,375
How far it is currently 150, 000, data,
which are, 78 data sets, asked for data

462
00:33:33,375 --> 00:33:35,975
mining and 53 of them is already done.

463
00:33:36,475 --> 00:33:38,265
we can look at the metrics.

464
00:33:38,265 --> 00:33:43,638
So right now we are
about 300, 000, records.

465
00:33:44,038 --> 00:33:46,144
The memory is warming up.

466
00:33:46,144 --> 00:33:49,761
The, the system is forming up.

467
00:33:49,761 --> 00:33:53,283
We see some timing, things.

468
00:33:53,743 --> 00:33:58,713
In this diagram, we see, number of,
requests and number of, process.

469
00:33:59,248 --> 00:34:00,658
processed, data minings.

470
00:34:00,688 --> 00:34:02,833
So everything is, working nicely.

471
00:34:02,893 --> 00:34:09,833
And this is how we see how fast is the
data process and, the amount of the data.

472
00:34:10,493 --> 00:34:18,283
So what we can try now to have some little
bit more interesting graphs, we can stop.

473
00:34:18,783 --> 00:34:25,403
So we should be able to see that the,
it stopped sending data, the graphs.

474
00:34:26,373 --> 00:34:32,243
Should flatten, it, it takes several
seconds, for, both, collecting data

475
00:34:32,283 --> 00:34:38,363
and the refresh of, Grafana, but
you'll see that, that, the data

476
00:34:38,373 --> 00:34:43,443
stopped being sent, to make everything
clear, we can clear the data.

477
00:34:43,913 --> 00:34:45,793
So we start fresh.

478
00:34:46,293 --> 00:34:47,233
second, that'll be.

479
00:34:47,958 --> 00:34:54,638
Zero in the data received and we
can, yeah, we can start with the,

480
00:34:55,138 --> 00:34:59,298
let's say a little bit more,
a little bit more, sources.

481
00:34:59,398 --> 00:35:07,868
So imagine a really big factory
with 100 different machines sending

482
00:35:07,888 --> 00:35:10,098
its data as quickly as possible.

483
00:35:10,098 --> 00:35:11,758
So let's start with 100.

484
00:35:12,258 --> 00:35:13,388
So now we can.

485
00:35:13,888 --> 00:35:16,208
We can run 100, subsystem.

486
00:35:16,218 --> 00:35:17,928
Let's see what happens on the server.

487
00:35:18,428 --> 00:35:24,718
Now there is 100, servers, trying
to fill the, fill the server.

488
00:35:25,218 --> 00:35:26,758
Can display the, internal.

489
00:35:27,258 --> 00:35:31,198
they have 65, 000 sets.

490
00:35:31,198 --> 00:35:34,518
And that it's increasing.

491
00:35:35,018 --> 00:35:41,158
So the server is able to handle just
without any specific configuration,

492
00:35:42,008 --> 00:35:44,978
able to handle pretty big, loads.

493
00:35:45,488 --> 00:35:47,388
so this also can be configured.

494
00:35:48,318 --> 00:35:51,278
to provide, better, better performance.

495
00:35:51,338 --> 00:35:56,608
Of course, the example is, is
predator also, there is no, no clever,

496
00:35:56,718 --> 00:36:03,328
clever caching or anything, just,
just a stock version of the cell.

497
00:36:03,828 --> 00:36:05,118
So this is how it works.

498
00:36:05,668 --> 00:36:13,418
I would like to just show what happens
if, the server will stop working.

499
00:36:13,418 --> 00:36:17,848
so how it is visible in
the, in the monitoring.

500
00:36:18,348 --> 00:36:20,223
So here we will see.

501
00:36:20,723 --> 00:36:26,163
On the upper left, corner that the
server is down in, this graph is down.

502
00:36:26,163 --> 00:36:31,563
So there, there can be some art,
to the monitor of the whole setup

503
00:36:31,563 --> 00:36:37,653
that something's go going wrong,
and that the server is down, which

504
00:36:37,653 --> 00:36:39,838
is of course, not the usual case.

505
00:36:40,338 --> 00:36:48,598
Yep, so that's, something what, we can,
end with the demo here, but I would like

506
00:36:48,608 --> 00:36:53,428
to share how the, how the demo was done.

507
00:36:53,678 --> 00:36:57,348
So this is the pretty
trivial, edge computing.

508
00:36:57,688 --> 00:37:04,378
It's just storing data in the cache
and provide some, counters, So it's

509
00:37:04,518 --> 00:37:11,268
typical, best endpoint with, with
processing data, which only stores data.

510
00:37:11,938 --> 00:37:14,678
This is just logging
and some, functionality.

511
00:37:15,668 --> 00:37:21,878
And all the measurement is done by
just annotating the, method with the,

512
00:37:21,878 --> 00:37:24,608
micro profile metrics annotation.

513
00:37:25,148 --> 00:37:30,428
And, I also try to provide
some more information.

514
00:37:30,928 --> 00:37:34,588
Again, predatorial things, and
they are then all visible here.

515
00:37:34,708 --> 00:37:38,538
These are the values which
are provided by the server.

516
00:37:39,038 --> 00:37:45,748
This is the end of the demo,
and I will just finish it's

517
00:37:45,748 --> 00:37:47,728
a little bit more optimistic.

518
00:37:48,238 --> 00:37:56,228
And so in a second, we will get it Up
again, and this is the end of the demo.

519
00:37:56,418 --> 00:38:03,268
So thanks and I'm resending words to
back to Kiara for the final words Thank

520
00:38:03,268 --> 00:38:08,738
you, Peter So just summarizing what we've
discussed today robot based industrial

521
00:38:08,748 --> 00:38:13,678
automation operation can greatly benefit
from the cloud for additional insights

522
00:38:14,188 --> 00:38:21,023
however You cannot just blindly adopt
the cloud, but you need a edge and,

523
00:38:21,033 --> 00:38:25,133
of course, a suitable technology is
needed to create an effective edge.

524
00:38:25,613 --> 00:38:30,839
the technology should rely on openness,
a certain standardization, as well

525
00:38:30,839 --> 00:38:33,247
as offer flexibility and scalability.

526
00:38:33,778 --> 00:38:37,668
This is why we've chosen Jakarta E
and Payara platform for the demo.

527
00:38:38,658 --> 00:38:44,698
And we've shown how a Jakarta E specific
Payara platform can offer the ideal

528
00:38:44,738 --> 00:38:48,718
application server for creating a
cutting edge, industrial internet of

529
00:38:48,718 --> 00:38:52,928
things that leverages edge computing
and cloud computing to advance.

530
00:38:53,523 --> 00:38:55,113
robot applications.

531
00:38:55,593 --> 00:38:59,073
Now, thank you so much
for attending this talk.

532
00:38:59,233 --> 00:39:00,303
I hope you had a good time.

533
00:39:00,313 --> 00:39:03,353
If you've got any questions, feel
free to get in touch with myself or

534
00:39:03,353 --> 00:39:06,303
Peter and enjoy the rest of the talks.

535
00:39:06,803 --> 00:39:07,573
So thank you.

536
00:39:07,603 --> 00:39:07,903
And goodbye.

537
00:39:08,403 --> 00:39:14,013
Hi, I am Chiara, and welcome to
this session at the Confo 42 IoT.

538
00:39:14,513 --> 00:39:19,003
Together with me is my speaker,
is my co speaker, Peter.

539
00:39:19,503 --> 00:39:19,953
Hello.

540
00:39:20,453 --> 00:39:24,723
Today we'll be talking about creating
advanced robotic application, the

541
00:39:24,723 --> 00:39:31,503
leverage, edge computing, and cloud
computing to create next level IoT.

542
00:39:32,003 --> 00:39:37,368
So before we start, I know I cannot see
you, but I'm going to ask you all that

543
00:39:37,478 --> 00:39:40,068
are attending this talk a question.

544
00:39:40,798 --> 00:39:43,408
Can you imagine a robot?

545
00:39:43,578 --> 00:39:46,238
What do you think is the
most common robot right now?

546
00:39:47,208 --> 00:39:51,358
Is it a humanoid, so with
like human like features?

547
00:39:52,148 --> 00:39:56,728
Is it a droid, so perhaps it has
weird shapes and functionalities?

548
00:39:57,228 --> 00:40:02,658
Or is it more like an exoskeleton,
thinking like Iron Man, for example?

549
00:40:03,158 --> 00:40:06,418
And now from here I'm probably going
to disappoint all of you because the

550
00:40:06,418 --> 00:40:14,218
most common type of robot currently
is just a robotic arm or a delta arm.

551
00:40:14,718 --> 00:40:20,848
So these have different axes that can
move, they don't look like a human,

552
00:40:20,848 --> 00:40:24,368
they don't look like a droid, and
they're definitely not exoskeletons.

553
00:40:25,118 --> 00:40:29,178
but they are the most common and just
to give you some facts and figures.

554
00:40:29,678 --> 00:40:35,468
Just to give you some stats in 2023,
there were over 541, 000 robots

555
00:40:35,468 --> 00:40:37,468
installed in factories worldwide.

556
00:40:38,258 --> 00:40:44,398
With a robot density of 162
units every 10, 000 employees.

557
00:40:45,278 --> 00:40:49,188
Now, the robot density is just
a sort of barometer to track the

558
00:40:49,188 --> 00:40:53,368
degree of automation adoption in the
manufacturing industry around the world.

559
00:40:53,368 --> 00:40:53,667
for listening.

560
00:40:54,217 --> 00:40:56,097
where are these robots?

561
00:40:56,487 --> 00:41:02,627
most of these, 500, 000 units, they
are in two sectors, the automotive and

562
00:41:02,637 --> 00:41:08,657
the electronics, which make almost 50
percent of industrial robot installations.

563
00:41:09,197 --> 00:41:16,157
Now, why, the automotive industry mostly
deals with very heavy pieces of equipment

564
00:41:16,167 --> 00:41:18,547
that needs to be assembled at high speed.

565
00:41:19,252 --> 00:41:21,782
of course, robots are perfect for that.

566
00:41:22,172 --> 00:41:25,052
Whereas in the electronic industries,
the components are much, much

567
00:41:25,052 --> 00:41:28,932
smaller, but they are also highly
sensitive to contamination.

568
00:41:28,992 --> 00:41:32,502
robots are perfect for
clean room environments.

569
00:41:33,002 --> 00:41:39,112
And With all these robots, I'm going
to share another very sad fact.

570
00:41:39,612 --> 00:41:41,102
They rarely see a cloud.

571
00:41:41,112 --> 00:41:45,062
All these 541, 000 robots
rarely see a cloud.

572
00:41:45,352 --> 00:41:50,022
And here, of course, I'm not talking
about real clouds, but digital cloud.

573
00:41:50,942 --> 00:41:53,192
Now, why should robots see the cloud?

574
00:41:53,202 --> 00:41:55,322
Why should they send data to the cloud?

575
00:41:55,972 --> 00:42:02,032
To gain additional insights, pretty
much, and to improve operations.

576
00:42:02,682 --> 00:42:09,042
by having robots send some of
their information to the cloud, the

577
00:42:09,042 --> 00:42:13,472
nation can access them at any time
to check for their performance,

578
00:42:13,492 --> 00:42:19,552
identify issues, as well as take any
preventative step to avoid downtime.

579
00:42:19,687 --> 00:42:22,307
Or to resolve downtime
as quickly as possible.

580
00:42:22,807 --> 00:42:28,587
basically you can monitor and analyze in
a near real time data, what the robots

581
00:42:28,587 --> 00:42:32,387
are doing remotely from anywhere in the
world, even if you're not in the plant.

582
00:42:33,307 --> 00:42:33,807
so what.

583
00:42:33,867 --> 00:42:38,057
What happens is that technicians
can detect potential issues before

584
00:42:38,057 --> 00:42:39,987
they escalate into major problems.

585
00:42:40,777 --> 00:42:42,917
this supports, of course,
proactive maintenance.

586
00:42:43,757 --> 00:42:48,417
by identifying early signs of failure,
technicians can schedule maintenance

587
00:42:48,417 --> 00:42:54,227
activities during planned downtime, and
this reduces unscheduled downtime and

588
00:42:54,227 --> 00:42:56,917
improves overall machine reliability.

589
00:42:57,417 --> 00:43:03,227
But also what you can do is then support
more advanced predictive maintenance

590
00:43:03,237 --> 00:43:08,887
strategies because you can analyze data
from multiple robots across your factory

591
00:43:08,887 --> 00:43:13,847
floor, for example, or across multiple
manufacturing facilities, and you can

592
00:43:13,867 --> 00:43:19,267
compare performance across different
time periods to gain key insights, for

593
00:43:19,267 --> 00:43:21,667
example, into potential improvements.

594
00:43:21,942 --> 00:43:25,422
and make more informed
data driven decisions.

595
00:43:26,142 --> 00:43:33,032
And also, because you can leverage then,
AI or machine learning algorithm, you

596
00:43:33,032 --> 00:43:39,822
can process the data, for example, on
maintenance or failures to predict,

597
00:43:39,823 --> 00:43:44,463
machine failure before they actually occur
based on the historical data available.

598
00:43:45,238 --> 00:43:50,888
And of course, this means that you don't
need to have a friend, almost random

599
00:43:50,898 --> 00:43:56,768
scheduled maintenance activities, but
you can take preemptive measures like

600
00:43:56,768 --> 00:44:02,118
replacing worn out components only when
it's needed, minimizing again, downtime

601
00:44:02,158 --> 00:44:04,048
and improving cost effectiveness.

602
00:44:04,548 --> 00:44:07,258
Now, why aren't robots
sending data to the cloud?

603
00:44:07,598 --> 00:44:11,868
the first point is there are way too
many data generated on the shop floor

604
00:44:11,878 --> 00:44:14,608
by robots, their controllers, etc.

605
00:44:14,648 --> 00:44:15,948
And way too quickly.

606
00:44:16,658 --> 00:44:20,558
And most of the data that are produced
on the factory floor for these

607
00:44:20,928 --> 00:44:24,928
automated operations, Is very fast.

608
00:44:24,988 --> 00:44:30,948
it's a lot of data and, so of course,
we need to consider that we still

609
00:44:30,958 --> 00:44:36,578
want the robots and the industrial
automation processes to operate.

610
00:44:36,888 --> 00:44:38,458
We don't want to.

611
00:44:38,693 --> 00:44:43,193
impact these operation because we
want to do additional analytics.

612
00:44:44,103 --> 00:44:50,043
of course, yes, the cloud can process
this data, but it probably cannot

613
00:44:50,073 --> 00:44:55,273
compete with the current capabilities
of, for example, industrial Ethernet

614
00:44:55,623 --> 00:44:58,203
for industrial automation processes.

615
00:44:58,703 --> 00:45:03,573
Now, For example, generally for
industrial automation networks, we

616
00:45:03,573 --> 00:45:07,953
are talking about a bandwidth with,
100 megabit per second or one gigabit

617
00:45:08,453 --> 00:45:10,273
per second, in terms of bandwidth.

618
00:45:10,773 --> 00:45:16,283
And if the data, this time sensitive
data are not transmitted, what happens

619
00:45:16,293 --> 00:45:19,503
is that the entire operation stops.

620
00:45:20,123 --> 00:45:26,123
So cloud computing here could
be a potential issue because it

621
00:45:26,133 --> 00:45:28,073
doesn't process data that quickly.

622
00:45:28,083 --> 00:45:30,843
It cannot probably handle
that volume of data.

623
00:45:31,133 --> 00:45:34,613
And also the cost can
be extremely elevated.

624
00:45:34,903 --> 00:45:38,823
so of course, using cloud computing
could potentially overwhelm

625
00:45:38,863 --> 00:45:41,702
your, IT and shop floor system.

626
00:45:41,732 --> 00:45:42,662
And you don't want that.

627
00:45:43,202 --> 00:45:47,852
in addition, what we also need
to consider is that, there are

628
00:45:47,852 --> 00:45:51,802
cyber security and visibility
issue that need to be considered.

629
00:45:52,192 --> 00:45:57,182
typically, shop floor are, have been
isolated with their industrial Ethernet

630
00:45:57,372 --> 00:46:02,582
because the access to the internet and the
cloud could potentially open up ways for

631
00:46:02,582 --> 00:46:08,997
cyber criminals and hackers to, access,
the equipment and potentially, stop all

632
00:46:09,007 --> 00:46:10,957
operation on the, manufacturing plant.

633
00:46:11,457 --> 00:46:15,447
in addition, related to the previous
issues, we don't want any latency.

634
00:46:15,767 --> 00:46:20,047
and finally, industrial automation
operation, because they tend to have

635
00:46:20,187 --> 00:46:26,467
extremely long service lives for their
equipment of about 25 years, they need

636
00:46:26,497 --> 00:46:31,667
to rely on standardized, So to ensure
backward compatibility in particular.

637
00:46:32,167 --> 00:46:35,037
So how can we connect robots to the cloud?

638
00:46:35,517 --> 00:46:38,357
The simple answer is
through edge computing.

639
00:46:38,837 --> 00:46:42,527
edge computing means processing
power is at the periphery of your

640
00:46:42,527 --> 00:46:44,507
industrial automation network.

641
00:46:44,917 --> 00:46:46,237
So close to the source.

642
00:46:46,237 --> 00:46:48,627
for example, in this
case, close to the robots.

643
00:46:49,057 --> 00:46:54,017
instead of sending All the data to the
cloud, so what you can do is filter.

644
00:46:54,027 --> 00:46:58,137
What data do you actually want to
send to the cloud for processing?

645
00:46:58,137 --> 00:47:01,047
Because you probably don't want
all the communication between the

646
00:47:01,047 --> 00:47:04,947
robot and its controller, but you
just want, for example, sensors,

647
00:47:05,197 --> 00:47:07,427
to identify anywhere and tear.

648
00:47:07,927 --> 00:47:11,807
So basically, what you have is a
separation, cloud computing would be the

649
00:47:11,807 --> 00:47:16,577
place where you develop the knowledge,
whereas edge computing is where you, put

650
00:47:16,577 --> 00:47:21,297
the knowledge into action almost so that
cloud computing is not just a massive

651
00:47:21,317 --> 00:47:26,997
storage space, which makes it, not really
cost effective and also that the insight

652
00:47:26,997 --> 00:47:30,557
that you can generate are then limited
because there's just way too many data.

653
00:47:30,577 --> 00:47:35,597
But you use edge computing as a
way to filter data and to specify

654
00:47:35,627 --> 00:47:37,047
which one needs to be processed.

655
00:47:37,547 --> 00:47:41,187
So this can support
then a timely reaction.

656
00:47:41,327 --> 00:47:45,127
So you're not overwhelming the
system, but also system resilience.

657
00:47:46,027 --> 00:47:50,887
Now, how can we move to the
edge and beyond to the cloud?

658
00:47:51,657 --> 00:47:58,067
Basically, if we implement edge
computing, or, if we expand the industrial

659
00:47:58,067 --> 00:48:02,507
automation network, so include edge
computing and then the cloud, you need

660
00:48:02,567 --> 00:48:06,497
a number of, systems and applications.

661
00:48:06,957 --> 00:48:10,357
And all, This needs to run somewhere.

662
00:48:10,357 --> 00:48:15,727
You need middleware to support this
data request, data exchange, etc.

663
00:48:16,047 --> 00:48:18,357
So application servers, are needed.

664
00:48:19,167 --> 00:48:22,517
Now when it comes to application
servers, you can either create

665
00:48:22,517 --> 00:48:26,077
your own solution or rely on
something that is already available.

666
00:48:26,697 --> 00:48:31,987
And, just like I doubt that, any,
manufacturing facility would develop

667
00:48:31,987 --> 00:48:36,807
its own robot, here, also in this
case, it might be best just to rely on

668
00:48:36,807 --> 00:48:38,927
existing application server technology.

669
00:48:39,467 --> 00:48:43,067
And, for a number of reasons,
you just don't want to.

670
00:48:43,567 --> 00:48:49,017
Put additional workload on your existing
team, which might not have the expertise,

671
00:48:49,367 --> 00:48:55,137
might not be able to rely on support,
but also the cost and time resource time

672
00:48:55,137 --> 00:48:57,447
and resources would be extraordinary.

673
00:48:57,947 --> 00:49:03,297
So here, I just wanted to show you what
a sort of a potential, diagram of a

674
00:49:03,297 --> 00:49:07,727
network where robots then communicate
to the edge and the cloud look like.

675
00:49:08,127 --> 00:49:13,927
this is based on a recent study and,
now, my colleague Peter will talk

676
00:49:13,937 --> 00:49:18,267
you a bit more about application
servers and the application platforms.

677
00:49:18,767 --> 00:49:19,407
Thank you, Tiara.

678
00:49:19,947 --> 00:49:23,787
so now we are, going to
application platform, what it

679
00:49:23,787 --> 00:49:25,667
is and why we should, about it.

680
00:49:26,217 --> 00:49:31,397
when we, develop an application,
you, realize that you need, to access

681
00:49:31,397 --> 00:49:36,137
lots of, various resources, organize
them, introduce some configuration

682
00:49:36,527 --> 00:49:41,612
and later you get into issues like
Horizontal scaling and load balancing,

683
00:49:42,132 --> 00:49:47,772
you will need to, ensure some level
of security and of course compliance.

684
00:49:48,062 --> 00:49:52,892
And this all functionality is something
that can be just provided by application

685
00:49:52,892 --> 00:49:57,442
platform and not necessarily to be
developed by every single application.

686
00:49:57,942 --> 00:50:02,802
So basically the, the role of the
application platform is simplify

687
00:50:02,852 --> 00:50:05,252
the development of applications.

688
00:50:05,622 --> 00:50:10,662
It provides, lots of, services,
to the developers and, do

689
00:50:10,662 --> 00:50:11,912
these, these, functionalities.

690
00:50:12,412 --> 00:50:18,552
It provides management of resources
if it is, threat to pools, database

691
00:50:18,552 --> 00:50:23,602
connection pools, the whole, stuff
around security, set up it's,

692
00:50:23,602 --> 00:50:25,792
done by the resource management.

693
00:50:26,302 --> 00:50:33,482
if there is necessary to, connect to some
other, middleware, the service provide,

694
00:50:34,012 --> 00:50:37,822
plugins to, To connect to these services.

695
00:50:37,822 --> 00:50:42,362
So if you want to be informed, if
something happens, if you want to

696
00:50:42,372 --> 00:50:49,002
be informed in some teams channel or
some select channel, it's possible

697
00:50:49,042 --> 00:50:51,472
if you need to integrate this.

698
00:50:52,357 --> 00:50:56,197
Messaging systems, you can
send messages just using the

699
00:50:56,227 --> 00:50:58,547
existing, plugins platforms.

700
00:50:58,797 --> 00:51:04,137
Very typically do care about failing
and provide, support for code balancing.

701
00:51:04,147 --> 00:51:09,007
So usually it's, Pretty easy
to, scale to some level, just

702
00:51:09,007 --> 00:51:10,687
automatically on the platform.

703
00:51:10,697 --> 00:51:15,377
Not to the level which provides
cloud, but, to some higher level,

704
00:51:15,907 --> 00:51:20,802
several, machines or at least, or to
level of several tens of machines.

705
00:51:21,302 --> 00:51:28,602
And of course, security is a natural
part of the platform, and the

706
00:51:29,082 --> 00:51:36,992
servers are certified and verified,
so they are much easier to be

707
00:51:37,022 --> 00:51:39,912
compliant with the company policies.

708
00:51:40,412 --> 00:51:45,392
If the application is developed
with a platform, There is no need

709
00:51:45,442 --> 00:51:50,842
to self assembly all the necessary
libraries and parts together.

710
00:51:50,942 --> 00:51:52,582
It's provided by the platform.

711
00:51:53,032 --> 00:51:54,332
They all work together.

712
00:51:54,392 --> 00:51:56,772
They provide versioned,
versioned, runtime.

713
00:51:56,852 --> 00:52:05,532
So it's, Easy to upgrade because every
time you upgrade a new version, you are

714
00:52:05,532 --> 00:52:08,302
sure that all the parts work together.

715
00:52:08,692 --> 00:52:14,432
So the upgrade of one part
doesn't break the whole setup.

716
00:52:14,932 --> 00:52:16,782
The security is built in.

717
00:52:16,862 --> 00:52:18,422
so it's easy to.

718
00:52:18,867 --> 00:52:24,477
to implement it, the platforms typically,
provide monitoring, health checking,

719
00:52:24,977 --> 00:52:27,427
high availability, scalability.

720
00:52:27,927 --> 00:52:32,107
So the development can just focus
on the application and not to take

721
00:52:32,117 --> 00:52:35,477
care of all the fun piece around it.

722
00:52:35,557 --> 00:52:41,907
it, works as a managed software supply
chain, just part of the libraries.

723
00:52:41,907 --> 00:52:41,987
That's it.

724
00:52:42,487 --> 00:52:48,837
How to choose the right framework,
for, yes, it's important to, have,

725
00:52:48,907 --> 00:52:54,257
open and, backward compatible,
technologies because they allow

726
00:52:54,357 --> 00:52:57,557
to be flexible if you don't like.

727
00:52:57,657 --> 00:53:03,427
One, platform you can very easily to start
using another, especially in the case

728
00:53:03,427 --> 00:53:06,097
of Jakarta, the service are compatible.

729
00:53:06,147 --> 00:53:11,927
they are interchange interchangeable
to a big level and, they,

730
00:53:12,027 --> 00:53:14,337
provide long, big compatibility.

731
00:53:14,367 --> 00:53:20,057
So the programs which are
developed years or 20 years ago,

732
00:53:20,057 --> 00:53:22,337
they are still able to run today.

733
00:53:22,837 --> 00:53:29,147
It's, easy to use, systems which support
IOT because, plug plugins to the platform.

734
00:53:29,157 --> 00:53:32,427
provide for example NM QTP, support.

735
00:53:32,427 --> 00:53:35,657
So it's something that's
already done for vendors.

736
00:53:36,562 --> 00:53:44,192
the broader, broader language, range of
devices is supported by the platform.

737
00:53:44,692 --> 00:53:51,462
And, also, because, usage of a
standardized platform, means, standard

738
00:53:51,462 --> 00:53:56,892
using standards like JMS, messaging
systems, it's, possible to, cooperate with

739
00:53:56,892 --> 00:54:02,942
other industry players on this standard
level and why we chose Jakarta ee.

740
00:54:03,782 --> 00:54:08,612
This specific platform provides
huge vendor neutrality.

741
00:54:08,882 --> 00:54:15,842
The, the standard is, agreed among
big players in the industry, and,

742
00:54:16,092 --> 00:54:18,782
all the servers must, pass, tests.

743
00:54:19,282 --> 00:54:25,242
The same test, so the same application,
they'll run against each of the,

744
00:54:25,292 --> 00:54:26,842
servers from various vendors.

745
00:54:26,842 --> 00:54:33,192
So the customer only chooses some
additional, some additional values of the

746
00:54:33,192 --> 00:54:39,492
server or regard, or, takes care who is
providing them, to what's the reliability

747
00:54:39,612 --> 00:54:45,202
of the servers, other features, but
it's possible to change the vendors.

748
00:54:45,202 --> 00:54:45,262
Thanks.

749
00:54:46,012 --> 00:54:47,312
There is no vendor locking.

750
00:54:48,252 --> 00:54:53,462
The specifications are open, so it's
very easy to, to check, what the,

751
00:54:53,962 --> 00:54:58,222
what the functionality should do and
what are the expectations and, what

752
00:54:58,222 --> 00:55:01,212
is the level of, service and details.

753
00:55:01,712 --> 00:55:06,922
the parts of Jakarta ee cooperate
together, so the specification,

754
00:55:06,972 --> 00:55:11,782
work together, without any issue
and, the service, are able to

755
00:55:11,782 --> 00:55:13,222
cooperate between themselves.

756
00:55:13,432 --> 00:55:14,812
For example, the JMS.

757
00:55:15,407 --> 00:55:16,097
In a simple way.

758
00:55:16,597 --> 00:55:16,867
Okay.

759
00:55:16,867 --> 00:55:21,577
The Jakarta is, driven by
development, by community.

760
00:55:21,877 --> 00:55:28,347
There is, board across the big,
players in, and, they agree on the

761
00:55:28,497 --> 00:55:33,807
new features, and, changes in the
function of the, in the, in the global

762
00:55:33,807 --> 00:55:36,397
direction, where the development goals.

763
00:55:36,897 --> 00:55:41,357
The huge advantage is stability,
backward compatibility.

764
00:55:41,357 --> 00:55:46,037
So application written 15 years
ago, they are still working.

765
00:55:46,567 --> 00:55:52,247
there is only one problem with the
package renaming in the, Java world.

766
00:55:53,187 --> 00:55:57,897
this, and for this, there are
tools which help to, which

767
00:55:57,897 --> 00:55:59,877
help, to, upgrade the sources.

768
00:56:00,427 --> 00:56:01,617
in a very fast way.

769
00:56:02,207 --> 00:56:09,487
So the same program is able to the
program written in 2008 is able to run

770
00:56:09,517 --> 00:56:12,607
on the on today's servers very quickly.

771
00:56:12,707 --> 00:56:16,377
there are very few backward
incompatible changes.

772
00:56:16,877 --> 00:56:25,527
Also, the servers, support multiple,
multiple platforms from Java versions.

773
00:56:26,037 --> 00:56:30,557
there are always several versions
of LTS Javas, which are supported

774
00:56:31,007 --> 00:56:33,807
and, also from operating systems.

775
00:56:34,422 --> 00:56:40,252
So it's possible to run the server
on an operating system you want in

776
00:56:40,392 --> 00:56:43,202
various code environments if necessary.

777
00:56:43,912 --> 00:56:49,472
And, the, simply Jakarta E servers
run everywhere from huge server

778
00:56:49,472 --> 00:56:52,752
to the smallest ARM machines.

779
00:56:52,852 --> 00:56:55,687
we, we deliver, arm image.

780
00:56:55,687 --> 00:56:59,827
So if, there is a application for
that, we can run on, on a planning

781
00:56:59,827 --> 00:57:02,337
arm machine ante is, modular.

782
00:57:02,547 --> 00:57:08,627
plenty of components and, if, you
want, you can choose the needed one.

783
00:57:08,657 --> 00:57:12,527
And there are simpler servers,
simpler versions of the servers.

784
00:57:13,457 --> 00:57:17,297
Which, which, start faster
and, are less demanding.

785
00:57:17,797 --> 00:57:22,377
API is robust, as it is
developed for a long time.

786
00:57:22,557 --> 00:57:28,477
It, provides full, full functionality
required from specific domains.

787
00:57:28,977 --> 00:57:33,837
And if, there is a request to run in
cloud, there is no problem with it.

788
00:57:34,417 --> 00:57:40,827
the platforms, based on Jakarta EE
usually provide auto scaling and

789
00:57:41,067 --> 00:57:44,487
they are easily running in, in cloud.

790
00:57:44,987 --> 00:57:51,367
The model of Jakarta EE, as you
see, The Jakarta EE is based

791
00:57:51,747 --> 00:57:57,247
on the set of specifications
which provide various features.

792
00:57:58,127 --> 00:58:04,567
From that, support, connection pools, the
database connection pools, monitoring,

793
00:58:05,097 --> 00:58:08,047
logging, messaging, and so on.

794
00:58:08,547 --> 00:58:13,217
And this is all provided
by the Jakarta E Server.

795
00:58:13,897 --> 00:58:19,227
We also support MicroProfile, which is
an additional set of specifications.

796
00:58:19,842 --> 00:58:23,092
especially for cloud uses,
but usages, but, they are very

797
00:58:23,462 --> 00:58:25,392
handy also in, in one server.

798
00:58:26,272 --> 00:58:28,022
You will see example of it in the demo.

799
00:58:28,522 --> 00:58:33,592
And, the only missing part in this,
model is actually your application.

800
00:58:34,282 --> 00:58:37,292
And, so it doesn't need to
take care of any service.

801
00:58:37,792 --> 00:58:38,682
It's all provided.

802
00:58:39,182 --> 00:58:42,492
The set of specification is pretty big.

803
00:58:43,122 --> 00:58:47,632
they are, they are, upgraded,
roughly around every two years.

804
00:58:47,662 --> 00:58:49,252
There is a big new version.

805
00:58:49,582 --> 00:58:55,007
So this is the description
of the upcoming Jakarta 11.

806
00:58:55,377 --> 00:58:59,647
the blue specifications are the
ones which have a new version.

807
00:59:00,237 --> 00:59:04,457
there is also one, completely new,
specification, Jakarta Data, which

808
00:59:04,457 --> 00:59:08,397
provides, easier access to, SQL databases.

809
00:59:08,897 --> 00:59:15,127
And, in the preparation it will be also,
providing data to NoSQL, databases.

810
00:59:15,627 --> 00:59:19,897
So the question is, what's
behind, every one specification?

811
00:59:19,897 --> 00:59:20,157
for listening.

812
00:59:20,737 --> 00:59:25,527
It's composed from three,
actually four parts.

813
00:59:25,787 --> 00:59:27,757
The first one is the specification itself.

814
00:59:28,327 --> 00:59:32,747
It, describes, it is documentation
of, all the features, which are

815
00:59:32,747 --> 00:59:34,647
provided by one specification.

816
00:59:35,617 --> 00:59:40,427
All the behavior of, each class
in the specification and, what are

817
00:59:40,447 --> 00:59:42,407
the expectation, expected outputs.

818
00:59:42,907 --> 00:59:49,587
Next, there, there is, API Java, API,
with interfaces, mostly interfaces,

819
00:59:50,277 --> 00:59:56,587
providing that, API to, to the
specification and a set of, tests.

820
00:59:57,207 --> 01:00:02,737
Technology compatibility kit is a huge
set of tests which verify that every

821
01:00:02,737 --> 01:00:07,887
implementation of this specification
is behaving exactly the same way.

822
01:00:08,837 --> 01:00:11,687
And this is the fourth
part, implementation.

823
01:00:12,332 --> 01:00:18,932
there are several implementation of each
of the specifications and the servers pick

824
01:00:19,002 --> 01:00:25,932
the implementations, put them there and
make, the platform working all together.

825
01:00:25,932 --> 01:00:29,862
So the developers don't need to
care about what implementation

826
01:00:29,912 --> 01:00:31,872
is used, what is the version.

827
01:00:32,172 --> 01:00:33,872
It all works together.

828
01:00:34,082 --> 01:00:36,162
There is no need to take care of this.

829
01:00:36,822 --> 01:00:38,352
It's just working.

830
01:00:38,852 --> 01:00:43,352
There are a few things which go
beyond the list of specifications

831
01:00:43,442 --> 01:00:45,152
like performance and monitoring.

832
01:00:45,722 --> 01:00:51,632
Every server provides some,
some control over performance

833
01:00:51,632 --> 01:00:52,892
and provides some monitoring.

834
01:00:53,302 --> 01:00:58,617
For example, in the concurrency,
it's possible to choose, to

835
01:00:58,617 --> 01:01:01,867
configure, the size of the trap pool.

836
01:01:02,467 --> 01:01:05,727
Also, there are many other features
which control its behavior.

837
01:01:06,337 --> 01:01:11,257
And also, it's possible to choose
which types of threads are used there.

838
01:01:11,767 --> 01:01:16,057
typically, there are the platform threads,
which are not from Java very well.

839
01:01:16,737 --> 01:01:21,887
But it's possible to use farm join
threads, which is specific to Para.

840
01:01:22,387 --> 01:01:27,847
Or it's possible to use web threats,
which is the new feature in Java, 21

841
01:01:28,147 --> 01:01:33,277
released last year, and it's part of the,
upcoming, Jakarta level and everything

842
01:01:33,277 --> 01:01:35,617
is just configurable on the server.

843
01:01:35,617 --> 01:01:41,547
so the, confi the person who co
configures the server can choose,

844
01:01:41,587 --> 01:01:43,377
which, threats are the best.

845
01:01:43,847 --> 01:01:47,877
version, best set up for
the particular use case.

846
01:01:48,497 --> 01:01:52,307
Of course, it's possible that it's,
specified by a program, whatever can

847
01:01:52,307 --> 01:01:58,177
override it, just on the size, for
example, amount of memory or power of

848
01:01:58,177 --> 01:02:03,027
the CPU or number of CPUs, which are
available on the particular server.

849
01:02:03,297 --> 01:02:07,767
So the behavior can change,
just, without the code change.

850
01:02:08,492 --> 01:02:13,602
And just based on, based on
configuration, my profile

851
01:02:13,602 --> 01:02:19,332
provides two nice, specifications
for, the use case for on edge.

852
01:02:19,342 --> 01:02:22,472
It's a metrics on health, which are just.

853
01:02:22,852 --> 01:02:29,392
Just, part of the platform, there is
nothing necessary to do, and they provide

854
01:02:29,432 --> 01:02:34,492
endpoints for Prometheus, and we will see
how to, how this can be displayed later

855
01:02:34,522 --> 01:02:36,772
in, in Grafana in a nice graphical way.

856
01:02:37,272 --> 01:02:42,822
PAR also provides, a tool called
Monitoring Console, which Also to display

857
01:02:42,822 --> 01:02:45,772
simple graphs directly in the server.

858
01:02:45,792 --> 01:02:50,162
So there is even not need and
external tools just built in.

859
01:02:50,802 --> 01:02:56,292
And of course, there are some other
ways how to monitor the server.

860
01:02:56,972 --> 01:02:57,552
Oh, good.

861
01:02:57,552 --> 01:02:58,612
JMX.

862
01:02:58,652 --> 01:03:03,332
There are some other connectors,
plugins, which are able to

863
01:03:03,342 --> 01:03:06,492
send messages and measurements.

864
01:03:07,002 --> 01:03:10,002
to the, to other, third party tools.

865
01:03:10,182 --> 01:03:16,462
And of course, there is also specific
rest, which allows to, display some

866
01:03:16,862 --> 01:03:20,222
additional internal information
if they are needed for monitoring.

867
01:03:20,722 --> 01:03:21,732
That's all from me.

868
01:03:21,792 --> 01:03:23,092
we are returning back to Chiara.

869
01:03:23,592 --> 01:03:24,242
Thank you, Peter.

870
01:03:24,732 --> 01:03:30,267
So now we looked at why Jakarta
EE platform Could be the ideal

871
01:03:30,477 --> 01:03:36,537
underlying technology to create edge
computing and in particular edge

872
01:03:36,597 --> 01:03:41,897
applications that support additional
insights into industrial robots.

873
01:03:42,527 --> 01:03:47,337
Now among all the Jakarta EE
compatible solutions, here we

874
01:03:47,337 --> 01:03:49,047
are using the Payara platform.

875
01:03:49,107 --> 01:03:50,267
So why is that?

876
01:03:51,077 --> 01:03:54,387
First, because it's highly
committed to Jakarta EE.

877
01:03:54,977 --> 01:04:00,077
and it's a, a main solutions for Jakarta
E developers because after all the

878
01:04:00,077 --> 01:04:03,297
platform is a Jakarta E first, solution.

879
01:04:03,847 --> 01:04:08,547
in particular, we, Payara Services,
so the company behind Payara Platform

880
01:04:08,557 --> 01:04:13,227
is a contributor of the Eclipse
Foundation, which is behind Jakarta Yi.

881
01:04:14,037 --> 01:04:17,967
It's a strategic members of the
Jakarta Yi Working Group and

882
01:04:18,007 --> 01:04:19,717
other associated working groups.

883
01:04:20,367 --> 01:04:24,777
In addition, when it comes to profile, we
are members of the micro profile working

884
01:04:24,777 --> 01:04:29,367
group, and we are part of the project
management committee for Jakarta EE.

885
01:04:29,707 --> 01:04:32,777
So we are really committed to this
platform and we believe this is

886
01:04:32,777 --> 01:04:36,787
the right solution for industrial
automation applications of the future.

887
01:04:37,287 --> 01:04:42,467
Now, Let's have a closer look at
what the Payara platform can offer

888
01:04:42,527 --> 01:04:44,177
for such specific application.

889
01:04:44,177 --> 01:04:50,227
We said that, stability, resilience, and
security were extremely important because,

890
01:04:50,227 --> 01:04:52,632
of course, we don't want to accumulate.

891
01:04:52,752 --> 01:04:58,012
Expose our robots to, additional
risk and vulnerable vulnerabilities,

892
01:04:58,012 --> 01:04:59,782
just to get some additional insights.

893
01:05:00,192 --> 01:05:05,542
So the Payara platform is stable and
fully supported, it's designed for

894
01:05:05,552 --> 01:05:07,762
mission critical production environments.

895
01:05:08,742 --> 01:05:14,272
With a long, software like cycle of
a minimum of 10 years, so that, for

896
01:05:14,272 --> 01:05:20,922
example, industrial automation plants,
with, robots at different stages of

897
01:05:20,922 --> 01:05:24,102
their life cycle can, be supported.

898
01:05:24,512 --> 01:05:29,552
There are security alerts and patches
with a monthly, release, so it

899
01:05:29,592 --> 01:05:31,922
complies with the regulatory bodies.

900
01:05:32,372 --> 01:05:37,982
and, Users can benefit from migration
project support as well as full

901
01:05:38,012 --> 01:05:42,462
engineering support that is available
either 24 seven or ten four five,

902
01:05:43,352 --> 01:05:47,972
depending on what the team needs and
within the play our platform, users

903
01:05:48,012 --> 01:05:51,452
can benefit from the pay our server,
which is the, let's say, traditional

904
01:05:51,452 --> 01:05:56,542
application server, as well as pay
our micro that is, a bit more tailored

905
01:05:56,572 --> 01:06:01,222
for, Cloud applications, and then
we've got, Payara Cloud that is a

906
01:06:01,222 --> 01:06:03,342
bit beyond the scope of today's talk.

907
01:06:03,382 --> 01:06:07,522
it's a fully managed, application
runtime for cloud deployments.

908
01:06:08,102 --> 01:06:12,532
Now, here the Payara platform is
really designed for deployments

909
01:06:12,532 --> 01:06:16,922
that are, leveraging IoT, edge
computing, and cloud computing.

910
01:06:16,922 --> 01:06:18,942
So what we are talking exactly today.

911
01:06:19,012 --> 01:06:24,157
And just to have a closer look,
Basically, the Pajaro platform can

912
01:06:24,187 --> 01:06:26,097
help you build intelligent servers.

913
01:06:26,577 --> 01:06:33,127
And, this is because, for example, the
IOT devices can send data over MQTT cloud

914
01:06:33,127 --> 01:06:38,647
connector, with MQTT being pretty much
the de facto standard in the industry.

915
01:06:39,057 --> 01:06:44,117
and basically they can send this
data, on the edge, and then,

916
01:06:44,127 --> 01:06:47,987
Business logic, aggregate, and
data analysis can be performed.

917
01:06:48,597 --> 01:06:52,857
then if you look at what happens in the
cloud, for example, you may think to

918
01:06:52,857 --> 01:06:58,027
have Pyara Micro as your go to solution
because it is optimized to work in

919
01:06:58,037 --> 01:07:02,127
containerized environments, while being
lightweight, of course, and compact so

920
01:07:02,137 --> 01:07:05,727
that it doesn't use a lot of resources
and it's ideal for cloud deployments.

921
01:07:06,227 --> 01:07:11,897
So here, of course, when, if we
are really tackling a, industrial

922
01:07:11,907 --> 01:07:16,407
automation application, of course, it
is recommended for any potential user

923
01:07:16,407 --> 01:07:20,387
to rely on the Enterprise Edition,
which offer exactly the full support.

924
01:07:20,817 --> 01:07:25,647
And is suitable for, mission critical
application in production environments.

925
01:07:26,147 --> 01:07:31,857
Now, Peter prepared a very nice
demo showcasing how we can, use,

926
01:07:31,857 --> 01:07:37,067
the platform and Jakarta E of
course, to, send robotic data.

927
01:07:37,707 --> 01:07:38,527
To the cloud.

928
01:07:39,027 --> 01:07:39,837
Thank you, Chiara.

929
01:07:40,507 --> 01:07:48,687
So now we are going to a pretty simple
demo of how such edge computing can

930
01:07:48,877 --> 01:07:52,147
look like and how to do an easy way.

931
01:07:52,507 --> 01:07:54,437
What on the screen is.

932
01:07:55,067 --> 01:08:01,227
monitoring of the edge computer,
it shows how the data is processed.

933
01:08:01,237 --> 01:08:05,937
We will go through everything during
the demo and on the right side,

934
01:08:05,937 --> 01:08:08,567
you see the simulation of robots.

935
01:08:08,847 --> 01:08:11,697
This is running on a separate computer.

936
01:08:11,697 --> 01:08:15,977
So so it properly simulates
sending remote requests.

937
01:08:16,452 --> 01:08:22,582
The data is, sent from, from, re,
from files with, recorded, real data.

938
01:08:23,122 --> 01:08:29,222
And they are processed in the, they are
stored and eventually can be filtered

939
01:08:29,282 --> 01:08:31,732
and, pre processed on the Edge computer.

940
01:08:32,412 --> 01:08:36,482
And then they are sent further
for the next processing, as Chiara

941
01:08:36,482 --> 01:08:40,482
mentioned, for some, analysis, some
data mining on top of the data.

942
01:08:40,482 --> 01:08:40,622
Thank you.

943
01:08:41,122 --> 01:08:45,062
And, we don't care about this part,
in this presentation, we assume that

944
01:08:45,072 --> 01:08:50,532
there is some cluster of computers,
or, that can be, more powerful computer

945
01:08:50,532 --> 01:08:52,822
or just a cloud with load balancer.

946
01:08:52,822 --> 01:08:55,142
So we will just send data somewhere else.

947
01:08:55,642 --> 01:08:59,842
So let's start with the whole, procedure.

948
01:09:00,172 --> 01:09:03,112
Now, the data which we are using.

949
01:09:03,692 --> 01:09:12,052
There are various sets of, data and,
there are various, examples of, samples

950
01:09:12,112 --> 01:09:19,302
of from one, one source and, this is
the format of the data time, position

951
01:09:19,302 --> 01:09:21,717
of the arm temperature and voltage.

952
01:09:22,617 --> 01:09:26,967
And there are, lots of the data
like three and a half thousand,

953
01:09:27,507 --> 01:09:29,397
measurements in, in one set.

954
01:09:29,787 --> 01:09:38,047
And once this set is, sent to the, to the
edge computer, it's considered one cycle.

955
01:09:38,087 --> 01:09:41,257
so the clients, the machine says.

956
01:09:42,082 --> 01:09:49,772
And now I finished, and the Edge computer,
sends the whole set for further analysis

957
01:09:49,912 --> 01:09:52,222
somewhere, for the, for the processing.

958
01:09:52,702 --> 01:09:55,222
what do we need to start?

959
01:09:55,967 --> 01:10:02,447
Is we need on the, on the remote
machine, which is this one.

960
01:10:02,947 --> 01:10:05,407
We need to start the edge computer.

961
01:10:05,907 --> 01:10:08,927
So this is this machine.

962
01:10:08,957 --> 01:10:14,717
Usually it starts with the application
with the start of the server.

963
01:10:15,317 --> 01:10:15,837
Okay.

964
01:10:16,637 --> 01:10:19,367
And we also start monitoring.

965
01:10:19,867 --> 01:10:22,617
We use Prometheus and Grafana configured.

966
01:10:23,167 --> 01:10:26,227
to the, to the sources we have.

967
01:10:26,727 --> 01:10:33,947
Also, we need to run the, the simulator
of, of, the data mining and processes.

968
01:10:33,947 --> 01:10:37,161
So we run on different
computer this thing.

969
01:10:37,161 --> 01:10:38,968
And we are ready.

970
01:10:38,968 --> 01:10:44,917
We are ready to start, to
start the data generator.

971
01:10:45,297 --> 01:10:48,707
We will just verify that everything works.

972
01:10:49,467 --> 01:10:51,437
So here is the edge computer.

973
01:10:51,937 --> 01:10:55,107
It tells us that nothing happened so far.

974
01:10:55,117 --> 01:10:56,237
It's fine.

975
01:10:56,237 --> 01:11:06,194
And we will, we should look at the
graphical graphical representation.

976
01:11:06,919 --> 01:11:08,129
So the server is up.

977
01:11:08,649 --> 01:11:09,969
No data is processed.

978
01:11:10,899 --> 01:11:12,359
Uptime is a minute.

979
01:11:12,609 --> 01:11:13,889
Classes were loaded.

980
01:11:14,649 --> 01:11:18,249
there is almost no, memory used so far.

981
01:11:18,749 --> 01:11:20,769
And everything's fine.

982
01:11:21,269 --> 01:11:21,879
Okay.

983
01:11:22,399 --> 01:11:27,135
for the servers, we provide
also, graphical interface.

984
01:11:27,635 --> 01:11:31,735
Which, can control the whole,
configuration of the server.

985
01:11:32,235 --> 01:11:38,005
So here we see this is the machine
which contains the data miner.

986
01:11:38,505 --> 01:11:42,984
And the data miner has very simple, UI.

987
01:11:43,564 --> 01:11:48,390
Okay, so now we can start
with, the processing of, data.

988
01:11:49,250 --> 01:11:51,759
So here we start, with the processors.

989
01:11:52,294 --> 01:11:58,631
As it is simulation, we will
start with just 10, 10 sources of

990
01:11:58,631 --> 01:12:00,218
the data to send to the server.

991
01:12:00,718 --> 01:12:05,348
A short compilation of the sources to
verify that we are on the latest version.

992
01:12:05,848 --> 01:12:06,998
And we start.

993
01:12:07,498 --> 01:12:09,358
So you see there are 10 servers.

994
01:12:10,083 --> 01:12:16,093
Sending, depending on the size of
the, dataset they are sending, data.

995
01:12:16,273 --> 01:12:22,533
And, also, there are various, cycles
depending on the speed of the processing.

996
01:12:23,033 --> 01:12:32,013
So we can easily, we can quickly review,
the data in our, measurement to see that.

997
01:12:32,523 --> 01:12:42,883
How far it is currently 150, 000, data,
which are, 78 data sets, asked for data

998
01:12:42,883 --> 01:12:45,483
mining and 53 of them is already done.

999
01:12:45,983 --> 01:12:47,773
we can look at the metrics.

1000
01:12:47,773 --> 01:12:53,146
So right now we are
about 300, 000, records.

1001
01:12:53,546 --> 01:12:55,652
The memory is warming up.

1002
01:12:55,652 --> 01:12:59,269
The, the system is forming up.

1003
01:12:59,269 --> 01:13:02,790
We see some timing, things.

1004
01:13:03,250 --> 01:13:08,220
In this diagram, we see, number of,
requests and number of, process.

1005
01:13:08,755 --> 01:13:10,165
processed, data minings.

1006
01:13:10,195 --> 01:13:12,340
So everything is, working nicely.

1007
01:13:12,400 --> 01:13:19,340
And this is how we see how fast is the
data process and, the amount of the data.

1008
01:13:20,000 --> 01:13:27,790
So what we can try now to have some little
bit more interesting graphs, we can stop.

1009
01:13:28,290 --> 01:13:34,910
So we should be able to see that the,
it stopped sending data, the graphs.

1010
01:13:35,880 --> 01:13:41,750
Should flatten, it, it takes several
seconds, for, both, collecting data

1011
01:13:41,790 --> 01:13:47,870
and the refresh of, Grafana, but
you'll see that, that, the data

1012
01:13:47,880 --> 01:13:52,950
stopped being sent, to make everything
clear, we can clear the data.

1013
01:13:53,420 --> 01:13:55,300
So we start fresh.

1014
01:13:55,800 --> 01:13:56,740
second, that'll be.

1015
01:13:57,465 --> 01:14:04,145
Zero in the data received and we
can, yeah, we can start with the,

1016
01:14:04,645 --> 01:14:08,805
let's say a little bit more,
a little bit more, sources.

1017
01:14:08,905 --> 01:14:17,375
So imagine a really big factory
with 100 different machines sending

1018
01:14:17,395 --> 01:14:19,605
its data as quickly as possible.

1019
01:14:19,605 --> 01:14:21,265
So let's start with 100.

1020
01:14:21,765 --> 01:14:22,895
So now we can.

1021
01:14:23,395 --> 01:14:25,715
We can run 100, subsystem.

1022
01:14:25,725 --> 01:14:27,435
Let's see what happens on the server.

1023
01:14:27,935 --> 01:14:34,225
Now there is 100, servers, trying
to fill the, fill the server.

1024
01:14:34,725 --> 01:14:36,265
Can display the, internal.

1025
01:14:36,765 --> 01:14:40,705
they have 65, 000 sets.

1026
01:14:40,705 --> 01:14:44,025
And that it's increasing.

1027
01:14:44,525 --> 01:14:50,665
So the server is able to handle just
without any specific configuration,

1028
01:14:51,515 --> 01:14:54,485
able to handle pretty big, loads.

1029
01:14:54,995 --> 01:14:56,895
so this also can be configured.

1030
01:14:57,825 --> 01:15:00,785
to provide, better, better performance.

1031
01:15:00,845 --> 01:15:06,115
Of course, the example is, is
predator also, there is no, no clever,

1032
01:15:06,225 --> 01:15:12,835
clever caching or anything, just,
just a stock version of the cell.

1033
01:15:13,335 --> 01:15:14,625
So this is how it works.

1034
01:15:15,175 --> 01:15:22,925
I would like to just show what happens
if, the server will stop working.

1035
01:15:22,925 --> 01:15:27,355
so how it is visible in
the, in the monitoring.

1036
01:15:27,855 --> 01:15:29,680
So here we will see.

1037
01:15:30,180 --> 01:15:35,620
On the upper left, corner that the
server is down in, this graph is down.

1038
01:15:35,620 --> 01:15:41,020
So there, there can be some art,
to the monitor of the whole setup

1039
01:15:41,020 --> 01:15:47,110
that something's go going wrong,
and that the server is down, which

1040
01:15:47,110 --> 01:15:49,295
is of course, not the usual case.

1041
01:15:49,795 --> 01:15:58,055
Yep, so that's, something what, we can,
end with the demo here, but I would like

1042
01:15:58,065 --> 01:16:02,885
to share how the, how the demo was done.

1043
01:16:03,135 --> 01:16:06,805
So this is the pretty
trivial, edge computing.

1044
01:16:07,145 --> 01:16:13,835
It's just storing data in the cache
and provide some, counters, So it's

1045
01:16:13,975 --> 01:16:20,725
typical, best endpoint with, with
processing data, which only stores data.

1046
01:16:21,395 --> 01:16:24,135
This is just logging
and some, functionality.

1047
01:16:25,125 --> 01:16:31,335
And all the measurement is done by
just annotating the, method with the,

1048
01:16:31,335 --> 01:16:34,065
micro profile metrics annotation.

1049
01:16:34,605 --> 01:16:39,885
And, I also try to provide
some more information.

1050
01:16:40,385 --> 01:16:44,045
Again, predatorial things, and
they are then all visible here.

1051
01:16:44,165 --> 01:16:47,995
These are the values which
are provided by the server.

1052
01:16:48,495 --> 01:16:55,205
This is the end of the demo,
and I will just finish it's

1053
01:16:55,205 --> 01:16:57,185
a little bit more optimistic.

1054
01:16:57,695 --> 01:17:05,685
And so in a second, we will get it Up
again, and this is the end of the demo.

1055
01:17:05,875 --> 01:17:12,725
So thanks and I'm resending words to
back to Kiara for the final words Thank

1056
01:17:12,725 --> 01:17:18,195
you, Peter So just summarizing what we've
discussed today robot based industrial

1057
01:17:18,205 --> 01:17:23,135
automation operation can greatly benefit
from the cloud for additional insights

1058
01:17:23,645 --> 01:17:30,480
however You cannot just blindly adopt
the cloud, but you need a edge and,

1059
01:17:30,490 --> 01:17:34,590
of course, a suitable technology is
needed to create an effective edge.

1060
01:17:35,070 --> 01:17:40,297
the technology should rely on openness,
a certain standardization, as well

1061
01:17:40,297 --> 01:17:42,705
as offer flexibility and scalability.

1062
01:17:43,235 --> 01:17:47,125
This is why we've chosen Jakarta E
and Payara platform for the demo.

1063
01:17:48,115 --> 01:17:54,155
And we've shown how a Jakarta E specific
Payara platform can offer the ideal

1064
01:17:54,195 --> 01:17:58,175
application server for creating a
cutting edge, industrial internet of

1065
01:17:58,175 --> 01:18:02,385
things that leverages edge computing
and cloud computing to advance.

1066
01:18:02,980 --> 01:18:04,570
robot applications.

1067
01:18:05,050 --> 01:18:08,530
Now, thank you so much
for attending this talk.

1068
01:18:08,690 --> 01:18:09,760
I hope you had a good time.

1069
01:18:09,770 --> 01:18:12,810
If you've got any questions, feel
free to get in touch with myself or

1070
01:18:12,810 --> 01:18:15,760
Peter and enjoy the rest of the talks.

1071
01:18:16,260 --> 01:18:17,030
So thank you.

1072
01:18:17,060 --> 01:18:17,360
And goodbye.

