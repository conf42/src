1
00:00:00,000 --> 00:00:02,340
Hey everybody, welcome to this session.

2
00:00:02,390 --> 00:00:05,030
we are going to talk about
cloud computing, edge

3
00:00:05,030 --> 00:00:06,800
computing and web assembly.

4
00:00:06,890 --> 00:00:07,850
I am Alex.

5
00:00:07,850 --> 00:00:09,649
great to join the conference today.

6
00:00:09,930 --> 00:00:10,889
what are we going to talk about?

7
00:00:11,200 --> 00:00:11,860
we'll go through.

8
00:00:11,964 --> 00:00:15,084
Some quick history just to make
sure we are on the same page about

9
00:00:15,084 --> 00:00:19,464
cloud and edge and what is web
assembly and all of that fun stuff.

10
00:00:19,705 --> 00:00:24,384
And then we dive into the Wasm Plus
Edge, and I'm going to also share,

11
00:00:24,654 --> 00:00:29,305
prac practical, real world use case
about, doing Wasm at the edge at.

12
00:00:29,725 --> 00:00:31,585
Edgy, which is the company I work for.

13
00:00:31,965 --> 00:00:32,655
I'm Alex.

14
00:00:32,685 --> 00:00:34,815
I'm a software engineer from Italy.

15
00:00:34,865 --> 00:00:37,445
I've joined a few different
companies in the last 10 years

16
00:00:37,445 --> 00:00:42,285
from the eCommerce world at Cloud
Academy to AWS, for about six years.

17
00:00:42,285 --> 00:00:44,865
And today I'm a developer
advocate at edgy.

18
00:00:45,295 --> 00:00:48,705
I'll tell you more about what Edge
is in a, in a few minutes, but

19
00:00:48,705 --> 00:00:50,745
let's start from the fundamentals.

20
00:00:50,795 --> 00:00:52,595
what do we actually mean?

21
00:00:52,955 --> 00:00:57,975
When we say edge computing because,
in my opinion it's quite a large

22
00:00:57,975 --> 00:01:01,925
umbrella, term that can mean different
things in different contexts.

23
00:01:02,165 --> 00:01:09,335
So what I want to focus on is the
web development, the web world.

24
00:01:09,365 --> 00:01:13,405
if you're a web developer, if
you build websites or APIs, edge

25
00:01:13,405 --> 00:01:15,235
computing problem means to you.

26
00:01:15,890 --> 00:01:22,320
code that can run in a almost serverless
fashion on top of, global networks

27
00:01:22,350 --> 00:01:26,870
or content delivery networks, the
Fastly or the CloudFlare of the world.

28
00:01:27,210 --> 00:01:29,610
there are a lot of other
meetings for the term.

29
00:01:29,640 --> 00:01:33,780
you probably have heard about edge
computing in the context of IOT.

30
00:01:34,225 --> 00:01:39,805
devices or other, subcategories of that
world, like telecom 5G gaming, virtual

31
00:01:39,805 --> 00:01:42,905
reality, smart retail, smart vehicles.

32
00:01:42,905 --> 00:01:47,645
there are a lot of smart things
where you take some computation that

33
00:01:47,675 --> 00:01:51,696
traditionally happens in a centralized
data center and you try to move it.

34
00:01:52,120 --> 00:01:56,230
Somewhere else to the edge of the
network on a or on a iot device,

35
00:01:56,230 --> 00:01:58,030
for example, or a smart device.

36
00:01:58,270 --> 00:02:01,660
We are not talking so much about that
today, although some of the things

37
00:02:01,660 --> 00:02:05,620
that we see do apply now to understand.

38
00:02:06,245 --> 00:02:10,415
How we got where we are, where we
are today about edge computing and

39
00:02:10,415 --> 00:02:11,795
all the things we all talk about.

40
00:02:12,095 --> 00:02:16,205
It's important, in my opinion,
to look at the cloud history.

41
00:02:16,295 --> 00:02:18,095
Now, this is very ancient history.

42
00:02:18,095 --> 00:02:21,785
If you're curious about that,
pause the video, have a quick look.

43
00:02:21,785 --> 00:02:26,465
There are some interesting milestones
in the last 50, 60, 70 years.

44
00:02:26,795 --> 00:02:28,175
I'm not going through all of that.

45
00:02:28,325 --> 00:02:32,195
Let's look together at
some more recent history.

46
00:02:32,245 --> 00:02:32,635
in the last.

47
00:02:33,245 --> 00:02:34,715
15, 20 years.

48
00:02:34,715 --> 00:02:40,185
The cloud, started existing, around
2 0 0 6 AWS came up, and then all the

49
00:02:40,185 --> 00:02:44,575
other vendors followed up from Google
to Azure to the open source, world.

50
00:02:44,575 --> 00:02:45,715
And then Docker came.

51
00:02:45,715 --> 00:02:51,385
And if you look at the pattern, we
went from barebone virtualization to.

52
00:02:51,795 --> 00:02:56,175
virtual machines that could start
up in minutes on the, in the cloud.

53
00:02:56,415 --> 00:03:00,165
And then we went from that, from
the virtual machines to containers,

54
00:03:00,165 --> 00:03:03,975
the Kubernetes and all the different
managed container services out there.

55
00:03:04,545 --> 00:03:09,435
And about 10 years ago, in 20 14,
20 15, we went from containers

56
00:03:09,435 --> 00:03:10,740
to serverless functions.

57
00:03:10,740 --> 00:03:15,030
they coexisted, the two communities
are now re converging back together.

58
00:03:15,220 --> 00:03:15,790
luckily.

59
00:03:16,340 --> 00:03:18,860
but this idea of running functions.

60
00:03:19,235 --> 00:03:23,740
In a serverless fashion where your code
just pins up runs for, I don't know, a

61
00:03:23,740 --> 00:03:25,810
hundred milliseconds and then shuts down.

62
00:03:26,170 --> 00:03:30,440
And so this different computing model
came up about, in the last 10 years

63
00:03:30,440 --> 00:03:31,910
and they've been evolving together.

64
00:03:32,130 --> 00:03:36,060
now most of these vendors are
just trying to sell you ai.

65
00:03:36,060 --> 00:03:39,720
But until a few years ago,
they deeply cared about compute

66
00:03:39,720 --> 00:03:41,610
models and compute obstructions.

67
00:03:41,610 --> 00:03:45,780
And what is the next thing and another
interesting evolution that happened.

68
00:03:46,740 --> 00:03:51,190
A kind of, in parallel, but for
some people, including myself,

69
00:03:51,190 --> 00:03:53,860
it happened behind the scenes
without a lot of people noticing.

70
00:03:53,860 --> 00:03:58,240
A trend is the evolution of
content delivery networks too.

71
00:03:58,550 --> 00:04:04,100
most of these were born to provide
simple content delivery or security

72
00:04:04,130 --> 00:04:05,870
DDoS production, for example.

73
00:04:06,650 --> 00:04:11,000
and some of these companies are as
old as Google, from 19 88, 19 89.

74
00:04:11,310 --> 00:04:14,659
Akamai, for example, was born, the
same year as Google, so they've

75
00:04:14,659 --> 00:04:16,219
been around for a lot of time.

76
00:04:16,320 --> 00:04:22,560
and there used to be various ways
to implement custom logic on top

77
00:04:22,590 --> 00:04:24,510
of these global delivery networks.

78
00:04:24,510 --> 00:04:28,590
They were optimized for, again,
delivering content, caching

79
00:04:28,590 --> 00:04:32,100
content, helping you with streaming,
especially, in the last few years.

80
00:04:32,395 --> 00:04:33,594
that grew a lot.

81
00:04:33,965 --> 00:04:37,655
maybe you've heard of things like
the varnish configuration language

82
00:04:37,655 --> 00:04:41,564
that allow you to do, more dynamic
logic directly at the edge.

83
00:04:41,744 --> 00:04:46,574
But, so this was the edge until, say,
10 years ago people used CDNs for

84
00:04:46,574 --> 00:04:48,764
caching, but then something happened.

85
00:04:48,854 --> 00:04:53,174
And look at the years, it's
all about, 2016 to 2019.

86
00:04:53,700 --> 00:04:59,340
This idea of running, the edge workers
or the CloudFlare workers, or the Lambda

87
00:04:59,700 --> 00:05:05,160
Edge or CloudFront functions in the AWS
world or the Fastly Compute platform, the

88
00:05:05,160 --> 00:05:10,260
idea of running code directly on top of
the hundreds and hundreds of points of

89
00:05:10,260 --> 00:05:12,780
presence became more and more popular.

90
00:05:12,810 --> 00:05:17,919
and this all kind of aligned to the
revolution of the serverless, mindset

91
00:05:17,919 --> 00:05:22,659
where you could just spin up a function,
run it, take care of some business logic

92
00:05:22,659 --> 00:05:25,030
in a few milliseconds, and then shut down.

93
00:05:25,059 --> 00:05:31,169
So it aligned to that, change, after
20 14, 20 15, Now there are many

94
00:05:31,169 --> 00:05:32,879
different technologies behind the hood.

95
00:05:33,119 --> 00:05:37,259
And another interesting fact is that
when you finally have compute somewhere,

96
00:05:37,529 --> 00:05:44,939
it's not long until you have additional
services, like key value store databases,

97
00:05:45,039 --> 00:05:48,159
AOC domain specific services like image.

98
00:05:48,425 --> 00:05:50,075
optimization and compression.

99
00:05:50,075 --> 00:05:54,614
You have databases, queues,
object storage, configuration

100
00:05:54,614 --> 00:05:56,824
management, services and so on.

101
00:05:57,274 --> 00:06:02,044
So if you look at this from the
perspective of the cloud computing

102
00:06:02,044 --> 00:06:06,604
world, it's almost as if, and some
people will tell you it's exactly

103
00:06:06,604 --> 00:06:09,674
as if, many c DM providers became.

104
00:06:09,989 --> 00:06:12,209
Cloud computing providers themselves.

105
00:06:12,209 --> 00:06:16,199
'cause now they offer you not just caching
and CDN and content delivery, they offer

106
00:06:16,199 --> 00:06:20,669
you everything from compute to databases,
queues, object storage, and so on.

107
00:06:20,909 --> 00:06:24,569
So the difference between edge computing
and cloud computing is blurring.

108
00:06:25,069 --> 00:06:28,039
if you see the pattern that
happened in the last few years.

109
00:06:28,459 --> 00:06:30,259
Now, another interesting.

110
00:06:30,349 --> 00:06:35,509
A pillar of this talk is web
assembly, where if you have

111
00:06:35,509 --> 00:06:37,039
never heard of it, don't worry.

112
00:06:37,039 --> 00:06:40,069
I'm going to try and cover the basics
and make sure everybody's on the same

113
00:06:40,069 --> 00:06:45,329
page if you have never heard of it, I
believe it's possibly one of the most

114
00:06:45,329 --> 00:06:51,119
interesting development in the web space
of the last few years, as we'll see later.

115
00:06:51,119 --> 00:06:54,059
Some cloud and edge providers
already allow you to deploy.

116
00:06:54,239 --> 00:06:54,569
Was.

117
00:06:55,184 --> 00:06:57,765
Applications to their computer platforms.

118
00:06:58,064 --> 00:07:03,794
to recap its evolution, it was announced
in 2015 and then released in 2017.

119
00:07:03,794 --> 00:07:05,325
So it's been around for a while.

120
00:07:05,564 --> 00:07:09,585
It became a W three C
recommendation in 2019.

121
00:07:09,614 --> 00:07:12,075
That's a bit more recent and
there is still a lot happening.

122
00:07:12,075 --> 00:07:15,025
So it's not, it's still
evolving, it's still changing,

123
00:07:15,025 --> 00:07:17,005
and adoption is still, growing.

124
00:07:17,305 --> 00:07:23,905
So a lot of people talk about web assembly
in the context of running binary files

125
00:07:23,935 --> 00:07:26,035
in the browser, and that's amazing.

126
00:07:26,035 --> 00:07:29,005
You can do incredible things
where you compile, super

127
00:07:29,005 --> 00:07:31,734
efficient, see or rust or go.

128
00:07:32,120 --> 00:07:37,969
Library or algorithm into a binary file,
web assembly file that then you can take

129
00:07:37,969 --> 00:07:42,230
and run anywhere else 'cause you have full
portability and one of the places where

130
00:07:42,230 --> 00:07:46,640
you can run this is in the browser, but
that's not what we're talking about today.

131
00:07:46,640 --> 00:07:51,499
We are talking about servers, li,
service side, execution of web assembly,

132
00:07:51,499 --> 00:07:53,479
which also has a lot of potential.

133
00:07:54,415 --> 00:07:58,475
Including at the Edge, of course,
now you may already know the

134
00:07:58,505 --> 00:08:03,125
Wasm support a lot of different
languages, from Java to TypeScript,

135
00:08:03,125 --> 00:08:06,695
PHPC, sharp, go Rust, and so on.

136
00:08:07,025 --> 00:08:12,545
It's probably the most interesting and
more common pattern is where you implement

137
00:08:12,545 --> 00:08:15,244
something complex or competitionally.

138
00:08:15,830 --> 00:08:22,700
Complex in a compiled language like
CC plus rust or go, and then you use

139
00:08:22,700 --> 00:08:28,319
that web assembly component or web
assembly module, into another language

140
00:08:28,379 --> 00:08:30,749
since you have full portability now.

141
00:08:31,514 --> 00:08:39,234
Some mandatory quote here in 2019, when it
reached, W three CA recommendation status.

142
00:08:39,294 --> 00:08:44,735
The founder of Docker, wrote
that if was and Wze, and we'll

143
00:08:44,735 --> 00:08:46,355
see what Wze is in a second.

144
00:08:46,594 --> 00:08:50,795
If they existed back in 2018,
they wouldn't have had to create

145
00:08:50,795 --> 00:08:52,355
Docker in the first place.

146
00:08:52,385 --> 00:08:56,464
So this is just to give you some
perspective of how much potential

147
00:08:56,464 --> 00:08:58,415
there is and how much the industry.

148
00:08:58,459 --> 00:09:02,620
It is trying to, adopt it and
see what's possible with it.

149
00:09:03,170 --> 00:09:05,970
now, there is a lot of
online documentation.

150
00:09:05,970 --> 00:09:11,070
Most things in the web assembly,
if not all things are open source.

151
00:09:11,100 --> 00:09:15,570
So you find, design decisions on
GI and a lot of documentation.

152
00:09:15,850 --> 00:09:21,460
the second interesting part of the full
picture, in addition to WebAssembly, is.

153
00:09:22,070 --> 00:09:25,550
Azi, which is the web
assembly system interface.

154
00:09:25,550 --> 00:09:30,890
It's basically a collection of APIs
that allow a, was and run time to

155
00:09:30,890 --> 00:09:32,750
interact with the operating system.

156
00:09:32,750 --> 00:09:37,280
So you get all the benefits of interacting
with the file system, with the network,

157
00:09:37,490 --> 00:09:42,800
with the, threading APIs, sockets, all
the operating system calls that you would

158
00:09:42,800 --> 00:09:45,980
not normally not have in wasn't now.

159
00:09:46,220 --> 00:09:49,700
the vision for some people here is
that was and will become the defacto

160
00:09:49,880 --> 00:09:52,040
standard for backend development.

161
00:09:52,040 --> 00:09:53,540
And that's a bold vision, right?

162
00:09:53,540 --> 00:09:57,500
It start to replace the Docker or
the Kubernetes, but they're actually

163
00:09:57,500 --> 00:10:01,120
already coexisting if you look at
some of the registries and, and

164
00:10:01,120 --> 00:10:03,550
services up there already support.

165
00:10:03,805 --> 00:10:05,685
wasm, containers, for example.

166
00:10:06,085 --> 00:10:11,605
there is also the wasm component
model, which is a more recent way

167
00:10:11,605 --> 00:10:16,225
to build, not modules or entire
applications, but component that

168
00:10:16,225 --> 00:10:20,475
are meant to be, composed and reused
across, applications and modules.

169
00:10:21,355 --> 00:10:26,425
Now some of the benefits that you may
have heard, but let's dive a bit deeper.

170
00:10:26,425 --> 00:10:29,725
You have full portability
when I compile into Asom.

171
00:10:29,725 --> 00:10:34,075
I can take that binary file and use it
literally anywhere in other operating

172
00:10:34,075 --> 00:10:36,625
systems, in other architectures and so on.

173
00:10:36,685 --> 00:10:40,965
So this kind of the dream, you probably
saw it decades ago, with the Java

174
00:10:40,965 --> 00:10:43,555
world as well, differences, here the.

175
00:10:43,945 --> 00:10:49,255
The kind of layer of the operating
system is much smaller and the

176
00:10:49,495 --> 00:10:53,905
startup time is super, super fast
and you get near native performance.

177
00:10:54,085 --> 00:10:57,745
So some of these benefits are
super useful for cloud and edge

178
00:10:57,745 --> 00:10:59,485
deployments as we'll see later.

179
00:10:59,815 --> 00:11:01,555
And another, and probably my favorite.

180
00:11:01,795 --> 00:11:06,415
Another interesting feature of Wasm
is that you have secure sandboxing

181
00:11:06,415 --> 00:11:11,425
by default, meaning your code doesn't
have access to anything by default.

182
00:11:11,425 --> 00:11:15,925
So you can't just do an H TT
P call or a file system call.

183
00:11:16,105 --> 00:11:21,535
You have to explicitly provide access
to those APIs, and that's incredibly

184
00:11:21,535 --> 00:11:26,185
useful, especially if your final goal as
a vendor, as a provider, as a platform

185
00:11:26,515 --> 00:11:29,095
is to be able to run untrusted code.

186
00:11:29,815 --> 00:11:31,525
And we'll, look into that later.

187
00:11:31,765 --> 00:11:33,835
Now, let's look into the Go Support.

188
00:11:33,995 --> 00:11:40,415
wasm has been supported as a target
since 2018, since version one point 11.

189
00:11:40,725 --> 00:11:44,605
the official tool chain here,
I. Also provides, JavaScript

190
00:11:44,635 --> 00:11:47,185
utilities to facilitate.

191
00:11:47,465 --> 00:11:51,545
running was modules in the browser
if that's what you want to do.

192
00:11:51,545 --> 00:11:56,105
for many people like us at Edgy,
we are doing only server side,

193
00:11:56,105 --> 00:11:58,275
so that's not, super useful.

194
00:11:58,425 --> 00:12:01,905
I'm also sharing some links, feel
free to check them out, to dive a

195
00:12:01,905 --> 00:12:03,735
bit deeper into some of these topics.

196
00:12:04,325 --> 00:12:08,585
now the component model and
the WZ support is a bit behind.

197
00:12:08,615 --> 00:12:09,365
It's been.

198
00:12:09,710 --> 00:12:16,770
In experimental status, since,
2023 in version one, point 21.

199
00:12:17,130 --> 00:12:19,650
So there was the preview one.

200
00:12:19,650 --> 00:12:22,820
There are currently two was
the P one and the P two.

201
00:12:23,220 --> 00:12:23,910
but.

202
00:12:24,255 --> 00:12:27,345
There is support for Wasi P two.

203
00:12:27,405 --> 00:12:30,855
So the preview two of Wasi in Tiny Go.

204
00:12:31,155 --> 00:12:36,135
So typically you want to do
a tiny Go application or you

205
00:12:36,135 --> 00:12:37,965
want to use Tiny Go to Compile.

206
00:12:38,175 --> 00:12:44,225
And an additional thing you probably
need, if you are using your own interfaces

207
00:12:44,225 --> 00:12:51,185
or even the default ones, is that you
want to use Wi Bind Gen Go to generate.

208
00:12:51,555 --> 00:12:56,565
the kind of the bindings for the
interfaces and so there is a lot

209
00:12:56,565 --> 00:12:59,505
of co-generation involved as well.

210
00:12:59,845 --> 00:13:00,265
wit.

211
00:13:00,850 --> 00:13:06,070
Is the way that you define
interfaces in the azi world.

212
00:13:06,340 --> 00:13:10,420
So you pretty much have some standard
interfaces that interface with the

213
00:13:10,420 --> 00:13:15,790
operating system, like file system
sockets, HTTP, network calls.

214
00:13:15,900 --> 00:13:18,270
Clocks random randomness.

215
00:13:18,300 --> 00:13:25,200
And so you can also define your own
width interfaces because this is a, an

216
00:13:25,200 --> 00:13:27,480
actual interface definition language.

217
00:13:27,730 --> 00:13:31,000
so for example, that's something
we are doing at Edge as well.

218
00:13:31,000 --> 00:13:34,897
We are defining our own domain
specific interfaces so that.

219
00:13:35,810 --> 00:13:41,210
we can then allow developers to build
their own components that implement the

220
00:13:41,210 --> 00:13:45,300
interface that we defined, and we can,
run those components, in our platform.

221
00:13:45,820 --> 00:13:49,660
another interesting development from
I think a couple months ago, yeah, a

222
00:13:49,660 --> 00:13:55,480
few weeks ago, is that Google announced
expanded support in version 1 24 of Go.

223
00:13:55,750 --> 00:13:59,480
So there are better ways
to explore functions to, go

224
00:13:59,480 --> 00:14:01,010
functions to web assembly.

225
00:14:01,230 --> 00:14:04,620
And so that allows you a deeper
integration with a web assembly

226
00:14:04,650 --> 00:14:09,150
host that's super useful if you
are building modules or components.

227
00:14:09,820 --> 00:14:12,670
in the same article, and this
is something I initially missed

228
00:14:12,970 --> 00:14:15,700
myself, they also announced that.

229
00:14:16,050 --> 00:14:21,840
Wasm at the Edge is supported in the
Google pla, Google Cloud platform.

230
00:14:21,840 --> 00:14:25,500
This is super interesting 'cause
they now allow you to use service

231
00:14:25,500 --> 00:14:31,140
extensions implemented in web assembly,
in their application load balancer.

232
00:14:31,140 --> 00:14:35,880
So you can add, custom code
and custom logic in the path of

233
00:14:35,880 --> 00:14:37,470
the, in the request response.

234
00:14:37,785 --> 00:14:38,265
Path.

235
00:14:38,665 --> 00:14:43,105
I think that's an incredibly cool
example of what is possible with

236
00:14:43,105 --> 00:14:49,135
WebAssembly and also how cloud providers
or platforms in general can use it

237
00:14:49,135 --> 00:14:51,675
to extend the service capabilities.

238
00:14:52,485 --> 00:14:56,565
Now, of course, you also find
official was wasm run times,

239
00:14:56,565 --> 00:14:58,495
for example, wasm time here.

240
00:14:58,775 --> 00:15:03,895
and these run times are, Explicitly
designed for, speed and security

241
00:15:03,895 --> 00:15:07,675
and easy of configuration, and was
it support So you don't have to

242
00:15:07,675 --> 00:15:12,525
re-implement the wheel every time, just
add a little layer of, was on time.

243
00:15:12,525 --> 00:15:14,175
And that simplifies a lot of things.

244
00:15:14,625 --> 00:15:17,895
so for example, here was on
time is designed and developed

245
00:15:18,165 --> 00:15:20,055
by the, bio Code Alliance.

246
00:15:20,555 --> 00:15:23,885
If you've never heard of the Bike
Alliance, they are nonprofit.

247
00:15:24,185 --> 00:15:28,355
They're working on a lot of
different toolings like called RS

248
00:15:28,355 --> 00:15:33,515
and runtime and additional language
specific tooling for web assembly.

249
00:15:33,575 --> 00:15:33,635
It.

250
00:15:34,415 --> 00:15:38,345
they are supported by a lot
of tech companies out there.

251
00:15:38,345 --> 00:15:41,045
You probably recognize some of the logos.

252
00:15:41,045 --> 00:15:46,385
many of these are cloud providers,
edge CDM providers or even

253
00:15:46,385 --> 00:15:48,825
Wasm, native, wasm platforms.

254
00:15:48,825 --> 00:15:49,905
So there is a lot of.

255
00:15:50,275 --> 00:15:51,895
work happening in this space.

256
00:15:51,945 --> 00:15:54,795
feel free to check it out
on the website as well.

257
00:15:55,245 --> 00:15:56,475
now we have the basics.

258
00:15:56,505 --> 00:16:01,395
We know everything about edge computing
and how we got here with the compute

259
00:16:01,425 --> 00:16:07,195
platforms and with all the additional
services we know about, web assembly

260
00:16:07,255 --> 00:16:13,315
and where it's going, and how is the Go
community integrating it more deeply.

261
00:16:13,645 --> 00:16:16,975
Now, what I find super interesting
about this combination of.

262
00:16:17,570 --> 00:16:23,480
edge and web assembly is that
with edge computing, you have an

263
00:16:23,480 --> 00:16:29,240
incredible advantage that your
code is, or your application is

264
00:16:29,240 --> 00:16:31,430
globally distributed by design.

265
00:16:31,760 --> 00:16:33,680
So by default.

266
00:16:34,295 --> 00:16:38,705
When you push code to the edge, it will
run on hundreds and hundreds of edge

267
00:16:38,705 --> 00:16:41,305
locations or pops points of presence.

268
00:16:41,675 --> 00:16:43,925
and that's a big difference
compared to the cloud.

269
00:16:43,925 --> 00:16:45,755
That's interesting to be aware of.

270
00:16:45,935 --> 00:16:51,575
'cause usually an architecture starts as
a centralized or monolithic application

271
00:16:51,635 --> 00:16:55,685
that runs in a single data center or
maybe in a two or three availability

272
00:16:55,685 --> 00:16:57,455
zones, within a cloud region.

273
00:16:58,115 --> 00:16:59,405
And that's super convenient.

274
00:16:59,435 --> 00:17:01,865
you probably don't need
more than that, but.

275
00:17:02,235 --> 00:17:06,825
especially if you are building a
website or a product with a global

276
00:17:06,825 --> 00:17:12,275
audience, you quickly, very quickly
end up, using or involving some kind

277
00:17:12,275 --> 00:17:14,675
of CDN for caching and distributing.

278
00:17:14,675 --> 00:17:17,465
That's like a architectural best practice.

279
00:17:17,735 --> 00:17:23,085
And so you want to, distribute and
cash and even run code as close as

280
00:17:23,085 --> 00:17:27,805
possible to your final, visitors to
your final, users and customers and.

281
00:17:28,145 --> 00:17:31,475
I find it very fascinating
that with edge computing, all

282
00:17:31,475 --> 00:17:33,575
of that happens automatically.

283
00:17:33,815 --> 00:17:39,105
And so your edge applications are globally
distributed, with a couple of clicks.

284
00:17:39,255 --> 00:17:43,255
If you compare that to the cloud,
it's been increasingly easier to

285
00:17:43,255 --> 00:17:47,125
do in the last few years, it's
still not the same, in my opinion.

286
00:17:47,845 --> 00:17:49,530
Now, another interesting.

287
00:17:50,260 --> 00:17:55,360
Technical trade off to be aware of
is that usually at the edge you have

288
00:17:55,360 --> 00:18:00,190
less compute power and you have less
resources in general, compared to a

289
00:18:00,190 --> 00:18:04,020
virtual machine where you can have,
gigabytes and gigabytes of ram or a

290
00:18:04,020 --> 00:18:06,240
container or even a serverless function.

291
00:18:06,580 --> 00:18:07,510
also.

292
00:18:07,945 --> 00:18:11,935
Things really need to happen
quickly because often your edge

293
00:18:11,935 --> 00:18:17,285
compute logic runs before and
after, every single HTTP request.

294
00:18:17,495 --> 00:18:23,685
So if you are adding, if it takes you 20
or 50 or a hundred milliseconds to run,

295
00:18:23,925 --> 00:18:25,665
it means that you're probably adding.

296
00:18:25,975 --> 00:18:29,655
Additional latency to
every single, HCDP request.

297
00:18:29,685 --> 00:18:31,335
And that's not great, right?

298
00:18:31,335 --> 00:18:33,285
You want to run as fast as possible.

299
00:18:33,525 --> 00:18:38,445
So normally you want to run
your AT Logic in five to 10

300
00:18:38,445 --> 00:18:40,635
milliseconds, and that's really fast.

301
00:18:40,635 --> 00:18:41,415
If you think about it.

302
00:18:41,415 --> 00:18:46,545
If you have to talk to a Qing system
or a database or a key value store,

303
00:18:46,695 --> 00:18:48,345
you know you really need to be quick.

304
00:18:48,845 --> 00:18:54,395
Now, while it's true that some Edge
and CDN providers are making this.

305
00:18:54,895 --> 00:18:56,455
Less of a problem.

306
00:18:56,505 --> 00:19:01,725
most edge deployments need to be aware
of, this kind of technical constraints or

307
00:19:01,725 --> 00:19:04,665
limitations or, trade offs, for example.

308
00:19:05,440 --> 00:19:10,150
bunny.net recently announced their
magic containers, just a few weeks ago.

309
00:19:10,450 --> 00:19:14,650
And also Akamai seems to be pushing
a lot their managed container

310
00:19:14,650 --> 00:19:19,000
service in their cloud, which is
actually, distributed like the edge.

311
00:19:19,330 --> 00:19:22,750
So there is a lot happening
also in this space and being

312
00:19:22,750 --> 00:19:24,535
aware of the trade offs and the.

313
00:19:25,000 --> 00:19:29,650
Pricing limitations on or differences is
really useful in my opinion, especially

314
00:19:29,650 --> 00:19:34,090
if you come from the more traditional
cloud world and you're used to, Ty,

315
00:19:34,600 --> 00:19:36,490
traditional visual machines, for example.

316
00:19:36,990 --> 00:19:42,330
Now, if you remember the was key
benefits that we saw earlier.

317
00:19:42,610 --> 00:19:46,330
There are two or three of these that
are really important for the edge,

318
00:19:46,360 --> 00:19:48,490
especially the neo native performance.

319
00:19:48,490 --> 00:19:52,880
Again, we need to run as quickly as
possible within just a few milliseconds.

320
00:19:52,880 --> 00:19:55,400
Ideally, 2, 3, 4, 5 is great.

321
00:19:55,640 --> 00:19:56,420
If you go above.

322
00:19:56,825 --> 00:19:59,195
10, 20 or 50 becomes a problem.

323
00:19:59,665 --> 00:20:04,715
we also have that very small size
and very fast initialization, because

324
00:20:04,715 --> 00:20:10,115
we cannot afford seconds and seconds
of startup time or cold starts like

325
00:20:10,115 --> 00:20:11,675
you typically have with containers.

326
00:20:11,705 --> 00:20:15,545
It could take tens of seconds to
spin up a container, or it could

327
00:20:15,545 --> 00:20:20,285
take hundreds of milliseconds to
spin up a serverless function.

328
00:20:20,965 --> 00:20:24,745
Typically at the edge, we can't afford
that, so we need to be even faster.

329
00:20:25,175 --> 00:20:30,665
and then we love the security sandboxing
for the edge, especially if you are

330
00:20:30,665 --> 00:20:35,615
running, again, untrusted code and you
want to limit network access because

331
00:20:35,615 --> 00:20:39,455
you know it might become problematic
if you need to fetch an external API

332
00:20:39,455 --> 00:20:43,955
call and it takes two seconds or half
a second, even half a second is a lot.

333
00:20:44,585 --> 00:20:45,095
Now.

334
00:20:45,935 --> 00:20:47,915
That's why we chose.

335
00:20:48,305 --> 00:20:54,335
This interesting match of web
assembly and edge computing at edgy.

336
00:20:54,395 --> 00:20:59,635
And as you can guess from the name, we
are doing a lot of, stuff at the edge.

337
00:20:59,945 --> 00:21:06,075
in a nutshell, we are building a platform
for application level services powered

338
00:21:06,075 --> 00:21:08,025
by edge computing and web assembly.

339
00:21:08,665 --> 00:21:12,595
lemme tell you a bit more, the core
service that we are, that we've been

340
00:21:12,595 --> 00:21:15,235
working on so far is really focused on.

341
00:21:15,605 --> 00:21:19,565
data collection and web analytics,
but that's just the starting point.

342
00:21:19,875 --> 00:21:24,865
the final goal, for data collection
and web analytics is to allow our

343
00:21:24,865 --> 00:21:31,735
customers to transfer those typical,
heavy client side SDKs, like for the

344
00:21:31,735 --> 00:21:33,985
Google analytics or segment or amplitude.

345
00:21:33,985 --> 00:21:39,420
things that you have to do traditionally,
have to do on the client, somewhere else.

346
00:21:39,420 --> 00:21:40,230
So we want to.

347
00:21:40,605 --> 00:21:46,275
Take advantage of the edge and
transform those SDKs into web assembly

348
00:21:46,275 --> 00:21:50,775
components that can run even before
the page is sent back to the browser.

349
00:21:51,195 --> 00:21:52,155
So this allows.

350
00:21:52,515 --> 00:21:57,035
Zero latency, very secure and
unblockable data connection, collection.

351
00:21:57,035 --> 00:22:00,065
So it is solving an
actual business problem.

352
00:22:00,285 --> 00:22:04,975
if you're a website owner, you want
to take decisions based on, how people

353
00:22:04,975 --> 00:22:08,635
use your product or what content
they are consuming on your platform.

354
00:22:08,795 --> 00:22:11,975
this is important to make
sure you can make data-driven

355
00:22:11,975 --> 00:22:13,385
decisions that make sense.

356
00:22:14,255 --> 00:22:16,685
and again, this is just a starting point.

357
00:22:16,745 --> 00:22:20,285
We're working on new types of
components in the future to

358
00:22:20,285 --> 00:22:21,755
support additional use cases.

359
00:22:21,755 --> 00:22:26,415
data collection is, the core, but
we are adding AB testing, feature

360
00:22:26,415 --> 00:22:30,525
flags, AI inference, and a lot
more use cases in the future.

361
00:22:30,805 --> 00:22:36,195
we also created what we call the
edgy component registry and this is

362
00:22:36,195 --> 00:22:40,845
basically a registry for wasm components.

363
00:22:41,310 --> 00:22:45,780
Running at the edge, so this is just
very new from a few weeks ago as a

364
00:22:45,780 --> 00:22:51,270
developer, now you can build, push,
and share A was component and then.

365
00:22:51,900 --> 00:22:55,440
Allow anybody to use them
directly on the edgy platform.

366
00:22:55,440 --> 00:22:57,060
And, this is super cool.

367
00:22:57,060 --> 00:22:59,660
I think, all of these
components are open source.

368
00:22:59,870 --> 00:23:04,630
Even the, proxy of the edgy
proxy itself is open source.

369
00:23:04,690 --> 00:23:09,110
And so what we're trying to do here is
create a nice community of, contributors

370
00:23:09,200 --> 00:23:13,790
and component developers that can
build and share these components.

371
00:23:13,850 --> 00:23:18,530
So you can think of this
as a domain specific.

372
00:23:18,980 --> 00:23:23,760
Registry, for web assembly components
where you can discover and push

373
00:23:24,120 --> 00:23:28,380
either private or public components
for yourself, for your customers,

374
00:23:28,380 --> 00:23:30,490
for the whole community, to use.

375
00:23:30,730 --> 00:23:34,060
Now we also invested a
lot in developer tools.

376
00:23:34,060 --> 00:23:39,970
it is just uploading files in a
website or, or, invoking APIs manually.

377
00:23:40,180 --> 00:23:42,790
We wanted to make the
developer experience as.

378
00:23:43,155 --> 00:23:45,765
easy modes and pleasant as possible.

379
00:23:45,855 --> 00:23:50,805
So we built some developer tools
like the ed, GCLI to allow you to

380
00:23:50,805 --> 00:23:52,875
support all the different languages.

381
00:23:52,875 --> 00:23:54,915
of course, GO is supported.

382
00:23:55,125 --> 00:24:00,905
We also support, rust and Python and
C Sharp and type script and so on.

383
00:24:01,445 --> 00:24:06,185
The goal of the CLI really is to allow
you to build and test locally whatever

384
00:24:06,185 --> 00:24:11,015
language you're using, and then easily
push your component to the registry.

385
00:24:11,355 --> 00:24:13,035
it's is also open source.

386
00:24:13,475 --> 00:24:15,935
and I also wanted to show you.

387
00:24:16,195 --> 00:24:17,605
What this actually looks like.

388
00:24:17,975 --> 00:24:20,165
so you can very easily, install it.

389
00:24:20,165 --> 00:24:21,215
There are different ways to do it.

390
00:24:21,215 --> 00:24:22,895
And then you create a new component.

391
00:24:23,015 --> 00:24:26,775
So for example, let's choose
go, it will auto initialize all

392
00:24:26,775 --> 00:24:30,525
the width dependencies, and then
you implement a business logic

393
00:24:30,555 --> 00:24:32,415
and compile to web assembly.

394
00:24:32,415 --> 00:24:36,615
It's all one comment add component
build, and it magically does.

395
00:24:36,980 --> 00:24:41,130
They work for you of generating
the width, bindings and running.

396
00:24:41,460 --> 00:24:46,350
They compile into wasm, and then you
can finally test locally and make sure

397
00:24:46,350 --> 00:24:48,390
that your code is behaving properly.

398
00:24:48,510 --> 00:24:52,890
And when everything's ready, you
add your component, push into

399
00:24:52,890 --> 00:24:55,110
the registry and your component.

400
00:24:55,110 --> 00:25:00,260
If public becomes available to everyone
out there, or even, maybe you push it as

401
00:25:00,260 --> 00:25:04,250
a private one and it becomes available
to your organization or your customers.

402
00:25:04,750 --> 00:25:05,830
So this is really cool.

403
00:25:06,020 --> 00:25:08,630
I also wanted to share with you
a little bit of the high level

404
00:25:08,630 --> 00:25:11,000
architecture, what this all looks like.

405
00:25:11,030 --> 00:25:14,460
I already showed you what the
super high level looks like.

406
00:25:14,670 --> 00:25:17,190
So you have the client
devices, you have the.

407
00:25:17,600 --> 00:25:21,410
edge Proxy running, on Fastly today.

408
00:25:21,410 --> 00:25:25,700
We are expanding soon to run on
other CDNs like CloudFlare and so

409
00:25:25,700 --> 00:25:31,190
on, and then the proxy is there
in between the client devices and

410
00:25:31,190 --> 00:25:33,230
the website, the final website.

411
00:25:33,530 --> 00:25:39,020
And so there is a lot happening behind the
scenes because not a hundred percent of

412
00:25:39,020 --> 00:25:41,090
the logic can happen directly at the edge.

413
00:25:41,090 --> 00:25:43,790
We have some kind of backend
services and managed.

414
00:25:44,085 --> 00:25:46,245
consoles and APIs and so on.

415
00:25:46,435 --> 00:25:51,265
for example, the Edge proxy is
talking to an event API, which

416
00:25:51,265 --> 00:25:52,650
take cares of actually running.

417
00:25:53,215 --> 00:25:56,725
The web assembly component and
integrating with third party

418
00:25:56,755 --> 00:25:58,825
APIs and third party platforms.

419
00:25:59,155 --> 00:26:03,265
And then you have the public
website, you have the Edge GCLI

420
00:26:03,385 --> 00:26:08,125
and potentially other API consumers
who talk to the edgy API as well.

421
00:26:08,505 --> 00:26:12,675
and as you can imagine, the edge
behavior needs to be customizable.

422
00:26:12,795 --> 00:26:17,055
So the edgy API itself needs to
be able to interact with the proxy

423
00:26:17,145 --> 00:26:21,835
and provide, customizations and
configurations directly at the edge.

424
00:26:22,255 --> 00:26:23,815
There is a lot going on.

425
00:26:24,035 --> 00:26:28,595
our long-term vision here is to be
able to run even more of the web

426
00:26:28,595 --> 00:26:34,195
assembly things directly on top of,
the edge proxy on top of, CDNs, there

427
00:26:34,195 --> 00:26:38,635
are some technical limitations today
as far as the component model support.

428
00:26:38,875 --> 00:26:42,115
So we are ending up creating our own.

429
00:26:42,280 --> 00:26:47,610
Distributed network across multiple
clouds, across multiples, compute models.

430
00:26:47,610 --> 00:26:51,480
For now, we are focusing on AWS
Lambda because it's helping us

431
00:26:51,480 --> 00:26:54,200
go, fast and scale when needed.

432
00:26:54,590 --> 00:26:56,990
and so that's what I had for you today.

433
00:26:56,990 --> 00:26:58,115
I wanted to remember that.

434
00:26:58,555 --> 00:27:02,325
CDNs, are not just for caching
and data protection anymore.

435
00:27:02,325 --> 00:27:07,825
There is a lot more, compute capacity
and application level services like

436
00:27:07,825 --> 00:27:09,805
databases, object storage, and so on.

437
00:27:10,285 --> 00:27:14,305
The edge is providing a new
way for building application,

438
00:27:14,305 --> 00:27:17,875
especially globally distributed
applications and functionalities.

439
00:27:18,570 --> 00:27:22,830
web assembly and yz have a very
bright future in my opinion, and

440
00:27:22,830 --> 00:27:24,450
we are investing a lot on it.

441
00:27:24,750 --> 00:27:29,260
There is a big community, focusing on
tooling and improving experience and

442
00:27:29,260 --> 00:27:31,330
adding support for even more languages.

443
00:27:31,610 --> 00:27:35,330
if you're interested into the idea of
a component registry and you want to

444
00:27:35,360 --> 00:27:38,660
contribute and create your components,
feel free to join our community.

445
00:27:38,750 --> 00:27:40,130
You can push for free.

446
00:27:40,260 --> 00:27:44,220
there is a free tier that allow you to
do a lot and experiment as a developer.

447
00:27:44,675 --> 00:27:46,475
Then we can talk business as well.

448
00:27:46,965 --> 00:27:48,495
thank you for joining this session.

449
00:27:48,495 --> 00:27:50,085
I am Alex from edgy.

450
00:27:50,085 --> 00:27:53,035
You can find me on LinkedIn
or on other social media.

451
00:27:53,275 --> 00:27:54,325
Feel free to reach out.

452
00:27:54,655 --> 00:27:58,125
I hope you learned something
new today and, have fun with

453
00:27:58,125 --> 00:27:59,355
wet assembly and the edge.

454
00:27:59,770 --> 00:28:00,260
Bye-bye.

