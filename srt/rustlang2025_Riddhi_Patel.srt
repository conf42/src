1
00:00:00,500 --> 00:00:01,279
Welcome everyone.

2
00:00:01,369 --> 00:00:05,299
My name is Ti Patel from DRC system LLC.

3
00:00:05,869 --> 00:00:10,879
Today I will walk you through how Rust
can help solve the problems and the

4
00:00:10,879 --> 00:00:13,999
safety challenges of next generation 5G.

5
00:00:14,450 --> 00:00:18,380
This talks brings together
my experience in system level

6
00:00:18,380 --> 00:00:23,840
architecture and my current research
into rust based network system.

7
00:00:24,340 --> 00:00:28,570
We will begin with the core
performance challenges of 5G.

8
00:00:28,659 --> 00:00:32,290
Then I will explain Rust unique
strength that makes it deal

9
00:00:32,290 --> 00:00:33,820
for the system programming.

10
00:00:34,450 --> 00:00:39,310
We will dive into real world
implementation for traffic management.

11
00:00:39,730 --> 00:00:44,200
I will share the benchmark result
and with the practical techniques

12
00:00:44,230 --> 00:00:46,209
you can use in your work.

13
00:00:46,709 --> 00:00:50,969
5G system requires extremely low
latency under five milliseconds,

14
00:00:50,969 --> 00:00:55,559
and to end the must handle
massive concurrency and maintain.

15
00:00:56,430 --> 00:01:01,410
Near perfect reliability, whether
traditional language like C and c plus

16
00:01:01,410 --> 00:01:08,010
thread memory, safety for speed, which
introduce risk and a safe language like

17
00:01:08,010 --> 00:01:12,990
Java, or go struggle with the real time
guarantee due to garbage collection.

18
00:01:13,490 --> 00:01:15,290
Why traditional approach falls apart.

19
00:01:15,620 --> 00:01:21,195
CNC plus offers speed, but at the
cost of MA safety leading to issue

20
00:01:21,255 --> 00:01:25,785
like a buffer overflows, manual memory
management, slow down development,

21
00:01:25,785 --> 00:01:30,840
and increased bucks language with
the garbage collector like Java and

22
00:01:30,880 --> 00:01:32,920
a go are safer, but unpredictable.

23
00:01:33,600 --> 00:01:36,390
Because of pauses, make them unsuitable.

24
00:01:36,660 --> 00:01:42,030
For the realtime 5G workloads, we need
a solution that's both fast and safe.

25
00:01:42,420 --> 00:01:44,490
That was rust Come in.

26
00:01:44,990 --> 00:01:47,600
Rust unique advantage for the 5G system.

27
00:01:48,020 --> 00:01:51,020
Rust, give us a mammary safety
without a garbage collector.

28
00:01:51,229 --> 00:01:55,190
Thanks to its ownership
model, its zero Cost.

29
00:01:55,190 --> 00:02:00,289
Abstraction mean you get the high level
core with the C. Like performance.

30
00:02:00,789 --> 00:02:03,579
Fearless concurrency is built in rust.

31
00:02:03,579 --> 00:02:05,139
Prevent data, racist.

32
00:02:05,709 --> 00:02:11,829
At compile time and even when you
need low level control, rust unsafe

33
00:02:11,829 --> 00:02:17,200
blocks are scoped and the control
ensuring overall system safety.

34
00:02:17,700 --> 00:02:19,620
Smart network manager architecture.

35
00:02:19,950 --> 00:02:24,870
So here's a Simplifi architecture for
the high performance 5G Traffic manager.

36
00:02:25,350 --> 00:02:30,630
The radio interface layer process packets
are synchronously using zero copy buffer.

37
00:02:31,320 --> 00:02:36,090
The traffic classification engine
uses rust types system for the

38
00:02:36,090 --> 00:02:41,040
compiled time optimized matching
the routing core handle log free

39
00:02:41,130 --> 00:02:43,440
concurrency and the performance mam.

40
00:02:43,710 --> 00:02:47,880
Safe DMA operation for fast, safe routing,

41
00:02:48,380 --> 00:02:50,750
zero copy networking in cc plus.

42
00:02:50,750 --> 00:02:54,590
You have to manually manage
mammary if you forget to free.

43
00:02:55,090 --> 00:02:58,660
You get a leak or crash rust model.

44
00:02:58,750 --> 00:03:04,870
Let us use slices to create a
zero copy views of data safety.

45
00:03:05,470 --> 00:03:08,860
Memory is automatically released
when it goes out of scope.

46
00:03:09,190 --> 00:03:10,780
No leaks, no crashes.

47
00:03:11,140 --> 00:03:15,190
This model help us achieve both
safety and a high throughout.

48
00:03:15,690 --> 00:03:21,000
So there is a, our system achieves
like 4.2 milliseconds, end to end

49
00:03:21,000 --> 00:03:26,790
latency even under heavy load, well
under the five milliseconds target.

50
00:03:27,390 --> 00:03:33,450
We show 300% throughout the gain compared
towards similar c plus implementation.

51
00:03:34,050 --> 00:03:36,870
CPU usage dropped by 65%.

52
00:03:36,960 --> 00:03:38,130
Freeing up resources.

53
00:03:38,630 --> 00:03:44,710
And over 18 months of deployment,
zero mammary safety, P memory

54
00:03:44,710 --> 00:03:46,810
bandwidth improvements.

55
00:03:47,140 --> 00:03:52,300
Rest zero copy techniques greatly reduce
how much data we have moved around

56
00:03:52,300 --> 00:03:57,940
in the mammary that not only increase
speed, but also reduce the strain on

57
00:03:57,940 --> 00:04:05,045
hardware, making it idle for the resource
constrained environment like H devices.

58
00:04:05,545 --> 00:04:07,525
Advancing pattern.

59
00:04:08,005 --> 00:04:11,515
So rust is a sync or a
weight model help us.

60
00:04:11,545 --> 00:04:15,355
The non-blocking code that's
both fast and reliable.

61
00:04:15,855 --> 00:04:20,575
We use the custom custom futures
and the stream combinator to

62
00:04:20,575 --> 00:04:22,495
protect packets efficiently.

63
00:04:23,005 --> 00:04:28,165
Unlike callback based in model
rust approach avoids spaghetti code

64
00:04:28,225 --> 00:04:31,195
with the cutting down memory usage.

65
00:04:31,695 --> 00:04:35,115
Rust type system in a hidden
superpower for performance.

66
00:04:35,355 --> 00:04:40,575
With the compiled time polymorphism,
we write generic code that compiles

67
00:04:40,605 --> 00:04:43,245
into highly optimized routines.

68
00:04:43,815 --> 00:04:45,285
No runtime cost.

69
00:04:45,765 --> 00:04:51,215
The type state pattern and code
app state in a system, eliminating

70
00:04:51,215 --> 00:04:53,675
whole classes of runtime bucks.

71
00:04:54,175 --> 00:04:54,925
Memory safe.

72
00:04:54,925 --> 00:05:00,055
DMA operations DMA is accessed
in traditionally dangerous,

73
00:05:00,085 --> 00:05:01,615
but we can wrap it up.

74
00:05:01,675 --> 00:05:03,295
Safe rest abstraction.

75
00:05:03,355 --> 00:05:10,125
Here we define the DMA buffers struck and
implement cleanup in a safe way using.

76
00:05:11,040 --> 00:05:11,700
The result.

77
00:05:12,210 --> 00:05:16,740
Direct Hardware access with the
safety guarantees sometime previously

78
00:05:16,740 --> 00:05:19,800
only possible with the risky code.

79
00:05:20,300 --> 00:05:25,430
Rest, give us a performance
without compromise, sub family.

80
00:05:25,430 --> 00:05:27,050
Second lesson, latency and a total.

81
00:05:27,550 --> 00:05:33,070
Memory safety, its ownership
model allows for zero copy data.

82
00:05:33,070 --> 00:05:37,390
Race free networking you
can adapt in incrementally.

83
00:05:37,390 --> 00:05:42,795
Start by replacing critical components in
CNC plus system without a full rewrite.

84
00:05:43,505 --> 00:05:48,910
REST is not just a safe language, it's
the next generation system language

85
00:05:48,970 --> 00:05:51,370
that 5G infrastructure demand.

86
00:05:51,870 --> 00:05:52,950
Thank you for listening.

87
00:05:52,950 --> 00:05:58,230
If you would like to dive deeper and
explore collaboration around 5G or

88
00:05:58,230 --> 00:06:00,390
the system, feel free to contact.

89
00:06:00,960 --> 00:06:01,440
Thank you.

