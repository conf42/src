1
00:00:00,010 --> 00:00:00,740
Hello everyone.

2
00:00:01,350 --> 00:00:03,450
Welcome and thank you
for joining me today.

3
00:00:04,240 --> 00:00:08,039
I'm excited to take you through
how Python and AI can enhance

4
00:00:08,039 --> 00:00:12,189
test automation and security for
quality driven DevSecOps approach.

5
00:00:12,689 --> 00:00:16,289
Before we dive in, let me give a
quick introduction about myself.

6
00:00:16,339 --> 00:00:19,719
I'm Sriman Yaram, senior software
engineering manager in test at

7
00:00:19,759 --> 00:00:23,519
Coupa Software with over 19 plus
years of experience in distributed

8
00:00:23,519 --> 00:00:26,999
systems, microservices, and
quality engineering practices.

9
00:00:27,474 --> 00:00:31,054
I have worked across industries
like FinTech, SaaS, and enterprise

10
00:00:31,084 --> 00:00:35,334
products, delivering high scalable
and resilient products used by Fortune

11
00:00:35,334 --> 00:00:39,774
500 companies, with several products
recognized as industry leaders and

12
00:00:39,774 --> 00:00:44,504
best in its class by research firms
like Forster, Gartner, and IDC.

13
00:00:44,884 --> 00:00:48,314
Outside the work, I enjoy mentoring
and sharing knowledge with a

14
00:00:48,314 --> 00:00:51,744
tech community, staying ahead
in evolving software landscape.

15
00:00:52,104 --> 00:00:57,784
I explore AI, AI's impact on the ever
changing, software industry, landscape.

16
00:00:58,654 --> 00:01:00,894
Before we dive in, here is a disclaimer.

17
00:01:01,044 --> 00:01:04,124
I would like to clarify that views
and contents shared today are

18
00:01:04,154 --> 00:01:08,804
entirely my own and does not reflect
those of my employers or, employer.

19
00:01:09,279 --> 00:01:11,179
or any, affiliated organization.

20
00:01:11,189 --> 00:01:14,929
The code samples provided are
demonstration purpose only and may

21
00:01:14,929 --> 00:01:19,008
not be fully functional serving to
illustrate, concepts rather than, rather

22
00:01:19,008 --> 00:01:20,942
than being a production ready code.

23
00:01:21,442 --> 00:01:24,702
Okay, before we dive in, again,
quick agenda, introduction

24
00:01:24,702 --> 00:01:26,971
to, Dev, DevOps and DevSecOps.

25
00:01:27,111 --> 00:01:32,001
in this one, we'll try to focus on
understanding DevSecOps, its importance

26
00:01:32,001 --> 00:01:34,521
and differences from Dev, DevOps.

27
00:01:34,991 --> 00:01:37,411
Then we'll go into role
of Python in Dev, DevOps.

28
00:01:37,471 --> 00:01:41,171
Python automates security tasks and
integrates into CI, CD pipelines.

29
00:01:41,671 --> 00:01:46,251
then we will roll into leveraging
AI in DevSecOps, AI enhanced

30
00:01:46,261 --> 00:01:50,371
security with automated threat
detection and proactive insights.

31
00:01:50,811 --> 00:01:52,901
Then we'll go into tool based approach.

32
00:01:53,011 --> 00:01:56,832
And I tried mapping, this, tools,
in a DevSecOps, phase, right

33
00:01:56,852 --> 00:01:58,422
from the, development phase.

34
00:01:58,432 --> 00:02:00,582
So we divide the tools into dev phase.

35
00:02:00,622 --> 00:02:04,392
What are the tools that we can use,
code review phase, build phase,

36
00:02:04,422 --> 00:02:06,442
deployment phase, production ready phase.

37
00:02:06,942 --> 00:02:09,872
And how these tools can be
effectively implemented as well.

38
00:02:10,582 --> 00:02:13,892
Then we will, go into some of
the best practices, practical

39
00:02:13,932 --> 00:02:17,992
tips, for gradual adoption and
focusing on high impact areas.

40
00:02:18,462 --> 00:02:22,592
While I mentioned many times in the
slides that CICD very frequently,

41
00:02:22,642 --> 00:02:24,732
in, in, in upcoming slides.

42
00:02:24,877 --> 00:02:28,807
But for this demo, our focus is on
showing the key open source tool.

43
00:02:29,377 --> 00:02:34,177
These tools can be seamlessly integrated
into CICD pipelines for GitHub actions

44
00:02:34,227 --> 00:02:36,957
or for automated security testing.

45
00:02:37,457 --> 00:02:38,327
Interaction.

46
00:02:38,827 --> 00:02:39,977
So DevOps.

47
00:02:40,317 --> 00:02:43,957
DevOps transforms software
development by focusing on speed,

48
00:02:44,487 --> 00:02:46,287
collaboration, and automation.

49
00:02:46,797 --> 00:02:50,967
However, security often takes
backseat, leading to vulnerabilities.

50
00:02:51,467 --> 00:02:55,287
Now, that's where, this, what, DevOps,
DevSecOps comes into the picture.

51
00:02:55,627 --> 00:03:00,047
DevSecOps builds on DevOps by
embedding security from day one.

52
00:03:00,617 --> 00:03:06,097
Right from the development phase itself,
making it as a continuous, development.

53
00:03:06,667 --> 00:03:11,857
And it's a shared responsibility across
development operations and security team.

54
00:03:12,357 --> 00:03:14,347
Why shift to DevSecOps?

55
00:03:14,887 --> 00:03:18,947
Cyber, attacks are becoming, more
sophisticated and very frequent.

56
00:03:19,807 --> 00:03:25,182
Compliances like GDPR, SOC, HIPAA
requires proactive security measures.

57
00:03:25,682 --> 00:03:29,882
A breach can, result in, several
financial and, reputational damage.

58
00:03:30,392 --> 00:03:34,202
DevSecOps helps us to detect
the vulnerabilities right in the

59
00:03:34,222 --> 00:03:38,562
development phase itself and prevent
security gaps before they escalate.

60
00:03:39,062 --> 00:03:44,382
On this slide, my key takeaways
are DevOps focused on speed.

61
00:03:45,182 --> 00:03:50,102
DevSecOps ensures speed with
security, preventing costly

62
00:03:50,112 --> 00:03:55,272
mistakes and costly mistakes to
be avoided as early as possible.

63
00:03:56,152 --> 00:04:00,082
While we are ensuring the
compliances from the start as well.

64
00:04:00,582 --> 00:04:05,652
Let's quickly see the role
of Python in DevSecOps.

65
00:04:06,532 --> 00:04:09,112
As we know, Python is
one powerful language.

66
00:04:09,152 --> 00:04:11,502
Python is a game changer in DevSecOps.

67
00:04:12,162 --> 00:04:16,732
Python is a top choice for security
automation because of its simplicity,

68
00:04:16,742 --> 00:04:19,452
flexibility, rich echo system.

69
00:04:20,037 --> 00:04:25,017
Rich echo library systems, while
other languages can do similar, tasks,

70
00:04:25,097 --> 00:04:32,027
Python stands out of it's easy of use
and fast deployment, making security

71
00:04:32,027 --> 00:04:34,407
automation accessible to everyone.

72
00:04:35,297 --> 00:04:39,707
I would like to highlight where Python,
really helps vulnerability scanners.

73
00:04:40,207 --> 00:04:44,257
Detecting flaws early with
the tools like Safety, Bandit,

74
00:04:44,707 --> 00:04:46,547
Dependabot, Trufflehawk, GitLinks.

75
00:04:46,577 --> 00:04:48,687
There are a lot of tools
which are available.

76
00:04:49,447 --> 00:04:51,787
AI based security solutions.

77
00:04:52,027 --> 00:04:57,507
Python strengthens in AI, ML. Helps
to build smarter threat detection and

78
00:04:57,527 --> 00:05:00,807
more models faster than any other.

79
00:05:01,307 --> 00:05:03,367
Another, good thing, threat detection.

80
00:05:03,647 --> 00:05:08,837
it analyzes the logs, real time
logs to catch suspicious activities

81
00:05:08,867 --> 00:05:11,517
before they became bigger issues.

82
00:05:12,017 --> 00:05:15,277
While, the other things which I
would like to highlight in Python

83
00:05:15,287 --> 00:05:17,327
as well, it's easy to learn and use.

84
00:05:17,752 --> 00:05:20,972
for even for non security
professionals or for any other

85
00:05:21,152 --> 00:05:23,631
programming language experts as well.

86
00:05:23,632 --> 00:05:27,042
Works well with popular
security and DevOps tools.

87
00:05:27,482 --> 00:05:29,072
Large community support.

88
00:05:29,122 --> 00:05:32,732
We have large community support
and ready to use libraries with,

89
00:05:33,272 --> 00:05:35,672
which makes automation much easier.

90
00:05:36,462 --> 00:05:38,056
Again, key takeaway.

91
00:05:38,447 --> 00:05:45,207
Python makes DevSecOps practical and
efficient by simplifying security

92
00:05:45,207 --> 00:05:49,987
automations and enabling teams to
focus on building secure applications

93
00:05:49,997 --> 00:05:52,247
without extra complexities.

94
00:05:52,747 --> 00:05:57,007
Now comes why role of AI
in security and DevSecOps.

95
00:05:57,577 --> 00:05:58,977
Why AI in security?

96
00:05:59,477 --> 00:06:00,817
It's a provoking question, right?

97
00:06:00,867 --> 00:06:02,517
Why AI in security?

98
00:06:02,517 --> 00:06:04,197
What are the key benefits we are getting?

99
00:06:04,207 --> 00:06:07,027
How does it contributes to DevSecOps?

100
00:06:07,417 --> 00:06:10,997
Yeah, security techs are
getting smarter and faster.

101
00:06:10,997 --> 00:06:18,832
AI help us to stay ahead by Predicting,
predicting potential risk by analyzing

102
00:06:18,862 --> 00:06:23,922
the patterns, just assume just like
a weather app forecast, be forecast

103
00:06:23,932 --> 00:06:28,102
storms and weather conditions based
on the day, based on the past data.

104
00:06:28,602 --> 00:06:31,032
Detecting suspicious
activity in real time.

105
00:06:31,962 --> 00:06:35,392
Think like of a home security
system that alerts you when

106
00:06:35,722 --> 00:06:37,722
it detects unusual moments.

107
00:06:38,222 --> 00:06:42,972
respond, instantly stop threats
from spreading like an automatic

108
00:06:42,972 --> 00:06:47,322
sprinkler system that puts out
a fire before it gets worse.

109
00:06:47,822 --> 00:06:50,882
Again, if we go back to the second
question, the second provoking

110
00:06:50,882 --> 00:06:53,382
question, what are the key
benefits that we are going to get?

111
00:06:53,882 --> 00:06:55,182
Automated Threat Scanning.

112
00:06:55,502 --> 00:06:59,032
AI can scan a huge amount of data quickly.

113
00:06:59,752 --> 00:07:05,532
Like a spam filter that sorts through
emails to catch phishing attempts.

114
00:07:06,032 --> 00:07:07,472
Intelligent Code Analysis.

115
00:07:07,522 --> 00:07:11,932
It not only spots security flaws,
but also suggests fixes just

116
00:07:11,942 --> 00:07:13,302
like a grammar checker, right?

117
00:07:13,832 --> 00:07:15,822
That corrects your mistakes as you write.

118
00:07:16,322 --> 00:07:17,972
Continuous security improvement.

119
00:07:18,582 --> 00:07:20,472
AI keeps learning and adapting.

120
00:07:20,882 --> 00:07:24,272
It's like your fitness tracker
that adjusts goals based

121
00:07:24,282 --> 00:07:26,002
on your activity patterns.

122
00:07:26,502 --> 00:07:29,462
Now the third question I would
try to address is how does

123
00:07:29,502 --> 00:07:31,442
AI contribute to DevSecOps?

124
00:07:32,002 --> 00:07:33,602
Smarter test pipelines.

125
00:07:34,102 --> 00:07:36,142
AI creates better test cases.

126
00:07:36,622 --> 00:07:40,002
Oh, assume like it's like
GP, it's like your GPS.

127
00:07:40,262 --> 00:07:44,882
or maps suggesting the best route
and, based on the real time, traffic.

128
00:07:45,712 --> 00:07:47,822
Real time anomaly detection.

129
00:07:48,302 --> 00:07:52,022
AI monitors, logs, and system, logs.

130
00:07:52,562 --> 00:07:55,862
It's like a surveillance
camera and that notifies you an

131
00:07:55,872 --> 00:07:57,592
unexpected visitor is coming.

132
00:07:58,092 --> 00:07:59,822
Automated complaincy checks.

133
00:08:00,682 --> 00:08:02,732
AI ensures policies are followed.

134
00:08:03,297 --> 00:08:10,007
Think of it's like a tax software that
helps to stay you complaint without manual

135
00:08:10,007 --> 00:08:12,537
effort to just to conclude the slide.

136
00:08:12,637 --> 00:08:17,197
my key takeaway here is AI
is not here to replace us.

137
00:08:18,097 --> 00:08:22,787
It's there to make security smarter,
faster and easier to manage.

138
00:08:23,287 --> 00:08:26,907
before we get into deep dive into
the tools, here is, what I have

139
00:08:26,907 --> 00:08:30,657
divided the tools into six phases,
considering the development life cycle.

140
00:08:30,997 --> 00:08:34,517
one is the static analysis,
phase where I, dev phase, and we

141
00:08:34,517 --> 00:08:36,417
use, tools like static analysis.

142
00:08:37,037 --> 00:08:41,047
the, again, the security, Security
is not just about having the tools

143
00:08:41,047 --> 00:08:46,837
again, it's about making them smarter
with AI to catch issues early and

144
00:08:46,837 --> 00:08:48,437
automate responses effectively.

145
00:08:48,937 --> 00:08:52,857
AI helps to optimize security
tools to work better and faster.

146
00:08:53,382 --> 00:08:57,902
So again, as I mentioned, at dev phase,
we are going to use static analysis tools.

147
00:08:58,632 --> 00:09:02,082
at code review phase, we would
be, using secret detection tools

148
00:09:02,102 --> 00:09:03,342
like Git Lake, TruffleHawk.

149
00:09:03,392 --> 00:09:06,702
there are, if you take the
landscape of these tools, there

150
00:09:06,702 --> 00:09:08,567
are Hundreds of tools available.

151
00:09:09,027 --> 00:09:12,567
but for this demo I just picked
for each phase two tools.

152
00:09:12,567 --> 00:09:15,747
Some of them would be
common, but just to, for this

153
00:09:15,747 --> 00:09:17,427
demonstration purpose, I took two.

154
00:09:17,697 --> 00:09:19,167
There are, commercial tools as well.

155
00:09:19,167 --> 00:09:20,547
There are open source tools as well.

156
00:09:20,547 --> 00:09:22,017
There are lot of tools as well.

157
00:09:22,477 --> 00:09:26,887
the idea is to just how we can integrate
these tools into our pipeline using.

158
00:09:27,132 --> 00:09:30,912
And then leveraging the AI to make
sure the threats are attempted

159
00:09:30,962 --> 00:09:32,672
as early as they are detected.

160
00:09:33,172 --> 00:09:37,332
Now, static analysis tools, we are
going to use PYLint and CodeQL.

161
00:09:37,532 --> 00:09:40,724
AI, here we'll leverage
the AI help as well.

162
00:09:40,724 --> 00:09:42,572
AI does not just point out issues.

163
00:09:42,947 --> 00:09:45,567
It suggests fixes and
predicts risks as well.

164
00:09:46,177 --> 00:09:49,807
another example like is like a smart
assistant that helps you to write

165
00:09:49,817 --> 00:09:53,637
better, more, better code and more,
secure code and a quality code.

166
00:09:54,377 --> 00:09:58,197
Another, one, again, we are speaking
about code review phase, secret detection,

167
00:09:58,307 --> 00:10:00,387
git leaks or truffle hawk, right?

168
00:10:00,767 --> 00:10:04,327
AI helps cut down, false alarms
and provides guidance on,

169
00:10:04,377 --> 00:10:06,407
storing sec, secret securely.

170
00:10:06,587 --> 00:10:11,377
Think of, it's like an experienced
auditor who knows exactly what to look to.

171
00:10:12,367 --> 00:10:15,087
Then we'll go into dependency
scan on the build phase.

172
00:10:15,127 --> 00:10:18,687
tools like safety, safety
or dependabot, helps.

173
00:10:18,727 --> 00:10:22,747
And if you are leveraging AI, AI
can analyze the trends and warns

174
00:10:23,017 --> 00:10:26,197
about potential vulnerabilities
before they become serious.

175
00:10:26,742 --> 00:10:31,292
Similar to how a health app predicts
potential issues based on the trends.

176
00:10:32,022 --> 00:10:35,912
Now then comes to functional phase
or we can, sorry, deployment phase

177
00:10:35,912 --> 00:10:37,492
where we will do functional testing.

178
00:10:38,332 --> 00:10:43,302
Tools like Postman, Helinium, can be
used here and leveraging AI creates

179
00:10:43,302 --> 00:10:47,872
and adapt to a test case, generation
automatically test case generation fixed,

180
00:10:48,122 --> 00:10:52,762
fixing broken, issues or fix, reducing
the flakiness in the test execution.

181
00:10:53,402 --> 00:10:56,982
Assume as we spoke, it's like
a GPS rerouting when you hit a

182
00:10:56,982 --> 00:11:01,552
roadblock and, we will use then
next comes as the security testing.

183
00:11:01,582 --> 00:11:02,892
That's where post deployment.

184
00:11:03,392 --> 00:11:05,552
this is where, DAST,
comes into the picture.

185
00:11:05,552 --> 00:11:06,822
We call it as DAST.

186
00:11:07,152 --> 00:11:09,542
DAST tools, OSAP, ZAP is one tool.

187
00:11:09,842 --> 00:11:13,472
Yeah, and leveraging AI can help
you pre authorize vulnerabilities

188
00:11:13,502 --> 00:11:14,952
based on the real, impact.

189
00:11:15,337 --> 00:11:17,997
in other words, it's like a
doctor telling you which health,

190
00:11:18,407 --> 00:11:20,387
issues needs an urgent attention.

191
00:11:20,887 --> 00:11:23,117
Then comes, finally, post deployment.

192
00:11:23,167 --> 00:11:25,217
it's not just, sitting
and relaxing, right?

193
00:11:25,247 --> 00:11:28,497
We have to do, the product, production
phase as well to see if there are

194
00:11:28,557 --> 00:11:30,907
any anomalies in our, production.

195
00:11:31,602 --> 00:11:32,712
It's monitoring, right?

196
00:11:32,742 --> 00:11:36,612
when again, we are trying to
leverage AI, continuously, it, it,

197
00:11:36,662 --> 00:11:40,872
it watches the logs and detects
anomalies before they escalate.

198
00:11:41,232 --> 00:11:45,112
And an example could be just
like a home security system that

199
00:11:45,112 --> 00:11:46,982
learns and adapts to new patterns.

200
00:11:47,652 --> 00:11:51,302
Again, to just to see what would
be the key takeaway from here.

201
00:11:51,802 --> 00:11:56,742
AI makes security smarter by
improving, detection, reducing

202
00:11:56,742 --> 00:12:01,092
manual effort and helping team to
focus on what matters the most.

203
00:12:01,592 --> 00:12:05,812
Now, we'll try to look into some of the
tools that we discussed in the past slide.

204
00:12:05,912 --> 00:12:09,482
So in the dev phase, we are
focusing on, Two tools, uh,

205
00:12:10,362 --> 00:12:12,892
that is PY Linked and, CodeQL.

206
00:12:13,702 --> 00:12:18,142
if you see, the line number, before we
go into the code demonstration, let me

207
00:12:18,152 --> 00:12:20,172
help you to understand what is PY Linked.

208
00:12:20,802 --> 00:12:24,622
Think of PYLint is like a spell
checker for your Python code.

209
00:12:25,122 --> 00:12:30,342
It enforces coding standards, detects
issues like unused variables, for

210
00:12:30,342 --> 00:12:35,362
example, unused variables, and ensures,
ensures compliances with best practice,

211
00:12:35,412 --> 00:12:37,602
ensures compliances and, best practices.

212
00:12:37,962 --> 00:12:41,302
For example, practices like PEP8
and all those things can help you.

213
00:12:41,822 --> 00:12:46,092
with the AI, integrating with the
AI, it offers smart suggestions.

214
00:12:46,092 --> 00:12:46,142
Thanks.

215
00:12:46,857 --> 00:12:50,107
auto fixes and better
issue pre authorization.

216
00:12:50,997 --> 00:12:53,537
Then comes to, the other tool
that we were talking about, right?

217
00:12:53,547 --> 00:12:53,797
CodeQL.

218
00:12:54,357 --> 00:12:55,677
What CodeQL is?

219
00:12:55,717 --> 00:12:59,877
CodeQL acts like a security
detective, scanning to identify

220
00:12:59,887 --> 00:13:01,927
vulnerabilities in your code itself.

221
00:13:02,307 --> 00:13:07,777
could be such as like SQL injections, XSS
and all things right at the development

222
00:13:07,777 --> 00:13:09,577
phase, analyzing the code itself.

223
00:13:10,467 --> 00:13:14,617
Now, integrating with AI, if you
take, an example of, we are taking

224
00:13:14,617 --> 00:13:16,777
here as a Salesforce code, TFI base.

225
00:13:16,807 --> 00:13:19,707
that's one of the model,
that's developed by Salesforce.

226
00:13:20,067 --> 00:13:23,667
what it does is it has past
vulnerabilities, databases, and provides

227
00:13:23,667 --> 00:13:26,347
deeper insights, for better prevention.

228
00:13:26,857 --> 00:13:30,177
we, it's that model is being,
basically, it's trained on

229
00:13:30,327 --> 00:13:32,432
analyzed, generated code insights.

230
00:13:32,432 --> 00:13:35,702
It helps summarizing, and,
provides actionable, fixes.

231
00:13:36,407 --> 00:13:40,737
boosting your development, productivity
by automating tedious tasks.

232
00:13:41,557 --> 00:13:46,237
another, thing that I want to highlight
here is why we are taking a local model.

233
00:13:46,507 --> 00:13:47,017
Okay.

234
00:13:47,077 --> 00:13:48,947
There are models, there
are different models.

235
00:13:49,287 --> 00:13:52,897
We can either use GPT or
BERT or any other models.

236
00:13:53,312 --> 00:13:54,802
But here is the thing, right?

237
00:13:54,802 --> 00:13:56,502
So I'm taking a local model.

238
00:13:56,542 --> 00:13:59,952
So it's running on the local,
your machine where your pipelines

239
00:14:00,022 --> 00:14:01,252
are, where this code is running.

240
00:14:01,252 --> 00:14:03,842
That's where the model
will be run as well.

241
00:14:03,892 --> 00:14:06,582
please remember here, see
certain things, right?

242
00:14:06,952 --> 00:14:08,752
Privacy comes into the picture.

243
00:14:08,872 --> 00:14:12,732
Some companies won't allow to share
our findings to, external system.

244
00:14:12,732 --> 00:14:15,782
GDPR compliances comes into the pictures.

245
00:14:15,812 --> 00:14:19,362
That's where I took a model here,
which is running in Salesforce.

246
00:14:19,607 --> 00:14:22,937
Salesforce model, which is running
on local, but, there is one

247
00:14:22,937 --> 00:14:24,687
advantage and disadvantage as well.

248
00:14:24,687 --> 00:14:29,057
Let's talk about that running model
locally ensures privacy, without

249
00:14:29,057 --> 00:14:30,557
sending data to external servers.

250
00:14:31,057 --> 00:14:34,897
However, these models
may not be up to date.

251
00:14:34,957 --> 00:14:37,757
That's a cons because
it's running in local.

252
00:14:37,757 --> 00:14:41,937
It has might learn from the past,
data, but not one of which is

253
00:14:41,937 --> 00:14:43,367
going on the, currently, right?

254
00:14:43,367 --> 00:14:44,787
So that needs to be updated.

255
00:14:44,787 --> 00:14:48,147
So this model needs to be frequently
updated to have, the good,

256
00:14:48,187 --> 00:14:49,687
vulnerability database with you.

257
00:14:50,387 --> 00:14:54,407
Again, there are possible other possible,
models as well, which can run, locally is

258
00:14:54,407 --> 00:14:56,387
code, but, great for coding understanding.

259
00:14:56,887 --> 00:15:00,677
GPT codecs, provides intelligency
code suggestions, tab 9,

260
00:15:00,907 --> 00:15:03,477
polycoder, and, other things.

261
00:15:03,577 --> 00:15:08,517
Now, when you're making a decision, just
look into privacy versus updates, right?

262
00:15:08,627 --> 00:15:10,167
Local mode ensures privacy.

263
00:15:10,562 --> 00:15:13,642
But may miss the latest security
trends that we discussed.

264
00:15:13,842 --> 00:15:14,712
Performance boost.

265
00:15:15,042 --> 00:15:18,852
AI helps developers focus on real
issues, saving time and effort.

266
00:15:19,352 --> 00:15:22,652
Again, before we go, let's
go into co, co, deep dive.

267
00:15:22,962 --> 00:15:27,582
So if you see, line number five to eight,
if you focus, there is a function which

268
00:15:27,582 --> 00:15:32,652
is trying to do a run pylint, which is
trying to run the lint, linting process.

269
00:15:33,042 --> 00:15:35,762
And, here we took a sample, Python file.

270
00:15:35,832 --> 00:15:37,882
You can run it in the entire repository.

271
00:15:38,112 --> 00:15:42,242
And then you get everything in,
standard out, in the results.

272
00:15:42,242 --> 00:15:43,632
standardout file.

273
00:15:43,712 --> 00:15:46,942
And then we are also running,
codeql, and, Code ql.

274
00:15:46,942 --> 00:15:47,812
Again, there is a process.

275
00:15:47,812 --> 00:15:50,872
You can, you can go and check
the documentation, how it runs.

276
00:15:51,142 --> 00:15:55,262
We create a database with fi,
python code scanning, Q Ls file.

277
00:15:55,262 --> 00:15:58,892
That's, latest, security vulnerabilities
that can, it can understand.

278
00:15:58,892 --> 00:16:00,662
So it'll check based on that.

279
00:16:00,662 --> 00:16:02,222
So the new ones keeps updating.

280
00:16:02,222 --> 00:16:06,082
So again, this needs to be updated
as well to have new, newer one.

281
00:16:06,682 --> 00:16:09,582
And then again, this is also, we
are trying to store it in a result

282
00:16:09,582 --> 00:16:11,317
data, in a result, variable.

283
00:16:11,317 --> 00:16:14,537
And then, I'm trying to extract, based
on the line numbers because I'm trying

284
00:16:14,537 --> 00:16:16,397
to remove all the junk, from this one.

285
00:16:16,777 --> 00:16:20,597
And then finally, what I'm trying to do
is per line number that I'm retrieving,

286
00:16:20,597 --> 00:16:22,127
I'm passing it to the, my model.

287
00:16:22,527 --> 00:16:22,807
Okay.

288
00:16:23,157 --> 00:16:26,947
My model is now trying to understand
and finally, gives me an output.

289
00:16:27,167 --> 00:16:28,397
let's see the output first.

290
00:16:29,152 --> 00:16:29,412
Okay.

291
00:16:29,422 --> 00:16:30,872
This is how the output looks.

292
00:16:30,882 --> 00:16:33,732
If you see PY linked,
before, AI integrated.

293
00:16:34,332 --> 00:16:36,812
If you see, it says PY
linked analysis report.

294
00:16:37,242 --> 00:16:40,662
Just focus on line number seven,
constant name, secret key does not

295
00:16:40,672 --> 00:16:44,612
confirm to uppercase naming style,
which just says that, secret key is

296
00:16:44,612 --> 00:16:48,132
not in a, does not confirm to uppercase
naming style and all those things.

297
00:16:48,132 --> 00:16:52,727
It's just PY links is, Checking on,
naming cases and all those things

298
00:16:52,727 --> 00:16:54,407
like camel cases and all those things.

299
00:16:54,657 --> 00:16:54,987
Okay.

300
00:16:55,287 --> 00:16:58,767
Now line number 15, again, combined
injections are detected via os.

301
00:16:58,787 --> 00:17:03,277
py open and end of line, end of py lines.

302
00:17:03,327 --> 00:17:06,017
But I'm just for a demonstration,
I'm taking these two lines.

303
00:17:06,367 --> 00:17:10,727
And if I, if you give the same thing
to, AI before and after, if you see,

304
00:17:11,447 --> 00:17:16,327
It's not only suggesting to, use, the
naming conventions and all those things.

305
00:17:16,337 --> 00:17:22,037
However, AI is also suggesting to use hard
coded secret with secret key, using this.

306
00:17:22,037 --> 00:17:23,937
So it's a suggestion it is also giving.

307
00:17:23,987 --> 00:17:26,767
it's not only detecting your
coding standards, but it also

308
00:17:26,767 --> 00:17:28,287
suggesting, the things as well.

309
00:17:28,327 --> 00:17:34,057
because we pass that, report to AI and
the model that Salesforce model, and

310
00:17:34,057 --> 00:17:35,497
it's just trying to suggest those things.

311
00:17:35,527 --> 00:17:36,867
And similarly for line 15.

312
00:17:37,307 --> 00:17:41,637
It says, subprocess that run,
versus instead of, os p, po open.

313
00:17:41,637 --> 00:17:44,967
So what it is trying to do is
it's trying to speed up our work.

314
00:17:44,967 --> 00:17:49,827
It's trying to supercharge the developer,
to start looking in this direction.

315
00:17:49,827 --> 00:17:53,367
It's a suggestion which is trying to
give versus what we have with PY link.

316
00:17:53,427 --> 00:17:56,997
That's where the flexibility, that's
where the real usage of the tools is

317
00:17:56,997 --> 00:18:00,357
coming into the picture, where it,
we are trying to fasten up our work.

318
00:18:00,827 --> 00:18:02,717
Now, similarly, if you take a code ql.

319
00:18:03,552 --> 00:18:04,892
Security analysis report.

320
00:18:05,242 --> 00:18:08,942
Before AI integration, if you
see line number 22, SQL injection

321
00:18:08,942 --> 00:18:10,742
vulnerability detected in raw query.

322
00:18:11,212 --> 00:18:15,032
However, we know that there is a SQL
injection could be possible at line

323
00:18:15,032 --> 00:18:17,562
number 22, but how do we fix that?

324
00:18:17,862 --> 00:18:18,852
No, we don't know that.

325
00:18:19,702 --> 00:18:23,592
or an expert developer could know
it, but as soon as we see this

326
00:18:23,642 --> 00:18:27,242
particular execution, we would
not be able to justify that what

327
00:18:27,242 --> 00:18:28,657
could be the possible SQL engine.

328
00:18:29,257 --> 00:18:30,017
Injection attack.

329
00:18:30,507 --> 00:18:33,707
On line number 30, cross site
scripting, is possible as well.

330
00:18:34,217 --> 00:18:38,827
Now, AI suggested fixes, if you see, it
says replace raw query with parameterized

331
00:18:38,867 --> 00:18:42,407
SQL query, and it is suggesting as well.

332
00:18:43,227 --> 00:18:45,657
So that's the power of
AI we are leveraging.

333
00:18:45,707 --> 00:18:49,057
That's the power of AI, the model we
are trying to take, which will help

334
00:18:49,057 --> 00:18:53,357
us to fasten up, not only detecting,
it is also providing the solution.

335
00:18:53,697 --> 00:18:55,857
These kinds of things are
available in commercial tools.

336
00:18:55,867 --> 00:18:58,747
However, with open source also,
we can achieve this, where we are

337
00:18:58,817 --> 00:19:02,607
taking the AI help to get solutions
as well for the problems we have.

338
00:19:03,277 --> 00:19:08,467
Line number 30, use escape name to
sanitize user input in HTML rendering.

339
00:19:08,497 --> 00:19:10,377
So this is the end of AI fixes.

340
00:19:10,717 --> 00:19:11,807
That's what it is suggesting.

341
00:19:12,397 --> 00:19:15,477
So tools like, there are a bunch
of tools that we can use it, but

342
00:19:15,477 --> 00:19:18,967
if you are trying to leverage AI
help, you are getting supercharged.

343
00:19:18,997 --> 00:19:20,087
that's where it helps.

344
00:19:20,597 --> 00:19:22,367
Now let's talk about a review phase.

345
00:19:23,322 --> 00:19:26,222
secret detections, while we,
while many good coders also

346
00:19:26,222 --> 00:19:28,092
tries to, hard code a secret.

347
00:19:28,092 --> 00:19:31,952
So it could be in a test file or it could
be anything or, any other, tokens as well.

348
00:19:31,982 --> 00:19:34,502
So we need, a tool which
can help us in review phase.

349
00:19:34,942 --> 00:19:37,792
It's very hard if a developer,
tries to review it, there is

350
00:19:37,792 --> 00:19:39,172
a chances that it'll mess.

351
00:19:39,382 --> 00:19:41,422
That's where these tools
comes into the picture.

352
00:19:41,897 --> 00:19:45,917
secrets made, secrets, detection
made simple with, GitLab

353
00:19:46,217 --> 00:19:47,517
Git Lake and Truffle Hawk.

354
00:19:47,917 --> 00:19:51,262
and again, AI is power by
Salesforce code, TFI base.

355
00:19:51,262 --> 00:19:54,652
Again, you can use any of the models,
which are, can be run locally.

356
00:19:54,652 --> 00:19:58,967
But here for our demonstration, I'm using
this, again, secrets like API, keys.

357
00:19:59,267 --> 00:20:03,457
passwords and tokens can be
unintentionally end up in code, right?

358
00:20:03,777 --> 00:20:07,467
So posing a serious security
risk, manually finding them is a

359
00:20:07,467 --> 00:20:11,847
difficult, but tools like Git leaks
and Truffle Hawks can help them

360
00:20:11,887 --> 00:20:14,107
or directly find them efficiently.

361
00:20:14,597 --> 00:20:17,647
we'll talk before, we go in before
detail and the demo of the code,

362
00:20:17,667 --> 00:20:20,647
we'll see, what is Git leaks, Git
leaks, basically, GitLinks tries

363
00:20:20,647 --> 00:20:25,337
to scan the entire repositories
and finds, predefined patterns of

364
00:20:25,497 --> 00:20:27,127
secrets and entropy checks as well.

365
00:20:27,977 --> 00:20:31,297
it can be worked with any CACD
pipeline, to catch serious,

366
00:20:31,297 --> 00:20:32,737
issues before, deployment.

367
00:20:32,737 --> 00:20:36,127
That means your PR cannot be merged
until, unless you address this.

368
00:20:36,127 --> 00:20:39,607
you can integrate that with,
pipelines or even in GitHub

369
00:20:39,617 --> 00:20:41,177
actions, you can integrate this.

370
00:20:41,737 --> 00:20:44,027
Trufflehawk again, dives
deeper into commit history.

371
00:20:44,322 --> 00:20:49,972
to uncover high entropy strings that could
be, that could be posing the credentials

372
00:20:49,972 --> 00:20:52,612
and all other sort of security issues.

373
00:20:52,922 --> 00:20:56,752
Ideal for post commit reviews
to catch overlooked secrets.

374
00:20:56,962 --> 00:21:01,267
Then now, if you are integrating
with AI, How it can help us.

375
00:21:01,707 --> 00:21:05,330
So AI, again, we have seen in the,
in the, in the past example, smarter

376
00:21:05,330 --> 00:21:10,260
detection, Code T5 improves accuracy
by learning from the past findings

377
00:21:10,290 --> 00:21:11,690
and reducing false positives.

378
00:21:11,700 --> 00:21:13,690
Sometimes it could be a
false positive as well.

379
00:21:13,710 --> 00:21:16,320
That also will be helping us as well.

380
00:21:16,640 --> 00:21:19,520
Context awareness, it
understands the code context.

381
00:21:19,860 --> 00:21:24,640
to different, real secrets from a noise,
and also provides automatic remediation,

382
00:21:24,700 --> 00:21:29,390
provides actionable, recommendations
such as moving secrets to secret values.

383
00:21:29,850 --> 00:21:33,260
Continuous learning adapts to
evolving patterns, identifying

384
00:21:33,270 --> 00:21:35,010
new risks as they emerge.

385
00:21:35,180 --> 00:21:35,520
Okay.

386
00:21:35,880 --> 00:21:40,980
overall it's enhancing productivity, helps
developers quickly address identified

387
00:21:41,215 --> 00:21:46,535
Issues with all with without manual
intervention again, before we go deeper

388
00:21:46,535 --> 00:21:51,205
into the code Here is my key takeaway from
this with ai power tools like salesforce

389
00:21:51,705 --> 00:21:58,875
Codify secrets detections becomes smarter
faster and more reliable Ensuring better

390
00:21:59,155 --> 00:22:01,595
security without extra manual effort.

391
00:22:02,205 --> 00:22:06,500
Now if you see the code
line number six to, 13.

392
00:22:06,520 --> 00:22:10,680
If you see what we are trying to do is we
are trying to run, the tools basically.

393
00:22:10,680 --> 00:22:14,690
So the two tools we, you can
either use TruffleHog or GitLex.

394
00:22:14,700 --> 00:22:17,930
See, refer line number 24 and 25.

395
00:22:18,090 --> 00:22:22,040
which where we are trying to call first
TruffleHog and then later GitLinks

396
00:22:22,540 --> 00:22:25,230
and we are calling the method runScan.

397
00:22:25,610 --> 00:22:29,400
Again, if you see we are trying to
run this and then we are trying to

398
00:22:29,400 --> 00:22:34,070
get the output and then again we are
passing that both TruffleHog output

399
00:22:34,070 --> 00:22:39,540
and GI Lake's output into our model
and model is trying to passe it and

400
00:22:39,540 --> 00:22:42,090
then it is trying to suggest the fixes.

401
00:22:42,090 --> 00:22:46,230
Let's see how the fixes looks like,
what before and after, how it looks.

402
00:22:46,600 --> 00:22:49,780
So if you see Truffle hog
before it is adjacent file,

403
00:22:49,780 --> 00:22:51,160
it's very hard to understand.

404
00:22:51,350 --> 00:22:54,330
at least, as a developers, we would be
able to understand how we were, you know.

405
00:22:54,985 --> 00:22:58,915
this is very, vague strings found AWS
key password and all sorts of things.

406
00:22:59,475 --> 00:23:02,995
So AI integration after
AI, this is how it looks.

407
00:23:03,055 --> 00:23:05,375
Let's focus directly on
the AI suggested fix.

408
00:23:05,375 --> 00:23:07,785
Move the keys to AWS secret manager.

409
00:23:08,280 --> 00:23:11,710
This is your friend, your buddy, who is
trying, it's acting like your buddy who

410
00:23:11,710 --> 00:23:16,510
is trying to help you to understand that,
hey, move this, things to a secret manager

411
00:23:16,730 --> 00:23:19,090
and reference it via environment variable.

412
00:23:19,110 --> 00:23:20,650
That's a very good, suggestion.

413
00:23:21,100 --> 00:23:24,540
And, GitLeaks, again, if you see
GitLeaks, it is trying to say

414
00:23:24,560 --> 00:23:29,050
secrets are found in so and so
file method and all sort of things.

415
00:23:29,070 --> 00:23:31,980
And now if you see the things,
use the environment variables

416
00:23:31,990 --> 00:23:33,090
for, or a secret manager.

417
00:23:33,815 --> 00:23:36,095
Instead of storing
credential in this file.

418
00:23:36,405 --> 00:23:40,485
So these are the suggestions we are
getting not only suggesting it is try

419
00:23:40,485 --> 00:23:44,285
to help us our code and it will try
to Say that there is a problem here

420
00:23:44,325 --> 00:23:45,875
and then you can fix it this way.

421
00:23:45,885 --> 00:23:49,585
So that's the Power that we are
getting from integrating now.

422
00:23:49,635 --> 00:23:50,955
let's see a build phase.

423
00:23:50,985 --> 00:23:55,665
uh, in the build phase we will try to
find out the hidden vulnerabilities

424
00:23:55,665 --> 00:23:59,850
in our third party libraries that we
are using You However, finding the

425
00:23:59,850 --> 00:24:03,270
tools like safety dependable will
help us to find out the libraries.

426
00:24:03,770 --> 00:24:07,040
However, the problem, comes
into the picture is, challenges

427
00:24:07,040 --> 00:24:08,510
and dependency management.

428
00:24:08,800 --> 00:24:09,090
Okay.

429
00:24:09,370 --> 00:24:12,390
Manage, managing software
dependency is a complex and

430
00:24:12,390 --> 00:24:14,010
challenging, challenging as well.

431
00:24:14,110 --> 00:24:17,410
Developer often time face,
faces several key challenges.

432
00:24:17,620 --> 00:24:20,020
Like such as like security risk, right?

433
00:24:20,020 --> 00:24:22,620
Dependency may contain
vulnerabilities that expose

434
00:24:22,650 --> 00:24:24,190
application to potential threats.

435
00:24:24,190 --> 00:24:25,190
That's what we are discussing.

436
00:24:25,780 --> 00:24:28,830
Tracking and resolving these
vulnerabilities manually

437
00:24:28,830 --> 00:24:30,050
is very time consuming.

438
00:24:30,120 --> 00:24:30,540
Okay.

439
00:24:30,830 --> 00:24:34,770
it's very frustrating as well because
one library you change, it may not be

440
00:24:34,770 --> 00:24:37,150
compatible because of multiple things.

441
00:24:37,450 --> 00:24:37,810
Okay.

442
00:24:37,860 --> 00:24:39,010
deprecated code issues.

443
00:24:39,030 --> 00:24:40,990
An example could be a
deprecated code issues.

444
00:24:41,010 --> 00:24:43,700
Upgrading dependencies can
introduce breaking changes.

445
00:24:43,700 --> 00:24:43,990
Okay.

446
00:24:44,125 --> 00:24:47,845
to the deprecated functions, I
didn't identifying affected code.

447
00:24:48,195 --> 00:24:53,130
manually, fixing, requests a significant
of effort of the time, again,

448
00:24:53,130 --> 00:24:54,960
high cost of, regression as well.

449
00:24:55,025 --> 00:24:57,875
now, because you have to test
the entire application, whether

450
00:24:57,875 --> 00:24:59,135
it's working fine or not.

451
00:24:59,765 --> 00:25:03,515
Every dependencies, upgrade,
this is time consuming.

452
00:25:03,665 --> 00:25:05,035
and overall, it's a problem.

453
00:25:05,455 --> 00:25:07,555
So what we can do is, using ai.

454
00:25:08,055 --> 00:25:13,005
The solution could be, use AI, so
which would, help us to, help us

455
00:25:13,025 --> 00:25:17,355
in, dependency management, how AI
can, help us in enhancing dependent

456
00:25:17,595 --> 00:25:22,325
management by automatically, detecting
the vulnerabilities, compatibility

457
00:25:22,325 --> 00:25:24,695
analysis, and, risk predictions.

458
00:25:24,745 --> 00:25:26,585
These are the things, which could help us.

459
00:25:26,615 --> 00:25:28,265
And here is what my approach is.

460
00:25:28,305 --> 00:25:29,855
I'll explain the code in detail.

461
00:25:30,360 --> 00:25:33,600
But, it's a multi step process,
which I would say, first one

462
00:25:33,600 --> 00:25:36,930
is where we are trying to find
automated, vulnerability scanning.

463
00:25:36,980 --> 00:25:39,390
So we are using a tool like safety here.

464
00:25:39,510 --> 00:25:43,220
And I took an example of a safety or you
can use depend on what as well, or another

465
00:25:43,250 --> 00:25:45,590
tool, to detect known vulnerabilities.

466
00:25:45,600 --> 00:25:49,360
First, it is trying to scan and it
is trying to find out what are the

467
00:25:49,360 --> 00:25:52,730
vulnerabilities coming by our third
party libraries that we are using.

468
00:25:53,395 --> 00:25:57,415
Okay, then we will try to analyze
the code for deprecations.

469
00:25:57,445 --> 00:26:01,425
Say, let's say, there is a library
we found and we want to use

470
00:26:01,425 --> 00:26:04,075
that, but is there any deprecated
method or any code issues?

471
00:26:04,085 --> 00:26:08,985
So I use a technique called AST based
parsing to identify outdated functions.

472
00:26:09,605 --> 00:26:12,245
Then I'm using, dependency visualization.

473
00:26:12,295 --> 00:26:14,995
That's not coming, that code
is not showing up in the slide.

474
00:26:15,085 --> 00:26:16,445
We'll see in the next slide.

475
00:26:16,925 --> 00:26:19,925
graph based mapping to
understand the relationships.

476
00:26:20,005 --> 00:26:24,195
So we are using JNN networks to
understand the code relationships.

477
00:26:24,595 --> 00:26:27,985
And then finally, we are going
with AI powered risk production.

478
00:26:27,985 --> 00:26:31,495
This is where the AI is, where
we are using, GCN models.

479
00:26:31,545 --> 00:26:35,355
We are using GCN models to pre authorize
updates and minimize the failures.

480
00:26:35,965 --> 00:26:39,355
again, We can use real time
security again, which will, which

481
00:26:39,355 --> 00:26:42,385
we can integrate with the GitHub
advisories to stay updated.

482
00:26:42,385 --> 00:26:46,405
So another tool which we can also
use is GitHub advisories, which

483
00:26:46,405 --> 00:26:49,975
will have the updated, libraries
information and all sort of things.

484
00:26:50,225 --> 00:26:55,050
if you go into, detail of the code,
from line one, line number one, to PHI

485
00:26:55,110 --> 00:26:58,940
as where we are now focusing where, the
function, what it does is it scans the.

486
00:26:59,265 --> 00:27:03,645
project dependencies using safety
tool, to know, to find the,

487
00:27:03,695 --> 00:27:05,165
identify, known vulnerabilities.

488
00:27:05,665 --> 00:27:08,595
The output is passed into a JSON
format for further processing.

489
00:27:08,595 --> 00:27:10,615
so that's where the JSON format is.

490
00:27:11,055 --> 00:27:15,285
Now, we will see in the next two slides
how AI can help us, but, I'll just try

491
00:27:15,315 --> 00:27:19,415
to help you to understand here as, it pre
authorized the detected vulnerabilities

492
00:27:19,445 --> 00:27:21,445
based on severity and expo.

493
00:27:21,945 --> 00:27:23,705
and, possible, noise.

494
00:27:23,945 --> 00:27:26,755
then, let's focus on the next, method.

495
00:27:26,805 --> 00:27:32,325
next code block, refer here nine
to, 16, code block nine to 16.

496
00:27:32,895 --> 00:27:38,640
What it basically does the functions,
scans and gives, gi gives a python

497
00:27:38,640 --> 00:27:40,140
to detect the deprecated function.

498
00:27:40,140 --> 00:27:42,090
As I mentioned, we are
using a SD technique here.

499
00:27:42,120 --> 00:27:46,055
Try to find out the deprecated
functions, to analyze the code structure.

500
00:27:46,925 --> 00:27:48,325
how AI can help here?

501
00:27:48,435 --> 00:27:51,435
AI can suggest alternative
functions and estimate the impact

502
00:27:51,435 --> 00:27:52,945
of replacing the deprecate methods.

503
00:27:53,095 --> 00:27:54,725
that's automatically analyzing.

504
00:27:55,255 --> 00:27:57,405
Now let's go to the
next block of the code.

505
00:27:57,465 --> 00:28:01,865
here if you see, step number three, we
are trying to visualize the dependency

506
00:28:01,915 --> 00:28:03,545
vulnerabilities using network.

507
00:28:03,955 --> 00:28:07,475
What it basically does,
build a dependencies graph.

508
00:28:07,975 --> 00:28:11,685
To visualize the relation between
dependencies and their vulnerabilities.

509
00:28:12,155 --> 00:28:15,415
Highlights risks dependencies visually.

510
00:28:15,455 --> 00:28:19,015
So I haven't executed this code,
but if you take an example here,

511
00:28:19,055 --> 00:28:20,995
you will see the dependency graph.

512
00:28:21,595 --> 00:28:25,795
now if you are leveraging AI, AI
can detect complex relationships

513
00:28:25,795 --> 00:28:28,505
and predict that the impact
of change before they happen.

514
00:28:28,675 --> 00:28:29,075
Okay.

515
00:28:29,705 --> 00:28:35,325
Now, fourth one, if you refer the block
from 30 to 40, Two, where I would say,

516
00:28:35,765 --> 00:28:41,125
utilizes graph neural network GNN to
predict risk scores for dependencies.

517
00:28:41,785 --> 00:28:44,525
AI learn pattern from
historical vulnerabilities

518
00:28:44,535 --> 00:28:46,195
and dependency relationships.

519
00:28:46,720 --> 00:28:52,440
Now, provide AI can, AI helps to
understand, the PID provides actionable

520
00:28:52,440 --> 00:28:54,800
risk to prioritize upgrades efficiently.

521
00:28:54,800 --> 00:28:57,830
whichever the library you want to
upgrade, it will help you to understand

522
00:28:57,830 --> 00:29:02,280
that and reduce unnecessary updates by
focusing on high risk, dependencies.

523
00:29:02,910 --> 00:29:03,220
Okay.

524
00:29:03,300 --> 00:29:04,330
this is my approach.

525
00:29:04,370 --> 00:29:06,480
There are multiple approaches
that you can, take.

526
00:29:06,490 --> 00:29:09,460
And finally, the fifth one,
fetch real time security update

527
00:29:09,680 --> 00:29:11,670
updates from advisory from GitHub.

528
00:29:12,130 --> 00:29:15,580
You can have your GitHub token and
all sort of things and find out, the

529
00:29:15,580 --> 00:29:17,510
security advisory from Git as well.

530
00:29:18,010 --> 00:29:22,130
Now, let's see how this
code looks like before AI.

531
00:29:22,190 --> 00:29:23,750
the, it is a manual process.

532
00:29:23,780 --> 00:29:25,280
It shows dependencies.

533
00:29:25,290 --> 00:29:27,830
NumPy has a high risk here.

534
00:29:28,000 --> 00:29:30,635
and then dependency request
has high, high risk.

535
00:29:30,715 --> 00:29:31,325
One as well.

536
00:29:31,665 --> 00:29:33,225
Sorry, medium as well.

537
00:29:33,225 --> 00:29:36,905
Potentially deprecated old
function in examplecode.

538
00:29:36,945 --> 00:29:38,265
py at line number 15.

539
00:29:38,275 --> 00:29:44,245
So again, as I mentioned, I'm not sharing
the live code outputs because I'm just

540
00:29:44,325 --> 00:29:46,605
trying to show you how this code is.

541
00:29:46,625 --> 00:29:47,435
it's written by me.

542
00:29:47,515 --> 00:29:47,945
Example.

543
00:29:48,155 --> 00:29:48,355
code.

544
00:29:48,375 --> 00:29:51,745
py has an all deprecated method
so that I, for demonstration

545
00:29:52,005 --> 00:29:53,225
purpose, I just captured here.

546
00:29:53,725 --> 00:29:59,650
Again, After AI automated the process
looks like this dependency MPI cv

547
00:29:59,710 --> 00:30:02,680
security high and risk score is 0.85.

548
00:30:02,740 --> 00:30:06,920
So we got, 0.85 as the
highest one recommended action

549
00:30:06,950 --> 00:30:09,020
upgrade to MPI to this one.

550
00:30:09,200 --> 00:30:11,510
Impact analysis deprecated
function detected.

551
00:30:11,510 --> 00:30:16,370
In example, code Dopy rep replace this
old function with the new function.

552
00:30:16,995 --> 00:30:21,855
that's a beauty of the AI coming into
the picture So here again, I haven't

553
00:30:21,895 --> 00:30:27,045
taken the real time example, just a
mocked up example here again dependency

554
00:30:27,045 --> 00:30:29,355
requests, for this library as well.

555
00:30:29,395 --> 00:30:33,200
We are trying to find out the score is
zero zero point six five Recommendation

556
00:30:33,200 --> 00:30:36,355
is review api usage and apply patches.

557
00:30:36,385 --> 00:30:37,765
No breaking changes detected.

558
00:30:37,765 --> 00:30:41,485
So there is no breaking changes,
which would be detected so

559
00:30:42,415 --> 00:30:45,905
Challenges, dependencies are
listed without a pre authorization.

560
00:30:45,905 --> 00:30:49,815
If we, if you see the before AI,
developers must manually assess

561
00:30:50,185 --> 00:30:52,325
impact and compatibility issues.

562
00:30:52,375 --> 00:30:54,315
extensive manual effort is required.

563
00:30:54,885 --> 00:30:58,265
With the, improvements of AI,
Pre authorization of risk scores.

564
00:30:58,285 --> 00:30:59,485
You could see the risk scores as 0.

565
00:30:59,485 --> 00:31:01,065
85 for NumPy.

566
00:31:01,695 --> 00:31:06,845
And automated code analysis AI can help
you to identify the potential breaking

567
00:31:06,915 --> 00:31:08,865
changes and suggest the fixes as well.

568
00:31:09,265 --> 00:31:12,945
So overall, it reduces the testing
effort, and, saves your time.

569
00:31:13,750 --> 00:31:19,370
Overall, on this particular one, my
key takeaways, AI empowers developers

570
00:31:19,370 --> 00:31:24,000
to handle dependency management very
effectively, with a confident, with

571
00:31:24,000 --> 00:31:28,580
a very confidence by automating the
analysis and prioritizing the risk and

572
00:31:28,780 --> 00:31:31,070
overall reducing the time, and effort.

573
00:31:31,570 --> 00:31:33,670
Now, let's talk about functional testing.

574
00:31:33,780 --> 00:31:37,800
again, here we are taking, functional
testing Postman, Neumann, and, Hellenium.

575
00:31:38,410 --> 00:31:41,360
the goal here is to ensure the
correctiveness and reliability,

576
00:31:41,430 --> 00:31:44,700
by validating the business
flows, workflows end to end.

577
00:31:44,785 --> 00:31:50,285
it could be the APIs or it could be, UI
and also identify, the whole goal, right?

578
00:31:50,285 --> 00:31:54,335
So we want to identify the security as
well as the functional, issues as well.

579
00:31:54,715 --> 00:31:58,725
to reduce the production issues, which
will in turn saves the cost and effort.

580
00:31:59,680 --> 00:32:02,400
Here the tools, as I mentioned,
Postman and Newman, just to give a

581
00:32:02,400 --> 00:32:05,890
quick overview for those who doesn't
know what is Postman and Newman.

582
00:32:06,420 --> 00:32:11,300
Simplifies API testing, and automates
workflows and enables continuous

583
00:32:11,300 --> 00:32:12,930
validation in CI CD pipeline.

584
00:32:13,485 --> 00:32:18,795
Hellenium, again, AI powered self
healing tool that adapts to UI changes

585
00:32:18,825 --> 00:32:23,055
by tracking elements, locators,
reducing flaky test failures.

586
00:32:23,055 --> 00:32:26,245
Let's say flaky, there is
a flaky test case which has

587
00:32:26,245 --> 00:32:27,935
changed because of a locator.

588
00:32:27,935 --> 00:32:30,855
Hellenium can help us to bypass
that and helps to move forward.

589
00:32:31,235 --> 00:32:33,275
And which is very much
required, in, testing.

590
00:32:33,805 --> 00:32:38,375
with the AI integration here, what we
can do is smart test pre authorization,

591
00:32:38,745 --> 00:32:42,285
focus on high risk areas by analyzing
test history and failure trends.

592
00:32:43,005 --> 00:32:46,335
we can say, ensure resource are used
efficiently, and, again, with the

593
00:32:46,335 --> 00:32:48,925
self healing automation in coming
into the picture, as I mentioned.

594
00:32:49,470 --> 00:32:53,930
If there is a flakiness, we are
reducing or minimizing the flakiness

595
00:32:53,930 --> 00:32:58,250
and, which will help us to overall
maintain the test cases and focus on

596
00:32:58,260 --> 00:33:00,040
new future testing, and other things.

597
00:33:00,040 --> 00:33:04,480
And, AI can also help us providing
actionable insights, provides root

598
00:33:04,490 --> 00:33:07,780
cause analysis and recommendations
for improving test coverage.

599
00:33:08,240 --> 00:33:11,870
Again, my key takeaway here
is AI driver functional test

600
00:33:11,870 --> 00:33:13,610
cases, reduces the flakiness.

601
00:33:14,050 --> 00:33:17,760
It accelerates debugging and
improves reliability, making

602
00:33:17,800 --> 00:33:19,810
tests smarter and faster.

603
00:33:20,310 --> 00:33:22,430
Okay, now let's focus on security testing.

604
00:33:23,080 --> 00:33:25,400
Why security testing is still needed?

605
00:33:26,010 --> 00:33:30,380
Even with the security coding practices,
security testing is essential to detect

606
00:33:30,700 --> 00:33:35,600
runtime vulnerabilities, evolving
threats, and configuration issues that

607
00:33:35,600 --> 00:33:37,780
might arise post deployment as well.

608
00:33:38,250 --> 00:33:44,180
It ensures compliances, protects
against emerging attacking, vectors and

609
00:33:44,180 --> 00:33:46,400
provides an additional layer of defense.

610
00:33:46,440 --> 00:33:48,830
So that's where security
testing is very important.

611
00:33:49,390 --> 00:33:54,480
So we are using here two tools, OSAP,
ZAP, and Nikito, both will enhance

612
00:33:54,480 --> 00:33:55,810
the security testing with DAST.

613
00:33:56,310 --> 00:33:57,080
And, SAST.

614
00:33:57,550 --> 00:33:58,160
So what is DAST?

615
00:33:58,160 --> 00:34:00,640
Dynamically Application, Security Testing.

616
00:34:00,650 --> 00:34:05,290
The ones which we have seen so far
is, SAST tools, which is Static

617
00:34:05,310 --> 00:34:06,840
Application Security, Testing.

618
00:34:07,120 --> 00:34:08,770
now we are seeing the DAST tool here.

619
00:34:08,910 --> 00:34:13,550
OSAP, ZAP is one of the famous, tool,
which is also called a Z Attack Proxy.

620
00:34:14,070 --> 00:34:18,645
very popular tool that simulates real
world, attacks which are, To see how the

621
00:34:18,645 --> 00:34:20,585
application will behave at a run time.

622
00:34:20,685 --> 00:34:25,365
Okay, The attacks could be different
the vulnerabilities that could be

623
00:34:25,495 --> 00:34:30,825
different sql injections cross site
scripting security misconfigurations in

624
00:34:30,825 --> 00:34:35,335
our live applications, so it basically
analyzes the web application without

625
00:34:35,345 --> 00:34:39,380
access to the source code mimicking,
attacking as a behavior, attacking

626
00:34:39,430 --> 00:34:42,460
as a, customer or attacker behavior.

627
00:34:42,750 --> 00:34:43,130
Okay.

628
00:34:43,820 --> 00:34:48,830
While DAST focuses on runtime security,
as I mentioned, SAST focuses on source

629
00:34:48,830 --> 00:34:52,790
and binaries to detect vulnerables
at the code level before deployment.

630
00:34:52,800 --> 00:34:56,550
So that's why we need, testing,
security testing at, DAST level

631
00:34:56,550 --> 00:34:57,990
as it's a runtime application.

632
00:34:58,540 --> 00:35:01,130
how AI can enhance our security testing.

633
00:35:01,190 --> 00:35:07,490
AI can enhance security testing by
automating scans, prioritizing critical

634
00:35:07,510 --> 00:35:12,070
vulnerabilities, and reducing false
positives, allowing team to focus on

635
00:35:12,070 --> 00:35:16,450
real threats and faster remediation
before it goes into the production.

636
00:35:16,460 --> 00:35:18,245
So we are marking up the cases.

637
00:35:18,315 --> 00:35:20,295
And then trying to test our application.

638
00:35:20,785 --> 00:35:21,155
Okay.

639
00:35:21,265 --> 00:35:23,685
AI enhanced security
testing, code overview.

640
00:35:23,765 --> 00:35:26,305
If you see how I am
using this application.

641
00:35:26,305 --> 00:35:28,705
So generally people use, scripts to run.

642
00:35:28,755 --> 00:35:30,725
but however, I have coded everything here.

643
00:35:30,985 --> 00:35:34,445
So if you see a step one, we are
running Ozap, and Nikito scans.

644
00:35:34,495 --> 00:35:38,225
so we first, we are triggering, Nikito
at line number three and then, Zap.

645
00:35:38,860 --> 00:35:44,290
And then, we, once that is done, we are
scanning the results and then we are pre

646
00:35:44,290 --> 00:35:46,370
authorizing which one we want to fix it.

647
00:35:46,700 --> 00:35:49,590
And then we are finally,
reducing the false, positive.

648
00:35:49,990 --> 00:35:53,930
to go back again, line number one to
seven, which will help you to perform

649
00:35:53,930 --> 00:35:58,830
the automated scans on the application,
and then we are going, line number, 14,

650
00:35:58,930 --> 00:36:05,540
to 20, if we see we are pre authorizing
the findings AI ranks vulnerabilities

651
00:36:05,540 --> 00:36:06,860
based on severity and risk factors.

652
00:36:06,860 --> 00:36:08,990
And then we are going
with, false positives.

653
00:36:09,040 --> 00:36:10,820
We want to reduce the false positives.

654
00:36:10,850 --> 00:36:12,620
So we are using the filter basically.

655
00:36:12,620 --> 00:36:17,480
So from line number 23 to 31, it
refines, results, ensuring, accuracy

656
00:36:17,480 --> 00:36:19,600
by filtering the irrelevant alerts.

657
00:36:19,610 --> 00:36:23,470
So if we have, we need that, we want
to focus on the right ones, right?

658
00:36:23,860 --> 00:36:26,220
And then step five is
where the suggest fixes.

659
00:36:26,370 --> 00:36:31,200
So we are trying to, take AI help
on providing actionable security

660
00:36:31,200 --> 00:36:34,540
fixes, that could help us the
acceleration of the development.

661
00:36:35,145 --> 00:36:37,055
Again, and then, line block number six.

662
00:36:37,055 --> 00:36:39,185
If you see, we are just
atti running the, script.

663
00:36:39,185 --> 00:36:41,795
And I used my stream tech here.

664
00:36:41,920 --> 00:36:47,300
and, the key takeaway from this particular
script is security testing with ai.

665
00:36:47,300 --> 00:36:51,720
Ensure proactive protection, by
detecting active, actual evolving

666
00:36:51,750 --> 00:36:55,980
threats, and then we can automate,
automation of the pre authorization

667
00:36:55,980 --> 00:36:58,520
and accelerating the remediations.

668
00:36:59,240 --> 00:37:04,700
So now, if we go back, how, basically
it looks before and after, let's

669
00:37:04,730 --> 00:37:06,570
go back before AI integration.

670
00:37:06,720 --> 00:37:13,680
If you see, Before AI, challenges we
see is manual security testing required

671
00:37:13,680 --> 00:37:20,280
constant oversight, large volumes of false
positives overwhelmed with security teams.

672
00:37:20,340 --> 00:37:23,540
Lack of prioritization
led to delayed responses.

673
00:37:24,480 --> 00:37:29,080
And again, fixing vulnerabilities
requires extensive research and effort.

674
00:37:29,520 --> 00:37:34,050
However, after the ai, if you see
now, if you see it's very neatly

675
00:37:34,050 --> 00:37:36,810
done, based on the prioritization
it is giving, it's taking the

676
00:37:36,810 --> 00:37:39,060
risk score, risk factors as well.

677
00:37:39,090 --> 00:37:42,575
If you see, predictive risk
score is 0.92, critical.

678
00:37:42,635 --> 00:37:44,315
That means we need to address immediately.

679
00:37:44,975 --> 00:37:48,925
Automated scans, run some schedules
without, manual, manual interventions.

680
00:37:49,685 --> 00:37:53,895
AI filters out the noises and
focus on critical vulnerabilities.

681
00:37:53,935 --> 00:37:57,725
Now, if you see it's pre authorized
and then also, suggest a fixed,

682
00:37:57,945 --> 00:37:59,515
fixes, how you can fix it.

683
00:37:59,645 --> 00:38:03,575
So if you take an SQL injection
attack, again, here it's example.

684
00:38:03,605 --> 00:38:07,845
login, use parameterized
queries and input validation.

685
00:38:08,345 --> 00:38:11,205
Then again, suggested fixes,
line number two, if you see,

686
00:38:11,205 --> 00:38:15,695
implement a proper input sanitize,
sanitization using security library.

687
00:38:16,465 --> 00:38:18,545
so it detects and it pre authorize.

688
00:38:18,965 --> 00:38:23,025
So increased, the advantages that we
get, again, is increased efficiency.

689
00:38:23,105 --> 00:38:28,115
security can focus on real threats
without wasting time on false positives.

690
00:38:28,565 --> 00:38:30,025
again, improved, accuracy.

691
00:38:30,265 --> 00:38:34,675
AI reduces the chances of human error in
manual pre authorization and response.

692
00:38:35,145 --> 00:38:38,175
And overall, again, faster
reduction, faster, fixes.

693
00:38:38,920 --> 00:38:43,560
And overall, my key takeaway again,
integrating AI into security, testing

694
00:38:43,580 --> 00:38:47,300
transforms a reactive approach
then, transforms a reactive approach

695
00:38:47,350 --> 00:38:51,790
into a proactive and efficient
processes, reducing exposures

696
00:38:51,850 --> 00:38:54,250
and ensuring faster, resolutions.

697
00:38:54,750 --> 00:38:55,000
Okay.

698
00:38:55,030 --> 00:38:58,480
Now let's see, with the, AI
integration, how the logs looks like.

699
00:38:58,920 --> 00:39:01,230
So in traditional, security,
the challenges, right?

700
00:39:01,230 --> 00:39:01,990
So if you see.

701
00:39:02,240 --> 00:39:05,270
if you take back the same scenario
like detecting threats like brute

702
00:39:05,270 --> 00:39:08,790
force attacks and unauthorized
access could lead inefficiencies

703
00:39:08,820 --> 00:39:12,940
because slow detection, reactive
approach, false positives, manual,

704
00:39:13,210 --> 00:39:16,550
contaminations, which all creates time.

705
00:39:16,810 --> 00:39:17,190
Okay.

706
00:39:17,300 --> 00:39:20,540
If you take example before the
logs, before, AI integration,

707
00:39:20,540 --> 00:39:23,435
if you see User login attempted
it from so and so IP address.

708
00:39:23,435 --> 00:39:25,305
Multiple logins fails detected.

709
00:39:25,305 --> 00:39:27,045
Potential brute force attacks detected.

710
00:39:27,705 --> 00:39:30,465
Now, with the, without AI action, right?

711
00:39:30,465 --> 00:39:34,295
So security teams again has to
go manually analyze the logs and

712
00:39:34,295 --> 00:39:36,115
block the IP after detection.

713
00:39:36,115 --> 00:39:38,995
In meanwhile, there could be a
serious threats which could happen.

714
00:39:39,695 --> 00:39:44,615
All, all what is happening is response
delays and further unauthorized

715
00:39:45,115 --> 00:39:46,125
possible, access attempts.

716
00:39:46,595 --> 00:39:50,385
With the AI, we are trying to enhance
the security monitoring improvements

717
00:39:50,385 --> 00:39:57,135
with AI automated detection with, AI
identifies suspicious patterns instantly

718
00:39:57,205 --> 00:40:01,365
proactive responses, reduce false
positives, automated contamination,

719
00:40:01,375 --> 00:40:04,305
that's a beautiful immediately
blocking of threats and enforcement

720
00:40:04,305 --> 00:40:06,305
of security, security measures.

721
00:40:06,395 --> 00:40:11,345
Now, if you see example here, we have
detected an alert on our login page.

722
00:40:11,585 --> 00:40:12,875
So the risk is very critical.

723
00:40:12,875 --> 00:40:17,525
The scoring is also, we have done with
our previous algorithm, 9.5 and what,

724
00:40:17,550 --> 00:40:20,790
contamination we are, try, trying to
take IP address is blocked because we

725
00:40:20,790 --> 00:40:24,880
don't want to more number of, threats
to come up or, request to come up.

726
00:40:24,970 --> 00:40:27,640
And we also enable, we have
also identified what are the

727
00:40:27,640 --> 00:40:29,480
customers who has been, affected.

728
00:40:29,480 --> 00:40:33,690
And immediately we have enabled, MFA, we
have, revoked the, session tokens as well.

729
00:40:33,995 --> 00:40:37,805
then we are also suggesting the developer
to implement rate limiting and capture.

730
00:40:38,165 --> 00:40:43,395
So all this will help us, to
immediately take an action, using, ai.

731
00:40:43,945 --> 00:40:46,275
so the key take, key takeaway again here.

732
00:40:46,515 --> 00:40:50,815
AI driven monitoring enables
faster, detection, faster

733
00:40:50,815 --> 00:40:55,345
resolution, automate automation of
contamination smarter, remediation.

734
00:40:56,020 --> 00:40:59,190
Reducing overall risks very effectively.

735
00:40:59,690 --> 00:41:04,310
With that saying, let's talk
about some of the best practices.

736
00:41:04,640 --> 00:41:05,000
Okay.

737
00:41:05,260 --> 00:41:08,430
So best practices for AI
driven DevOps, DevSecOps.

738
00:41:08,500 --> 00:41:08,780
Okay.

739
00:41:08,780 --> 00:41:11,220
Practically, let's see this.

740
00:41:11,720 --> 00:41:14,147
Start with small and grow smart.

741
00:41:14,147 --> 00:41:16,650
AI can be overwhelming.

742
00:41:16,670 --> 00:41:20,350
So it is because to start, it's
recommended to start with small

743
00:41:20,400 --> 00:41:24,090
manageable projects instead of trying
to implement everything at one place.

744
00:41:24,580 --> 00:41:25,100
One place.

745
00:41:25,140 --> 00:41:27,670
Pick specific area and then try to fix it.

746
00:41:28,220 --> 00:41:29,800
preauthorize what matters most.

747
00:41:30,050 --> 00:41:33,460
Some of the internal services are there
which may not be, that, important.

748
00:41:33,480 --> 00:41:34,440
Customer facing, right?

749
00:41:34,440 --> 00:41:37,110
So take examples of customer
facing applications.

750
00:41:37,830 --> 00:41:42,925
so focus, like, where there is a lot of
customer facing security enhancements

751
00:41:42,925 --> 00:41:46,975
are required automation automate as much
as repeated to tasks and then slowly

752
00:41:46,985 --> 00:41:49,375
move into what is the most required.

753
00:41:50,335 --> 00:41:53,955
These areas could help us you
to provide a quick wins and help

754
00:41:54,045 --> 00:41:56,775
establish trust in the AI capabilities.

755
00:41:57,285 --> 00:41:58,225
Keep it transparent.

756
00:41:58,595 --> 00:41:58,975
Okay.

757
00:41:59,365 --> 00:42:03,565
once the biggest concern with AI is
trust, ensure that AI driven decisions

758
00:42:03,565 --> 00:42:05,465
are clear and easy to understand.

759
00:42:05,465 --> 00:42:05,585
Okay.

760
00:42:06,085 --> 00:42:09,655
Transparency helps teams feel
confident in AI recommendations.

761
00:42:10,115 --> 00:42:13,915
Make it easier and adopt, and
act on AI driven insights.

762
00:42:13,945 --> 00:42:17,745
If possible, if people don't
trust it, then it may not

763
00:42:17,755 --> 00:42:20,385
be, it won't be that useful.

764
00:42:20,915 --> 00:42:21,675
Always improve.

765
00:42:21,895 --> 00:42:24,065
A is not a one time setup.

766
00:42:24,115 --> 00:42:25,955
It needs continuous
learning and improvement.

767
00:42:25,975 --> 00:42:30,815
We discussed, about, the local models
versus, the frequently upgraded model.

768
00:42:30,905 --> 00:42:34,025
So again, regular updates
are required, fine tuning,

769
00:42:34,035 --> 00:42:35,870
feedbacks, feedback loopholes.

770
00:42:36,270 --> 00:42:39,880
Help maintains, the accuracy
and effectiveness of our models.

771
00:42:39,960 --> 00:42:43,450
And over time, the system would
be predictable and trustable.

772
00:42:44,410 --> 00:42:48,480
As your time evolves, your
AI model should also evolve.

773
00:42:49,200 --> 00:42:50,450
Integrate it smoothly.

774
00:42:50,700 --> 00:42:53,940
AI should fit into your
existing DevSecOps workflows.

775
00:42:54,460 --> 00:42:57,150
Seamlessly, don't enable
everything at once, start with

776
00:42:57,150 --> 00:42:58,630
smaller steps as we discussed.

777
00:42:59,040 --> 00:43:02,840
It should not feel like an overwhelming
response to developer and also,

778
00:43:02,890 --> 00:43:06,760
should not be a burden rather than
enhancement, to the current process.

779
00:43:06,760 --> 00:43:10,640
Choose AI solutions that, that
compliment your tools and workflows,

780
00:43:11,040 --> 00:43:13,370
to make it a transition effortlessly.

781
00:43:13,500 --> 00:43:17,300
initially, you will see some, hiccups
and some back, back, back steps.

782
00:43:17,585 --> 00:43:21,175
But slowly, you have to educate
the developers and get things done.

783
00:43:21,225 --> 00:43:22,745
not developers, every engineering team.

784
00:43:23,215 --> 00:43:23,465
Okay.

785
00:43:23,505 --> 00:43:26,575
Now the future of AI in DevSecOps.

786
00:43:27,115 --> 00:43:30,665
Let's take a look at how AI is
shaping the future of DevSecOps and

787
00:43:30,665 --> 00:43:35,015
why it is becoming as an essential
part of modern security practices.

788
00:43:35,515 --> 00:43:41,145
AI enhances speed, accuracy and
efficiency, proactive security and

789
00:43:41,175 --> 00:43:43,535
automation, scaling without human bias.

790
00:43:44,085 --> 00:43:48,495
enables a smarter, decisions
making through insights, continuous

791
00:43:48,495 --> 00:43:50,535
improvement with feedback loops.

792
00:43:51,005 --> 00:43:56,255
So overall, what I want to say is AI,
as it continues to evolve, it will also

793
00:43:56,255 --> 00:44:02,025
play in a bigger role in DevSecOps,
driving efficiencies, automations, and

794
00:44:02,025 --> 00:44:07,585
smarter security strategies and smarter
remediations, smarter contaminations

795
00:44:07,895 --> 00:44:12,555
that helps organizations to build
safer and more resilient applications.

