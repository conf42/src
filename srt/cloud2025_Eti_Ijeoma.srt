1
00:00:00,000 --> 00:00:03,400
Hello  everyone,  my  name  is
Ijeoma  Eti  and  I  will  be

2
00:00:03,400 --> 00:00:07,120
talking  on  optimizing  cache
usage  in  Docker  Build.

3
00:00:07,620 --> 00:00:12,100
About  me,  I'm  a  software  engineer
and  I'm  very  passionate  about

4
00:00:12,100 --> 00:00:14,180
sharing  knowledge  through  writing.

5
00:00:14,759 --> 00:00:18,799
I'm  also  an  active  contributor
to  the  open  source  community.

6
00:00:19,540 --> 00:00:22,279
And  then  you  can  connect  with
me  on  LinkedIn  or  Twitter.

7
00:00:22,305 --> 00:00:22,805
Twitter.

8
00:00:23,355 --> 00:00:26,595
let's  get  started  by
talking  about  why  Docker

9
00:00:26,595 --> 00:00:28,255
builds  can  feel  very  slow.

10
00:00:28,855 --> 00:00:33,474
So  one  of  the  biggest  pain,  um,
points  with  Docker,  with  Docker

11
00:00:33,474 --> 00:00:38,694
build  is  that  even  the  smallest  code
change  can  trigger  a  full  rebuild.

12
00:00:38,974 --> 00:00:42,155
That  means  you  are  often
rebuilding  parts  of  your  application

13
00:00:42,155 --> 00:00:43,805
that  haven't  Even  changed.

14
00:00:44,445 --> 00:00:48,945
And  this  can  significantly
increase  view  times.

15
00:00:49,845 --> 00:00:53,945
So  without  optimization  of
your  docker,  docker  will

16
00:00:53,945 --> 00:00:57,805
usually  run  through  unnecessary
steps  again  and  again.

17
00:00:58,684 --> 00:01:01,164
Wasting,  um,  the  compute  power.

18
00:01:01,335 --> 00:01:01,835
Right.

19
00:01:02,115 --> 00:01:07,275
And,  um,  if  you've  ever  worked  in  a
CI -CD  environment,  this  is  usually  a

20
00:01:07,275 --> 00:01:13,255
very  real  problem  because  it  causes
a  very  long  build  time  and  slows

21
00:01:13,255 --> 00:01:18,215
down  your  testing  or  your  deployment,
which,  um,  ultimately  reduces

22
00:01:18,215 --> 00:01:20,895
the  entire  developer  productivity.

23
00:01:21,455 --> 00:01:25,115
And  no  one  wants  to  really  sit
around  waiting  for  use  to  finish.

24
00:01:25,280 --> 00:01:29,640
When  they  can,  like,  they  could
be  shipped,  uh,  they  could

25
00:01:29,640 --> 00:01:31,240
ship  features  really  quickly.

26
00:01:32,140 --> 00:01:34,260
So  why  does  this
optimization  really  matter?

27
00:01:34,900 --> 00:01:38,400
First,  it  speeds  up
the  development  faster.

28
00:01:39,020 --> 00:01:45,294
And  also,  it's,  um,  Allows
developers  to  iterate  and  test

29
00:01:45,294 --> 00:01:47,074
their  changes  really,  really  quickly.

30
00:01:48,035 --> 00:01:51,435
So,  um,  also  it  helps
save  money,  right?

31
00:01:51,495 --> 00:01:57,414
Cause  when  you  have  a  faster  build,
it  means  that  you  won't  have  to

32
00:01:57,414 --> 00:02:01,755
spend  a  lot  of  compute  power  which
can  reduce  infrastructure  costs.

33
00:02:02,255 --> 00:02:03,614
Um,  so...

34
00:02:04,114 --> 00:02:06,194
Yeah,  understanding  docker  build.

35
00:02:06,614 --> 00:02:11,234
So  now  let's  take  a  closer  look
at  how  docker  build  actually  work.

36
00:02:11,915 --> 00:02:16,795
So,  um,  the  first  thing  is  that,
uh,  when  you  start  building,

37
00:02:17,454 --> 00:02:19,594
docker  loads  the  build  context.

38
00:02:19,954 --> 00:02:23,494
So  when  you  run  a  docker  build,
like  it  gathers  all  the  files

39
00:02:23,494 --> 00:02:26,894
in  the  directory  where  you  are
building  the  image  and  these

40
00:02:26,894 --> 00:02:31,394
files  make  up  the  build  context
and  can  impact  the  build  process.

41
00:02:31,834 --> 00:02:35,734
So,  um,  the  next  thing  that  it  does
is  that  it  passes  the  Dockerfile.

42
00:02:36,075 --> 00:02:38,374
So,  Docker  reads  this
instruction  in  the  Dockerfile

43
00:02:38,374 --> 00:02:41,415
and  executes  them  one  by  one.

44
00:02:41,954 --> 00:02:46,135
And  then,  um,  the  next  step  is
that  it  creates  an  immutable  layer.

45
00:02:46,754 --> 00:02:50,915
So,  just,  these  are  like  sets
of  instructions  in  the  Dockerfile.

46
00:02:51,199 --> 00:02:53,999
Why  do  you  need  the
expression  for  change?

47
00:02:53,999 --> 00:02:56,959
That's  because  for  each
instruction  in  the  Dockerfire,

48
00:02:57,139 --> 00:03:01,679
you  create  a  new  layer  and
then  these  layers  are  immutable.

49
00:03:02,159 --> 00:03:04,819
So  once  they  are  built,
they  do  not  change.

50
00:03:04,939 --> 00:03:08,839
So  also,  the  last  thing  that
happens  is  that  Docker  uses

51
00:03:08,839 --> 00:03:11,019
caching  to  P -Dop  rebuild.

52
00:03:11,260 --> 00:03:14,899
So,  rebuild  like  when  you  need
to  build  your  Docker,  your

53
00:03:14,899 --> 00:03:16,659
application  again  using  Docker.

54
00:03:17,099 --> 00:03:21,739
So,  Docker  just  reuses  the  unchanged
layer  to  avoid  redundant  processing

55
00:03:21,739 --> 00:03:23,459
and  making  your  build  much  faster.

56
00:03:23,959 --> 00:03:26,980
So,  this  is  an  example
of  a  Docker  file.

57
00:03:27,760 --> 00:03:30,140
And,  um,  let  me  just  break
this  down  really  quickly.

58
00:03:30,640 --> 00:03:34,119
Um,  we  have  the  first  one
that's  from  Python  3 .1.

59
00:03:34,359 --> 00:03:34,880
Right?

60
00:03:34,999 --> 00:03:36,499
So,  this  is  like  the  base  image.

61
00:03:36,499 --> 00:03:38,959
Ideally,  you  could  use
like  an  Alpine,  which  is...

62
00:03:39,459 --> 00:03:41,049
Um,  um,  um.

63
00:03:41,109 --> 00:03:44,309
Copy  all  the  content
from  the  requirements.

64
00:03:44,569 --> 00:03:46,289
CX  T  file  first.

65
00:03:46,449 --> 00:03:47,889
So  this  is  like  Python.

66
00:03:48,379 --> 00:03:50,059
Projects,  right?

67
00:03:50,239 --> 00:03:54,599
And  then  it  sort  of  installs
the  dependency  and  this  step

68
00:03:54,599 --> 00:03:58,460
is  you  can  be  cashed  if  the
requirement  of  TXT  doesn't  change.

69
00:03:58,579 --> 00:04:03,439
So  like  if  you  do  not  add  any
new  stuff  to  the  requirement,

70
00:04:03,719 --> 00:04:08,100
any  new  model  to  the,  or
package  the  requirement  of  TXT.

71
00:04:08,354 --> 00:04:11,434
It  doesn't  install  more  dependency.

72
00:04:12,094 --> 00:04:14,994
And  then  the  next  thing  is
that  it  copies  the  rest  of

73
00:04:14,994 --> 00:04:17,015
the  application  files,  right?

74
00:04:17,174 --> 00:04:20,774
And  then  it  defines  the
command  to  run  the  application.

75
00:04:20,974 --> 00:04:23,754
So  this  is  like,  um,  what  happens.

76
00:04:24,434 --> 00:04:27,314
So,  um,  but  there's  one
very  important  thing,  right?

77
00:04:27,454 --> 00:04:29,794
The  order  of  the
instruction  really  matters.

78
00:04:29,885 --> 00:04:35,964
So  if  you  place,  um,  placing
copied  or  requirement  your  txt  and

79
00:04:35,964 --> 00:04:40,564
running  pip  install  would  first  help
docker  to  cache  the  dependencies

80
00:04:40,564 --> 00:04:43,664
separately  from  the  application  code.

81
00:04:44,005 --> 00:04:48,125
And  this  avoids  unnecessary
reinstalling  dependencies

82
00:04:48,125 --> 00:04:49,944
when  only  code  changes.

83
00:04:50,444 --> 00:04:55,424
So,  um,  now  that  we've  really
understood  the  fundamentals,  let's

84
00:04:55,424 --> 00:04:57,264
explore  ways  to  optimize  caching.

85
00:04:57,489 --> 00:04:59,409
For  even  faster  build.

86
00:04:59,909 --> 00:05:02,750
So,  how  does  caching  work?

87
00:05:03,250 --> 00:05:08,150
Now  we  understand  how  docker
builds  work,  Um,  let's

88
00:05:08,150 --> 00:05:09,090
just  talk  about  caching.

89
00:05:09,590 --> 00:05:12,210
So,  which  is  one  of  the
most  important  ways  docker

90
00:05:12,210 --> 00:05:13,750
uses  to  speed  up  builds.

91
00:05:14,310 --> 00:05:15,270
So,  what  is  docker?

92
00:05:15,570 --> 00:05:21,825
Um,  basically  docker  cache
Docker  torrentships  on  a  larger

93
00:05:21,825 --> 00:05:25,745
new  layer  and  dorch  it  on
changed  steps  whenever  possible.

94
00:05:26,245 --> 00:05:29,025
At  least  we  avoid  rebuilding
the  parts  of  ebenage  that

95
00:05:29,025 --> 00:05:31,885
haven't  changed,  making
the  build  much  faster.

96
00:05:32,364 --> 00:05:35,744
So,  for  example,  if  you  want  to
install  a  dependents  independently

97
00:05:35,744 --> 00:05:41,085
of  a  docker  file  and  they  haven't
changed,  docker  reuses  previous

98
00:05:41,085 --> 00:05:44,385
built  layers,  instead  of  running
the  application  process  again.

99
00:05:44,885 --> 00:05:49,905
Concepts  in  layers  caching  and  like
each  instruction,  the  Dockerfile

100
00:05:49,905 --> 00:05:54,105
creates  a  layer  and  some  layers
can  be  cached  while  others  can't.

101
00:05:54,405 --> 00:05:57,025
So  let's  go  over  the
table  in  the  slides.

102
00:05:57,685 --> 00:06:05,425
Um,  from  the  previous,  um,  slide,
I,  I  showed  you,  uh,  a  Dockerfile.

103
00:06:05,905 --> 00:06:10,425
Um,  so  here  I'm  just  going  to
talk  about  the  layers  that  can

104
00:06:10,425 --> 00:06:12,305
be  cached  in  that  Dockerfile.

105
00:06:12,655 --> 00:06:16,905
Um,  Um,  we  have  um,  um,  the
from  Python,  um,  um,  Swaraj,  3.

106
00:06:17,375 --> 00:06:20,535
um,  1  zero,  um  that  is  cacheable.

107
00:06:21,035 --> 00:06:27,975
Um,  Um,  So  eh,

108
00:06:28,475 --> 00:06:28,935
uh ,ride.

109
00:06:29,435 --> 00:06:31,435
change  often,  right?

110
00:06:31,615 --> 00:06:33,935
So  docker  usually  caches  this  part.

111
00:06:34,435 --> 00:06:39,115
So,  um,  the,  the  step,  um,
for  copying  the  requirement

112
00:06:39,115 --> 00:06:41,575
of  txt  is  also  cacheable.

113
00:06:41,815 --> 00:06:44,495
So  this  step  is  cached  as
long  as  like  the  requirement

114
00:06:44,495 --> 00:06:46,335
of  txt  remains  the  same.

115
00:06:46,915 --> 00:06:52,235
And  then,  um,  if  the  requirement
of  txt  hasn't  changed,  docker

116
00:06:52,235 --> 00:06:54,455
will  reuse  the  cache  dependencies.

117
00:06:54,955 --> 00:07:00,495
Um,  so  the  command  to  copy
the  entire,  um,  application

118
00:07:00,495 --> 00:07:03,275
code  is  usually  not  cacheable.

119
00:07:03,835 --> 00:07:09,075
And  this  step,  um,  copies  all  the
files  basically  in  the  directory.

120
00:07:09,475 --> 00:07:13,415
And  if  any  file  changes,  this
step  breaks  and  the  cache  is

121
00:07:13,415 --> 00:07:16,855
forced,  um,  this  step  breaks  the
cache  and  is  forced  to  rebuild.

122
00:07:16,975 --> 00:07:18,695
So,  that's  what  happens.

123
00:07:19,255 --> 00:07:22,915
So  this  is  why  it's  important  to
structure  your  Docker  strategically.

124
00:07:23,135 --> 00:07:30,475
So,  um,  The  problem,  why  docker
builds  can  become  inefficient.

125
00:07:31,355 --> 00:07:37,035
So  even  with  caching,  docker  builds
can  be  very  slow  and  here's  why.

126
00:07:37,535 --> 00:07:40,955
So  one  thing  is,  um,  small
mistakes  in  the  docker  file

127
00:07:40,955 --> 00:07:45,235
can  invalidate  the  cache  and
forcing  unnecessary  rebuilds.

128
00:07:45,705 --> 00:07:48,965
So  another  thing  also
is  the  structure.

129
00:07:49,145 --> 00:07:54,725
So  if  the  instructions  are  not
properly,  um,  ordered,  um,  this  can

130
00:07:54,725 --> 00:07:57,645
also  force  an  unnecessary  rebuild.

131
00:07:58,325 --> 00:08:02,305
So  another  thing  is,  um,
frequent  dependency  change.

132
00:08:02,385 --> 00:08:07,225
So  if  you  are  constantly  updating
your  dependency,  it  means  that  you're

133
00:08:07,225 --> 00:08:12,480
forcing  Docker  to...  Um,  um,  um,
um,  um,  um,  um,  um,  um,  um,  um,

134
00:08:12,480 --> 00:08:13,510
um,  um,  um,  um,  um,  um,  um,  um,
um,  um,  um,  um,  um,  um,  um,  um,

135
00:08:13,510 --> 00:08:15,030
um,  um,  um,  um,  um,  um,  um,  um,
um,  um,  um,  um,  um,  um,  um,  um,

136
00:08:15,030 --> 00:08:15,390
um,  um,  um,  um,  um,  um,  um,  um,
um,  um,  um,  um,  um,  um,  um,  um,

137
00:08:15,390 --> 00:08:15,549
um,  um,  um,  um,  um,  um,  um,  um,
um,  um,  um,  um,  um,  um,  um,  um,

138
00:08:15,549 --> 00:08:16,800
um,  um,  um,  um,  um,  um,  um,  um,
um,  um,  um,  um,  um,  um,  um,  um,

139
00:08:16,800 --> 00:08:16,959
um,  um,  um,  um,  um,  um,  um,  um,
um,  um,  um,  um,  um,  um,  um,  um,

140
00:08:16,959 --> 00:08:26,759
um,  um,  um,  um,  um  Um,  um,  Um,  Um,
Um,  Um,  Um,  Um,  Um,  Um,  Um,  Um,

141
00:08:26,759 --> 00:08:28,390
Um,  Um,  Um,  Um,  Um,  Um,  Um,  Um,
Um,  Um,  Um,  Um,  Um,  Um,  Um,  Um,

142
00:08:28,390 --> 00:08:29,550
Um,  Um,  Um,  Um,  Um,  Um,  Um,  Um,
Um,  Um,  Um,  Um,  Um,  Um,  Um,  Um,

143
00:08:29,550 --> 00:08:30,859
Um,  Um,  Um,  Um,  Um,  Um,  Um,  Um,
Um,  Um,  Um,  Um,  Um,  Um,  Um,  Um,

144
00:08:30,859 --> 00:08:31,450
Um,  Um,  Um,  Um,  Um,  Um,  Um,  Um,
Um,  Um,  Um,  Um,  Um,  Um,  Um,  Um,

145
00:08:31,450 --> 00:08:32,100
Um,  Um,  Um,  Um,  Um,  Um,  Um,  Um,
Um,  Um,  Um,  Um,  Um,  Um,  Um,  Um,

146
00:08:32,100 --> 00:08:38,270
Um,  Um,  Um,  Um,  Um,  Um,  Um,  Um,
Um,  Um,  Um,  Um,  Um,  Um,  Um,  Um,

147
00:08:38,270 --> 00:08:40,200
Um,  Um,  Um,  Um  Sous -titres  réalisés
para  la  communauté  d .org  So,  yeah,

148
00:08:40,700 --> 00:08:44,600
so  some  common  pitfalls,  uh,
like  I  already  said  earlier,

149
00:08:44,780 --> 00:08:46,640
uh,  your  order  of  instructions.

150
00:08:47,080 --> 00:08:50,420
Then,  um,  another  thing  is
using  add  instead  of  copy.

151
00:08:50,560 --> 00:08:53,500
So  this,  like,  extracts
files  unnecessarily.

152
00:08:53,920 --> 00:08:57,850
But  copy  uses,  like,  So,
um,  use  copy,  like,  um,

153
00:08:57,850 --> 00:08:59,550
unless  downloading  archives.

154
00:09:00,170 --> 00:09:02,370
So,  like,  try  to  avoid  using  add.

155
00:09:02,990 --> 00:09:07,550
Um,  sorry,  um,  try  to  use  add
instead  of  copy  every  single  time.

156
00:09:08,070 --> 00:09:11,950
And  then,  um,  any  changes
invalidates  the  cache.

157
00:09:12,290 --> 00:09:15,250
So  be  very  explicit
about  your  copied  files.

158
00:09:15,590 --> 00:09:20,170
So,  um,  you  can  try  to
always  use  the  wildcard.

159
00:09:20,670 --> 00:09:25,210
Best  practices  for  optimizing
docker  build  using  cache.

160
00:09:25,710 --> 00:09:29,650
Um,  structure  a  docker  file
for  maximum  cache  reuse.

161
00:09:29,885 --> 00:09:35,945
Um,  so  another  thing  is  you
need  to  place  table  instructions

162
00:09:35,945 --> 00:09:39,105
before  the  frequently  changed  ones.

163
00:09:39,785 --> 00:09:44,585
And  then  you  can  use  the
multi -stage  build  to  reduce

164
00:09:44,585 --> 00:09:46,245
the  final  image  size.

165
00:09:46,280 --> 00:09:49,900
So  you  only  want  to  keep
what's  necessary  in  the  final

166
00:09:49,900 --> 00:09:53,020
image,  um,  to  reduce  bloat.

167
00:09:53,620 --> 00:09:57,340
And  then,  make  sure  to
leverage  the  docker  ignore  to

168
00:09:57,340 --> 00:09:59,120
reduce  the  build  context  size.

169
00:09:59,480 --> 00:10:04,540
So,  exclude  any  unnecessary
file  that,  um,  that  could

170
00:10:04,540 --> 00:10:07,060
slow  down  the  build.

171
00:10:07,560 --> 00:10:08,200
Um,

172
00:10:08,700 --> 00:10:13,260
another  thing  we  want  to  do  is
we  want  to  use  arguments  as  the

173
00:10:13,260 --> 00:10:15,580
arg  instead  of  environment  variable.

174
00:10:16,420 --> 00:10:19,420
And  because  arg  is  always
available,  it's  only  available

175
00:10:19,420 --> 00:10:22,880
during  the  build  time  and
it  keeps  your  image  cleaner.

176
00:10:23,380 --> 00:10:28,720
Um,  so  we  can  see  from  the
Dockerfile  that  I  placed  here  and  we

177
00:10:28,720 --> 00:10:30,920
see  how  it  was  properly  structured.

178
00:10:31,579 --> 00:10:38,460
So,  um,  Erm,  erm,  This  is  optimized
because  the  dependencies  are

179
00:10:38,460 --> 00:10:42,400
copied  first  and  so  they're  cached
separately  and  then  the  application

180
00:10:42,400 --> 00:10:46,680
files  are  copied  last  so  preventing
unnecessary  cache  invalidation.

181
00:10:47,180 --> 00:10:53,000
Erm,  so,  There  are,  This  is
the  basic  caching  instructions

182
00:10:53,000 --> 00:10:54,650
or  caching  techniques.

183
00:10:55,150 --> 00:10:58,459
So,  in  the  next  slide,  I'll
be  talking  about  advanced  Sous

184
00:10:58,459 --> 00:11:00,189
-titres  réalisés  para  la  communauté
d .org  Caching  techniques.

185
00:11:00,870 --> 00:11:04,449
So  now  we've  covered  the
basic  caching  techniques.

186
00:11:04,930 --> 00:11:10,230
Um,  um,  there  are  some  really
advanced  caching  techniques

187
00:11:10,230 --> 00:11:12,970
and  that  is  using  the
mouse  for  building  cache.

188
00:11:13,390 --> 00:11:16,930
So  one  powerful  way  we
can  speed  up  things  is  by

189
00:11:16,930 --> 00:11:18,089
using  mouse  for  caching.

190
00:11:18,510 --> 00:11:25,170
So,  um,  BindMount,  um,  or
VolumeMount,  um,  can  help  persist

191
00:11:25,170 --> 00:11:29,890
dependencies  across  build  and
reduce  a  redundant  installation.

192
00:11:30,670 --> 00:11:36,390
So  we  can  add  the  mount,
um,  equal  to  type,  and  equal

193
00:11:36,390 --> 00:11:38,550
to  type  cache  with  buildkit.

194
00:11:38,689 --> 00:11:42,930
And  this  allows  Docker  to  cache
immediate  build  without  creating

195
00:11:42,930 --> 00:11:46,670
unnecessary  layer  and  this  would
help  to  improve  the  performance.

196
00:11:47,410 --> 00:11:55,244
So,  um,  We  can  also  leverage
external  cache  sources,  right?

197
00:11:55,714 --> 00:12:00,494
Um,  one  of  the,  um,  Docker  has
a  build  X  for  distributed  caching

198
00:12:00,494 --> 00:12:04,574
and  this  allows  caching  to  be
stored,  to  be  shared  across

199
00:12:04,574 --> 00:12:06,834
multiple  platforms  and  environments.

200
00:12:07,795 --> 00:12:08,555
So.

201
00:12:09,055 --> 00:12:14,635
Um,  yeah,  I  just  placed  a  code
on  how  to,  an  example  of  how  to,

202
00:12:14,755 --> 00:12:18,954
um,  stop  build  cache  in  a  registry
so  every  new  build  can  reuse  it.

203
00:12:19,795 --> 00:12:26,855
So  this  ensures  that  the  build,
um,  ensures  the  build  reuse  the

204
00:12:26,855 --> 00:12:31,074
cache  layers,  making  them  much
faster,  especially  if  you're

205
00:12:31,074 --> 00:12:33,055
working  in  a  CI -CD  environment.

206
00:12:34,050 --> 00:12:40,110
Um,  so  another  thing,  uh,  when
you've  improved  your  cache  layer

207
00:12:40,110 --> 00:12:44,890
properly,  you  want  to  measure
or  debug  the  build  performance.

208
00:12:45,430 --> 00:12:50,990
And,  um,  There  are  different  ways
of  checking  it  or,  um,  so  one

209
00:12:50,990 --> 00:12:56,270
way  it's  by  using  the  docker
build  progress  plane  and  this

210
00:12:56,270 --> 00:13:02,430
shows,  um,  it  just  gives  you  a
more  detailed  outputs  to  check

211
00:13:02,430 --> 00:13:04,670
if  the  layers  are  being  reused.

212
00:13:05,110 --> 00:13:09,530
And  you  can  also  use  the  docker
history,  um,  this  would  basically

213
00:13:09,530 --> 00:13:13,750
list  image  layers  and  their  sizes
to  see  what  exactly  is  cached.

214
00:13:14,064 --> 00:13:18,744
So  if  you  want  to  analyze  the
docker  image,  you  can  use,  you

215
00:13:18,744 --> 00:13:22,124
can  also  use  the  docker  history,
you  can  use  the  time  docker  build,

216
00:13:22,584 --> 00:13:26,864
and  this  should,  this  measures
like  the  duration  to  track  if

217
00:13:26,864 --> 00:13:31,094
you're,  if  you're,  if  there's  any
improvements  in  your  docker  history.

218
00:13:31,104 --> 00:13:37,984
um,  using  all  these  tools
it,  it,  it  helps  like,

219
00:13:38,224 --> 00:13:40,584
um,  spot  any  inefficiencies.

220
00:13:41,285 --> 00:13:44,264
Um,  and  then  it  can
keep  your  beauty.

221
00:13:44,264 --> 00:13:46,504
It  can  make  your
build  run  really  fast.

222
00:13:47,004 --> 00:13:52,504
So,  um,  dokr  builds  in  conclusion,
dorket -build  is  very  essential

223
00:13:52,504 --> 00:13:56,804
for  speeding  up  builds  and
it  reduces  the  resource  usage.

224
00:13:57,304 --> 00:14:00,354
so  by  structuring  your
dockerfiles  effectively  and

225
00:14:00,354 --> 00:14:04,894
avoiding  common  mistakes  and
utilising  advanced  techniques  like

226
00:14:04,894 --> 00:14:09,514
i  mentioned,  using  the  build
-ex  we  can,  um  significably,

227
00:14:09,854 --> 00:14:12,899
significantly  recite  Ficantly
improve  the  build  performance.

228
00:14:13,799 --> 00:14:16,899
And  the  next  step  after
doing  all  of  this  is  to,

229
00:14:16,999 --> 00:14:20,639
um,  apply  this  in  your  real
life,  in  your  real  project.

230
00:14:21,039 --> 00:14:28,679
And  then  also  try  to,  um,  analyze
if  your,  your  build  time  or  analyze

231
00:14:28,679 --> 00:14:34,139
if  the  caching  works  properly  based
on  the  technique  I  explained  earlier.

232
00:14:34,639 --> 00:14:35,099
Thank  you.

