1
00:00:00,190 --> 00:00:00,820
Hello everyone.

2
00:00:01,520 --> 00:00:02,640
Thank you for being here.

3
00:00:02,910 --> 00:00:03,900
I'm Omila Raju.

4
00:00:04,110 --> 00:00:06,430
I'm a senior solution architect with AWS.

5
00:00:07,240 --> 00:00:10,829
Today we are going to talk
about AWS serverless application

6
00:00:10,829 --> 00:00:12,850
model or the AWS SAM.

7
00:00:13,259 --> 00:00:17,000
This is going to help you with your
development and deployment of modern

8
00:00:17,009 --> 00:00:18,850
serverless and cloud native application.

9
00:00:19,380 --> 00:00:20,160
Let's get started.

10
00:00:20,660 --> 00:00:24,660
AWS SAM is an open source developer
tool that simplifies and improve the

11
00:00:24,670 --> 00:00:27,850
experience of building and running
serverless applications on AWS.

12
00:00:28,800 --> 00:00:32,160
It's going to streamline your,
serverless development cycle and

13
00:00:32,490 --> 00:00:35,690
help you to quickly and efficiently
take an idea into production.

14
00:00:36,190 --> 00:00:39,170
So first of all, the exam is
for modern cloud native apps.

15
00:00:39,480 --> 00:00:41,830
How do you define a
modern cloud native app?

16
00:00:42,280 --> 00:00:46,090
Through the modern architectural
patterns, like event driven architecture,

17
00:00:46,090 --> 00:00:50,760
microservices, and use serverless
services wherever possible to

18
00:00:50,760 --> 00:00:52,280
increase the operational efficiency.

19
00:00:52,770 --> 00:00:57,030
And have developer agility that
is ability to deploy fast in an

20
00:00:57,030 --> 00:01:01,680
automated way and have abstractions
wherever possible to remove the

21
00:01:01,680 --> 00:01:03,360
undifferentiated redundant work.

22
00:01:03,860 --> 00:01:08,810
And of course, in on top of that, have the
necessary guardrails and, use standardized

23
00:01:08,810 --> 00:01:13,010
services so that you have your, governance
still in place, along with speed.

24
00:01:13,510 --> 00:01:16,540
And then this is another one
that is used to use purpose built

25
00:01:17,210 --> 00:01:20,080
databases and data sources that
is right for your application.

26
00:01:20,100 --> 00:01:23,020
So these are common principles
of a modern cloud native app.

27
00:01:23,780 --> 00:01:26,790
And today's focus is mainly
going to be in these three areas.

28
00:01:26,799 --> 00:01:30,349
That is serverless, developer agility,
and how do you maintain governance.

29
00:01:30,359 --> 00:01:31,840
That is DevOps plus serverless.

30
00:01:32,470 --> 00:01:35,960
And see how can we build and
deploy serverless apps with speed.

31
00:01:36,460 --> 00:01:40,120
So the first thing before even going
to think about which tool is right

32
00:01:40,130 --> 00:01:44,100
for you, the main thing to know is
your cloud operating model, that is

33
00:01:44,140 --> 00:01:46,500
how do you manage and run cloud today?

34
00:01:46,830 --> 00:01:48,369
Is it ready for your modern apps?

35
00:01:48,849 --> 00:01:53,219
I want to show you some
operational model frameworks.

36
00:01:53,399 --> 00:01:56,850
So we'll start from the left, that
is like traditional operations.

37
00:01:57,070 --> 00:02:01,070
So you can have a look and see where your
organization fits in this operation model.

38
00:02:01,570 --> 00:02:04,870
So for, traditional, like a monolith
application, like a front end middleware

39
00:02:04,870 --> 00:02:08,930
and backend database, usually there'll
be like different, teams like application

40
00:02:08,930 --> 00:02:10,550
engineering, application operations.

41
00:02:10,670 --> 00:02:13,250
Same way if you are deploying it in
cloud, that will be cloud platform

42
00:02:13,250 --> 00:02:14,630
engineering and operations team.

43
00:02:15,130 --> 00:02:18,230
And then we have distributed
DevOps or decentralized DevOps.

44
00:02:18,290 --> 00:02:20,680
So most of, both of
these are DevOps models.

45
00:02:21,130 --> 00:02:26,019
it's like how it differs this, what
is the level of autonomy you give to

46
00:02:26,019 --> 00:02:27,549
your application engineering team?

47
00:02:28,099 --> 00:02:30,389
to build and run their own components.

48
00:02:31,039 --> 00:02:34,009
and how much of the control
and governance you have with

49
00:02:34,019 --> 00:02:35,269
the cloud platform engineering.

50
00:02:35,889 --> 00:02:39,399
So usually, organizations start
with distributed DevOps and move

51
00:02:39,399 --> 00:02:40,749
towards decentralized DevOps.

52
00:02:41,519 --> 00:02:45,349
And for building modern applications,
using these kind of DevOps

53
00:02:45,350 --> 00:02:46,769
frameworks is really needed.

54
00:02:47,279 --> 00:02:50,789
So you need frameworks to deploy
code and infrastructure to your

55
00:02:50,849 --> 00:02:52,239
accounts, that is AWS accounts.

56
00:02:52,804 --> 00:02:56,224
to, support an application runtime
operations and optimization.

57
00:02:57,214 --> 00:03:00,074
So when you come to serverless
apps, how do you do that?

58
00:03:00,244 --> 00:03:01,454
And what are the challenges?

59
00:03:02,244 --> 00:03:04,334
The thing is like code and the
infrastructure, though there

60
00:03:04,334 --> 00:03:07,414
is not any real infrastructure,
you still have to like, create

61
00:03:07,414 --> 00:03:09,125
your serverless services, right?

62
00:03:09,444 --> 00:03:11,404
And that with the code
are tightly coupled.

63
00:03:11,524 --> 00:03:14,944
Examples being these services, and
there can be many more examples,

64
00:03:14,984 --> 00:03:18,464
but the key ones here, that you
create a lambda function and your

65
00:03:18,514 --> 00:03:20,174
runtime and the code is within that.

66
00:03:20,729 --> 00:03:24,159
And if when you use EventBridge,
you provision an event bus and your

67
00:03:24,189 --> 00:03:27,619
business rules of which sources
come into the bridge and which

68
00:03:27,619 --> 00:03:31,819
targets you're going to reach out to
stays within the EventBridge rules.

69
00:03:32,129 --> 00:03:34,899
Similar way, all the business
function workflow is going to

70
00:03:34,899 --> 00:03:36,559
remain within step functions.

71
00:03:37,059 --> 00:03:41,339
So in that case, who takes the
responsibility of what and how do you

72
00:03:41,839 --> 00:03:46,479
choose the right infrastructure as tool
that is going to help you with building

73
00:03:46,479 --> 00:03:49,139
such a serverless and modern application.

74
00:03:49,909 --> 00:03:55,119
So I'm going to show you some ISE tools
because it's not just I'm going to say

75
00:03:55,119 --> 00:04:00,189
that it's all can be done in AWS SAM
because it depends on various factors

76
00:04:00,249 --> 00:04:02,039
of what is right for your organization.

77
00:04:02,609 --> 00:04:07,549
So we have AWS native options like AWS
CloudFormation, which is in the YAML

78
00:04:07,559 --> 00:04:13,739
format and all the features and services,
to deploy them, are available, constructs

79
00:04:13,739 --> 00:04:15,664
are available within AWS CloudFormation.

80
00:04:16,164 --> 00:04:20,514
An AWS Sam, which is the focus of
today, is built on transformation,

81
00:04:20,874 --> 00:04:24,564
but it has various most powerful
features and constructs, which is

82
00:04:24,564 --> 00:04:28,404
going to help you specifically with
serverless resources and applications.

83
00:04:29,154 --> 00:04:32,515
And also a higher level,
tool or a construct is the

84
00:04:32,814 --> 00:04:34,074
AWS cloud development data.

85
00:04:34,974 --> 00:04:37,554
So this is based on writing
the infrastructure as code

86
00:04:37,614 --> 00:04:38,874
in programming languages.

87
00:04:39,284 --> 00:04:42,014
For example, if your app team, so
when we discussed on distributed

88
00:04:42,014 --> 00:04:42,929
or decentralized, DevOps.

89
00:04:43,549 --> 00:04:46,099
Where the application management
team is going to have most

90
00:04:46,099 --> 00:04:47,809
of the ownership on the code.

91
00:04:48,319 --> 00:04:50,759
In that case, you can use a,
let's say your organization

92
00:04:50,759 --> 00:04:52,099
is fully on a Python stack.

93
00:04:52,159 --> 00:04:56,779
Then you can write your infrastructure
as code in Python and use a

94
00:04:56,899 --> 00:04:57,969
cloud development kit for that.

95
00:04:58,959 --> 00:05:02,149
Another option is the open
source tools like the serverless

96
00:05:02,159 --> 00:05:03,409
framework or the Terraform.

97
00:05:03,789 --> 00:05:06,049
So these tools are like platform agnostic.

98
00:05:06,119 --> 00:05:10,684
So you can use it on prem, AWS or
on other cloud providers as well.

99
00:05:11,374 --> 00:05:15,394
So if you have been like using such
tools, let's say Terraform, and

100
00:05:15,424 --> 00:05:18,394
we want to continue to use that in
AWS, you can very well, do that.

101
00:05:18,934 --> 00:05:22,514
But one thing to highlight here is,
so whenever there is new features

102
00:05:22,514 --> 00:05:26,215
and services coming in, so it gets,
available in, CloudFormation first.

103
00:05:26,455 --> 00:05:29,995
And then, so since SAM is built on
CloudFormation, immediately you can

104
00:05:30,045 --> 00:05:31,425
adapt it into the same SAM framework.

105
00:05:32,370 --> 00:05:36,530
But, it'll take a few, time for
those, frameworks on, or new features

106
00:05:36,530 --> 00:05:40,510
and services to be available and
supported by these open source, tools.

107
00:05:41,110 --> 00:05:42,560
So that is the, caveat, here.

108
00:05:43,060 --> 00:05:46,690
So now with that, we'll see what are
the, like I'm going to highlight on

109
00:05:46,690 --> 00:05:51,120
where, Sam is going to be useful because
Sam, as I mentioned, it's not just

110
00:05:51,120 --> 00:05:54,420
IAC, there are many more things that we
are going to see of, how you use Sam.

111
00:05:55,230 --> 00:05:57,150
So we will focus on that
for the rest of the.

112
00:05:57,555 --> 00:05:57,955
session.

113
00:05:58,755 --> 00:06:03,295
So first what I want to show you
is a practical guide to using SAM

114
00:06:03,295 --> 00:06:06,185
using a serverless JNA app example.

115
00:06:06,825 --> 00:06:10,185
So first I will show you a demo
of that application so that we

116
00:06:10,185 --> 00:06:11,745
know that what we are working on.

117
00:06:12,015 --> 00:06:15,895
Then we will see the architecture of
it and then see how you build that

118
00:06:15,895 --> 00:06:19,125
application in parts using AWS SAM.

119
00:06:19,475 --> 00:06:23,030
So why I have chosen a JNA application
is So it's when we say serverless,

120
00:06:23,030 --> 00:06:28,199
it's not just, usual services like
API Gateway, Lambda, DynamoDB, etc.

121
00:06:28,280 --> 00:06:32,790
So I want to showcase how you can use
the rest of the serverless, ecosystem

122
00:06:32,820 --> 00:06:37,250
within AWS and bring it into SAM
and build applications very quickly.

123
00:06:37,870 --> 00:06:38,580
So let's get into that.

124
00:06:39,080 --> 00:06:41,820
So this is a very,
simple, Dine application.

125
00:06:42,200 --> 00:06:44,610
So what we're going to do is,
this is like an, for an event.

126
00:06:44,730 --> 00:06:46,950
If, participants are
coming in or the attendees.

127
00:06:47,420 --> 00:06:51,790
So here I've taken our con 42
cloud native 2025 as an example.

128
00:06:52,370 --> 00:06:56,700
So attendees at the after attending
the session will give their name and

129
00:06:56,700 --> 00:07:00,180
it will select any of the sessions
that they attended and, submitted.

130
00:07:00,610 --> 00:07:03,580
So when they submit, they will
get a session summary about the

131
00:07:03,580 --> 00:07:06,900
session that they attended and
also they will be allowed to do

132
00:07:06,910 --> 00:07:08,420
some feedback on that session.

133
00:07:08,450 --> 00:07:09,340
So let's do that.

134
00:07:09,610 --> 00:07:10,820
I'm giving my name here.

135
00:07:11,580 --> 00:07:14,730
Let's say in this drop down you have
the full list of all the sessions,

136
00:07:14,740 --> 00:07:17,440
so I've just given four examples
and I'm going to choose my session

137
00:07:17,790 --> 00:07:19,860
as the example and submit it.

138
00:07:20,450 --> 00:07:23,790
So once it submits, it goes to the back
end, we will see the architecture next,

139
00:07:23,840 --> 00:07:25,560
but for now let's just see the demo.

140
00:07:26,090 --> 00:07:27,780
so it's waiting on a response.

141
00:07:28,280 --> 00:07:32,460
So it is going back, to an actually
a JNI model to feed the session name

142
00:07:32,730 --> 00:07:36,850
and it is getting a session summary
based on the abstract of the session.

143
00:07:36,850 --> 00:07:40,280
So if you see in the con 42 page,
there is a session abstract.

144
00:07:40,610 --> 00:07:42,380
So I have loaded that into a table.

145
00:07:42,860 --> 00:07:47,800
So the system will fetch that abstract and
create the summary based on that abstract.

146
00:07:47,850 --> 00:07:48,800
So that's the first part.

147
00:07:48,930 --> 00:07:50,420
So we are using JNI for that.

148
00:07:50,830 --> 00:07:53,470
And the next part is we will
ask them to rate the session.

149
00:07:54,150 --> 00:07:56,560
it's my session, so I'm just going
to say it's an excellent session

150
00:07:56,940 --> 00:07:58,450
and give some text feedback.

151
00:07:58,800 --> 00:08:03,790
Like useful session to start with
serverless apps, something like

152
00:08:03,830 --> 00:08:05,370
that and submit the feedback.

153
00:08:05,920 --> 00:08:07,940
So now it's again, waiting on a response.

154
00:08:08,360 --> 00:08:11,290
So what we are doing is based on that
feedback, we are going to create a

155
00:08:11,350 --> 00:08:12,980
thank you note for that, participant.

156
00:08:13,405 --> 00:08:15,825
So it says, dear Urmila, thank you
for attending the session, which is

157
00:08:15,865 --> 00:08:17,135
picking up the session name here.

158
00:08:17,585 --> 00:08:22,125
And, and it does a sentiment analysis on
what feedback that you have given as well.

159
00:08:22,775 --> 00:08:25,455
And it says we are glad you found the
session helpful and we are delighted,

160
00:08:25,745 --> 00:08:28,605
that, to invite you for the future
events, yeah, something like that.

161
00:08:28,605 --> 00:08:30,285
So this one is also JNI generated.

162
00:08:30,285 --> 00:08:33,415
So you see two JNI generated,
text, generation example, here.

163
00:08:33,580 --> 00:08:38,140
So if you, and the application works in
such a way that if you want to generate

164
00:08:38,140 --> 00:08:41,080
new content again for another session,
you can click on this button and do

165
00:08:41,080 --> 00:08:42,940
that or just finish to complete that.

166
00:08:43,320 --> 00:08:45,490
So that's a quick example
of this architecture.

167
00:08:45,800 --> 00:08:48,790
So we will, we'll see the
actual architecture behind it.

168
00:08:49,030 --> 00:08:51,250
So just one thing to note here
is what's happening is you are

169
00:08:51,280 --> 00:08:54,135
filling in some details and you
are sending it to the backend.

170
00:08:54,135 --> 00:08:58,100
And from the JNI application perspective,
whatever you give here, that is the

171
00:08:58,100 --> 00:09:02,430
name of the session and your feedback
here, all are like user prompts.

172
00:09:02,485 --> 00:09:04,825
That you give to the
engineer system behind.

173
00:09:05,125 --> 00:09:08,355
And, using that there is a generic
response that you, review back.

174
00:09:09,045 --> 00:09:09,765
So that's an mo.

175
00:09:09,945 --> 00:09:11,865
So now we will go back
and see the architecture.

176
00:09:12,365 --> 00:09:14,885
So this is the full
architecture of this app.

177
00:09:15,725 --> 00:09:15,935
Don't worry.

178
00:09:15,935 --> 00:09:19,385
We are going, not going to build the whole
thing using Sam within this, session.

179
00:09:19,985 --> 00:09:21,535
I'll take you part by, part here.

180
00:09:21,685 --> 00:09:24,495
So there are like, so though
this is a full one application.

181
00:09:25,155 --> 00:09:28,765
You can do it in a very modular way, and
in an actual organization, there could

182
00:09:28,765 --> 00:09:31,995
be multiple teams who collaborate with
each other to build such an application.

183
00:09:32,615 --> 00:09:36,945
For example, there could be an integration
services team whose responsibility is

184
00:09:36,975 --> 00:09:42,095
to, bring the data from your, let's say,
from your front end to your, middleware.

185
00:09:42,525 --> 00:09:46,295
And at the same time, take the data from
your back end back to your front end.

186
00:09:46,715 --> 00:09:49,735
So in this case, what's happening here
is, you have an API gateway, through

187
00:09:49,735 --> 00:09:53,255
which you get the, so if you remember the
demo, whatever you type in the front end

188
00:09:53,255 --> 00:09:57,145
is coming to the API gateway and going
to a Lambda, and then it gets published

189
00:09:57,145 --> 00:09:58,835
as an, events in an event bridge.

190
00:09:59,065 --> 00:10:01,805
this is a fully event driven
architecture, whatever response that

191
00:10:01,805 --> 00:10:06,385
you see back in the, front end is not
going in the same API gateway call.

192
00:10:06,675 --> 00:10:08,844
So the API gateway call is
just to publish the events.

193
00:10:09,145 --> 00:10:13,015
So if you see in the backend, from, again,
the results are published into the even

194
00:10:13,015 --> 00:10:15,435
bridge, which goes to the, front end Yeah.

195
00:10:15,495 --> 00:10:16,815
Through asynchronous messaging.

196
00:10:16,875 --> 00:10:20,055
And there is a, I'm not going to explain
each of the services here, but not in

197
00:10:20,055 --> 00:10:24,165
the scope of the session, but you can
use services like a WSI core to send the

198
00:10:24,165 --> 00:10:26,265
asynchronous messaging to the front end.

199
00:10:26,535 --> 00:10:27,795
So that's what is used in this design.

200
00:10:28,065 --> 00:10:31,395
And let's say that a team is that
they take the responsibility of

201
00:10:31,395 --> 00:10:34,595
doing this, type of integrations for
receiving the events and also sending

202
00:10:34,595 --> 00:10:35,530
back the events to the front end.

203
00:10:36,225 --> 00:10:39,335
And then there can be a business
application team who manages the actual

204
00:10:39,365 --> 00:10:42,065
business logic of this application.

205
00:10:42,095 --> 00:10:45,665
So in this demo, you saw
that there was two parts.

206
00:10:45,685 --> 00:10:49,675
One is first it generated a summary
and then it created a thanks note.

207
00:10:50,145 --> 00:10:53,735
So both of these events gets
evaluated in an event bridge rules.

208
00:10:53,795 --> 00:10:54,895
Actually, there are like two rules.

209
00:10:54,975 --> 00:10:57,855
I have just put like a one
rule in this diagram and then

210
00:10:57,855 --> 00:10:58,855
it goes to a step function.

211
00:10:58,875 --> 00:11:01,955
So a part of what's happening
in the step functions for now.

212
00:11:02,465 --> 00:11:05,865
but this, why I have shown this other
flow is, so this application though

213
00:11:05,865 --> 00:11:09,805
we just saw a text summary, there
could be other new features which

214
00:11:09,805 --> 00:11:11,465
can be added in a very modular way.

215
00:11:11,775 --> 00:11:14,385
So that, which sketch can be
treated as another event and it

216
00:11:14,385 --> 00:11:17,365
goes through another rule and goes
to another, like generic model to

217
00:11:17,385 --> 00:11:18,985
create an image maybe in that case.

218
00:11:19,345 --> 00:11:22,205
So we are not going to see that part
in the, in the session, but this is

219
00:11:22,205 --> 00:11:25,669
just to show you how an event driven
architecture can model, modularly grow.

220
00:11:26,230 --> 00:11:29,640
And then there can be a JNI team who
actually suggest on which model is

221
00:11:29,640 --> 00:11:33,700
best for you and provides the API
information to access that and all that.

222
00:11:34,060 --> 00:11:37,670
And maybe there can be a front end team as
well who is managing the front end code.

223
00:11:38,170 --> 00:11:41,609
So now let's look at how to use a SAC.

224
00:11:41,920 --> 00:11:44,920
And we will start in a very,
simple way of just focusing on this

225
00:11:44,950 --> 00:11:48,600
integration services team A, and
then look at these three parts alone.

226
00:11:48,690 --> 00:11:52,049
That is receiving the events from the
front end through API Gateway, Lambda,

227
00:11:52,050 --> 00:11:53,790
and then publish it into an, event bridge.

228
00:11:54,140 --> 00:11:55,420
And how do we use SAM for that?

229
00:11:56,130 --> 00:11:57,640
So SAM has two parts.

230
00:11:57,860 --> 00:12:01,910
one is the transformation templates, which
is the actual similar to CloudFormation

231
00:12:01,910 --> 00:12:05,084
template, the YAML template, which can
be used as the infrastructure as code.

232
00:12:05,615 --> 00:12:10,115
And next is the SAM CLI which is
used for like local development and

233
00:12:10,175 --> 00:12:14,355
testing, building, packaging and also
from there you can directly deploy,

234
00:12:14,445 --> 00:12:16,205
create pipelines and lots more.

235
00:12:16,735 --> 00:12:20,375
So we will see an example of all of
this across the development cycle using

236
00:12:20,385 --> 00:12:21,975
this Genai application as an example.

237
00:12:22,475 --> 00:12:24,215
So as I said, it's built
on top of CloudFormation.

238
00:12:25,005 --> 00:12:25,935
So it's still YAML.

239
00:12:26,205 --> 00:12:28,525
So the SAM template as well is YAML.

240
00:12:29,120 --> 00:12:33,500
But if you look at this transform
statement at the top, so when you create

241
00:12:34,000 --> 00:12:38,150
a SAM template, it gets converted into a
CloudFormation template internally when

242
00:12:38,150 --> 00:12:40,700
you build it and then you deploy it.

243
00:12:40,790 --> 00:12:43,790
So finally when you are deploying
it, it is going to get deployed as a

244
00:12:43,790 --> 00:12:45,700
CloudFormation stack behind the scenes.

245
00:12:46,525 --> 00:12:48,745
So this is just an example of
how a SAM template looks like.

246
00:12:49,025 --> 00:12:52,955
So the notation for using, the,
SAM construct is AWS serverless.

247
00:12:53,025 --> 00:12:54,785
And if it is lambda, it's called function.

248
00:12:55,095 --> 00:12:58,175
And, we have nearly nine, resource types,
which we will see in the next slide.

249
00:12:58,645 --> 00:13:01,355
and also pay attention to this, IM row.

250
00:13:01,795 --> 00:13:04,325
So you can associate
like managed policies.

251
00:13:04,405 --> 00:13:05,975
So these are the another advantage.

252
00:13:06,165 --> 00:13:10,124
So here this lambda function
has to read a DynamoDB table.

253
00:13:10,125 --> 00:13:14,415
So you just add the policy and give
the table name as the reference.

254
00:13:14,905 --> 00:13:18,555
so all this ref all are
like usual CloudFormation

255
00:13:18,555 --> 00:13:19,304
notations that you will use.

256
00:13:19,675 --> 00:13:23,465
I will be using it all along in the
session, assuming that you have, some

257
00:13:23,465 --> 00:13:25,145
idea on how CloudFormation, works.

258
00:13:25,515 --> 00:13:25,705
Yeah.

259
00:13:26,135 --> 00:13:28,745
so this, what is the advantage of
using this is, it is going to help

260
00:13:28,745 --> 00:13:30,565
you define fine grained policies.

261
00:13:30,895 --> 00:13:33,435
That is the, the permission of this
Lambda is going to be restricted to

262
00:13:33,435 --> 00:13:35,715
just this table and just for the read.

263
00:13:35,925 --> 00:13:39,235
So that is built in automatically when
you use this kind of managed policy.

264
00:13:39,735 --> 00:13:43,089
And then when you use events, it
is going to attach a API gateway.

265
00:13:43,420 --> 00:13:45,080
And this one is for the, DynamoDB table.

266
00:13:45,460 --> 00:13:49,710
So just with this code, a few lines of
code, you are able to create a Lambda

267
00:13:49,710 --> 00:13:54,730
function, a DynamoDB table, an API
gateway, and also the IAM role for the

268
00:13:54,730 --> 00:13:57,550
Lambda function to access, DynamoDB table.

269
00:13:57,630 --> 00:14:01,060
So that's how these kind of high
level serverless constructs.

270
00:14:01,080 --> 00:14:04,530
So we have this available for nine
resource type, which you can use.

271
00:14:04,880 --> 00:14:07,790
And then reduce the number of
lines of code that you actually

272
00:14:07,790 --> 00:14:09,084
write for infrastructure as, code.

273
00:14:09,965 --> 00:14:12,355
And, to make that into
a bigger CloudFormation

274
00:14:12,355 --> 00:14:15,124
template, SAM takes care of it.

275
00:14:16,005 --> 00:14:20,105
And, yeah, so this is the, IAM policies,
managed policies that I told, there are,

276
00:14:20,165 --> 00:14:22,465
so there are 75 plus policies available.

277
00:14:22,965 --> 00:14:24,315
So you can like, so this is the link.

278
00:14:24,325 --> 00:14:28,195
So have a look at that, before like
defining your own policies, think,

279
00:14:28,455 --> 00:14:31,595
see that if any of these can be
like just leveraged without having

280
00:14:31,595 --> 00:14:33,325
you to, write in depth policies.

281
00:14:33,825 --> 00:14:37,430
And, yeah, so here as events,
because Lambda is invoked,

282
00:14:37,430 --> 00:14:38,842
how does Lambda is invoked?

283
00:14:38,842 --> 00:14:41,265
It's invoked only, at, at an event.

284
00:14:41,495 --> 00:14:45,365
So the event can be API gateway as in
this example, but there can be other,

285
00:14:45,395 --> 00:14:46,685
events which is triggering Lambda.

286
00:14:47,035 --> 00:14:50,585
So in, SAM, there are like 19, plus
function, events that is supported.

287
00:14:50,875 --> 00:14:54,075
So like example, if there is a file
arriving in S3, that could be a

288
00:14:54,075 --> 00:14:55,445
trigger to, trigger a Lambda function.

289
00:14:55,815 --> 00:15:00,175
Or, a DynamoDB stream event that is a
record being updated, deleted, et cetera.

290
00:15:00,245 --> 00:15:02,735
And so all of this can
be leveraged in SAM.

291
00:15:03,235 --> 00:15:06,785
So I kept mentioning that, that SAM
can be used across the development

292
00:15:06,785 --> 00:15:09,275
cycle and it's not just for
building infrastructure, right?

293
00:15:09,445 --> 00:15:13,835
So as you can see, these are the various
SAM CLI, commands that you can use.

294
00:15:14,270 --> 00:15:16,060
And it is spread across
the development cycle.

295
00:15:16,380 --> 00:15:20,090
So whether you are a persona of an
application developer or you are a

296
00:15:20,090 --> 00:15:24,700
DevOps person, as we go along, you
can see where you can use each of

297
00:15:24,700 --> 00:15:29,630
these CLI constructs and for your
own persona and the type of job you

298
00:15:29,640 --> 00:15:31,490
do and making the application line.

299
00:15:31,900 --> 00:15:36,380
So let's first start from the SAM init
and, and then go along each of it.

300
00:15:36,650 --> 00:15:40,400
for the SAM init, we are going to look
at just this area, which is the API

301
00:15:40,400 --> 00:15:43,010
gateway and, and Lambda and go from there.

302
00:15:43,510 --> 00:15:45,460
This is my, ID that I use.

303
00:15:45,500 --> 00:15:49,510
You can use any ID of your own, like
VS code or, anything that you prefer,

304
00:15:49,890 --> 00:15:53,940
which can have like code, terminal and
ability to access your local files.

305
00:15:54,440 --> 00:15:56,920
So in here, there are already some
demo applications, but I'm going

306
00:15:56,920 --> 00:15:59,030
to start one saying SAM init.

307
00:15:59,280 --> 00:16:00,860
So all of the SAM CLI.

308
00:16:00,880 --> 00:16:08,520
So this IDE, I've installed AWS CLI, SAM
CLI, and Docker as well as a prerequisite.

309
00:16:09,020 --> 00:16:09,530
Why Docker?

310
00:16:09,580 --> 00:16:12,460
we'll see.

311
00:16:12,460 --> 00:16:15,460
So when we do SAM init, it's going
to ask you to give some QuickStart

312
00:16:15,500 --> 00:16:16,770
templates and custom templates.

313
00:16:17,200 --> 00:16:19,720
So if you already have a template,
you can bring it into that.

314
00:16:20,480 --> 00:16:21,880
But we'll do a QuickStart template.

315
00:16:22,270 --> 00:16:25,840
And it has this all this, like serverless
API, ThreadLine function, and we'll just

316
00:16:25,840 --> 00:16:27,580
do this hello world example for now.

317
00:16:28,310 --> 00:16:30,540
And, what are the runtimes to use?

318
00:16:30,870 --> 00:16:33,430
I'm going to, give n, not use Python 3.

319
00:16:33,430 --> 00:16:35,750
13 to show you all of the other
things that is, available.

320
00:16:36,280 --> 00:16:37,760
So you can choose anything that you need.

321
00:16:38,180 --> 00:16:40,070
my, ID is a Python 3.

322
00:16:40,260 --> 00:16:42,230
9, so I'm just going to use that.

323
00:16:43,040 --> 00:16:45,670
And, we are not doing image
type, we are doing, normal zip.

324
00:16:46,240 --> 00:16:50,730
And all this, tracing and, monitoring,
I'm not going to enable it for now.

325
00:16:51,060 --> 00:16:52,960
And then you give a project name for this.

326
00:16:53,320 --> 00:16:56,800
So I'm, we're doing, if you remember,
we are doing team A, B and C, right?

327
00:16:56,820 --> 00:16:59,520
So this is for team A. So team A
app 1, I will name it like that.

328
00:17:00,020 --> 00:17:03,050
So now if you see team A app 1,
it has created a folder structure

329
00:17:03,410 --> 00:17:04,470
with, various, subfolders.

330
00:17:04,995 --> 00:17:09,295
And the main thing is this template, YAML
five, which is t Sam template itself.

331
00:17:09,795 --> 00:17:09,945
Yeah.

332
00:17:09,975 --> 00:17:11,385
So I will use a terminal below.

333
00:17:11,385 --> 00:17:13,275
From now on, we'll close this.

334
00:17:13,860 --> 00:17:16,130
we'll go into our, a app one folder.

335
00:17:16,730 --> 00:17:20,115
And if you see we have already
got, the resources, which is, the

336
00:17:20,115 --> 00:17:23,205
function is the Lambda function
and the runtime that you chose.

337
00:17:23,220 --> 00:17:24,480
And events.

338
00:17:24,480 --> 00:17:28,300
It is, regarded by any a p. So all,
everything is available already in,

339
00:17:28,350 --> 00:17:32,370
and this out output section is to give
some, idea on the resources created

340
00:17:32,430 --> 00:17:33,960
when your start formation stack.

341
00:17:33,960 --> 00:17:34,620
It's, deployed.

342
00:17:34,990 --> 00:17:38,350
so when you finally have the resources
deployed, when you go to the output

343
00:17:38,350 --> 00:17:41,800
sections of the cloud formation
stack, you will see the, API endpoint,

344
00:17:41,940 --> 00:17:43,770
function in point and, function.

345
00:17:43,770 --> 00:17:45,310
Im role, for now.

346
00:17:45,310 --> 00:17:49,200
We are going to like, just comment
it out and, and focus on here.

347
00:17:49,940 --> 00:17:53,090
if you see we have the
hello world and app.

348
00:17:53,940 --> 00:17:54,940
lambda handler.

349
00:17:55,460 --> 00:17:59,410
So that is the template and then
for each of the function that you

350
00:17:59,410 --> 00:18:03,120
create there is a subfolder in
which there is an requirements.

351
00:18:03,120 --> 00:18:05,820
txt file and the actual app code here.

352
00:18:05,920 --> 00:18:08,760
So we chose python so
the code is in python.

353
00:18:08,960 --> 00:18:10,310
So there is some example.

354
00:18:10,810 --> 00:18:15,110
So I have a code that is needed for
sending the necessary information for us.

355
00:18:15,480 --> 00:18:20,860
So I'm going to copy paste that
code into this function and then

356
00:18:20,860 --> 00:18:21,970
we'll see what the code has got.

357
00:18:22,470 --> 00:18:25,300
So this code, if you
see, what does it say?

358
00:18:25,300 --> 00:18:30,920
Intentation is not proper.

359
00:18:31,420 --> 00:18:32,370
Yeah, okay.

360
00:18:32,960 --> 00:18:35,940
so this is a simple lambda function
where it is going to get the

361
00:18:35,950 --> 00:18:40,610
event from the API gateway and
publish it into an event bridge.

362
00:18:40,760 --> 00:18:44,440
So that's what it is saying and the
input parameters that you have here.

363
00:18:44,640 --> 00:18:47,380
So once you put it in lambda, the
BOTO3, it's all like automatically

364
00:18:47,380 --> 00:18:48,970
imported for local testing.

365
00:18:49,030 --> 00:18:51,440
you can put that in
your requirements file.

366
00:18:51,960 --> 00:18:52,810
So this was the default one.

367
00:18:52,810 --> 00:18:53,990
We don't need a request package.

368
00:18:53,990 --> 00:18:54,380
We need BOTO3.

369
00:18:54,790 --> 00:18:57,380
So I'll put that, here and
save that, and close this.

370
00:18:58,295 --> 00:19:02,995
And for the rest of the details, if
you see, it is taking the event and

371
00:19:02,995 --> 00:19:04,795
writing that event in a different format.

372
00:19:04,865 --> 00:19:09,775
So it is giving a source column,
detail type, and the actual detail

373
00:19:09,825 --> 00:19:11,035
that is coming in the event bridge.

374
00:19:11,155 --> 00:19:12,445
We will see what that detail is.

375
00:19:12,715 --> 00:19:14,625
And then it is giving an event bus name.

376
00:19:14,735 --> 00:19:20,475
So I have an event bus already
created in my AWS account.

377
00:19:21,020 --> 00:19:24,030
So in the interest of time, I'm
not going to show the IAC or

378
00:19:24,030 --> 00:19:25,290
template for the event bus as well.

379
00:19:26,080 --> 00:19:29,380
I used this for a previous event, that's
why the name is Cloud AI and Dublin.

380
00:19:29,800 --> 00:19:34,210
So the event bus, this is the event
bus, if you look in the console and

381
00:19:34,210 --> 00:19:39,210
within the event bus, we have various
rules to send it to various targets

382
00:19:39,420 --> 00:19:40,950
based on what the event type is.

383
00:19:41,240 --> 00:19:43,340
So we will see into that rules in a while.

384
00:19:43,820 --> 00:19:45,190
Coming back to the console.

385
00:19:45,470 --> 00:19:47,400
So you have your code ready now.

386
00:19:47,670 --> 00:19:48,740
So the next step is.

387
00:19:49,240 --> 00:19:53,850
Before you go and directly deploy it,
SAM provides you to ability to do a

388
00:19:53,950 --> 00:19:57,320
local invoke of this lambda function
to see if the code is right, you have

389
00:19:57,320 --> 00:19:58,790
built it before getting into deployment.

390
00:19:59,110 --> 00:20:00,890
So that we will see as the next step.

391
00:20:01,390 --> 00:20:01,670
Okay.

392
00:20:01,670 --> 00:20:04,720
So the next piece that we are going
to see is about the SAM local.

393
00:20:05,170 --> 00:20:09,930
That is how do you locally test
your serverless resources before

394
00:20:10,050 --> 00:20:11,470
getting it into deployment.

395
00:20:11,560 --> 00:20:15,010
you, for Lambda, as I mentioned,
you need to have the events

396
00:20:15,020 --> 00:20:16,090
from a particular service.

397
00:20:16,520 --> 00:20:20,940
So you can simulate events using SAM local
from each of the services that you see,

398
00:20:21,160 --> 00:20:23,870
and then use it to locally invoke Lambda.

399
00:20:23,870 --> 00:20:28,320
As I mentioned, all Lambdas
So first of all, let's,

400
00:20:28,320 --> 00:20:31,020
generate some, event, for that.

401
00:20:31,040 --> 00:20:34,020
So for here, the source service,
which is going to generate

402
00:20:34,080 --> 00:20:35,525
the event is API Gateway.

403
00:20:35,965 --> 00:20:38,705
So when you give this command, it
is going to give you all of the

404
00:20:38,715 --> 00:20:41,435
services that can trigger an event.

405
00:20:41,435 --> 00:20:45,225
So we will choose API Gateway
from here and include that as

406
00:20:45,225 --> 00:20:47,185
a parameter to see the options.

407
00:20:47,615 --> 00:20:48,875
here there are like four options.

408
00:20:49,345 --> 00:20:54,355
it can, because Lambda, API Gateway can
be, used to, integrate with Lambda as

409
00:20:54,355 --> 00:20:57,525
a Lambda authorizer, which is the first
one, and Lambda proxy integration or

410
00:20:57,535 --> 00:20:59,955
HTTP API, proxy integration and so on.

411
00:21:00,515 --> 00:21:03,495
so the way we have defined
here in the template, about

412
00:21:03,995 --> 00:21:05,925
is a normal HTTP API proxy.

413
00:21:06,525 --> 00:21:09,435
But I want to show you
how a REST API works.

414
00:21:09,545 --> 00:21:15,965
So for which we need the AWS, proxy,
usually how an API gateway, event

415
00:21:15,965 --> 00:21:18,410
will look like is something like this.

416
00:21:18,910 --> 00:21:22,300
So it will have the actual body,
which will have the message from the

417
00:21:22,310 --> 00:21:25,880
front end, and then, the resource
parameter, headers and so on.

418
00:21:26,670 --> 00:21:31,090
But when you use it as an AWS proxy
integration, when it goes through to

419
00:21:31,100 --> 00:21:35,320
Lambda, it is going to just send it as
a proxy and just send this information,

420
00:21:35,320 --> 00:21:38,860
that is the top body information
is what will get to the, Lambda.

421
00:21:39,360 --> 00:21:42,659
So instead of using this, full
event for the testing purpose.

422
00:21:43,040 --> 00:21:47,370
As if we are using a AWS
proxy integration, we will

423
00:21:47,380 --> 00:21:49,080
use this type of an app event.

424
00:21:49,080 --> 00:21:51,290
So if you see this another
file sessions, event.

425
00:21:51,539 --> 00:21:52,380
So this is what is here.

426
00:21:52,409 --> 00:21:56,199
So if you go back to our demo and
remember my demo, we initially

427
00:21:56,239 --> 00:21:57,879
created a summary of the session.

428
00:21:57,979 --> 00:22:01,379
So the input from the front end
was the session name and the event

429
00:22:01,389 --> 00:22:02,809
type, which is generate summary.

430
00:22:02,809 --> 00:22:03,859
So the event type is summary.

431
00:22:04,289 --> 00:22:06,054
So this is what is going to go to the.

432
00:22:06,994 --> 00:22:07,404
function.

433
00:22:07,674 --> 00:22:14,504
So now if we do a SAM local invoke, hyphen
e. So if you give hyphen e, that means you

434
00:22:14,504 --> 00:22:17,434
are going to give the event as the input.

435
00:22:17,934 --> 00:22:21,214
So I'm going to give the session
event as the input to see how

436
00:22:21,214 --> 00:22:22,764
the lambda function gets invoked.

437
00:22:23,264 --> 00:22:25,704
So now it is invoked.

438
00:22:26,434 --> 00:22:31,214
And yeah, one thing to highlight here
is, When you are invoking this function,

439
00:22:31,604 --> 00:22:38,184
do you see this one local image and then
it is getting a public image from ECR.

440
00:22:38,184 --> 00:22:43,614
So what is happening here is, Sam in
the CLI, it is pulling a lambda image

441
00:22:43,744 --> 00:22:45,434
and spinning up a local container.

442
00:22:45,435 --> 00:22:47,604
So remember I mentioned
the docker query site.

443
00:22:47,664 --> 00:22:50,564
This is why we need the docker
here so that it will create a local

444
00:22:50,564 --> 00:22:54,174
lambda image and run your code in
that and provide you the answer.

445
00:22:54,244 --> 00:22:55,474
So you've got the response here now.

446
00:22:55,829 --> 00:23:00,839
As a response code 200 and what is being
returned is the actual event that you

447
00:23:00,839 --> 00:23:02,829
will be passing on to the, event bridge.

448
00:23:03,299 --> 00:23:06,819
So it is going and publishing an
event in the event bridge, but I

449
00:23:06,819 --> 00:23:09,559
put that in the response object
with just to see what is being fed.

450
00:23:09,959 --> 00:23:13,299
So now we have successfully tested
the Lambda, but we have tested

451
00:23:13,299 --> 00:23:17,629
it through the existing small
configuration of an, normal API.

452
00:23:18,069 --> 00:23:21,619
Now as I mentioned, let's see how
it can be changed into a REST API

453
00:23:21,649 --> 00:23:23,409
with even more complex parameters.

454
00:23:24,249 --> 00:23:30,199
So if I show you in an console, an
example API, let's take this one.

455
00:23:30,699 --> 00:23:36,419
So this is a REST API, which has a
post integration, to a Lambda function.

456
00:23:37,319 --> 00:23:41,339
And you have, various other parameters
configured as part of this, a PA

457
00:23:41,339 --> 00:23:44,879
con, configuration, such as from
the Lambda response, what is the

458
00:23:44,879 --> 00:23:48,179
response score that is being, returned
and, what are the response headers

459
00:23:48,179 --> 00:23:52,014
being, a returned and allowed, and
the response body pipe, et cetera.

460
00:23:52,524 --> 00:23:56,994
So if you want a proper configuration,
everything done through Sam and without

461
00:23:57,044 --> 00:24:00,464
touching the console, then you, need
to code each of those parameters.

462
00:24:01,109 --> 00:24:05,369
So an easier way of, how it can be
achieved is one way is if you have an

463
00:24:05,369 --> 00:24:10,129
example, API, in the console, you can
go to the, deploy the stage and go to

464
00:24:10,129 --> 00:24:14,999
the stage actions and do an export and
export it in an open, I open a p format.

465
00:24:15,389 --> 00:24:19,259
And since we are going to use it
in, Sam, choose the YAML format and

466
00:24:19,259 --> 00:24:22,999
also export with the API gateway,
extensions so that you get the full

467
00:24:22,999 --> 00:24:25,579
information from the A-W-S-A-I gateway.

468
00:24:25,959 --> 00:24:27,319
And, and then export this API.

469
00:24:27,449 --> 00:24:30,719
So when you export it, you will
have something like this one.

470
00:24:31,309 --> 00:24:37,149
So I've exported it and put it into a
yaml file in our project root folder.

471
00:24:37,289 --> 00:24:38,159
Yeah, it's here.

472
00:24:38,659 --> 00:24:39,869
so this will look like
something like this.

473
00:24:40,389 --> 00:24:43,779
So you are going to, have the regular
OpenAPI format if you have, if

474
00:24:43,779 --> 00:24:45,029
you're familiar with OpenAPI format.

475
00:24:45,269 --> 00:24:48,119
So even if you are exporting an external
API from some other system and want

476
00:24:48,119 --> 00:24:51,509
to put it as an AWS API gateway,
this is an easier way of doing it.

477
00:24:51,509 --> 00:24:53,979
You get, you just get the
OpenAPI specification and

478
00:24:53,989 --> 00:24:55,459
use it in your, SAM template.

479
00:24:56,269 --> 00:24:58,219
So what you are doing, so
this is an external file.

480
00:24:58,249 --> 00:25:01,519
So we have our template file
separately and we are having the API.

481
00:25:01,589 --> 00:25:02,859
yaml file.

482
00:25:02,859 --> 00:25:05,079
So you can, use all the
information here, as is.

483
00:25:05,159 --> 00:25:07,454
So if you see, this is
the one that I mentioned.

484
00:25:07,724 --> 00:25:12,124
All the API Gateway configurations like
the header methods allowed, response

485
00:25:12,154 --> 00:25:16,424
codes, everything gets copied into this
as is and the main thing that you need

486
00:25:16,424 --> 00:25:20,734
to change here or customize for the
new deployment is this credentials.

487
00:25:21,284 --> 00:25:25,174
So this credentials is the role
that API Gateway will use to

488
00:25:25,194 --> 00:25:26,504
access the integration points.

489
00:25:26,504 --> 00:25:28,404
So in this case, the
integration service is Lambda.

490
00:25:28,904 --> 00:25:31,034
So do not hardcode it, like
the way I have done here.

491
00:25:31,314 --> 00:25:35,624
Use an, parameterized, attribute, which
because your role itself you might

492
00:25:35,624 --> 00:25:38,214
be creating in your SAM template, as
part of the same template or you're

493
00:25:38,214 --> 00:25:39,244
fetching from another template.

494
00:25:39,474 --> 00:25:41,904
so use the parameterized,
attribute rather than hardcoding.

495
00:25:42,204 --> 00:25:44,174
So credentials is one that
you need to customize.

496
00:25:44,244 --> 00:25:45,378
And the next one is the URI.

497
00:25:45,378 --> 00:25:49,566
URI is the actual, end point which
you will call from API gateway.

498
00:25:49,896 --> 00:25:51,276
So here the endpoint is lambda.

499
00:25:51,276 --> 00:25:53,256
So it is, the syntax
is in a particular way.

500
00:25:53,256 --> 00:25:56,696
So have a look at it in the
documentation and, and then you have

501
00:25:56,696 --> 00:25:58,426
to have the actual lambda name here.

502
00:25:58,476 --> 00:26:01,216
Again, do not hard code it,
but get the actual name of the

503
00:26:01,216 --> 00:26:04,196
lambda from your template and
parameterize it and put it here.

504
00:26:04,716 --> 00:26:09,186
So once you have done this, now
you have to use this API, YAML

505
00:26:09,556 --> 00:26:11,946
in your actual template YAML.

506
00:26:12,086 --> 00:26:13,336
So let's see how we do that.

507
00:26:13,946 --> 00:26:15,816
so if I go here, just a minute.

508
00:26:16,316 --> 00:26:19,356
So what we are going to do here is we
have to introduce another resource.

509
00:26:19,356 --> 00:26:23,666
So far we didn't have a separate
resource type for API Gateway.

510
00:26:23,746 --> 00:26:25,806
So now as a REST API, we
are going to add this.

511
00:26:25,846 --> 00:26:30,146
So if I give, I've given a name
REST API and the type is this one.

512
00:26:30,146 --> 00:26:32,316
So this is the serverless
construct used for REST API.

513
00:26:32,826 --> 00:26:37,166
And I'm giving a stage name and in the
definition URI, I'm giving the API.

514
00:26:37,426 --> 00:26:38,476
yaml file.

515
00:26:38,556 --> 00:26:41,046
So we need not define anything
else in the template, we are just

516
00:26:41,046 --> 00:26:43,706
using the OpenAPI, YAML as is here.

517
00:26:44,286 --> 00:26:47,656
And in your lambda function, also we
need to make the changes so that you

518
00:26:47,656 --> 00:26:49,996
will refer this API resource in here.

519
00:26:50,496 --> 00:26:51,126
So for that.

520
00:26:51,626 --> 00:26:53,236
I'm, going to change this part.

521
00:26:53,236 --> 00:26:58,806
So what I have done is, so I've given
API event type and, as the registry API.

522
00:26:58,806 --> 00:27:03,076
So I've done a reference of this
API in here and I've given a path

523
00:27:03,126 --> 00:27:04,316
and the method is going to be post.

524
00:27:05,246 --> 00:27:08,676
that's all we need to define here and
I'm going to add a few more things,

525
00:27:08,876 --> 00:27:10,376
but not go into the details of it.

526
00:27:10,676 --> 00:27:15,286
Those are the information of the, IM
role and, IM policy that is required

527
00:27:15,286 --> 00:27:18,113
by the, API gateway and the Lambda.

528
00:27:18,303 --> 00:27:21,603
I'm just putting it here, but not going
into the details of it because this Lambda

529
00:27:21,603 --> 00:27:25,163
has further, needs permission to, write
it to the, event bridge if you remember.

530
00:27:25,213 --> 00:27:26,963
we have examples which is the events.

531
00:27:27,518 --> 00:27:29,468
Put event, permission we
are giving to the Lambda.

532
00:27:29,468 --> 00:27:31,378
So all that I am, adding it here.

533
00:27:31,878 --> 00:27:33,178
And then, I've saved this.

534
00:27:33,978 --> 00:27:36,478
And just to show you that
it is, how it is, working.

535
00:27:36,908 --> 00:27:39,638
I'm going to do a local
build and, deployment.

536
00:27:39,988 --> 00:27:43,378
So I'll say what happens in the build,
and, deploy in the coming slides.

537
00:27:43,738 --> 00:27:44,998
So if we do a SAM build now.

538
00:27:45,498 --> 00:27:50,108
Sam will package all of your code
and dependencies that you, had in

539
00:27:50,108 --> 00:27:53,028
the inside this hello world, folder
and it will create a package.

540
00:27:53,458 --> 00:27:57,488
So now it will, to just to check if
your, package has created a template

541
00:27:57,488 --> 00:27:59,298
correctly, you can do a Sam validate.

542
00:27:59,578 --> 00:28:01,038
So this will not do a deployment.

543
00:28:01,348 --> 00:28:04,758
This will, So just check,
if, the template is right.

544
00:28:04,858 --> 00:28:06,598
So here actually we are, getting an error.

545
00:28:07,158 --> 00:28:08,068
Let's see what the error is.

546
00:28:08,718 --> 00:28:10,808
So API proxy function, okay.

547
00:28:11,278 --> 00:28:15,778
So changed everything, but we had
this name as still as hello world

548
00:28:15,778 --> 00:28:19,488
function, but, everywhere I think
the roles that I have defined is

549
00:28:19,488 --> 00:28:21,818
using it as API proxy function.

550
00:28:22,288 --> 00:28:27,668
So I'm going to change this
function name as API proxy function.

551
00:28:28,168 --> 00:28:32,108
And do a build again and
do a Sam Valley data game.

552
00:28:32,608 --> 00:28:33,958
Now the template is, valid.

553
00:28:34,498 --> 00:28:37,908
Now we will do a deploy to see if,
everything is getting deployed correctly.

554
00:28:38,088 --> 00:28:39,798
So use this when you're
doing it for the first time.

555
00:28:39,798 --> 00:28:42,468
Use the guided deployment, so
that you'll see all the steps.

556
00:28:42,968 --> 00:28:45,098
Umac name, you can give a name,
or if you do leave it blank,

557
00:28:45,098 --> 00:28:46,388
it'll just take the defaults.

558
00:28:46,938 --> 00:28:50,498
confirm changes I give as, And role
creation, give it as yes, because

559
00:28:50,498 --> 00:28:53,738
you want to, you want SAM to allow
to create a role in order to do this

560
00:28:53,738 --> 00:28:56,358
deployment for rest of the things.

561
00:28:56,468 --> 00:28:58,198
So this one give yes, because
we haven't defined any

562
00:28:58,198 --> 00:29:00,708
authentication for the, API gateway.

563
00:29:00,908 --> 00:29:01,888
All this was default.

564
00:29:02,388 --> 00:29:05,018
So now it is, waiting for the
change set to be, created.

565
00:29:05,238 --> 00:29:09,368
So it will define all of the, so if
I show you here, so this template is

566
00:29:09,368 --> 00:29:10,638
going to define so many resources.

567
00:29:11,148 --> 00:29:16,048
That is a policy and, so here you can
see the resource type, IAM policy, Lambda

568
00:29:16,048 --> 00:29:21,358
permission, policy actual function and
the API gateway deployment and everything.

569
00:29:21,858 --> 00:29:24,098
So the create, now the
create is in progress.

570
00:29:24,488 --> 00:29:26,888
Now if we go to the cloud formation,

571
00:29:27,388 --> 00:29:30,278
so this is your stack that is in progress.

572
00:29:30,958 --> 00:29:34,088
So you can see the
various events happening.

573
00:29:34,588 --> 00:29:37,808
And once that is complete, you
will see it is create complete.

574
00:29:38,758 --> 00:29:41,038
So all of the resources are now deployed.

575
00:29:41,538 --> 00:29:48,218
And then just to test your API, you take
the, let's find out where that new API is.

576
00:29:48,718 --> 00:29:51,988
Actually when I did the recording,
today is, you can see the date on

577
00:29:51,988 --> 00:29:54,688
my computer, it is 28th February.

578
00:29:54,998 --> 00:29:57,078
So this is the latest one
that has been created.

579
00:29:57,228 --> 00:30:01,058
So I go into this and it
has created a DevStage.

580
00:30:01,558 --> 00:30:02,558
So if I go into this,

581
00:30:03,058 --> 00:30:07,328
So this is the invoke URL that
you have to use to call this API.

582
00:30:08,108 --> 00:30:09,488
So let's try

583
00:30:09,988 --> 00:30:16,118
a POST to this URL and we pass
the data as the events file.

584
00:30:16,618 --> 00:30:19,438
that we were using so far in our testing.

585
00:30:19,938 --> 00:30:22,998
So you can see that it is deployed
correctly and you are getting the

586
00:30:22,998 --> 00:30:24,948
response from the lambda function.

587
00:30:25,448 --> 00:30:28,088
All right, now we are
seeing how build works.

588
00:30:28,618 --> 00:30:31,488
So build what it does is quickly
at each of your resource,

589
00:30:31,488 --> 00:30:33,928
mainly the lambda function.

590
00:30:34,258 --> 00:30:37,838
It will package your dependencies
and code, and even there is

591
00:30:37,838 --> 00:30:39,058
a concept of Lambda layers.

592
00:30:39,468 --> 00:30:41,658
In the interest of time,
I'm not going into that.

593
00:30:41,998 --> 00:30:45,898
But if you have like different layers, you
have to finally create a package of it.

594
00:30:46,228 --> 00:30:49,398
And that's what SamBuild
is going to help you with.

595
00:30:50,338 --> 00:30:53,278
And after that, we are
going to see about SamSync.

596
00:30:53,778 --> 00:30:58,738
So SamSync is something where you can, you
have your deployment, initial deployment.

597
00:30:59,238 --> 00:31:03,978
And then you sync just your, code,
a piece of it into your resources

598
00:31:04,178 --> 00:31:05,728
without doing an actual deployment.

599
00:31:05,998 --> 00:31:08,928
So this is fine for an, for a
development environment, but

600
00:31:08,928 --> 00:31:10,988
do not do it in production.

601
00:31:11,288 --> 00:31:13,958
Use proper pipelines and
deployment methods when

602
00:31:13,958 --> 00:31:15,158
you're doing it in production.

603
00:31:15,518 --> 00:31:18,128
But when you are testing, but you
want to keep changing the code and

604
00:31:18,128 --> 00:31:22,808
pushing it into a test or a development
environment, then Samsung can be useful.

605
00:31:23,308 --> 00:31:28,298
So now actually to see how Samsung works
and where it is really useful, I want to

606
00:31:28,298 --> 00:31:31,408
now shift the focus to the second team,
which is the business application team,

607
00:31:31,848 --> 00:31:35,878
where if you see from the front end, we
just checked on how, the Lambda function

608
00:31:35,908 --> 00:31:37,708
emits the events into the event bridge.

609
00:31:38,088 --> 00:31:40,558
So from the event bridge, there
are various rules I mentioned

610
00:31:40,608 --> 00:31:43,648
and the summary event, which we
have been discussing so far, it

611
00:31:43,648 --> 00:31:45,788
actually goes into a step function.

612
00:31:46,358 --> 00:31:49,768
So step function, as it has
like various tasks and it has

613
00:31:49,768 --> 00:31:51,878
a workflow needs to be defined.

614
00:31:52,338 --> 00:31:57,098
So how can we like easily do the, step
functions for deployment and, samsync

615
00:31:57,148 --> 00:32:00,568
actually can be very useful, in, in
that, as I mentioned, it creates a

616
00:32:00,638 --> 00:32:05,058
temporary layer and it syncs, your,
code into your Lambda function,

617
00:32:05,068 --> 00:32:08,368
which without an actual deployment
or a stack implementation going on.

618
00:32:09,318 --> 00:32:13,978
how we can, use, make use of that mainly
in, step functions and also in the open

619
00:32:13,978 --> 00:32:16,278
API, specification that we just saw.

620
00:32:16,738 --> 00:32:20,678
So let's say you have a initial
step function or a API gateway

621
00:32:20,678 --> 00:32:23,808
deployment with an, and we will
just talk about step functions now.

622
00:32:24,068 --> 00:32:28,028
So let's say you have like just one state,
in your, workflow and you have deployed

623
00:32:28,028 --> 00:32:31,878
it and then you create, the further,
steps and then you want to push it and

624
00:32:31,878 --> 00:32:33,338
see how it updates in your, console.

625
00:32:33,768 --> 00:32:37,358
If that's their aim, then
SAMSYNC can be very useful.

626
00:32:37,858 --> 00:32:39,888
Okay, looking into the step functions now.

627
00:32:40,068 --> 00:32:44,418
So far we have been talking about how
local development helps you a lot.

628
00:32:44,808 --> 00:32:49,518
But step function is that one service,
which is easier to get started with on the

629
00:32:49,518 --> 00:32:54,568
build within the console because it has
got a very nice visual experience where

630
00:32:54,568 --> 00:32:59,778
you can drag and drop services into your
workflow and configure your parameters.

631
00:33:00,408 --> 00:33:03,098
So this is our step function
in the demo that we are, using.

632
00:33:03,168 --> 00:33:06,478
So if you see, it is getting
the session abstract using the

633
00:33:06,538 --> 00:33:08,038
title from a DynamoDB table.

634
00:33:08,338 --> 00:33:12,158
And it is invoking, Bedrock and,
passing output of, the, Bedrock

635
00:33:12,158 --> 00:33:14,068
model into again an event bridge.

636
00:33:14,388 --> 00:33:17,118
And then we have, same thing
for, the thanks node generation.

637
00:33:17,528 --> 00:33:20,518
and then there is a process like,
it can repeat, wait for the user

638
00:33:20,518 --> 00:33:21,938
input and, repeat the same thing.

639
00:33:22,168 --> 00:33:23,768
That's why you see the
looping, process in here.

640
00:33:24,073 --> 00:33:30,713
So once you do this visually and
get this workflow created, then

641
00:33:30,713 --> 00:33:35,133
it is easier to take that code
into your SAM template rather than

642
00:33:35,133 --> 00:33:37,063
building everything from the scratch.

643
00:33:37,393 --> 00:33:40,463
So this is the design
of the visual studio.

644
00:33:40,813 --> 00:33:41,993
So there's a code part here.

645
00:33:42,443 --> 00:33:45,923
So this gives, this is called something
called the Amazon state language or

646
00:33:45,923 --> 00:33:49,983
the ASL is again a, yeah, my love,
sorry, Jason, if you are noticing.

647
00:33:50,573 --> 00:33:53,703
So you can copy this whole
thing and put it into the file.

648
00:33:54,163 --> 00:33:56,923
So when I put it into a file,
it looks something like this.

649
00:33:57,223 --> 00:33:59,233
So I have it, in my project folder.

650
00:33:59,993 --> 00:34:03,333
So if you notice, I am now coming
to a different folder, which is a TB

651
00:34:03,783 --> 00:34:08,803
project space, and which is having a
separate template YAML file as well.

652
00:34:09,663 --> 00:34:12,393
So this is the full ASL
of the step function.

653
00:34:12,783 --> 00:34:17,363
But let's start with a smaller one,
with just one, pass task, just to

654
00:34:17,373 --> 00:34:18,373
see how it is getting deployed.

655
00:34:18,813 --> 00:34:20,843
So this is our, a l do J file.

656
00:34:21,203 --> 00:34:22,253
And this is the template file.

657
00:34:22,283 --> 00:34:24,983
So in that template file, I
have defined the resource.

658
00:34:25,073 --> 00:34:28,633
So this is the construct for, defining
the, step function or the state machine.

659
00:34:29,083 --> 00:34:33,023
And similar to the, API gateway
definition, URI, you'll have a

660
00:34:33,023 --> 00:34:36,593
definition URI, where you will give
the location of your a SL file.

661
00:34:37,283 --> 00:34:40,048
And then you are giving the role of
the state function and, and the policy.

662
00:34:40,758 --> 00:34:44,048
So the policy, as you had seen,
it needs policy or permission

663
00:34:44,078 --> 00:34:48,578
to call bedrock models, DynamoDB
table and all that is defined here.

664
00:34:49,238 --> 00:34:53,248
So I'm going to try to build this,
template and then deploy this.

665
00:34:53,748 --> 00:34:54,768
So the build is complete.

666
00:34:55,278 --> 00:34:57,068
Now I'm going to, deploy this.

667
00:34:57,568 --> 00:35:01,058
So again, it will create a,
CloudFormation, stack and it will

668
00:35:01,058 --> 00:35:02,168
get deployed in your, account.

669
00:35:02,168 --> 00:35:06,508
And So I have run this previously so
it is saying, it is going to modify the

670
00:35:06,508 --> 00:35:11,308
state machine as per, my, sorry, yes,
as per the changes that I have done.

671
00:35:12,028 --> 00:35:16,128
So right now this is this one, step
that we are going to deploy and, it

672
00:35:16,128 --> 00:35:17,388
is getting successfully deployed.

673
00:35:17,618 --> 00:35:21,408
So now if I go to the state
machine, I exit this one,

674
00:35:21,908 --> 00:35:24,638
yeah, let's see, yeah,
I think this is the one.

675
00:35:25,138 --> 00:35:27,128
If I edit, it should have only one state.

676
00:35:27,628 --> 00:35:31,318
And this file has got the full
step function with all the states.

677
00:35:31,798 --> 00:35:35,688
So I will put the name
of this JSON in here.

678
00:35:36,188 --> 00:35:37,288
Or let's do the other way around.

679
00:35:37,888 --> 00:35:39,308
We copy this one.

680
00:35:39,808 --> 00:35:42,400
And put it here.

681
00:35:42,400 --> 00:35:45,628
And do the same thing.

682
00:35:46,128 --> 00:35:48,188
So what has happened is it has
completed a build on its own.

683
00:35:48,638 --> 00:35:49,728
And it has synced to the code.

684
00:35:50,228 --> 00:35:54,858
So if I go to the step functions
now, go and edit, now we should

685
00:35:54,858 --> 00:35:58,238
see the full step functions from
that one state updated immediately.

686
00:35:58,808 --> 00:36:03,078
So in this way you can, once you have
the full workflow from the studio,

687
00:36:03,628 --> 00:36:10,238
then you can sync up the code and
get it deployed in a very easy way.

688
00:36:10,238 --> 00:36:13,898
And now to show you how the step
function is actually invoked,

689
00:36:14,198 --> 00:36:15,648
let's do a SAM locally invoke.

690
00:36:15,648 --> 00:36:17,458
Now I'm back to the team A app one.

691
00:36:17,868 --> 00:36:21,908
And we are doing that API invocation
to the lambda which publishes

692
00:36:21,908 --> 00:36:23,598
the event in the event bridge.

693
00:36:23,608 --> 00:36:24,428
So back to that.

694
00:36:24,428 --> 00:36:27,388
So if we do that again once
more, it is giving an output.

695
00:36:27,578 --> 00:36:30,468
So what it is actually doing is, is
publishing an event into the event bridge.

696
00:36:30,798 --> 00:36:34,618
So if I go into the, event bridge, so if
you see this is the event bridge rules

697
00:36:35,218 --> 00:36:39,688
and this is the event bus, so we have
various rules set up and the rule, which

698
00:36:39,688 --> 00:36:41,953
matches this event is the summary input.

699
00:36:42,293 --> 00:36:45,533
So event pattern is something like
this where the event type is summary.

700
00:36:46,323 --> 00:36:49,213
So in here the target is a
step function state machine.

701
00:36:49,793 --> 00:36:55,393
So if I open this state machine now,
you can see that has been invoked by

702
00:36:55,393 --> 00:37:01,063
the event bridge and you have this
one execution in running status.

703
00:37:01,553 --> 00:37:05,923
So if I open that, whatever in green
is what is the completed states.

704
00:37:05,943 --> 00:37:08,013
So it gets the input
from the event bridge.

705
00:37:08,428 --> 00:37:14,043
And, it fetches the, abstract from the
Rhine Modi table using the session title.

706
00:37:14,043 --> 00:37:15,975
so you can see the input
and output in here.

707
00:37:15,975 --> 00:37:19,535
So the input is the actual,
JSON, which is having the data,

708
00:37:19,685 --> 00:37:21,665
summary, and your, session title.

709
00:37:22,335 --> 00:37:27,405
So then it creates a prompt in the next
step, to be, passed to the Bedrock model.

710
00:37:27,955 --> 00:37:30,950
So it is passed to the, Bedrock
Anthropic Class 3 model.

711
00:37:31,890 --> 00:37:35,170
So the prompt is this, write a short
and concise summary of the session

712
00:37:35,200 --> 00:37:40,860
titled so and you get a model response
as a session focuses on optimizers

713
00:37:40,900 --> 00:37:45,030
and this is what is displayed as the
final summary in the front end screen.

714
00:37:45,780 --> 00:37:49,540
So the execution is in pause
now as you can see because

715
00:37:49,540 --> 00:37:50,570
it is waiting for user input.

716
00:37:50,930 --> 00:37:54,290
Remember the demo, we did this one
summary and then we had a second

717
00:37:54,290 --> 00:37:55,750
step for creating a thank you note.

718
00:37:55,970 --> 00:37:57,170
So you are giving some feedback.

719
00:37:57,500 --> 00:38:00,450
So the step function is designed in
such a way that it awaits and resumes.

720
00:38:00,820 --> 00:38:02,340
When, the next set of input comes in.

721
00:38:02,730 --> 00:38:04,860
So I'm not going to the detail
of those, design, but it's a

722
00:38:04,860 --> 00:38:06,140
very interesting one to, look at.

723
00:38:06,640 --> 00:38:10,740
So we have seen about SAM sync
and also about, SAM deploy and

724
00:38:10,780 --> 00:38:11,850
the differences between them.

725
00:38:12,660 --> 00:38:17,060
so far we have seen about the local
environments and how it can help

726
00:38:17,270 --> 00:38:21,790
developers and testers, to progress
the, serverless application with speed.

727
00:38:22,510 --> 00:38:27,630
So though you can use SAM deploy to
put your resources in any environment,

728
00:38:28,100 --> 00:38:32,690
there needs to be some governance and
control over who deploys what and where.

729
00:38:33,370 --> 00:38:37,820
So when you have like various
teams doing various parts of the

730
00:38:38,100 --> 00:38:42,660
application, you need to have an
oversight on how this can be managed.

731
00:38:42,960 --> 00:38:47,220
So that's where the proper continuous
integration and continuous deployment,

732
00:38:47,270 --> 00:38:49,230
the CICD methods comes in handy.

733
00:38:49,730 --> 00:38:52,750
and also, so we were talking about
like various teams maintaining

734
00:38:52,750 --> 00:38:53,940
their own, templates, right?

735
00:38:54,150 --> 00:38:58,180
So one good framework or model could
be having a nester stack that is, each

736
00:38:58,180 --> 00:39:01,860
team has their own employee, template
and deploys them in their own, local

737
00:39:01,860 --> 00:39:04,645
environments or, within the AWS accounts.

738
00:39:04,735 --> 00:39:07,015
and then when it comes to higher
environment like integration testing,

739
00:39:07,525 --> 00:39:10,645
there may be a central team who takes
control, modules these templates

740
00:39:10,645 --> 00:39:13,860
into a main template and then
deploys it into one, environment.

741
00:39:14,560 --> 00:39:18,120
So how do we do it, do those kind
of deployment in a very streamlined

742
00:39:18,120 --> 00:39:19,960
way is where we use SAM pipeline.

743
00:39:20,700 --> 00:39:26,440
So SAM pipeline is the way to, as an
abstraction over your CICD process.

744
00:39:26,830 --> 00:39:31,700
So it has the ability to integrate
with the CICD systems like AWS core

745
00:39:31,700 --> 00:39:36,150
pipeline and also third party systems
like GitLab, Jenkins and Bitbucket.

746
00:39:36,650 --> 00:39:39,120
So let's take, GitHub as an
example, which is what we will

747
00:39:39,120 --> 00:39:40,710
see in the demonstration as well.

748
00:39:41,080 --> 00:39:46,190
So if the, developers are pushing
their code into a GitHub repo, how do

749
00:39:46,190 --> 00:39:50,320
you set up a workflow, from the GitHub
repo to be deployed, the resources to

750
00:39:50,320 --> 00:39:52,470
be deployed into your, AWS accounts?

751
00:39:52,470 --> 00:39:55,060
So there can be a staging account, there
can be a different production account.

752
00:39:55,280 --> 00:39:58,650
You can set up your pipeline in such a way
that it first goes into a staging account.

753
00:39:59,250 --> 00:40:02,370
And maybe you set up a flag for a
manual approval and then it goes into

754
00:40:02,460 --> 00:40:05,530
a production pool, or you can have a
fully automated, pipeline, as well.

755
00:40:06,340 --> 00:40:10,720
So this is a normal CACD process, but
how does Sam makes it easier is, using

756
00:40:10,720 --> 00:40:12,490
this bootstrap step, first of all.

757
00:40:12,910 --> 00:40:17,850
So when you use a boots strap for a
ritual, CACD, process that you use, what

758
00:40:17,850 --> 00:40:22,570
you need is the necessary permission and
rules for allowing, the tool to go and

759
00:40:22,570 --> 00:40:24,430
do the deployment in your, AWS account.

760
00:40:25,085 --> 00:40:29,605
SAM pipeline bootstrap will take that,
role and create necessary, resources,

761
00:40:29,705 --> 00:40:33,615
which is the buckets into which the
code has to go into and the necessity

762
00:40:33,615 --> 00:40:37,655
cloud formation and, pipeline execution
roles in each of your, deployment,

763
00:40:37,675 --> 00:40:41,405
accounts will be automatically created
by the SAM pipeline, bootstrap.

764
00:40:42,125 --> 00:40:46,555
And after that, it will also create the
workflow file, which needs, which has

765
00:40:46,565 --> 00:40:52,255
all the information to pull the, changes
from your, repo like GitHub or, GitLab

766
00:40:52,865 --> 00:40:57,285
and pushes that changes into the staging
and production or how many other stages

767
00:40:57,305 --> 00:40:58,985
that you have deployed in your, pipeline.

768
00:40:59,515 --> 00:41:00,575
So this is the concept.

769
00:41:00,775 --> 00:41:04,435
We will see a quick demonstration of this
before, closing the session for today.

770
00:41:04,935 --> 00:41:08,555
Let's do a SAM pipeline in it, with the
bootstrap command so that we can set

771
00:41:08,555 --> 00:41:10,135
up the pipeline in an interactive way.

772
00:41:10,625 --> 00:41:13,265
So we choose a pipeline template,
as I mentioned, there are five

773
00:41:13,275 --> 00:41:14,895
different CICD systems supported.

774
00:41:15,295 --> 00:41:18,095
We are going to choose
GitHub actions as an example.

775
00:41:18,645 --> 00:41:19,985
do you want to set up now?

776
00:41:19,995 --> 00:41:21,895
If you choose no, it gets
to reference other bitmaps.

777
00:41:22,315 --> 00:41:23,515
We will set it up.

778
00:41:24,015 --> 00:41:25,155
So give the stage name.

779
00:41:25,455 --> 00:41:26,645
So you're giving it as, a div.

780
00:41:27,145 --> 00:41:30,785
And then we are using your role,
which can be used to go and deploy

781
00:41:30,785 --> 00:41:34,165
the resources in the AWS accounts.

782
00:41:35,035 --> 00:41:38,185
So I'm using this two default
option because I have a profile

783
00:41:38,185 --> 00:41:41,105
in this IDE, which has the
ability to connect to the account.

784
00:41:41,545 --> 00:41:44,285
And, I'm going to deploy both
stages like development and

785
00:41:44,425 --> 00:41:45,445
production in the same account.

786
00:41:45,865 --> 00:41:48,375
But when you're setting this up,
if you give two different, roles,

787
00:41:48,705 --> 00:41:50,015
then, or two different profiles.

788
00:41:50,600 --> 00:41:54,996
That will be used by the pipeline to
go and assume that role and deploy

789
00:41:54,996 --> 00:41:58,820
the resources in each of the account.

790
00:41:58,820 --> 00:42:02,020
And enter the region and default is IAM.

791
00:42:02,520 --> 00:42:07,546
And all of this IAM user, you
need not create, this will be

792
00:42:07,546 --> 00:42:08,900
automatically created by the pipeline.

793
00:42:08,970 --> 00:42:13,640
So pipeline execution role, CloudFormation
execution role and the bucket artifact.

794
00:42:14,050 --> 00:42:16,150
And this one you have to give
n because we are not doing

795
00:42:16,150 --> 00:42:17,310
an image write plan function.

796
00:42:17,900 --> 00:42:21,970
And it will ask for to summarize whether
you are okay with creating all this.

797
00:42:21,970 --> 00:42:22,560
Yes.

798
00:42:23,060 --> 00:42:27,520
So after it has set up the development
stage, it is going to ask the same

799
00:42:27,530 --> 00:42:28,960
set of parameters for the next stage.

800
00:42:28,970 --> 00:42:30,340
So you can do more stages if you want.

801
00:42:30,380 --> 00:42:32,610
In this one, we are showing two
stages, development and product.

802
00:42:33,040 --> 00:42:35,930
And if you see it has created the
access key and secret access key.

803
00:42:36,150 --> 00:42:39,720
This is an important parameter which
has to be set up in your, GitHub.

804
00:42:40,215 --> 00:42:43,025
repository for this workflow to, work.

805
00:42:43,055 --> 00:42:44,915
So say you have to save
this in a safe place.

806
00:42:45,035 --> 00:42:46,715
And now we go into the second stage.

807
00:42:47,105 --> 00:42:52,715
So for this name, we give us pro and,
choose the, rule all the default,

808
00:42:52,795 --> 00:42:59,145
rule creations, no for image type
and confirm the above values.

809
00:42:59,565 --> 00:43:00,825
Should we proceed with creation?

810
00:43:00,825 --> 00:43:01,485
Yes.

811
00:43:01,985 --> 00:43:05,675
Again, this will take some time,
so while it is progressing,

812
00:43:05,685 --> 00:43:08,265
let's go to the GitHub repo.

813
00:43:08,465 --> 00:43:13,945
I have created a repo called com42cloud
and here go to the settings and

814
00:43:14,195 --> 00:43:15,905
secrets and variables in actions.

815
00:43:16,365 --> 00:43:23,585
Create a new repository secret, for this,
you will create the access key ID and the

816
00:43:24,085 --> 00:43:24,665
Same way,

817
00:43:25,165 --> 00:43:31,505
do it for, the secret key and the value.

818
00:43:31,965 --> 00:43:32,565
So it's now added.

819
00:43:32,635 --> 00:43:34,845
Now go back to the, yeah.

820
00:43:35,345 --> 00:43:36,145
Shen is name.

821
00:43:36,525 --> 00:43:37,155
Complete file.

822
00:43:37,875 --> 00:43:39,005
so give a stack name.

823
00:43:39,015 --> 00:43:42,065
So we are giving team A dev pipeline.

824
00:43:42,065 --> 00:43:44,415
So that will be the stack name
for the development pipeline.

825
00:43:45,135 --> 00:43:49,255
And for the production, we will give it
as a team, sorry, team A prod pipeline.

826
00:43:49,755 --> 00:43:52,395
So we have created a dot
GitHub, workflow, file now.

827
00:43:52,685 --> 00:44:00,725
So if you go here, so workflow and
a pipeline, file created, here.

828
00:44:01,225 --> 00:44:03,775
So I have done an initial push
from the IDE to this, GitHub

829
00:44:03,775 --> 00:44:05,025
repo, so the team A app one.

830
00:44:05,025 --> 00:44:08,825
So you can find all of the, resources
from the, app one folder in here.

831
00:44:09,110 --> 00:44:09,140
Okay.

832
00:44:09,410 --> 00:44:16,790
Now, if I go into the, IDE and make
some changes here, push, let's say, and

833
00:44:16,790 --> 00:44:22,950
then add that change and do a commit and

834
00:44:23,450 --> 00:44:24,130
do a push.

835
00:44:24,630 --> 00:44:29,585
So now the, not just the
changes would Pushed in here.

836
00:44:29,855 --> 00:44:33,460
But if you go to actions, you would
see a pipeline in here getting started.

837
00:44:33,970 --> 00:44:36,520
So it is in the test start, then
it'll go into build and package.

838
00:44:36,730 --> 00:44:40,610
It'll, deploy and, an integration
test and then go into Deploy and Pro.

839
00:44:40,970 --> 00:44:44,360
So this step deploy test, when it
is completed, you will see one stack

840
00:44:44,450 --> 00:44:46,470
getting, created in the cloud formation.

841
00:44:47,280 --> 00:44:51,590
So something like this app one, and,
Sorry, like this, team A development

842
00:44:51,590 --> 00:44:53,410
pipeline and team A production pipeline.

843
00:44:53,910 --> 00:44:57,250
So after each of this is completed, you
will get the stacks deployed into that.

844
00:44:58,210 --> 00:45:01,980
And this one, where you see the build
and deploy feature is when you submit

845
00:45:02,080 --> 00:45:04,580
any changes into a feature branch.

846
00:45:05,130 --> 00:45:07,910
So that will get deployed
as a separate pipeline.

847
00:45:08,480 --> 00:45:12,990
And, when you merge and, do a pull
request, from the feature branch into

848
00:45:12,990 --> 00:45:16,140
your main branch, then it will get
sucked into your, actual, testing

849
00:45:16,150 --> 00:45:17,799
environment and, production environment.

850
00:45:18,679 --> 00:45:20,009
So this is now the build is complete.

851
00:45:20,279 --> 00:45:22,309
Then, the deploy is for
the testing has started.

852
00:45:22,499 --> 00:45:25,229
So you should be ideally
seeing, stack in here, soon.

853
00:45:25,729 --> 00:45:30,189
So while that is, happening, let's go
back and do a feature, branch, commit.

854
00:45:30,689 --> 00:45:35,519
let me check out into a branch called
Feature 1 and I will do another

855
00:45:35,519 --> 00:45:39,719
change, testing feature branch, yeah,

856
00:45:40,219 --> 00:45:41,359
and add this,

857
00:45:41,859 --> 00:45:49,329
Feature 1, commit this, and you push
this into the feature one branch.

858
00:45:49,829 --> 00:45:53,859
So when you do this one, so this
pipeline is already deploying.

859
00:45:54,469 --> 00:45:57,829
but there should be another
testing feature one branch that

860
00:45:57,829 --> 00:46:03,269
is created here, which will get
deployed as a separate pipeline.

861
00:46:03,269 --> 00:46:08,919
So now if I go into the CloudFormation
stack, so you can see that the team A

862
00:46:08,969 --> 00:46:12,749
development pipeline One is completed,
development pipeline is completed

863
00:46:13,099 --> 00:46:14,919
and the prod pipeline is in progress.

864
00:46:15,209 --> 00:46:17,739
So why this you are seeing it as
an update is, I was testing it

865
00:46:17,749 --> 00:46:18,869
out since yesterday on and on.

866
00:46:19,119 --> 00:46:21,389
So it is going and updating
it in the, same stack.

867
00:46:21,459 --> 00:46:23,589
Otherwise you would have seen
it as a create in progress.

868
00:46:24,449 --> 00:46:24,769
Okay.

869
00:46:24,789 --> 00:46:31,629
So the, let's go back and see
the, testing feature branch.

870
00:46:32,129 --> 00:46:35,819
So I have this done in, Another repo,
I will show you that in the interest of

871
00:46:35,829 --> 00:46:37,229
time, let's not wait for the other one.

872
00:46:37,669 --> 00:46:40,549
So if you see when you are testing
feature branch, it will go into

873
00:46:40,549 --> 00:46:42,499
this path and get deployed.

874
00:46:42,999 --> 00:46:47,539
And after that, when you do a pull
request, it will then pull the

875
00:46:47,539 --> 00:46:50,689
changes from the feature branch into
the main branch and get deployed.

876
00:46:51,189 --> 00:46:54,779
So we can do the pull request after
the feature branch is completed.

877
00:46:55,279 --> 00:46:58,669
So as you see the feature one,
it's now an update in, progress.

878
00:46:59,169 --> 00:47:03,049
So it is like separate set of resources
created for each of the, pipeline.

879
00:47:03,539 --> 00:47:05,339
so that we do, since we are
doing it in the same account,

880
00:47:05,639 --> 00:47:06,699
there will be, duplicate.

881
00:47:06,999 --> 00:47:10,909
But when you do it in, in a particular
example, you'll be doing it with different

882
00:47:10,909 --> 00:47:14,509
roles and in different AWS accounts
and maybe with also, checkpoints.

883
00:47:14,884 --> 00:47:17,704
of, not to just directly go into
production, you might have some

884
00:47:17,754 --> 00:47:20,724
testing, which is like automated
testing or manual testing followed

885
00:47:20,734 --> 00:47:24,304
by approval and then going into
production, the usual CICB, process.

886
00:47:25,304 --> 00:47:27,674
So now the, feature one is, completed.

887
00:47:28,054 --> 00:47:33,244
And now if I go here and do a, pull
request, create a new pull request.

888
00:47:33,744 --> 00:47:34,984
So I'm doing this, feature one.

889
00:47:35,484 --> 00:47:36,944
so this is the change that I have, made.

890
00:47:37,229 --> 00:47:41,589
Okay, create pull request,
confirm, create pull request, okay.

891
00:47:42,259 --> 00:47:43,069
And you are now merging.

892
00:47:43,569 --> 00:47:48,839
So now once you merge, automatically in
the actions, you should be seeing another

893
00:47:48,839 --> 00:47:54,269
pipeline triggered where it is going to
start the test and it is going to do this

894
00:47:54,269 --> 00:47:56,389
flow this time and put it in production.

895
00:47:56,889 --> 00:48:00,849
I'm not going to wait for this to
complete, but hope you get the idea of

896
00:48:00,849 --> 00:48:05,599
how these pipelines can be combined with
some ham pipeline and, HOPs has been

897
00:48:05,599 --> 00:48:10,729
useful to you in, seeing how you maintain,
your SAM environment and templates

898
00:48:10,739 --> 00:48:12,509
for different teams independently.

899
00:48:13,399 --> 00:48:17,629
And, use SAM to, not only deploy,
infrastructure code, but use it as a CLI

900
00:48:17,629 --> 00:48:22,369
as well to, for your local, building,
testing and, testing your deployments.

901
00:48:22,429 --> 00:48:25,449
And then finally, if you are
in a DevOps role, use pipelines

902
00:48:25,459 --> 00:48:26,839
to, deploy them together.

903
00:48:27,069 --> 00:48:30,559
So this really speeds up the way that
you build a serverless application.

904
00:48:30,839 --> 00:48:33,859
And as you can see, the serverless
landscape is a huge, so there

905
00:48:33,859 --> 00:48:37,099
are so many other services in the
AWS landscape that you can use.

906
00:48:37,804 --> 00:48:41,014
And, you can bring everything
under the, SAM template and,

907
00:48:41,014 --> 00:48:42,014
speed up your deployment.

908
00:48:42,084 --> 00:48:44,684
And when you are bringing it in
the pipeline, you're, you're just

909
00:48:44,684 --> 00:48:47,484
bringing everything into the,
deployment phase very easily.

910
00:48:48,284 --> 00:48:51,324
And also if you see this architecture
why I had chosen is to demonstrate

911
00:48:51,324 --> 00:48:52,814
the fully event driven mechanism.

912
00:48:53,174 --> 00:48:57,054
and in this part we didn't see that
is, the image generation, so that is

913
00:48:57,054 --> 00:49:00,714
maybe an extra feature set that, your
application can have and, deploy.

914
00:49:01,214 --> 00:49:03,634
I want to end with giving
you some, useful resources.

915
00:49:03,864 --> 00:49:07,644
So this serverless LAN patterns contains
a lot of, starter packs, and there's a

916
00:49:07,644 --> 00:49:11,574
SAM template with different run times in,
in Python, TypeScript, Java, et cetera.

917
00:49:11,794 --> 00:49:15,354
You can just, clone those, GitHub
repos and, and have a serverless,

918
00:49:15,384 --> 00:49:18,304
like if you want to have even bridge
triggering, step functions, there is

919
00:49:18,304 --> 00:49:19,574
a pattern for that which you can use.

920
00:49:19,874 --> 00:49:21,689
The next one is, YouTube series.

921
00:49:21,929 --> 00:49:24,869
from one of our senior developer
advocate, his name is Eric Johnson.

922
00:49:25,199 --> 00:49:28,889
So this is a series of, YouTube
videos, each one going in depth and

923
00:49:28,899 --> 00:49:32,199
going into a hands on session, to
explain about each of the SAM feature.

924
00:49:32,509 --> 00:49:35,139
So if you want to like, really get
started with, SAM and know about

925
00:49:35,179 --> 00:49:38,089
each of its features in detail,
this is a very good, YouTube series.

926
00:49:38,589 --> 00:49:40,629
Thank you so much for
listening to me today.

927
00:49:41,279 --> 00:49:44,759
Connect with me on LinkedIn and keep
watching the space on my LinkedIn feed.

928
00:49:44,829 --> 00:49:50,889
I'm planning to put the app code and
the SAM code into a GitHub repo, so

929
00:49:50,889 --> 00:49:52,339
that you can have a try of your own.

930
00:49:52,829 --> 00:49:53,199
Thank you.

