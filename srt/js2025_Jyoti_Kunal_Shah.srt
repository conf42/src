1
00:00:00,500 --> 00:00:04,789
Hello everyone and thank you for
joining this Conative conference.

2
00:00:05,289 --> 00:00:10,480
I'm Juhi SHA IEEE, senior
member and director of

3
00:00:10,480 --> 00:00:12,579
Applications Development at a DP.

4
00:00:13,080 --> 00:00:19,430
Today we will explore how agent
ai, autonomous goal-driven

5
00:00:19,820 --> 00:00:22,250
software agents can coordinate.

6
00:00:23,165 --> 00:00:27,995
The continuous co-evolution of
microservices and micro frontend

7
00:00:28,495 --> 00:00:34,065
in cloud native architectures,
microservices give us scalability,

8
00:00:34,695 --> 00:00:37,605
resile, and independent deployments.

9
00:00:38,105 --> 00:00:43,945
Micro frontend extended those
principles to the UI leader, but the

10
00:00:43,945 --> 00:00:46,135
real challenge is synchronization.

11
00:00:46,635 --> 00:00:53,985
How do we keep dozens of independent teams
and components moving at different speeds

12
00:00:54,945 --> 00:00:57,555
without breaking the user experience?

13
00:00:58,055 --> 00:01:03,395
In this session, I will walk you
through the problem, the architecture

14
00:01:03,455 --> 00:01:08,635
of a agent control plane, a real
world case study and future directions

15
00:01:09,295 --> 00:01:11,695
that move software from automation.

16
00:01:12,195 --> 00:01:12,465
Omi,

17
00:01:12,965 --> 00:01:14,975
let's start with the foundation.

18
00:01:15,815 --> 00:01:21,655
The Morton architecture, landscape
microservices, decompose applications

19
00:01:22,255 --> 00:01:25,255
into independently deployable services.

20
00:01:25,755 --> 00:01:33,655
Each owns a business capability, for
example, payment catalog or user profile.

21
00:01:34,155 --> 00:01:37,815
And can scale or deploy independently.

22
00:01:38,315 --> 00:01:42,574
This improves resilience
and team autonomy.

23
00:01:43,074 --> 00:01:47,335
Now extend that same
principle to the UI layers.

24
00:01:47,835 --> 00:01:50,115
That's where micro frontends come in.

25
00:01:50,615 --> 00:01:56,824
Teams can deploy frontend
modules in React js Angular.

26
00:01:57,324 --> 00:02:00,054
And plug them into a shared container.

27
00:02:00,554 --> 00:02:07,444
This gives incredible speed and parallel
deployment, but as you will see, it

28
00:02:07,444 --> 00:02:10,294
also creates an integration nightmare.

29
00:02:10,794 --> 00:02:16,059
Each team has its own framework,
release cycle, and dependencies.

30
00:02:16,559 --> 00:02:22,124
So when one part of the system changes,
others must catch up instantly.

31
00:02:22,624 --> 00:02:24,514
And that's where things start to break.

32
00:02:25,014 --> 00:02:30,894
As systems grow, we enter what
I call the coordination crisis,

33
00:02:31,394 --> 00:02:34,114
API evolve new endpoints.

34
00:02:34,614 --> 00:02:42,384
Renamed Fields different responses,
structures, framework, heterogeneity teams

35
00:02:42,449 --> 00:02:49,309
use react, angular view independently,
manual bottlenecks, QA cycles,

36
00:02:50,189 --> 00:02:52,659
multiply rollbacks become routine.

37
00:02:53,159 --> 00:02:59,269
In large enterprise, you might
have 25 microservices and 10 micro

38
00:02:59,269 --> 00:03:02,949
frontends spread across multiple teams.

39
00:03:03,449 --> 00:03:08,449
Each change must be communicated,
tested, and synchronized.

40
00:03:08,949 --> 00:03:13,329
That coordination effort
grows exponentially.

41
00:03:13,829 --> 00:03:20,459
With every new component, the result,
frequent integration breaks, inconsistent

42
00:03:20,819 --> 00:03:28,899
UX and deployment slowdowns, even though
we moved to microservices to go faster.

43
00:03:29,399 --> 00:03:34,074
Let's zoom in on what I call
the moving target problem.

44
00:03:34,574 --> 00:03:39,364
Every time a backend service
evolves by adding a new

45
00:03:39,604 --> 00:03:42,074
endpoint, modifying a payload.

46
00:03:42,574 --> 00:03:45,334
Or changing latency profiles.

47
00:03:45,834 --> 00:03:51,164
The dependent micro front ends
must adapt almost immediately

48
00:03:51,664 --> 00:03:52,519
if they don't.

49
00:03:53,019 --> 00:03:57,769
Users see runtime mismatches,
broken interactions.

50
00:03:58,269 --> 00:04:00,970
Or sluggish experiences.

51
00:04:01,470 --> 00:04:08,585
So while our A architecture is
decentralized by design, its dependencies

52
00:04:09,575 --> 00:04:12,515
remain tightly coupled in practice.

53
00:04:13,015 --> 00:04:14,665
This is the core paradox.

54
00:04:15,165 --> 00:04:21,935
Of modern microservice ecosystems,
we have gained team autonomy,

55
00:04:22,435 --> 00:04:29,030
but we have also inherited a
constant chase to stay in sync.

56
00:04:29,530 --> 00:04:35,060
Enterprises running 25 plus microservices.

57
00:04:35,560 --> 00:04:41,580
10 plus micro front ends
phase a mathematical explosion

58
00:04:42,080 --> 00:04:43,910
of version combinations.

59
00:04:44,410 --> 00:04:49,270
That's why traditional coordination
models, emails, tickets,

60
00:04:49,770 --> 00:04:52,090
manual testing, can't keep up.

61
00:04:52,590 --> 00:04:53,315
We need systems.

62
00:04:53,815 --> 00:05:00,965
That can sense and respond
autonomously to this constant movement.

63
00:05:01,465 --> 00:05:05,390
So how do we bring order
to this moving target?

64
00:05:05,890 --> 00:05:08,430
The answer is agent ai.

65
00:05:08,930 --> 00:05:14,550
These are autonomous software
agents with three core capabilities,

66
00:05:15,050 --> 00:05:17,990
perception, reasoning, and action.

67
00:05:18,490 --> 00:05:23,130
They perceive the state
of the system monitoring.

68
00:05:23,945 --> 00:05:28,575
Backend APIs, frontend
matrix, and telemetry.

69
00:05:29,075 --> 00:05:37,145
The reason detect schema drift or
behavioral anomalies and plan adoption,

70
00:05:37,645 --> 00:05:38,079
they act.

71
00:05:38,579 --> 00:05:46,389
Apply validated changes with rollback
mechanism, if anything, violates policy.

72
00:05:46,889 --> 00:05:54,289
Essentially, we are teaching a
software to self-diagnose and

73
00:05:54,289 --> 00:05:58,104
self-heal just as autonomous vehicles.

74
00:05:58,914 --> 00:06:02,394
Perceive and navigate their environment.

75
00:06:02,894 --> 00:06:09,114
Urgent AI agents navigate
code and configuration changes

76
00:06:09,614 --> 00:06:11,894
to keep systems aligned.

77
00:06:12,394 --> 00:06:16,254
The Agentic control plane or a CP.

78
00:06:16,754 --> 00:06:21,824
Is the framework that
orchestrates these agents.

79
00:06:22,324 --> 00:06:24,244
It has four plates.

80
00:06:24,744 --> 00:06:30,834
The first one, observation plane
collects telemetry through open

81
00:06:30,834 --> 00:06:33,464
telemetry, API, gateway logs.

82
00:06:33,964 --> 00:06:35,644
Real user monitoring data.

83
00:06:36,144 --> 00:06:40,884
This is how the system sees itself.

84
00:06:41,384 --> 00:06:48,874
The second one, cognition Plane host the
AI Brains Reinforcement learning agents.

85
00:06:49,834 --> 00:06:53,344
Optimize scaling and configuration.

86
00:06:53,844 --> 00:06:59,424
LLM agents generate
code or config patches.

87
00:06:59,924 --> 00:07:04,294
Contract agents monitor schema capability.

88
00:07:04,794 --> 00:07:07,304
The third one, execution plane.

89
00:07:07,804 --> 00:07:15,934
Applies changes using GitHubs
pipelines and service mesh controllers.

90
00:07:16,434 --> 00:07:22,294
Support cannery and blue green
releases with automatic rollback.

91
00:07:22,794 --> 00:07:26,429
The fourth plane policy
and governance layer.

92
00:07:26,929 --> 00:07:34,229
Defines safety envelopes, approval
thresholds, and auditable logs.

93
00:07:34,729 --> 00:07:42,799
These four planes work together in a loop
of perception, reasoning, and action,

94
00:07:43,299 --> 00:07:46,659
continuously optimizing the system.

95
00:07:47,334 --> 00:07:48,294
In real time.

96
00:07:48,794 --> 00:07:54,584
Let's see how these comes
together in practice.

97
00:07:55,084 --> 00:07:57,464
So the first one is drift detection.

98
00:07:57,964 --> 00:08:04,914
The observation plane notices a
schema change, perhaps an API field.

99
00:08:05,414 --> 00:08:06,524
Has been renamed.

100
00:08:07,024 --> 00:08:10,114
The second one, impact Analysis.

101
00:08:10,614 --> 00:08:17,984
The cognition plane identifies which
UI components consume that field.

102
00:08:18,484 --> 00:08:23,114
The third one, solution
generation, the LLM agents.

103
00:08:23,624 --> 00:08:30,494
Suggest a minimal code diff or
adapter to restore capability.

104
00:08:30,994 --> 00:08:33,864
The fourth one, safe deployment.

105
00:08:34,364 --> 00:08:39,034
The execution plan deploys
it to cannery environment,

106
00:08:39,534 --> 00:08:43,074
the fifth one, validation and rollout.

107
00:08:43,574 --> 00:08:48,014
Service level objectives remains stable.

108
00:08:48,514 --> 00:08:50,674
The change is promoted.

109
00:08:51,174 --> 00:08:54,204
If not, it auto rolls back.

110
00:08:54,704 --> 00:09:01,234
What's important is that no human has
to manually coordinate these steps.

111
00:09:01,734 --> 00:09:02,209
They happen.

112
00:09:02,709 --> 00:09:04,899
Under governance automation.

113
00:09:05,399 --> 00:09:11,390
Here's a real enterprise
example to quantify the impact.

114
00:09:11,890 --> 00:09:17,880
A global e-commerce organization
with 25 microservices and

115
00:09:17,880 --> 00:09:20,355
10 micro front ends adopted.

116
00:09:20,855 --> 00:09:22,715
Agent control plane

117
00:09:23,215 --> 00:09:30,205
before A-C-P-A-P-I changes
regularly, broke front ends

118
00:09:30,895 --> 00:09:32,785
and caused deployment delays

119
00:09:33,285 --> 00:09:34,290
after deployment.

120
00:09:34,790 --> 00:09:39,560
Adaptation latency improved by 35%.

121
00:09:40,060 --> 00:09:44,320
Front-end errors dropped by 40%.

122
00:09:44,820 --> 00:09:54,020
SLO compliance rose to 25% manual
coordination reduced to 50%.

123
00:09:54,520 --> 00:09:58,780
In other words, they moved
from reactive fixing.

124
00:09:59,665 --> 00:10:07,665
To proactive autonomous alignment with
traceable audit logs for every action.

125
00:10:08,165 --> 00:10:13,705
Let's balance the discussion
with both benefit and challenges

126
00:10:14,205 --> 00:10:15,735
the strategic benefits.

127
00:10:16,235 --> 00:10:22,305
Continuous synchronization between
backend and front end, reduced

128
00:10:22,425 --> 00:10:25,215
downtime through auto rollback.

129
00:10:25,715 --> 00:10:30,565
Explainable auto decisions
are logged and auditable.

130
00:10:31,065 --> 00:10:35,295
Enterprise scalability across frameworks.

131
00:10:36,135 --> 00:10:38,645
Teams, what are the challenges?

132
00:10:39,145 --> 00:10:44,834
Training overhead for re
enforcement learning needs.

133
00:10:45,165 --> 00:10:47,175
Quality telemetry.

134
00:10:47,675 --> 00:10:53,089
Trust building for LLM
generated code, it requires.

135
00:10:53,854 --> 00:10:56,254
Sandbox validation.

136
00:10:56,754 --> 00:10:58,284
Complex governance.

137
00:10:58,784 --> 00:11:05,074
We must define policies that
balance freedom and safety.

138
00:11:05,574 --> 00:11:10,824
This is where the human
element remains essential.

139
00:11:11,324 --> 00:11:13,124
AI augment stream.

140
00:11:13,624 --> 00:11:15,694
Not replaces them.

141
00:11:16,194 --> 00:11:24,239
Looking ahead, this convergence of
microservices, micro front ends and

142
00:11:24,239 --> 00:11:27,854
agentic AI is just the beginning.

143
00:11:28,354 --> 00:11:30,544
Three areas stand out.

144
00:11:31,044 --> 00:11:36,914
Explainable reinforcement learning,
ensuring that the reason behind

145
00:11:36,944 --> 00:11:42,714
every agent action is transparent
knowledge graphs, mapping

146
00:11:42,714 --> 00:11:49,769
dependencies across services and UIs
to predict drift before it occurs.

147
00:11:50,269 --> 00:11:51,049
Federated learning.

148
00:11:51,549 --> 00:11:56,319
Allowing different teams to
share adaptation strategies

149
00:11:56,819 --> 00:12:00,329
without exposing sensitive data.

150
00:12:00,829 --> 00:12:07,779
Our goal is not just to automate,
but to create systems that learn

151
00:12:08,319 --> 00:12:11,499
and govern themself responsibly.

152
00:12:11,999 --> 00:12:18,409
To wrap up, the agent control
plane proves that autonomous

153
00:12:18,409 --> 00:12:21,789
coordination is not science fiction.

154
00:12:22,289 --> 00:12:27,149
It's already improving
enterprise reliability today.

155
00:12:27,649 --> 00:12:36,344
By embedding AI agents that perceive
reason and act under governance, we

156
00:12:36,344 --> 00:12:43,599
enable continuous co-evolution between
microservices and micro front ends.

157
00:12:44,099 --> 00:12:48,209
This is the next step
in the DevOps journey

158
00:12:48,709 --> 00:12:51,524
from automation to omi.

159
00:12:52,024 --> 00:12:55,894
Thank you for your attention
and for being part of the future

160
00:12:55,954 --> 00:12:58,744
of cloud native engineering.

