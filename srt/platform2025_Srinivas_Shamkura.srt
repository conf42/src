1
00:00:00,500 --> 00:00:01,070
Hello everyone.

2
00:00:01,340 --> 00:00:02,230
This is Shankar.

3
00:00:02,550 --> 00:00:06,060
I'm here to present my topic on
the Platform Engineers Hidden

4
00:00:06,060 --> 00:00:10,350
Network Challenge, especially
to talk about the multicast in

5
00:00:10,350 --> 00:00:12,120
the cloud native environments.

6
00:00:12,620 --> 00:00:17,059
Traditionally the multicast is proven
to reduce the bandwidth consumption

7
00:00:17,659 --> 00:00:21,599
in the the on-prem environments,
but the major cloud providers.

8
00:00:21,974 --> 00:00:25,484
Most of them don't
natively support multicast.

9
00:00:25,544 --> 00:00:30,475
So I'm gonna be talking about the
pros and cons of multicast and some

10
00:00:30,475 --> 00:00:35,265
of the alternate options that could
potentially be implemented within

11
00:00:35,265 --> 00:00:36,975
the the cloud native environments.

12
00:00:37,475 --> 00:00:40,695
So when I say multicast
what exactly it means?

13
00:00:40,765 --> 00:00:44,785
It's replicating the same
data to multiple recipients.

14
00:00:44,785 --> 00:00:51,805
So since the data and the same data
is being received by the multiple

15
00:00:51,874 --> 00:00:54,330
in-house typically where this helps.

16
00:00:55,195 --> 00:00:57,805
If we consider unicast,
it's one-to-one, right?

17
00:00:58,015 --> 00:01:00,565
Sender sends the packet
to see what gets it.

18
00:01:01,135 --> 00:01:05,054
So for that to happen, they have
to establish a session initially.

19
00:01:05,565 --> 00:01:11,644
And if we assume hundreds or thousands
of receivers and one sender that

20
00:01:11,644 --> 00:01:17,404
single sender has to build hundred or
thousands of TCP sessions with each

21
00:01:17,404 --> 00:01:20,374
one of them, which is CPU Intensive.

22
00:01:20,374 --> 00:01:21,934
So you're literally wasting.

23
00:01:22,759 --> 00:01:26,539
The resource of the sender
just by establishing these

24
00:01:26,539 --> 00:01:28,219
sessions which is efficient.

25
00:01:28,729 --> 00:01:31,569
So the better approach is using malca.

26
00:01:32,079 --> 00:01:34,719
We use one sender since the packet.

27
00:01:35,274 --> 00:01:39,774
To the multicast group and whoever
joins that group, the receivers,

28
00:01:40,374 --> 00:01:41,934
they start receiving the packets.

29
00:01:41,934 --> 00:01:46,385
And there is no session between the sender
and receiver who are joins the group.

30
00:01:46,835 --> 00:01:50,615
They get those packets, and if you
leave, you're out of the stream.

31
00:01:50,714 --> 00:01:55,684
So you could consider the multicast
as an example of probably a radio

32
00:01:55,684 --> 00:01:58,285
stream or a TV channel streaming.

33
00:01:58,920 --> 00:02:04,435
Where the broadcaster broadcast the
channel, the programs on the channel

34
00:02:04,555 --> 00:02:08,115
and who are like, if you tune, tune
into that channel, you start seeing

35
00:02:08,115 --> 00:02:12,345
the picture in your TV and whoever
joins the channel, they'll be able to

36
00:02:12,345 --> 00:02:14,175
see the same thing at that given time.

37
00:02:14,225 --> 00:02:18,435
And same thing with the radio,
like the radio broadcaster

38
00:02:18,545 --> 00:02:20,645
streams on a certain frequency.

39
00:02:20,645 --> 00:02:22,865
And if you tune the
radio to that frequency.

40
00:02:23,415 --> 00:02:26,955
You start listening the sounds
or whatever broadcast is done.

41
00:02:26,955 --> 00:02:31,415
So it's the same concept like
the multicast one center streams

42
00:02:31,415 --> 00:02:35,435
data and whoever joins the group
they start receiving the data.

43
00:02:36,115 --> 00:02:41,575
There's the, though there's a dramatic
efficiency gain but implementing that

44
00:02:41,665 --> 00:02:43,705
in the large scale virtual environments.

45
00:02:44,110 --> 00:02:48,085
Has been complex and difficult
which is why I think it's still

46
00:02:48,085 --> 00:02:51,405
not yet need to be supported in
some of the major cloud providers.

47
00:02:51,905 --> 00:02:54,365
So what are the critical barriers, right?

48
00:02:54,435 --> 00:02:58,655
That broke multicast state explosion
and software defined networks.

49
00:02:59,025 --> 00:03:02,465
When we talk about multicast the
elements that are in the network

50
00:03:02,465 --> 00:03:04,625
have to maintain a forwarding table.

51
00:03:05,195 --> 00:03:08,585
And since and it has to be
consistent across the network

52
00:03:08,585 --> 00:03:10,325
infrastructure in the cloud.

53
00:03:10,920 --> 00:03:16,370
And as the, as there is if you have
multiple resources or the receivers

54
00:03:16,370 --> 00:03:19,970
joining and leaving the group, there's a
huge amount of calculations that happen.

55
00:03:20,420 --> 00:03:25,290
So this could stress out the control
plane of the the backend infrastructure.

56
00:03:25,290 --> 00:03:25,840
So that could be.

57
00:03:26,525 --> 00:03:31,335
One reason that could potentially prevent
multicast being implemented in this

58
00:03:31,455 --> 00:03:34,525
wide network of public cloud security.

59
00:03:34,805 --> 00:03:36,345
Another consideration.

60
00:03:36,625 --> 00:03:41,595
Typically the cloud native platforms
this strictly depend on the

61
00:03:41,605 --> 00:03:44,865
multi-tenancy with the different clients.

62
00:03:45,405 --> 00:03:49,445
Our customer workloads running the
shared fiscal infrastructure in the

63
00:03:49,445 --> 00:03:52,095
backend, but they're typically separated.

64
00:03:52,505 --> 00:03:57,155
There is no leakage of data or
the resource don't get shared into

65
00:03:57,155 --> 00:03:59,355
the other customers, environment.

66
00:03:59,395 --> 00:04:00,114
But the.

67
00:04:00,640 --> 00:04:05,099
Multicast designed to be operated
under one administrative control.

68
00:04:05,519 --> 00:04:10,720
So there could be a potential
that the the data could leak into

69
00:04:10,770 --> 00:04:12,720
the other tenant's environments.

70
00:04:12,720 --> 00:04:18,640
So that probably one reason
that the multicast could

71
00:04:18,640 --> 00:04:20,320
potentially be not implemented.

72
00:04:20,620 --> 00:04:24,850
The other thing is the operational
complexity and automation challenges.

73
00:04:25,270 --> 00:04:28,030
With unicast, you can
define it, static routing.

74
00:04:28,470 --> 00:04:32,150
But when it comes to multicast
it's dynamically changing behavior.

75
00:04:32,200 --> 00:04:36,040
It's, which is hard to predict and
as I said, they it potentially.

76
00:04:36,595 --> 00:04:40,435
Causes a lot of recalculations
in the forwarding table and a lot

77
00:04:40,435 --> 00:04:41,665
of stress in the control plane.

78
00:04:42,115 --> 00:04:46,435
So that's another reason the
fourth one performance degradation

79
00:04:46,465 --> 00:04:47,905
in the virtual environments.

80
00:04:48,755 --> 00:04:52,665
Theoretically multicast reduces
the the bandwidth consumption,

81
00:04:53,040 --> 00:04:58,275
but the com but it comes with
the complexity of implementation.

82
00:04:58,680 --> 00:05:02,610
And there's the processing of multicast
package through the virtual environments

83
00:05:03,000 --> 00:05:08,120
could potentially be far reaching or
maybe it exceeds the bandwidth savings.

84
00:05:08,540 --> 00:05:13,210
And the fifth one is the the architecture
mismatch with the cloud native patents.

85
00:05:13,710 --> 00:05:17,475
So the microservices they emphasize
loosely on the loose coupling.

86
00:05:18,075 --> 00:05:22,205
And they express explicit service
boundaries, but when it comes to

87
00:05:22,205 --> 00:05:26,255
multicast, it's implicit coupling between
the publisher and the subscribers.

88
00:05:26,845 --> 00:05:30,895
Those are like the five constraints
that could potentially has been

89
00:05:31,375 --> 00:05:35,455
restricting the multicast to be
natively supported in the cloud.

90
00:05:35,955 --> 00:05:36,420
And how.

91
00:05:36,920 --> 00:05:41,710
How having the multicast restricted
in this cloud it, it could

92
00:05:41,780 --> 00:05:43,840
impact infrastructure automation.

93
00:05:44,110 --> 00:05:45,970
One would be the migration challenges.

94
00:05:46,080 --> 00:05:51,730
So many financial data telecommunication
media streaming services, heavily

95
00:05:51,730 --> 00:05:55,220
relying on multicast for the
efficient data distribution.

96
00:05:55,320 --> 00:06:00,500
As most of their models depend on one
couple centers, multiple receivers.

97
00:06:00,950 --> 00:06:04,840
But when it needs to be, when it
needs to be brought into the the

98
00:06:05,090 --> 00:06:08,650
the cloud native it changed like the
legacy application moving into the.

99
00:06:09,335 --> 00:06:14,585
Changes the whole infrastructure
architecture because as it's not natively

100
00:06:14,585 --> 00:06:19,105
supported, so if you're moving from
on-prem legacy app, which is a multicast

101
00:06:19,105 --> 00:06:22,345
based into cloud yeah that's where.

102
00:06:22,830 --> 00:06:26,710
Since there is no native support from
multicast in the cloud you would have

103
00:06:26,710 --> 00:06:28,880
to employ some alternate solutions.

104
00:06:29,210 --> 00:06:33,860
So which kind of becomes complex and
that could result in migration challenges

105
00:06:34,430 --> 00:06:35,690
and infrastructure as code, right?

106
00:06:35,690 --> 00:06:37,610
Like terraform and cloud formations.

107
00:06:38,200 --> 00:06:42,760
There is, as there is no direct resource
natively supported, so you cannot directly

108
00:06:43,240 --> 00:06:45,540
implement using the declarative approach.

109
00:06:45,640 --> 00:06:49,540
Rather you have to have some complex
workarounds through custom scripts.

110
00:06:49,600 --> 00:06:53,210
And that kinda breaks the process.

111
00:06:53,210 --> 00:06:57,930
The platform engineers rely on like
the consistent repeatable code that

112
00:06:57,930 --> 00:06:59,790
we kinda rely on with the state files.

113
00:07:00,070 --> 00:07:01,750
That kind of probably gets lacked.

114
00:07:02,160 --> 00:07:05,839
So those could be two of the impacts
the infrastructure mission can

115
00:07:05,839 --> 00:07:10,039
have with the missing multicast,
native multicast supporting.

116
00:07:10,609 --> 00:07:13,929
Cloud container
orchestration complications.

117
00:07:14,429 --> 00:07:18,270
So service discovery service discovery
and Kubernetes typically depends

118
00:07:18,270 --> 00:07:21,810
on the DNS, which is like the point
to point communication patterns.

119
00:07:21,909 --> 00:07:26,710
Applications that generally use
multicast for dynamic service discovery.

120
00:07:26,809 --> 00:07:30,949
They must be modified to work with the
Kubernetes service abstraction model.

121
00:07:30,949 --> 00:07:35,119
So that's one challenge that
if you're gonna go from.

122
00:07:35,594 --> 00:07:40,444
Legacy app to like the microservices
that could be a huge change that needs

123
00:07:40,444 --> 00:07:42,774
to be considered security policy gaps.

124
00:07:42,784 --> 00:07:46,464
You can apply security policies
for part to part communications.

125
00:07:46,884 --> 00:07:51,674
But the Kubernetes security process
do not control the multicast traffic.

126
00:07:51,734 --> 00:07:52,994
And that could be, huh.

127
00:07:53,254 --> 00:07:57,374
Potential security gap that
could be left pod lifecycles.

128
00:07:57,429 --> 00:08:02,240
The pods lifecycle management the
pods could be created, destroyed

129
00:08:02,289 --> 00:08:06,539
pretty quickly even before the
multicast recalculations happen.

130
00:08:06,929 --> 00:08:09,539
So that could be one complication.

131
00:08:09,589 --> 00:08:10,284
If you want to implement.

132
00:08:11,049 --> 00:08:14,169
Multicast within the Kubernetes
in the cloud native environment.

133
00:08:14,669 --> 00:08:18,239
So does that mean like
we cannot do multicast?

134
00:08:18,699 --> 00:08:22,499
I would say there are a couple approaches
that could be employed though a little

135
00:08:22,499 --> 00:08:25,569
complex and have their pros and cons.

136
00:08:25,929 --> 00:08:29,219
But they, there could be few
approaches that could be taken.

137
00:08:29,500 --> 00:08:34,039
One is at the application level
itself within the developers actually

138
00:08:34,610 --> 00:08:39,339
take that network layer into the
application like code, the the

139
00:08:39,339 --> 00:08:42,479
membership, the group membership
management the message delivery and

140
00:08:42,479 --> 00:08:44,670
error handling within that application.

141
00:08:44,770 --> 00:08:48,479
And they actually maintain the
whole communication from center to

142
00:08:48,479 --> 00:08:50,579
receivers within the application.

143
00:08:50,680 --> 00:08:55,709
Though it increases the complexity,
but it does provide with an approach

144
00:08:55,709 --> 00:09:00,559
where you could generally move
migrate your applications into cloud.

145
00:09:00,559 --> 00:09:03,589
But the overhead of network
now falls under the developers.

146
00:09:03,959 --> 00:09:08,209
And also with the networking
layer added into the application

147
00:09:08,749 --> 00:09:10,550
there could be performance issues.

148
00:09:11,120 --> 00:09:11,720
As well.

149
00:09:11,950 --> 00:09:16,990
The other approach that we can
employ is creating over networks.

150
00:09:17,290 --> 00:09:21,760
So there, there are a couple vendors
that do support over networks within

151
00:09:21,810 --> 00:09:24,219
the public cloud environments.

152
00:09:24,319 --> 00:09:28,930
So the one way is to build let's say.

153
00:09:29,740 --> 00:09:34,819
You have a marketplace router that
you can deploy and you can build

154
00:09:34,819 --> 00:09:40,060
the GRE tunnels from the host and
the receivers, I mean from the

155
00:09:40,060 --> 00:09:44,449
center end receivers to that cloud
router, which can as a central point.

156
00:09:45,109 --> 00:09:50,364
And then build BGP between the end
house to that centralized router.

157
00:09:50,874 --> 00:09:53,334
And then the sender
sends the package to the.

158
00:09:53,980 --> 00:09:58,110
Router and you can configure like
the pim which kind of manages

159
00:09:58,110 --> 00:10:00,030
the whole multicast protocol.

160
00:10:00,140 --> 00:10:02,360
That's one way that it can be achieved.

161
00:10:02,430 --> 00:10:06,739
Though as I said it, it has its
own complexity, but it is one way

162
00:10:06,739 --> 00:10:11,699
that you can take off that overhead
from the application and bring it

163
00:10:11,699 --> 00:10:13,155
back into the the network layer.

164
00:10:13,885 --> 00:10:18,204
Compared to what we've discussed earlier
about application level replication,

165
00:10:18,454 --> 00:10:22,254
There are, there, there are a couple
cloud native alterna approaches that

166
00:10:22,254 --> 00:10:24,974
could potentially be reviewed as well.

167
00:10:25,064 --> 00:10:27,764
Mainly the messaging services like.

168
00:10:28,264 --> 00:10:31,954
Amazon SQS cloud pop sub they
provide reliable scalpel message

169
00:10:31,954 --> 00:10:37,524
delivery and if properly planned
and designed potentially the cloud

170
00:10:37,524 --> 00:10:39,714
native approach could be avoided.

171
00:10:39,744 --> 00:10:44,244
The network approach could be avoided
and potentially the application

172
00:10:44,244 --> 00:10:48,694
will be, can be built more of
with the cloud native resources.

173
00:10:49,264 --> 00:10:52,099
And if there is an application
like the content delivery networks.

174
00:10:52,864 --> 00:10:57,814
If the application relies on the
content distribution rather than

175
00:10:57,814 --> 00:11:02,054
real time data, then every cloud
provider provides support CDN.

176
00:11:02,354 --> 00:11:04,404
So that could be one
that could be employed.

177
00:11:04,974 --> 00:11:07,684
And and there are like
software defense solutions.

178
00:11:07,784 --> 00:11:11,434
Like the industries now, the
network industries coming up with

179
00:11:11,434 --> 00:11:15,724
some of the solutions that could
potentially be supported in the cloud

180
00:11:15,724 --> 00:11:17,494
as well, like a market solutions.

181
00:11:18,009 --> 00:11:22,829
So that, that could be one option that
we could potentially see in the future.

182
00:11:23,329 --> 00:11:23,719
Okay.

183
00:11:24,049 --> 00:11:29,099
So though we have the workarounds,
but it, it does have its own cons and

184
00:11:29,199 --> 00:11:30,879
first one is the complex workaround.

185
00:11:30,999 --> 00:11:36,379
Like even if you try to do it overly
or apply it in the application.

186
00:11:36,744 --> 00:11:40,144
The lack of native multicast
support it forces the development

187
00:11:40,144 --> 00:11:45,424
teams to learn new things and try
to inculcate into the application.

188
00:11:45,474 --> 00:11:49,914
The whole developer experience gets
affected and it might slow down the

189
00:11:49,914 --> 00:11:52,854
software lifecycle, like the software
development lifecycle as well.

190
00:11:53,354 --> 00:11:55,004
Environment inconsistency.

191
00:11:55,194 --> 00:11:57,684
You might be having a legacy
application that locally.

192
00:11:58,089 --> 00:11:58,869
Works fine.

193
00:11:59,079 --> 00:12:02,759
But with the with the alternate approach
that we try to implement in the cloud.

194
00:12:02,999 --> 00:12:07,789
So there's, there could be this huge
disconnect between the application,

195
00:12:07,789 --> 00:12:13,109
the on-prem to what it's working now
in the in the cloud native and the

196
00:12:13,319 --> 00:12:16,619
in the public cloud with alternate
solutions that you implement.

197
00:12:17,189 --> 00:12:18,539
And also the testing.

198
00:12:18,569 --> 00:12:22,139
The testing and the
legacy would differ a lot.

199
00:12:22,904 --> 00:12:25,504
When it comes to the solution
implemented in the cloud.

200
00:12:25,504 --> 00:12:29,954
So these are some of the challenges
that we might come across if

201
00:12:29,954 --> 00:12:34,014
implemented the alternate way of
implementing the multicast in the cloud

202
00:12:34,514 --> 00:12:37,364
and operational overhead and complexity.

203
00:12:37,874 --> 00:12:38,384
So

204
00:12:38,884 --> 00:12:42,094
monitoring, complexity, and,
capacity planning challenges and

205
00:12:42,094 --> 00:12:44,014
multiple communication patterns.

206
00:12:44,514 --> 00:12:50,134
So monitoring becomes complex with
the multicast because monitoring and

207
00:12:50,134 --> 00:12:55,894
troubleshooting actually given you
would be implementing different rather

208
00:12:55,894 --> 00:13:00,754
than using a cloud native now we'll be
implementing multiple, overlay networks

209
00:13:00,804 --> 00:13:04,794
with, implementing overlay network with
the different vendor elements in it.

210
00:13:04,794 --> 00:13:09,864
So it'll be hard to figure out where
the issue is, and also like monitoring

211
00:13:09,864 --> 00:13:15,224
different elements centrally that
becomes a huge problem And capacity

212
00:13:15,224 --> 00:13:20,544
planning given the multicast if you
implementing the application it would

213
00:13:20,544 --> 00:13:25,975
be hard to know what's the usage and
the scaling becomes difficult if it is

214
00:13:25,975 --> 00:13:28,345
managed entirely within the application.

215
00:13:28,645 --> 00:13:30,535
So that's another
challenge that could arise.

216
00:13:30,905 --> 00:13:32,795
Implementing the alternate solutions.

217
00:13:33,295 --> 00:13:36,475
So it typically affects
in higher costs, right?

218
00:13:36,475 --> 00:13:36,900
Higher costs.

219
00:13:37,490 --> 00:13:41,480
Incident resolution become longer
and there could be SLAs being missed,

220
00:13:41,780 --> 00:13:43,850
service disruptions, production issues.

221
00:13:43,900 --> 00:13:47,840
It, you could implement with
alterna approaches, but there are

222
00:13:47,840 --> 00:13:51,860
complexities and there are it, its
own cons that come along with it.

223
00:13:52,120 --> 00:13:55,030
As I mentioned, the future
prospects and emerging technologies.

224
00:13:55,645 --> 00:13:57,925
SGN native multi multicast protocols.

225
00:13:57,925 --> 00:14:04,050
So the vendors the networking, networking
vendors are probably gonna be building

226
00:14:04,050 --> 00:14:08,480
something that could natively support
in future within the cloud environments

227
00:14:08,990 --> 00:14:13,610
or maybe something that could be not
implemented across the wide area network.

228
00:14:14,070 --> 00:14:19,530
In the cloud, but potentially limited to a
certain scope for a specific purpose that

229
00:14:19,530 --> 00:14:21,810
could be option that could be implemented.

230
00:14:22,410 --> 00:14:25,640
And with the advancement of some
of the nicks, like the smart nicks

231
00:14:25,640 --> 00:14:29,130
and the data processing units
that could help potentially reduce

232
00:14:29,130 --> 00:14:33,370
the the challenges that we see in
the the virtualized environments.

233
00:14:33,860 --> 00:14:38,320
That could potentially reduce the the
performance issues that multicast posts in

234
00:14:38,370 --> 00:14:44,170
the cloud environments and maybe service
mesh integrations like ST on console.

235
00:14:44,200 --> 00:14:48,200
There's been great advancements
and potentially that's one area

236
00:14:48,380 --> 00:14:52,910
that could, can have like multicast
like functionality in future, one

237
00:14:52,910 --> 00:14:54,290
cloud native option that could.

238
00:14:55,035 --> 00:14:59,230
Being researched is serverless
event in architectures.

239
00:14:59,680 --> 00:15:04,220
Because I think with so many issues that
we could come across with the alternate

240
00:15:04,250 --> 00:15:09,550
approaches like doing multicast within
the application or doing the OA networks.

241
00:15:10,050 --> 00:15:13,340
As in increases as it in
introduces complexity.

242
00:15:13,760 --> 00:15:18,100
I think going with the cloud native
approach or redesigning your applications

243
00:15:18,550 --> 00:15:23,100
to be more cloud native probably
would be the going forward and as

244
00:15:23,445 --> 00:15:27,045
serverless even architectures could
be something that could be employed.

245
00:15:27,545 --> 00:15:32,204
And yeah, as I mentioned, you could
the cloud native alternates is

246
00:15:32,204 --> 00:15:34,325
one option that could be employed.

247
00:15:34,425 --> 00:15:34,784
Sorry.

248
00:15:35,274 --> 00:15:38,424
The operational complexity and
architectural constraints in the cloud

249
00:15:38,424 --> 00:15:41,934
environment, the total con of cost of
ownership include not just resource

250
00:15:41,934 --> 00:15:47,004
consumption, but also operational overhead
and development complexity, and the future

251
00:15:47,004 --> 00:15:51,264
of efficient group communication in cloud
environment likely lies in solutions

252
00:15:51,264 --> 00:15:55,134
Design specifically for software defines
centrally controlled architectures.

253
00:15:55,634 --> 00:15:58,844
Rather than adaptions of
traditional distribution protocols.

254
00:15:59,094 --> 00:16:00,564
That ends my topic.

255
00:16:00,724 --> 00:16:02,255
Thank you all for listening.

256
00:16:02,755 --> 00:16:03,175
Thanks.

