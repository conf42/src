1
00:00:00,500 --> 00:00:02,929
Hey, good morning, good afternoon,
and good evening to all.

2
00:00:03,710 --> 00:00:04,880
I'm Vanta.

3
00:00:05,180 --> 00:00:10,340
I have 23 years of experience
delivering projects in various

4
00:00:10,489 --> 00:00:17,029
Dominic Healthcare, finance, oil and
gas, worked in AWS and Azure Cloud

5
00:00:17,029 --> 00:00:20,630
environments, and have extensive
experience in big data frameworks

6
00:00:20,630 --> 00:00:23,419
like Oop, spark, Kafka, et cetera.

7
00:00:23,919 --> 00:00:27,095
Today I would like to share with you
the experiences I have gone through.

8
00:00:27,895 --> 00:00:32,545
In developing cross language libraries,
we will travel through the architectural

9
00:00:32,845 --> 00:00:39,115
patterns and methodologists follow
while creating the Spark JMS Connected

10
00:00:39,115 --> 00:00:41,635
project and their application to them.

11
00:00:41,815 --> 00:00:43,405
Last ecosystem development.

12
00:00:43,905 --> 00:00:46,965
Let's go to the agenda and see
what are all the topics which are

13
00:00:46,995 --> 00:00:49,305
covered as part of this presentation.

14
00:00:49,805 --> 00:00:51,934
So first we'll cover
the project background.

15
00:00:52,085 --> 00:00:53,645
We'll see what is the need.

16
00:00:54,005 --> 00:00:55,655
Of the Spark JMS connector.

17
00:00:55,865 --> 00:00:59,435
What are all the goals and
challenges we have faced while

18
00:00:59,495 --> 00:01:01,745
developing this Spark JMS connector?

19
00:01:02,245 --> 00:01:07,104
Then we will travel through the common
design challenges which we face while

20
00:01:07,164 --> 00:01:09,025
developing a trans language libraries.

21
00:01:09,525 --> 00:01:14,295
Number three, we will see the abstractions
and the interfaces of the both the JBM

22
00:01:14,295 --> 00:01:19,075
provided interfaces and the registrate,
and we'll next we will navigate to.

23
00:01:19,510 --> 00:01:25,150
The error handling strategies where
we will see the JBMs patterns and

24
00:01:25,150 --> 00:01:27,460
the rust result based approach.

25
00:01:27,960 --> 00:01:32,520
After that, we will see how we have
covered the implementation with

26
00:01:32,670 --> 00:01:37,020
the comprehensive testing across
all the implementations, both with

27
00:01:37,320 --> 00:01:43,190
the rust and the JBM and last, we
will see how we have generated the

28
00:01:43,190 --> 00:01:47,270
YouTube and discover discoverable
interfaces with the documentation.

29
00:01:47,770 --> 00:01:48,190
And a PA design.

30
00:01:48,690 --> 00:01:51,300
We'll quickly go through
the project background.

31
00:01:52,020 --> 00:01:52,200
Yeah.

32
00:01:52,470 --> 00:01:57,449
Capital One, spark JMS Connector
is created because the source

33
00:01:57,600 --> 00:02:01,410
is a message queue and we have
different message sources with the

34
00:02:01,410 --> 00:02:02,940
different types of message queues.

35
00:02:03,359 --> 00:02:08,489
You can see some JMS providers
provide the message in active queue,

36
00:02:08,489 --> 00:02:12,769
some providing IBM and queue and
some providing SOS number two.

37
00:02:13,609 --> 00:02:17,779
This JMS connector should support
the real time processing because we

38
00:02:17,779 --> 00:02:21,559
are going to read the financial data
and we need to quickly respond to the

39
00:02:21,829 --> 00:02:25,760
end customer as soon as we receive
them financial transaction from him.

40
00:02:26,260 --> 00:02:30,064
Number three, this has to be the
enterprise data connector for

41
00:02:30,064 --> 00:02:36,454
Apache Park because we are going to
reuse this connector library across

42
00:02:36,575 --> 00:02:38,734
all the departments in the cap.

43
00:02:39,234 --> 00:02:39,654
Next.

44
00:02:39,714 --> 00:02:42,834
The importance of it is it has
to be critical and real time.

45
00:02:43,165 --> 00:02:47,005
Real time data pipelines, and it has
to be part of the fraud detection

46
00:02:47,695 --> 00:02:51,464
and last, but the greatest, it
has to be performance sensitive.

47
00:02:51,464 --> 00:02:56,214
With strict reliability requirements,
you cannot lose the data customer gets

48
00:02:56,214 --> 00:02:57,709
annoyed with if you lose the data.

49
00:02:58,209 --> 00:03:01,274
The other challenge, which we
have seen is the input library.

50
00:03:01,929 --> 00:03:06,039
The inputs which we are getting for this
library have different message patterns.

51
00:03:06,759 --> 00:03:10,659
We need to combine all these
message patterns and make one unique

52
00:03:10,659 --> 00:03:15,339
message schema and handle it to
different broker for implementation.

53
00:03:15,839 --> 00:03:19,494
With this, we have covered
that departmental goals and the

54
00:03:19,494 --> 00:03:22,614
challenges which we are going to
face by developing this library.

55
00:03:23,114 --> 00:03:26,774
Next, we will go to the Universal Design
Challenges while creating a library.

56
00:03:27,274 --> 00:03:28,019
A library always.

57
00:03:28,834 --> 00:03:32,944
Should have abstraction boundaries
because the implementation may change

58
00:03:33,214 --> 00:03:39,184
and you cannot expect the user of this
library to change his code because

59
00:03:39,244 --> 00:03:40,444
your implementation has changed.

60
00:03:40,774 --> 00:03:45,224
So there should be an extra abstraction
between your implementation and

61
00:03:45,429 --> 00:03:46,449
the customer implementation.

62
00:03:46,509 --> 00:03:50,739
We have created the, we need to create
the interfaces to hide the implementation

63
00:03:50,739 --> 00:03:52,809
details for providing flexibility.

64
00:03:53,309 --> 00:03:55,049
Number two, configuration manage.

65
00:03:55,979 --> 00:04:00,119
You need to be able to configure the
things and customize the behavior

66
00:04:00,119 --> 00:04:04,859
of the library based, or you have,
you should be able to enable or

67
00:04:04,859 --> 00:04:09,269
disable some of the features based
on based on the configurations.

68
00:04:10,019 --> 00:04:12,059
Number three, error propagation.

69
00:04:12,559 --> 00:04:13,264
Error propagation.

70
00:04:13,489 --> 00:04:19,329
You should be able to communicate your
your failures effectively, and also you,

71
00:04:19,369 --> 00:04:21,529
you need to preserve the co context.

72
00:04:21,934 --> 00:04:23,194
And the recovery options

73
00:04:23,694 --> 00:04:24,924
and extensibility.

74
00:04:25,644 --> 00:04:30,534
You should always leave the space for the
future enhancements, but you should not

75
00:04:30,534 --> 00:04:35,694
be that future enha enhancement should not
come at the cost of breaking the backward

76
00:04:35,694 --> 00:04:37,844
compatibility, performance constraints.

77
00:04:37,844 --> 00:04:42,584
Yeah, you should minimize the
overhead while maintaining the

78
00:04:42,584 --> 00:04:43,989
safety and the correct carriage.

79
00:04:44,489 --> 00:04:47,189
First pattern we have identified
is the provider pattern.

80
00:04:47,759 --> 00:04:52,289
The provider interface pattern we used
in the JJMS connector, fortunately has

81
00:04:52,289 --> 00:04:54,389
a natural unlock in the restate system.

82
00:04:54,869 --> 00:05:00,389
So we were a, we were able to easily
blend the JVM provider interface

83
00:05:00,749 --> 00:05:06,129
with the respirate system, with the
as rest rate provides the zero cost

84
00:05:06,129 --> 00:05:11,129
abstractions with the compiled time
polymorphism and the JBM site provider

85
00:05:11,339 --> 00:05:12,914
interface is what we have done is.

86
00:05:13,154 --> 00:05:16,514
Is we have implemented the
dependency injection pattern

87
00:05:16,844 --> 00:05:19,934
to swap the implementations
based on the user selection.

88
00:05:20,434 --> 00:05:24,424
Now, the next architectural
pattern is separation of concepts.

89
00:05:24,924 --> 00:05:26,694
We need to isolate the component.

90
00:05:27,034 --> 00:05:32,044
We need component isolation patterns to
transfer between the two ecosystems so

91
00:05:32,044 --> 00:05:37,194
that those two ecosystems are cohesively
connected from the JBM implementation.

92
00:05:37,434 --> 00:05:38,889
What we have done is we have.

93
00:05:39,389 --> 00:05:43,169
Isolated the message consumers from
the connection management message.

94
00:05:43,499 --> 00:05:47,099
Consumers don't know from where
the message came from and from

95
00:05:47,099 --> 00:05:50,099
which message queue from the
message come from, come, came from.

96
00:05:50,599 --> 00:05:53,644
In the same way, acknowledgement
strategies are also separated

97
00:05:53,644 --> 00:05:54,664
from the message processing.

98
00:05:55,354 --> 00:05:59,844
So message processing doesn't know how to
acknowledge it, is separated between the

99
00:05:59,844 --> 00:06:03,944
connection and the processing connection
takes care of the acknowledgement.

100
00:06:04,439 --> 00:06:06,239
And message processing
does the processing work.

101
00:06:06,239 --> 00:06:06,599
Only

102
00:06:07,099 --> 00:06:10,939
Number three, error handlers are
decoupled from the core business logic.

103
00:06:11,269 --> 00:06:13,459
So they are used as a plug and play.

104
00:06:13,849 --> 00:06:18,459
The error handlers can be added,
are remote based on the requirement

105
00:06:18,959 --> 00:06:20,279
configuration validation.

106
00:06:20,279 --> 00:06:24,194
We have separated it from that
usage now from the rust side.

107
00:06:24,694 --> 00:06:27,484
Rust side, there are builtin
things, module system, which

108
00:06:27,484 --> 00:06:29,254
naturally enforces the boundaries.

109
00:06:29,824 --> 00:06:34,654
And though there is a ownership model
which clarifies the responsibility for the

110
00:06:34,654 --> 00:06:40,264
resources, and as I said earlier, trade
objects for run temporal when needed,

111
00:06:40,654 --> 00:06:45,024
and we did the type parameter checking
for the compiled plus borrow checker

112
00:06:45,024 --> 00:06:49,039
also enforces the clean separation,
prevents the leaky abstractions.

113
00:06:49,039 --> 00:06:49,359
If there are.

114
00:06:50,059 --> 00:06:53,694
Okay, now let's come to the
error handling strategies.

115
00:06:54,054 --> 00:06:59,424
So what we need to have is separate
approaches for both rush transition

116
00:06:59,724 --> 00:07:02,234
and the JBM for the JBM approach.

117
00:07:02,474 --> 00:07:07,994
What we have done is, as it is an
object oriented and relies on hierarchy

118
00:07:07,994 --> 00:07:11,024
inheritance, we wanted to follow the sale.

119
00:07:11,204 --> 00:07:14,714
What we have done is we have
created check and uncheck exception.

120
00:07:14,744 --> 00:07:18,554
Exception throws and catches
everywhere for the errors to propagate.

121
00:07:18,959 --> 00:07:19,139
Okay.

122
00:07:19,589 --> 00:07:24,229
And we we e for every exception
throne we emphasized on the detailed

123
00:07:24,229 --> 00:07:28,609
messages and the stack tracer, we
will be able to identify the exact

124
00:07:28,609 --> 00:07:31,039
location of the issue and fix it.

125
00:07:31,539 --> 00:07:37,239
And also, while creating the exceptions
and catching the exceptions we had, we

126
00:07:37,239 --> 00:07:39,939
didn't compromise on the performance.

127
00:07:39,999 --> 00:07:44,229
We considered the implications
of the performance because of.

128
00:07:45,144 --> 00:07:47,844
Creating try because of the
exception throwing and catching.

129
00:07:48,344 --> 00:07:53,234
Now, from the rust translation point
of view, we use the result, which is,

130
00:07:53,714 --> 00:07:56,684
which encodes whether it is a success or
failure, forcing the compound actually.

131
00:07:56,684 --> 00:07:56,774
And

132
00:07:57,274 --> 00:08:02,414
we use the custom arenas from, for
cohesive comp and composable error

133
00:08:02,414 --> 00:08:05,254
types, and for contextual training.

134
00:08:06,039 --> 00:08:06,429
Training.

135
00:08:06,429 --> 00:08:12,579
We used library anyhow, and this error
to provide agon context, tradition, and

136
00:08:12,579 --> 00:08:16,539
for pattern matching, we have exhaust to
match the pattern, match statements to

137
00:08:16,539 --> 00:08:18,370
ensure all the error cases are handled.

138
00:08:18,870 --> 00:08:22,409
Now let's go to the comprehensive
testing methodologies where we will

139
00:08:22,409 --> 00:08:25,650
discuss what are the unit testing
strategies and integration testing

140
00:08:25,650 --> 00:08:28,710
strategies and property based
testing strategies, which we have

141
00:08:28,710 --> 00:08:31,640
implemented to cover the test case.

142
00:08:31,640 --> 00:08:31,880
Yes.

143
00:08:32,510 --> 00:08:37,299
So we, for JVM, we used Marketo
for the interface mocking and

144
00:08:37,299 --> 00:08:40,270
for rust we have used the mock
implementations of the traits.

145
00:08:41,049 --> 00:08:46,120
And for integration testing, we have used
test containers for the broker instances.

146
00:08:46,120 --> 00:08:50,800
In JVM in case of rust, we have
used container based testing for

147
00:08:50,800 --> 00:08:53,009
feature flags or feature flags.

148
00:08:53,489 --> 00:08:58,694
And in case of property based testing, we
have used WIC theories or Jake W for JB.

149
00:08:59,445 --> 00:09:01,695
And for rust we have used prop test.

150
00:09:01,815 --> 00:09:02,265
A quick check.

151
00:09:02,765 --> 00:09:07,764
Now let's move on to the configuration
management pattern patterns like first

152
00:09:07,764 --> 00:09:09,654
thing is JVM configuration approach.

153
00:09:10,644 --> 00:09:14,964
We have used builder pattern for
the sensible defaults with the

154
00:09:14,964 --> 00:09:20,324
sensible defaults, and we have used
immutable configuration objects and

155
00:09:20,684 --> 00:09:23,204
we validated at the construction time.

156
00:09:23,609 --> 00:09:26,039
And the hierarchical
configuration with the over rates.

157
00:09:26,399 --> 00:09:33,629
So if you see this actually, so we
have used the builder pattern to, for

158
00:09:33,680 --> 00:09:38,110
with the sensibility fault for the
JJBM configurations, rust translation.

159
00:09:38,560 --> 00:09:42,520
Again, like in the last case, we have used
the builder pattern with the default rate.

160
00:09:43,000 --> 00:09:46,600
It goes to the default rate if it
doesn't find any implementation

161
00:09:46,600 --> 00:09:47,385
in case of builder pattern.

162
00:09:47,885 --> 00:09:51,425
We use a type safe confi configuration
with the compiled and validation,

163
00:09:51,724 --> 00:09:57,694
and we, for static configurations,
we used constant generics and we

164
00:09:57,694 --> 00:10:01,505
used con config structures with
the validate validation functions.

165
00:10:02,255 --> 00:10:05,804
Both a, both these approach
approaches emphasize the type

166
00:10:05,804 --> 00:10:07,304
safety 10 validation before use.

167
00:10:07,694 --> 00:10:13,685
But the advantage of rush over the j
or rush over the JVM is it can push

168
00:10:13,685 --> 00:10:15,319
more validation to the compiled type.

169
00:10:15,819 --> 00:10:16,120
Yeah.

170
00:10:16,240 --> 00:10:18,610
Next let's go to the
performance considerations.

171
00:10:18,880 --> 00:10:23,530
So what we have achieved after the
different optimization approaches

172
00:10:23,530 --> 00:10:29,079
that achieved similar goals when we
have taken care of batch pro batch

173
00:10:29,079 --> 00:10:33,740
processing, and JJVM JVM optimization,
connection, pooling, and reuse, instead

174
00:10:33,740 --> 00:10:38,420
of creating the connections every time
to keep, to reduce the pressure on.

175
00:10:38,700 --> 00:10:42,900
GC and the careful memory management
to reduce careful and reuse of the

176
00:10:42,900 --> 00:10:47,610
memory management to reduce the G
GC pressure and jet friendly core

177
00:10:47,610 --> 00:10:52,710
patterns we have used to reduce the
memory and from the rust optimization.

178
00:10:53,130 --> 00:10:57,775
What we have used is we used
mono modernization where it

179
00:10:57,775 --> 00:10:59,275
is zero cost abstractions.

180
00:10:59,425 --> 00:11:04,045
We used explicit memory management
with the lifetimes, and we used

181
00:11:04,045 --> 00:11:05,635
compiled time evaluation when possible.

182
00:11:06,369 --> 00:11:10,770
And we used ownership model, which
achieved a fearless concurrency.

183
00:11:11,270 --> 00:11:11,599
Now

184
00:11:12,099 --> 00:11:15,780
with this, we have achieved the
performance improvement of 10 times and

185
00:11:16,020 --> 00:11:21,780
with zero runtime overhead, and we have
H of 99.9% of the liability target.

186
00:11:22,280 --> 00:11:25,710
Now let's move on to the
documentation and API design.

187
00:11:26,210 --> 00:11:27,590
We have used a LA language.

188
00:11:27,860 --> 00:11:32,990
First of all, like during the coding, we
have used a consistent naming conventions.

189
00:11:33,980 --> 00:11:39,020
For example, for JVM, we used
Camel case for J Java variables

190
00:11:39,140 --> 00:11:40,880
and snake case for rust variables.

191
00:11:41,420 --> 00:11:44,930
And we have established a clear
domain specific technology.

192
00:11:45,860 --> 00:11:50,245
Because that remains consistent throughout
the a PA. We made simple use cases.

193
00:11:50,755 --> 00:11:53,574
We broke the complex use
cases into simple use case.

194
00:11:53,885 --> 00:11:55,775
So that it'll be easy to implement.

195
00:11:56,365 --> 00:12:00,565
They are advanced features are available,
but they are not required for the basic.

196
00:12:01,065 --> 00:12:04,965
So both ecosystems benefit from the
tired APIs with increased complexity.

197
00:12:05,465 --> 00:12:05,735
Both.

198
00:12:06,125 --> 00:12:10,445
We have used both OC and Java DOC
to support the embedded examples.

199
00:12:10,945 --> 00:12:16,064
Our JVM connector provided example
classes for the users to use it in stuff.

200
00:12:16,125 --> 00:12:20,469
Document, it's worked better than the
documentation part and rust documentation.

201
00:12:20,469 --> 00:12:23,799
Also, we have used the dock tests
that are automatically verified.

202
00:12:24,299 --> 00:12:28,389
Yeah, we have explicitly documented
the errors, which you can throw and

203
00:12:28,389 --> 00:12:31,179
the what are the errors which will
be thrown by the library, and what

204
00:12:31,179 --> 00:12:33,579
are the recovery strategies interest.

205
00:12:34,149 --> 00:12:37,209
That means we have documented
all the error variants that can

206
00:12:37,209 --> 00:12:38,859
be returned from each functions.

207
00:12:39,359 --> 00:12:42,079
What are the key learnings from
this library implementation?

208
00:12:42,579 --> 00:12:44,169
The first thing is abstraction.

209
00:12:44,169 --> 00:12:46,419
Principles are universal
for all the languages.

210
00:12:46,689 --> 00:12:49,349
Good interface design
transmits the languages.

211
00:12:49,619 --> 00:12:53,009
We can identify the right
abstraction boundaries regardless

212
00:12:53,009 --> 00:12:54,329
of the language implementation.

213
00:12:54,829 --> 00:12:58,939
Number two, you leverage the
strengths of each language.

214
00:12:59,629 --> 00:13:02,509
Plus ownership model and trade
system provides the compelling

215
00:13:02,509 --> 00:13:05,569
guarantees that required runtime
check in the JBM languages.

216
00:13:06,069 --> 00:13:09,319
One of things and testing
is la language agnostic.

217
00:13:09,649 --> 00:13:14,529
You have that the test cases might
be language language dependent test

218
00:13:14,529 --> 00:13:18,099
case implementation might be language
independent, but the testing strategies

219
00:13:18,430 --> 00:13:22,979
are, and that are like what, what
went between the ecosystems though?

220
00:13:22,979 --> 00:13:25,890
Implementation details are
different, as I said, and.

221
00:13:26,390 --> 00:13:29,209
When we are implementing and
the document intent, not just

222
00:13:29,209 --> 00:13:33,160
implementation, while we are
implementing the code, we have explained

223
00:13:33,160 --> 00:13:35,379
why a design is made as important.

224
00:13:35,379 --> 00:13:40,719
It's as important for the documentation
and how to use an a PA so that while

225
00:13:40,719 --> 00:13:44,530
generating the document, you'll get all
the information on how to use the a p

226
00:13:45,430 --> 00:13:49,415
and how, what design cha choices you
have made regardless of the language.

227
00:13:49,915 --> 00:13:50,155
Yeah.

228
00:13:50,395 --> 00:13:50,844
Thank you.

