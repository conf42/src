1
00:00:00,360 --> 00:00:00,990
Hi everyone.

2
00:00:01,040 --> 00:00:03,920
Thanks again for giving me this
opportunity to talk about Rush

3
00:00:03,920 --> 00:00:07,069
program rush programming, how we can
use this rush programming to build

4
00:00:07,120 --> 00:00:09,040
automation, enterprise level automation.

5
00:00:09,040 --> 00:00:12,340
Using this rush programming language,
we'll also see as a technical

6
00:00:12,340 --> 00:00:16,710
exploration, we'll also see how we
we can, how we can build a based AI

7
00:00:16,710 --> 00:00:21,050
solutions for transforming operational
processes across the industries

8
00:00:21,320 --> 00:00:24,440
through high performance and memory
safe implementation and architectures.

9
00:00:24,940 --> 00:00:25,300
Yeah.

10
00:00:25,580 --> 00:00:26,150
Hi everyone.

11
00:00:26,200 --> 00:00:29,040
Thanks again for giving me this
opportunity to talk about rush

12
00:00:29,040 --> 00:00:32,200
program rush programming, how we can
use this rush programming to build

13
00:00:32,250 --> 00:00:35,235
automation, enterprise level automation
using this rush programming line.

14
00:00:35,495 --> 00:00:38,105
Which we'll also see as
a technical exploration.

15
00:00:38,105 --> 00:00:42,275
We'll also see how we we can how we
can build US based AI solutions for

16
00:00:42,275 --> 00:00:46,215
transforming operational processes
across the industries through

17
00:00:46,215 --> 00:00:49,485
high performance and memory, safe
implementation and architectures.

18
00:00:49,985 --> 00:00:54,815
As like memory safe programming language,
and it will go through like how it

19
00:00:54,815 --> 00:00:58,970
is advantages for, and advantages
and why it's very useful for, and

20
00:00:58,970 --> 00:01:03,264
or why it plays a very crucial role
for building AI based applications.

21
00:01:03,544 --> 00:01:06,365
As we know rush is a programming
language that is perfect for

22
00:01:06,365 --> 00:01:10,414
building this AI co-pilot because
it gives us three main advantages.

23
00:01:10,414 --> 00:01:13,469
First one, it keeps our
system safe from memory error.

24
00:01:14,299 --> 00:01:19,199
So that they don't crash or behave
unpredictability, and it does not show it,

25
00:01:19,424 --> 00:01:23,734
it does not slow down during any processes
or any high level throughput, right?

26
00:01:23,784 --> 00:01:24,714
It never slows down.

27
00:01:24,714 --> 00:01:25,974
That is the biggest advantage.

28
00:01:26,364 --> 00:01:30,274
And the second thing, it lets the
huge amount of data to process at

29
00:01:30,274 --> 00:01:33,994
a time and without any problems
and without any race conditions.

30
00:01:34,384 --> 00:01:38,654
And that means everything stays accurate
and everything stays under a heavy load.

31
00:01:39,369 --> 00:01:40,659
That is the biggest advantage.

32
00:01:40,899 --> 00:01:44,349
And the third thing is it allows
to build complex features without

33
00:01:44,349 --> 00:01:45,729
any extra performance cost.

34
00:01:46,089 --> 00:01:50,239
And in short, rust helps us to
keep, make sure AI systems that

35
00:01:50,239 --> 00:01:51,754
are fast and safe and reliable.

36
00:01:52,254 --> 00:01:54,304
So when we look at the
rust programming, right?

37
00:01:54,344 --> 00:01:58,044
As we know rust is becoming more and
more popular these days and Rust is

38
00:01:58,044 --> 00:02:02,614
becoming a popular language or pop fab
fabric language for many programmers

39
00:02:02,914 --> 00:02:06,304
as we know it's a memory safe and it's
a low level code programming, right?

40
00:02:06,364 --> 00:02:10,494
And earlier days in future
RAs might be place c C plus

41
00:02:10,494 --> 00:02:12,054
place or any other low level.

42
00:02:12,299 --> 00:02:16,554
System, system programming in
my future, we, these days we see

43
00:02:16,554 --> 00:02:17,604
a lot of restorations, right?

44
00:02:17,784 --> 00:02:21,649
Let us see how how ra RAs can be
utilized for building this copilot

45
00:02:21,649 --> 00:02:24,679
or AI based application, enterprise
level applications, and how we

46
00:02:24,679 --> 00:02:28,609
can use the biggest features of
rust and why it is advantages.

47
00:02:28,609 --> 00:02:29,479
We'll cover all of that.

48
00:02:30,109 --> 00:02:34,989
And that is a modern programming language
that is becoming fabric for many many fab.

49
00:02:35,624 --> 00:02:38,174
Becoming favorite for many
developers these days, right?

50
00:02:38,174 --> 00:02:42,724
Like the main advantage, the main
reason for it is first one is it's

51
00:02:42,724 --> 00:02:44,464
a memory safe without memory safe.

52
00:02:44,464 --> 00:02:49,374
That means without slowing down the
process it can handle many operations and,

53
00:02:49,424 --> 00:02:51,314
and also in many other languages, right?

54
00:02:51,314 --> 00:02:55,850
If you see memory errors and bugs that
cause errors and that cause crashes,

55
00:02:56,239 --> 00:02:59,529
rash is designed to prevent all of
that that is a biggest advantage.

56
00:02:59,529 --> 00:03:00,429
It's a memory safe.

57
00:03:00,489 --> 00:03:04,509
Any errors related to memory
or any errors related to that

58
00:03:04,509 --> 00:03:05,979
are causing crashes, right?

59
00:03:05,979 --> 00:03:06,729
That can be Amen.

60
00:03:07,089 --> 00:03:11,789
That is the biggest advantage and, and
it'll also it'll also prevent these

61
00:03:11,789 --> 00:03:14,249
errors without adding any runtime cost.

62
00:03:14,489 --> 00:03:17,129
So that is the biggest, that is
one more advantage and coming

63
00:03:17,129 --> 00:03:18,539
to the second advantage, right?

64
00:03:18,589 --> 00:03:20,479
Why it is called fearless concurrency.

65
00:03:20,479 --> 00:03:24,049
The simple, it simply means like
a lot of tasks can be handled at

66
00:03:24,049 --> 00:03:25,369
a time like multi multithreading.

67
00:03:25,429 --> 00:03:29,024
Basically multithreading when it comes
to rest can handle this multithreading

68
00:03:29,124 --> 00:03:30,744
very simply and very easily.

69
00:03:31,114 --> 00:03:31,984
Massive sets, right?

70
00:03:31,984 --> 00:03:35,549
Like for example, multi-threading or
multi-processing processes, right?

71
00:03:35,579 --> 00:03:39,119
Like ma handling, ma massive data
sets or handling thousands of

72
00:03:39,119 --> 00:03:42,749
transactions or updating hundreds
of systems at a time, or without

73
00:03:43,349 --> 00:03:45,419
creating data mix ups or conflicts.

74
00:03:45,724 --> 00:03:48,774
For example, if in a traditional
programming to handle a thousands

75
00:03:48,774 --> 00:03:51,354
of transactions at a time,
it'll be very complex for us.

76
00:03:51,354 --> 00:03:55,014
With the, if we are going the high level
programming language like Java or C Sharp,

77
00:03:55,314 --> 00:03:56,839
it'll be very tedious job to handle.

78
00:03:57,109 --> 00:04:00,319
But when it comes to rest by
default, that has that mechanism.

79
00:04:00,319 --> 00:04:03,049
At the root level, it is very
easy for us to handle multi-level

80
00:04:03,149 --> 00:04:06,209
threading multi-level processes,
especially this is helping this.

81
00:04:06,589 --> 00:04:11,459
Can help us in banking sector or financial
domain because there will be mi millions

82
00:04:11,459 --> 00:04:12,779
of transactions per second, right?

83
00:04:13,229 --> 00:04:16,779
So Rust, that's why Rust is a fabricate
language for building a blockchain.

84
00:04:16,859 --> 00:04:19,559
Technologies, which has lacks
of transactions, a hundred

85
00:04:19,559 --> 00:04:20,609
thousand transactions per minute.

86
00:04:21,109 --> 00:04:22,559
And third advantage, right?

87
00:04:22,579 --> 00:04:24,129
Zero cost ab abstractions.

88
00:04:24,159 --> 00:04:27,369
We can build complex automation
logic like decision making engines

89
00:04:27,639 --> 00:04:30,889
or real time analytics without
slowing down without slowing down.

90
00:04:30,939 --> 00:04:33,009
The systems, for example, as right?

91
00:04:33,009 --> 00:04:37,299
Like when we are building the analytics
systems, like BI reports, visualizations,

92
00:04:37,299 --> 00:04:40,499
like when it is processing when it
is processing huge data loads to

93
00:04:40,499 --> 00:04:44,279
give the reports or do to show the
analytics also show the graphs, right?

94
00:04:44,429 --> 00:04:45,539
We encounter a lot of vision.

95
00:04:45,924 --> 00:04:49,694
Those kind of challenges we can fix
using this REST program language,

96
00:04:49,694 --> 00:04:51,374
which is one of the biggest advantage.

97
00:04:51,764 --> 00:04:53,144
So we put all together, right?

98
00:04:53,774 --> 00:04:57,864
Let us create a let us create this AI
co-pilots using this rest programming

99
00:04:57,869 --> 00:05:01,749
language, how we can, let us see
how we can create this AI co-pilots

100
00:05:01,749 --> 00:05:03,624
or AI safe application, right?

101
00:05:03,624 --> 00:05:08,149
AI applications using this stress
problem, which can handle this high, but.

102
00:05:08,364 --> 00:05:10,434
Close and run without crashes.

103
00:05:10,434 --> 00:05:15,204
Deliver results instantly, which exactly
what industry like finance, retail,

104
00:05:15,204 --> 00:05:18,684
and manufacturing and other utility
utility companies are looking for.

105
00:05:19,184 --> 00:05:19,904
Let us look at it.

106
00:05:19,904 --> 00:05:20,409
The other slide.

107
00:05:20,909 --> 00:05:24,469
Let us look at the main building
blocks that make the AI copilot work.

108
00:05:24,769 --> 00:05:26,419
First we have the data extraction engine.

109
00:05:26,419 --> 00:05:27,919
This is the system ICE and ERs.

110
00:05:28,749 --> 00:05:31,569
It collects all the information
from different data sources like

111
00:05:31,569 --> 00:05:36,399
spreadsheets, documents, databases,
or even for older file formats.

112
00:05:36,819 --> 00:05:40,744
It works fast and it can process ma
multiple streams at once and does

113
00:05:40,744 --> 00:05:42,244
not waste the memory as we know.

114
00:05:42,424 --> 00:05:45,979
We can use this we can use so it can
process ma, as I mentioned, right?

115
00:05:45,979 --> 00:05:46,744
It can process any.

116
00:05:47,209 --> 00:05:50,159
For any kind of files like it
does not have any limits, right?

117
00:05:50,159 --> 00:05:53,934
It can process ESE file, audio
file, or web file, or any kind file.

118
00:05:54,029 --> 00:05:54,809
It can be processing.

119
00:05:55,259 --> 00:05:57,029
And the next comes is the agent system.

120
00:05:57,249 --> 00:05:59,699
This, think, this is
like a brain of Cooper.

121
00:05:59,699 --> 00:06:03,679
It uses the AI models to understand
the data and make decisions, and

122
00:06:03,684 --> 00:06:05,384
it can also coordinate the task.

123
00:06:05,694 --> 00:06:09,414
It can even roll back actions if
something goes wrong and it can add up.

124
00:06:09,759 --> 00:06:10,629
Based on the context.

125
00:06:10,629 --> 00:06:12,519
And basically this is a context, a system.

126
00:06:13,089 --> 00:06:16,234
I understand what exactly it is
working on and what exactly the user

127
00:06:16,359 --> 00:06:18,069
is asking and what it can respond to.

128
00:06:18,399 --> 00:06:21,039
And even it can handle
task automation, right?

129
00:06:21,049 --> 00:06:21,829
Anything really.

130
00:06:21,829 --> 00:06:22,909
It can perform some tasks.

131
00:06:22,909 --> 00:06:26,329
Like basically if there is a prompt that
can not want execute any task, right?

132
00:06:26,389 --> 00:06:28,519
That can be handled by this agent system.

133
00:06:28,519 --> 00:06:30,859
This is like a brain that
handles all the instructions.

134
00:06:30,919 --> 00:06:32,374
The main, core logic is present here.

135
00:06:33,064 --> 00:06:34,984
The final one is the integration layer.

136
00:06:35,204 --> 00:06:37,944
As we know, this is integration
layer, which is used to connect to the

137
00:06:37,944 --> 00:06:41,489
different system like AI copilot if you
want to integrate the AI copilot with

138
00:06:41,489 --> 00:06:42,899
the other integration systems, right?

139
00:06:42,929 --> 00:06:46,319
Even though it's a modern or legacy
system, modern system that has

140
00:06:46,319 --> 00:06:50,484
API or or the legacy system, which
does not have any a PS, it can work

141
00:06:50,604 --> 00:06:55,414
seamlessly and it can integrate with
other systems safely and accurately.

142
00:06:55,914 --> 00:06:59,214
And these main, majorly, these
three major parts of this copilot

143
00:06:59,214 --> 00:07:03,214
that that ma the major three parts,
the data engine, AI brain, and

144
00:07:03,214 --> 00:07:04,734
the integration integration layer.

145
00:07:04,734 --> 00:07:07,835
They work together to make the
whole automation system much more

146
00:07:07,835 --> 00:07:10,145
reliable and fast and easy to connect.

147
00:07:10,760 --> 00:07:14,360
Especially in the industry environment,
especially where there are where there

148
00:07:14,360 --> 00:07:15,650
are thousands of transactions, right?

149
00:07:15,679 --> 00:07:19,599
For example, a financial industry or
retail industry, which has thousands

150
00:07:19,599 --> 00:07:21,309
of transactions per second, especially.

151
00:07:21,309 --> 00:07:23,589
That is the, this is ideal in those words.

152
00:07:23,890 --> 00:07:26,049
We'll look at those
examples in the next slide.

153
00:07:26,329 --> 00:07:29,919
We'll cover all of those use cases,
real time use cases in upcoming slides.

154
00:07:30,419 --> 00:07:30,720
Yeah.

155
00:07:31,049 --> 00:07:35,714
One of the best things about, about using
rust about using rust for copilot is that

156
00:07:35,764 --> 00:07:41,069
we don't have to keep keep reinventing the
whole wheel again, once it is built built

157
00:07:41,134 --> 00:07:46,384
like a component, like a data parer or a
reporting tool or addition making model,

158
00:07:46,384 --> 00:07:48,214
we can reuse it for a different project.

159
00:07:48,214 --> 00:07:51,904
It's like a module, like how we
use the DLL files in C or regular.

160
00:07:52,214 --> 00:07:53,744
Regular programming language, right?

161
00:07:53,744 --> 00:07:56,804
We can use it like if we build
one application, it can be used.

162
00:07:57,074 --> 00:08:01,154
Any component can be re imported
or referenced into another project

163
00:08:01,154 --> 00:08:05,724
and reused, taken this is possible
because the rust has very strong type

164
00:08:05,724 --> 00:08:07,724
system and it's a modular design.

165
00:08:08,144 --> 00:08:11,744
In simple terms, it means co the
code is like a building blocks.

166
00:08:11,744 --> 00:08:13,424
It can fit together perfectly.

167
00:08:13,754 --> 00:08:18,054
Even if they are used in different
business areas where we can create

168
00:08:18,054 --> 00:08:22,734
generic versions of tools, the, and
then customize customize them, right?

169
00:08:22,804 --> 00:08:25,429
For example we are building,
for example, I can give you,

170
00:08:26,269 --> 00:08:27,444
for example, we built a small.

171
00:08:27,944 --> 00:08:32,319
A POA system or a small application,
that's for a finance application.

172
00:08:32,589 --> 00:08:37,559
It can be modularized or it can be it can
be customized or it can be configured.

173
00:08:37,614 --> 00:08:38,274
For other industry.

174
00:08:38,274 --> 00:08:41,194
For example, we built it for finance
and it can be configured for other

175
00:08:41,194 --> 00:08:45,494
industry also, or has, or healthcare
or retail domain or other domain.

176
00:08:45,494 --> 00:08:47,614
Also, it can be modular as we know, right?

177
00:08:47,679 --> 00:08:52,134
ERP, like if we are building an ERP
system like ERP system, like SAP

178
00:08:52,474 --> 00:08:55,144
using the rest, it can be modularized.

179
00:08:55,144 --> 00:08:58,954
If we have 10 features that we build for
this ERP system and one company they want

180
00:08:58,954 --> 00:09:03,574
to use only five, and out of that five
and other company want only three, it

181
00:09:03,574 --> 00:09:05,164
can be easily customized, as I mentioned.

182
00:09:05,164 --> 00:09:08,234
These are like, this is like a
building blocks or building blocks

183
00:09:08,354 --> 00:09:11,674
the way the rust is built, the
programming language is built, right?

184
00:09:11,734 --> 00:09:12,874
It's like a building blocks.

185
00:09:12,874 --> 00:09:14,664
It can fit all of them perfectly.

186
00:09:14,934 --> 00:09:19,394
That makes the rest rust programming
very seamless and work and everything,

187
00:09:19,394 --> 00:09:21,314
all the components work together.

188
00:09:21,959 --> 00:09:26,209
And another benefit of another Ben
biggest benefit is comp comply.

189
00:09:26,259 --> 00:09:27,459
Compile time guarantees.

190
00:09:27,519 --> 00:09:31,609
That means system checks system
checks everything before even it runs.

191
00:09:31,609 --> 00:09:37,059
So if something does not match we watch
it clearly instead of finding out later

192
00:09:37,149 --> 00:09:41,039
in production if even during the compile
time only all the error are checked

193
00:09:41,279 --> 00:09:44,639
because in traditional programming or
in the current programming world like

194
00:09:44,759 --> 00:09:48,899
usually we see a lot of production bugs,
usually some of the issues, we encounter

195
00:09:48,899 --> 00:09:50,309
them only when we go to production.

196
00:09:50,309 --> 00:09:53,609
Those kind of issues can be
analyzed and understood even

197
00:09:53,609 --> 00:09:55,049
before, during the compilation.

198
00:09:55,924 --> 00:09:56,974
We are using the REST program.

199
00:09:57,814 --> 00:10:03,594
This usability has a huge impact on time
and cost in real world programs real world

200
00:10:03,594 --> 00:10:09,174
projects like companies have 60 have seen
like 60 to 75% direction of development

201
00:10:09,174 --> 00:10:13,714
time for new automation workloads
after they have reinvested once in f.

202
00:10:14,214 --> 00:10:15,684
Well, especially rest, right?

203
00:10:15,714 --> 00:10:18,214
As I mentioned, like you
say, system system friendly

204
00:10:18,214 --> 00:10:19,504
language and low level prep.

205
00:10:19,924 --> 00:10:23,604
And there are many frameworks that uses
this low code framework for building rest.

206
00:10:24,184 --> 00:10:25,409
There are on top of rest, right?

207
00:10:25,409 --> 00:10:26,699
They have built a subsets.

208
00:10:26,749 --> 00:10:29,359
Basically these are like subsets
of basically the low code versions.

209
00:10:29,869 --> 00:10:31,339
We are planning to build
any workflows, right?

210
00:10:31,339 --> 00:10:33,799
We can utilize these workflows
for building new workflows

211
00:10:33,799 --> 00:10:34,939
like workflow engines or.

212
00:10:35,154 --> 00:10:37,614
Flows, especially business
process automation.

213
00:10:37,674 --> 00:10:40,314
If you want to automate millions
of transactions, or if you

214
00:10:40,314 --> 00:10:43,399
want doing any data pipeline or
data orchestration jobs, right?

215
00:10:43,759 --> 00:10:47,500
We can leverage this RAs programming
language, which is very flexible for

216
00:10:47,500 --> 00:10:49,020
building those kind of operations.

217
00:10:49,470 --> 00:10:52,260
So instead of speaking, instead
of spending we spending weeks and

218
00:10:52,260 --> 00:10:56,000
building the weeks and months on
spend building using these legacy

219
00:10:56,000 --> 00:10:58,850
applications legacy programming
languages for development, right?

220
00:10:58,850 --> 00:11:01,940
We can adopt, to this even we
have seen, as I mentioned earlier

221
00:11:01,940 --> 00:11:05,450
like we have seen a 62, 70 5% of
reduction in development time.

222
00:11:05,500 --> 00:11:09,240
In build in development time for many
companies, which started to use this

223
00:11:09,270 --> 00:11:11,550
rush programming and a fewer bugs, right?

224
00:11:11,550 --> 00:11:15,580
A major major advantage is it has a
faster delivery, which is faster delivery,

225
00:11:15,580 --> 00:11:18,280
fewer bugs, main consistency, more.

226
00:11:18,760 --> 00:11:21,990
Consistent quality and
quality across all consistent.

227
00:11:22,030 --> 00:11:25,120
If we are using us as a main
Procore programming language

228
00:11:25,120 --> 00:11:26,290
for entire organization, right?

229
00:11:26,830 --> 00:11:29,700
As I mentioned earlier, we
can reuse these components.

230
00:11:29,730 --> 00:11:32,560
One like if it is developed
once, it can be reused anywhere.

231
00:11:33,550 --> 00:11:36,515
Let us look at how how this
works in real time world.

232
00:11:36,650 --> 00:11:39,775
Especially with starting with
financial financial services.

233
00:11:40,165 --> 00:11:44,230
One common one common example, is
a loan processing and automation

234
00:11:44,670 --> 00:11:46,110
in the finance industry, right?

235
00:11:46,110 --> 00:11:49,850
The speed and accuracy is everything,
and it makes it can make mistakes

236
00:11:49,850 --> 00:11:54,170
also, can lead to compliance issues
or financial loss, especially you,

237
00:11:54,200 --> 00:11:58,220
we are using with the rush powered
ai copilot can handle these thousands

238
00:11:58,220 --> 00:11:59,510
of transaction that time, right?

239
00:11:59,630 --> 00:12:04,010
Checking documents, verifying
information, making sure everything

240
00:12:04,010 --> 00:12:07,640
meets the strict regulatory rules
and all the validations, right?

241
00:12:08,240 --> 00:12:11,390
If we are going with this rest,
this can be solved very easily

242
00:12:11,810 --> 00:12:13,220
because rest is a memory safe.

243
00:12:13,250 --> 00:12:16,700
It is ideal for handling sensitive
data like personal details, income

244
00:12:16,700 --> 00:12:22,300
statements, or credit reports, or even
we, or even without making any leaks

245
00:12:22,300 --> 00:12:25,000
or errors in practical world, right?

246
00:12:25,000 --> 00:12:28,890
Like we have seen document
extraction has only 99.9% accurate,

247
00:12:28,890 --> 00:12:30,600
which means almost no mistakes.

248
00:12:31,050 --> 00:12:32,310
I have seen applications, right?

249
00:12:32,325 --> 00:12:35,765
Which uses rest for document
extraction which, or OCR, right?

250
00:12:35,885 --> 00:12:36,080
Which has.

251
00:12:36,710 --> 00:12:40,270
Very, which are very accurate
which that uses REST program, which

252
00:12:40,270 --> 00:12:43,040
are very accurate compared to the
traditional traditional systems.

253
00:12:43,430 --> 00:12:48,400
The system also validates almost all
the information even it's a real time.

254
00:12:48,450 --> 00:12:52,550
So the it's real time and so the approvals
or rejections can happen very quickly.

255
00:12:53,240 --> 00:12:57,110
So if you go with the legacy applications
or traditional applications it is, the

256
00:12:57,110 --> 00:13:01,270
process, like a process of doing the OCR
process is handled by one system, and

257
00:13:01,320 --> 00:13:03,120
approvals is handled by another system.

258
00:13:03,180 --> 00:13:06,630
And basically the pre-process is
handled by the one system and push

259
00:13:06,630 --> 00:13:07,920
process is handled by another system.

260
00:13:08,220 --> 00:13:11,190
But when it comes to arrest, everything
can be handled together because.

261
00:13:11,970 --> 00:13:14,420
It can support any kind
of application level.

262
00:13:14,480 --> 00:13:16,610
We can build any kind of
applications using this.

263
00:13:16,910 --> 00:13:19,530
And moreover, we can integrate,
for example we are building

264
00:13:19,530 --> 00:13:22,870
only the processing the core
processing system in rest.

265
00:13:23,170 --> 00:13:28,220
And we want to integrate office 365 or
core, our power platform, which has all.

266
00:13:28,695 --> 00:13:30,565
Built in approval systems, right?

267
00:13:31,015 --> 00:13:32,815
We can easily integrate this rust.

268
00:13:33,115 --> 00:13:34,525
So one part will be in rust.

269
00:13:34,585 --> 00:13:37,255
The major core part, the analysis
part will be in rust, and the

270
00:13:37,255 --> 00:13:39,985
approval part will be in the
other systems like power platform.

271
00:13:40,825 --> 00:13:45,595
And because of this because Rust is a very
high performance system that usually runs

272
00:13:45,595 --> 00:13:50,035
smoothly even during the peak times, while
hundreds of applications are in single

273
00:13:50,035 --> 00:13:54,190
hour, that means there is no delay to the
customers and no backlog for the bank.

274
00:13:54,690 --> 00:13:58,860
And as we know rest it perform compared
to if you see the benchmarks of a

275
00:13:58,860 --> 00:14:02,400
traditional programming, like a Java based
application or a do net based application

276
00:14:02,400 --> 00:14:04,260
with rest, it's a low level program.

277
00:14:04,260 --> 00:14:07,070
It can perform very high
high compared to high.

278
00:14:07,400 --> 00:14:08,865
It has high, very high benchmarks.

279
00:14:08,865 --> 00:14:09,080
It.

280
00:14:09,335 --> 00:14:12,985
In terms of performance that,
that helps us especially

281
00:14:12,985 --> 00:14:14,065
during the high times, right?

282
00:14:14,245 --> 00:14:17,955
We have seen, especially in the banking
sector sometimes the systems might go

283
00:14:17,955 --> 00:14:19,455
down because of the huge transaction.

284
00:14:19,455 --> 00:14:23,445
Especially, for example, if you take
the trading trading world, sometimes

285
00:14:23,535 --> 00:14:25,875
systems might crash or systems might load.

286
00:14:26,355 --> 00:14:27,735
This can be used at this rest.

287
00:14:27,735 --> 00:14:30,945
Programming language can be used in
such scenarios to handle very fast

288
00:14:30,945 --> 00:14:35,635
loads, especially without handling the
crashes and handling the through handling

289
00:14:35,635 --> 00:14:37,485
those especially during the peak times.

290
00:14:38,115 --> 00:14:41,765
In short in finance, rush power,
copilots can deliver perfect mix

291
00:14:41,765 --> 00:14:45,945
of accuracy, speed, and accuracy,
and which exactly is needed by the

292
00:14:45,945 --> 00:14:47,790
current current finance sector.

293
00:14:48,150 --> 00:14:49,940
Let us look at the industry application.

294
00:14:50,270 --> 00:14:51,850
Second industry application
like retail sector.

295
00:14:52,145 --> 00:14:58,330
How this copilot AI coate can be used
for in retail industry, in retail

296
00:14:58,330 --> 00:15:03,280
in retail timing, and are critical
because every small delays can lead

297
00:15:03,280 --> 00:15:05,360
to lead to empty shelves or mystery.

298
00:15:05,860 --> 00:15:06,670
Yeah, rush powered.

299
00:15:06,670 --> 00:15:10,315
The AI copilot can completely transform
real time inventory management.

300
00:15:10,405 --> 00:15:13,195
It can handle distributed
updates and meaning.

301
00:15:13,245 --> 00:15:17,035
That means it can keep track of
stocks or across the hundreds of

302
00:15:17,035 --> 00:15:21,375
stores at the same time without risk
of two system overriding each other.

303
00:15:21,390 --> 00:15:21,610
And.

304
00:15:22,525 --> 00:15:27,265
And this is possible because rush has a
con, a concurrency feature that lets the

305
00:15:27,265 --> 00:15:31,775
processes of multiple stores multiple
stores handle and update safely in a

306
00:15:31,775 --> 00:15:34,165
parallel parallel on top of that, right?

307
00:15:34,165 --> 00:15:36,115
Ai ai we can use ai.

308
00:15:36,520 --> 00:15:41,370
AI for analyzing the sales data and trends
and parallel or, and make the predictive

309
00:15:41,760 --> 00:15:43,320
ordering or predictive suggestions.

310
00:15:43,350 --> 00:15:45,960
Basically, these are like
supply chain for example.

311
00:15:46,060 --> 00:15:49,620
If you take for if you take in certain
terms, in certain items, right?

312
00:15:49,680 --> 00:15:53,370
In certain items are selling faster
than expected, the system may system

313
00:15:53,370 --> 00:15:57,600
can recommend of ordering of those
items even before it, it ran out

314
00:15:58,020 --> 00:16:02,130
and, it does instantly instantly,
no matter how large the data set is,

315
00:16:02,130 --> 00:16:05,560
it can process the data set and it
can give us the predictor results.

316
00:16:06,070 --> 00:16:09,370
Another big advantage is
legacy po OS integration.

317
00:16:09,370 --> 00:16:12,640
As we know already, most of the stores
still use the legacy systems, legacy

318
00:16:12,640 --> 00:16:14,410
po o as a point of sale systems, right?

319
00:16:14,770 --> 00:16:16,960
Many retailers still use those systems.

320
00:16:17,470 --> 00:16:20,190
And more of, most of them does
not have the re APIs, right?

321
00:16:20,190 --> 00:16:21,330
Like it cannot there.

322
00:16:21,330 --> 00:16:24,630
It's not they're not like iot, which
can be integrated with internet or

323
00:16:24,630 --> 00:16:28,410
which can, does not have any internet
connection or it does not have any APIs.

324
00:16:28,910 --> 00:16:31,760
We can have, we can build an
integration layer that build, we

325
00:16:31,760 --> 00:16:34,970
can build these integration layer
with those legacy systems using this

326
00:16:34,980 --> 00:16:40,075
rest, which can translate regular
transactional data or p os data into

327
00:16:40,385 --> 00:16:42,510
extract the data into this hour.

328
00:16:43,010 --> 00:16:46,850
Based online system and do
performance and do do a analysis

329
00:16:46,850 --> 00:16:49,070
on top of that as a result, right?

330
00:16:49,070 --> 00:16:53,450
As we know, we can work on legacy systems,
it can be integrated with legacy systems.

331
00:16:53,450 --> 00:16:59,515
It is it can both ly do do, supply chain
management and predict to analytics

332
00:16:59,515 --> 00:17:01,545
and real time operations, right?

333
00:17:01,645 --> 00:17:05,215
This makes RA based AI applications
or RA based applications a

334
00:17:05,575 --> 00:17:07,275
best fit for retail world.

335
00:17:07,775 --> 00:17:10,415
Now let's talk about
manufacturing and the utilities.

336
00:17:10,445 --> 00:17:13,795
The two sectors where down
downtime and inefficiency can be

337
00:17:13,795 --> 00:17:16,105
extremely costly in manufacturing.

338
00:17:16,555 --> 00:17:17,655
A rest rest about ai.

339
00:17:17,655 --> 00:17:22,005
Copilot can automate I automate pro
procurement and supply coordination.

340
00:17:22,015 --> 00:17:22,980
It can manage real.

341
00:17:23,290 --> 00:17:24,670
Orders or optimization.

342
00:17:25,000 --> 00:17:26,550
An example check a supplier.

343
00:17:26,760 --> 00:17:28,500
It can check the supplier availability.

344
00:17:28,500 --> 00:17:32,270
Compare the prices, placing orders
in parallel without slowing down.

345
00:17:32,270 --> 00:17:34,120
It can perform even negotiations.

346
00:17:34,120 --> 00:17:39,110
Also even it can perform negotiations
with multiple suppliers at the same time,

347
00:17:39,110 --> 00:17:43,930
it can ensure, quantity right quantity
right quality or doc right quality.

348
00:17:44,260 --> 00:17:48,100
And also control the documents and
automatically process those documents

349
00:17:48,100 --> 00:17:51,130
or process the communication, like
whatever communication that happens

350
00:17:51,250 --> 00:17:52,780
during these processes, right?

351
00:17:52,840 --> 00:17:55,240
That can be handled by
the same system itself.

352
00:17:55,300 --> 00:17:59,405
We may not rely on the other systems,
especially, we have seen a situations

353
00:17:59,405 --> 00:18:02,760
where for supply chain management,
they're using one system and for

354
00:18:02,760 --> 00:18:06,480
the other processes, sales and
coordination, they're using outreach.

355
00:18:06,530 --> 00:18:08,300
They're using a different systems, right?

356
00:18:08,330 --> 00:18:09,230
Two different systems.

357
00:18:09,680 --> 00:18:10,580
Those can be avoided.

358
00:18:10,940 --> 00:18:14,070
If we are going with this rush based
approach rush can replace those

359
00:18:14,280 --> 00:18:18,770
kind of, for example, in utilities,
in let take the utilities world.

360
00:18:18,820 --> 00:18:23,180
In utilities many companies rely on
world infrastructure like SCADA systems.

361
00:18:23,670 --> 00:18:27,110
Like Boulder Systems, flex
Rush integration layer allows

362
00:18:27,110 --> 00:18:28,520
us to extend the system.

363
00:18:28,520 --> 00:18:31,040
These by, without replacing them,
we can directly integrate them,

364
00:18:31,100 --> 00:18:32,450
as I mentioned in earlier, right?

365
00:18:32,450 --> 00:18:35,300
Like even license systems can
be integrated with recession.

366
00:18:35,330 --> 00:18:39,550
That means without zero disruptions
or zero operations zero disruptions

367
00:18:39,550 --> 00:18:43,190
to operations, like without having
disturbing the existing operations, right?

368
00:18:43,190 --> 00:18:47,820
We can integrate, we can bring this
in into our, into our ecosystem.

369
00:18:48,360 --> 00:18:52,075
We can we can add fault tolerance
monitoring that keeps working even if.

370
00:18:52,835 --> 00:18:55,715
Part of the system fails as
we, as I mentioned, right?

371
00:18:55,715 --> 00:18:56,795
This is a modular system.

372
00:18:56,845 --> 00:18:59,635
Even though some part of it
fails, but the remaining part of

373
00:18:59,695 --> 00:19:00,980
it still can continue working.

374
00:19:01,195 --> 00:19:05,245
We can automate regulatory reporting
for the compliance teams can, don't

375
00:19:05,245 --> 00:19:07,195
have to spend hours gathering the data.

376
00:19:07,555 --> 00:19:11,175
So by default as most of the
modern enterprise applications

377
00:19:11,205 --> 00:19:14,895
have the reporting a log or
transactional logs capability, right?

378
00:19:14,895 --> 00:19:18,410
The same way we can implement
those kind of system, which can.

379
00:19:18,910 --> 00:19:21,760
Which can capture all the logs
and all the transactions that

380
00:19:21,760 --> 00:19:23,020
are happening on these systems.

381
00:19:23,080 --> 00:19:25,700
Especially during the audit,
when audit happens, right?

382
00:19:25,700 --> 00:19:31,165
If you want to if you want to see like
why why what happened and all the digital

383
00:19:31,165 --> 00:19:35,765
stuff, the audit teams spending hundred
percent hours of time on on understanding

384
00:19:35,765 --> 00:19:37,205
the data, analyzing the data, right?

385
00:19:37,205 --> 00:19:39,185
We can use this output as.

386
00:19:39,920 --> 00:19:41,510
We can save a lot of time for audit team.

387
00:19:42,320 --> 00:19:46,790
The final key benefit of using Rusty is
it can handle large, complex operations

388
00:19:47,030 --> 00:19:51,420
predictably, whether it is monitoring
thousands of meters in a power grid, or

389
00:19:51,520 --> 00:19:56,090
coordinating suppliers across countries,
or the system remains fast and safe,

390
00:19:56,090 --> 00:19:58,550
reliable, and without any downtime.

391
00:19:59,050 --> 00:20:03,590
Now we have seen a couple of use cases,
especially in utility world, finance

392
00:20:03,590 --> 00:20:05,390
world, and supply chain world, right?

393
00:20:05,390 --> 00:20:09,720
Now let let us look at the number
numbers like how how rash is compared,

394
00:20:09,720 --> 00:20:13,910
like how can rash can perform compared
to other, traditional approaches.

395
00:20:14,330 --> 00:20:15,800
First is the memory usage.

396
00:20:16,100 --> 00:20:21,070
Rushed ownership model means it uses
about 30% less memory care compared

397
00:20:21,070 --> 00:20:22,660
to the regular or typical systems.

398
00:20:23,050 --> 00:20:27,275
That is important because it allows allows
us to run the same workloads on smaller

399
00:20:27,275 --> 00:20:28,835
and more cost efficient infrastructure.

400
00:20:29,730 --> 00:20:31,680
Second one is a processing speed in real.

401
00:20:31,710 --> 00:20:36,100
In real world testing, RAs can
perform data in incent intensive

402
00:20:36,100 --> 00:20:40,320
operations up to five times faster than
compared to conventional platforms.

403
00:20:40,620 --> 00:20:44,040
This is a huge boost when it, when
you are working on a high volume

404
00:20:44,040 --> 00:20:46,500
transactions or real world analytics.

405
00:20:47,250 --> 00:20:48,655
And the third third one is.

406
00:20:49,465 --> 00:20:54,415
Concurrency and efficiency that can
handle a parallel task up to 200%

407
00:20:54,535 --> 00:20:58,565
more efficiently without risk for
data corruption or race conditions.

408
00:20:59,085 --> 00:21:02,985
This especially especially this critical
this is very critical in critical in

409
00:21:02,985 --> 00:21:06,705
industries where multiple systems are
updating the same data at the same time.

410
00:21:06,705 --> 00:21:07,755
Especially in the finance world.

411
00:21:08,255 --> 00:21:11,460
These performance gains are, or
just theoretical they translate

412
00:21:11,460 --> 00:21:16,040
into faster operations and lower,
lower the cost, and also a smoother

413
00:21:16,340 --> 00:21:20,210
experience for both internal teams
as well as the, and the customers.

414
00:21:20,710 --> 00:21:23,560
So beyond the, our performance
Rest Restore also delivers a strong

415
00:21:23,560 --> 00:21:25,390
business and developer benefits.

416
00:21:25,750 --> 00:21:27,410
First one let us look at the first one.

417
00:21:27,420 --> 00:21:28,470
Computational efficiency with.

418
00:21:29,230 --> 00:21:32,740
Computational efficiency with
zero zero overhead abstractions

419
00:21:32,770 --> 00:21:34,810
and a smart smart memory model.

420
00:21:35,290 --> 00:21:39,700
Rash can give us up to near near
C level performance CC programming

421
00:21:39,700 --> 00:21:43,920
level performance while it is
being safe in practice in practice.

422
00:21:43,970 --> 00:21:48,710
This means the 80% of 80% reduction
in infrastructure requirements, fewer

423
00:21:48,710 --> 00:21:53,730
servers, fewer low fewer low cloud
clause, and predictable predictable

424
00:21:53,830 --> 00:21:56,260
latency even when workloads changes.

425
00:21:56,760 --> 00:22:00,230
Plus also there is no garbage
collection and pauses slow.

426
00:22:00,280 --> 00:22:03,700
And there is no garbage collection,
which improves performance drastically.

427
00:22:04,180 --> 00:22:06,010
Next one is the developer productivity.

428
00:22:06,010 --> 00:22:10,265
Even even though Rust has a big learning
curve, once team gets familiar with.

429
00:22:10,795 --> 00:22:13,045
Familiar with Thera programming,
it saves a lot of time.

430
00:22:13,435 --> 00:22:17,500
We have seen 65% less debugging
time because compiler ca comply.

431
00:22:17,500 --> 00:22:22,520
Comp compiler catches many error before,
even before the other program runs.

432
00:22:23,120 --> 00:22:27,070
The carbo the cargo ecosystem
manages to manages dependencies.

433
00:22:27,075 --> 00:22:29,920
The that makes e our developer life easy.

434
00:22:30,010 --> 00:22:33,400
And the documentation and the tooling
are very excellent, as we know.

435
00:22:33,400 --> 00:22:35,170
It actually is evolving so much.

436
00:22:35,170 --> 00:22:35,800
These days.

437
00:22:35,830 --> 00:22:39,990
There are a lot of, a lot of resources
for learning and it evolves so much.

438
00:22:39,990 --> 00:22:43,470
There, there are a lot of resources or
a lot of tutorial available on web where

439
00:22:43,570 --> 00:22:48,310
once the team or the once the team gets
familiar with this rush program it'll be.

440
00:22:49,230 --> 00:22:51,300
Very easy for us to implement this.

441
00:22:51,750 --> 00:22:53,800
Finally, infrastructure consolidation.

442
00:22:53,800 --> 00:22:56,730
Instead of maintaining the
multiple specialized systems, a

443
00:22:56,730 --> 00:23:00,300
single rush code base can replace
all of them as we know, right?

444
00:23:00,300 --> 00:23:03,360
Industries tend to use the different
programming languages because of

445
00:23:03,360 --> 00:23:06,195
that, they have to maintain huge,
different systems like for example,

446
00:23:06,195 --> 00:23:10,245
Java based system or Linux based
system or windows based system.

447
00:23:10,545 --> 00:23:13,935
All of this, that, that can be this
it can run on any kind of system.

448
00:23:13,935 --> 00:23:17,215
Infrastructure wise, we can
eliminate those kind of limitations.

449
00:23:17,730 --> 00:23:21,710
That means unified monitoring,
consistent development and consistent

450
00:23:21,710 --> 00:23:25,880
development patterns or the consistent
and makes simple, makes the audit

451
00:23:25,880 --> 00:23:29,930
simple and fewer moving parts and fewer
to manage and management wise, right?

452
00:23:29,930 --> 00:23:33,860
I it infrastructure, we, it is very
hard to maintain different systems

453
00:23:33,860 --> 00:23:36,670
for different applications, which
are not different ecosystems, right?

454
00:23:37,180 --> 00:23:41,930
So rash makes that if we replace
those systems with rest it can, it can

455
00:23:41,930 --> 00:23:45,530
default those kind of infrastructure
or maintena maintainability problem.

456
00:23:46,100 --> 00:23:47,690
So rust isn't fast.

457
00:23:47,725 --> 00:23:48,625
Rust isn't safe.

458
00:23:48,695 --> 00:23:49,415
Rust isn't safe.

459
00:23:49,725 --> 00:23:53,265
It also reduces operational cost,
speeds up development and makes

460
00:23:53,265 --> 00:23:54,825
the system easier to maintain it.

461
00:23:54,895 --> 00:23:55,585
In long term.

462
00:23:55,585 --> 00:23:57,625
It saves lot of cost for the companies.

463
00:23:58,125 --> 00:23:58,365
Yeah.

464
00:23:58,365 --> 00:24:02,445
Now let's talk about how we can
implement this rest for AI automation.

465
00:24:03,055 --> 00:24:07,825
Generally we, we follow a few proven
design patterns that make our system

466
00:24:07,825 --> 00:24:09,145
both powerful and maintainable.

467
00:24:09,205 --> 00:24:11,435
For example actor model let's.

468
00:24:11,825 --> 00:24:15,205
Act for example, actor model that
lets different parts of the system run

469
00:24:15,205 --> 00:24:19,685
independently and talk to each other
without stepping on each other's data.

470
00:24:20,265 --> 00:24:22,425
But this is perfect for
the complex workflows.

471
00:24:22,485 --> 00:24:27,765
And next one is the type state pattern,
which helps us to lock the correct order

472
00:24:27,855 --> 00:24:32,315
or the step at the compile time, which
so we cannot, we can't accidentally

473
00:24:32,435 --> 00:24:34,745
run the process in the wrong sequence.

474
00:24:35,435 --> 00:24:37,145
And the third one is command pattern.

475
00:24:37,205 --> 00:24:40,935
Which is useful useful for operations
that might need that might need to

476
00:24:40,935 --> 00:24:42,525
underdone that might need to underdone.

477
00:24:42,645 --> 00:24:46,795
It pack packages each task so
we can control we can roll back.

478
00:24:46,795 --> 00:24:47,805
Its, when it is needed.

479
00:24:48,255 --> 00:24:52,590
And another one is repository pattern
repository pattern extracts how we

480
00:24:52,590 --> 00:24:57,220
can store and retrieve the data making
it easy to switch the databases or

481
00:24:57,270 --> 00:24:59,190
backends without rewriting the logic.

482
00:24:59,810 --> 00:25:05,640
As we, as we use feature flags to enable
or disable the features at the deployment

483
00:25:05,640 --> 00:25:07,520
time, which is great for testing the.

484
00:25:08,480 --> 00:25:09,470
Gradual rollouts.

485
00:25:10,130 --> 00:25:13,300
We can also leverage the powerful
tools from rush ecosystem

486
00:25:13,300 --> 00:25:14,930
like Tokyo for handling.

487
00:25:15,030 --> 00:25:19,640
Lot of task at once and Saturday
for working with different data

488
00:25:19,645 --> 00:25:22,790
coordinate REST belt, which is
a natural language processing.

489
00:25:22,970 --> 00:25:27,965
And rayon for parallel data
processing and tonic for G GRPC

490
00:25:27,995 --> 00:25:30,255
communication GRPC based communication.

491
00:25:30,735 --> 00:25:34,585
By combining all these data patterns
the no known data patterns and the

492
00:25:34,585 --> 00:25:39,005
right tools, we can build automation
systems very easily that are not.

493
00:25:39,265 --> 00:25:45,205
Only fast, but also safe and reliable,
and which are flexible and adaptable.

494
00:25:45,705 --> 00:25:49,370
Let us wrap up let us wrap up
the key takeaways from everything

495
00:25:49,390 --> 00:25:50,450
we have covered till now.

496
00:25:51,095 --> 00:25:54,775
First one is by investing in rest based
automation framework, organizations

497
00:25:54,775 --> 00:26:00,955
can save up to 65 62 c, 75% reduction
in development time for new workflows.

498
00:26:01,375 --> 00:26:04,935
And that is because once the core
components are built, they can

499
00:26:04,935 --> 00:26:08,045
be reused across all the other
projects and other departments.

500
00:26:08,345 --> 00:26:12,065
Second is memory, safety and
pre and predictable performance

501
00:26:12,095 --> 00:26:15,755
that can lead to ni 89% of
reduction in production incidents.

502
00:26:16,055 --> 00:26:18,335
That means fewer crashes, fewer bugs.

503
00:26:18,340 --> 00:26:22,390
And more firefighting for the
development operation in terms.

504
00:26:23,110 --> 00:26:26,460
Third one is the overall process
times overall process time can be

505
00:26:26,460 --> 00:26:31,140
improved by an average of 83%, which
is directly translates into faster

506
00:26:31,140 --> 00:26:35,640
service delivery, faster services and
faster deliveries, better customer

507
00:26:35,640 --> 00:26:37,290
experiences, and higher efficiency.

508
00:26:37,770 --> 00:26:40,020
So the message is simple, gives you.

509
00:26:40,900 --> 00:26:43,750
Gives you fast, safe, and
reliable automation that can

510
00:26:43,800 --> 00:26:47,380
that can work across industries
that can work across industries.

511
00:26:47,800 --> 00:26:51,730
It's a foundation that balances
innovation and reliability, and it's

512
00:26:51,730 --> 00:26:54,930
a proven it's a proven to world,
real world that the results in

513
00:26:54,930 --> 00:26:57,060
performance, cost savings, and quality.

514
00:26:57,560 --> 00:27:00,170
You for giving me this opportunity
to talk about how we can

515
00:27:00,170 --> 00:27:03,620
leverage this s programming for
building AI based to copilot.

516
00:27:04,100 --> 00:27:05,510
Now what next steps?

517
00:27:05,510 --> 00:27:08,480
Coming to next steps rather
like the final conclusion?

518
00:27:08,530 --> 00:27:11,600
I want to say the first step
is to evaluate your current

519
00:27:11,600 --> 00:27:13,610
automation challenges and see.

520
00:27:14,540 --> 00:27:18,530
Where the performance, reliability, or
scalability are critical pain points,

521
00:27:18,920 --> 00:27:23,340
these areas are where we can fit the
rest and show the biggest impact.

522
00:27:23,820 --> 00:27:26,500
Next is to consider the
starting a pilot project.

523
00:27:26,500 --> 00:27:29,230
Choose the process that is
important for your organization.

524
00:27:29,630 --> 00:27:31,430
Something where failure isn't an option.

525
00:27:31,970 --> 00:27:35,330
And test rush powered AI
copilot platforms over there.

526
00:27:35,840 --> 00:27:39,730
And from there you can expand
gradually reusing these components

527
00:27:39,730 --> 00:27:43,180
you have built in the pilot and
to speed up the future projects.

528
00:27:43,600 --> 00:27:46,940
Once this is override, you can
benefit ly faster development,

529
00:27:46,970 --> 00:27:50,025
like faster development, fewer
issues, and more consistent results.

530
00:27:50,915 --> 00:27:54,915
The goal isn't to replace everything
overnight, but it is about building

531
00:27:54,915 --> 00:27:59,225
the solid foundation where future
proof of your automation given given

532
00:27:59,225 --> 00:28:03,545
you the PA performance, safety, and
flexibility, you need to stay competitive.

533
00:28:04,045 --> 00:28:04,335
Okay.

