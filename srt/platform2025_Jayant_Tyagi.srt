1
00:00:00,500 --> 00:00:01,310
Hello everyone.

2
00:00:01,609 --> 00:00:02,989
My name is Jen Taghi.

3
00:00:03,170 --> 00:00:05,060
I'm a software engineer at Salesforce.

4
00:00:05,240 --> 00:00:08,840
I'm part of the Slack engineering team,
and today I'm going to be talking about.

5
00:00:09,420 --> 00:00:13,860
Scaling enterprise development with cloud
IDs, security and performance at scale.

6
00:00:14,220 --> 00:00:18,580
So this presentation is inspired from
a project that I led at Slack which

7
00:00:18,670 --> 00:00:23,140
involved the development of a new remote
development environment platform here at

8
00:00:23,140 --> 00:00:29,700
Slack that allowed engineers here to move
from developing at using their laptops to

9
00:00:29,700 --> 00:00:31,680
a shared remote development environment.

10
00:00:32,170 --> 00:00:35,360
If you've used products like
GI Pod and other cloud IDs,

11
00:00:35,360 --> 00:00:36,770
you might be familiar with it.

12
00:00:37,070 --> 00:00:39,680
But this is about building
something from the ground up

13
00:00:39,980 --> 00:00:41,990
that meets your unique needs.

14
00:00:42,560 --> 00:00:44,780
Alright, so with that, I'll get started.

15
00:00:44,970 --> 00:00:47,100
I think the idea is like,
why do we even need it?

16
00:00:47,100 --> 00:00:50,660
What are the challenges that are unique
to enterprise software development?

17
00:00:51,230 --> 00:00:51,749
So we are often.

18
00:00:52,249 --> 00:00:56,179
We have to navigate huge code
bases, distributed teams.

19
00:00:56,239 --> 00:01:01,500
Everybody's working on certain subsets of
the code base that makes local development

20
00:01:01,500 --> 00:01:03,194
extremely slow and hard to manage.

21
00:01:03,850 --> 00:01:08,470
When oftentimes if you're working on your
laptop, it might take you minutes, if not

22
00:01:08,500 --> 00:01:13,460
hours, to be done with your builds because
your local laptops just doesn't have the

23
00:01:13,460 --> 00:01:19,180
hardware or the compute capacity required
to actually build these large code bases.

24
00:01:19,540 --> 00:01:25,190
Even with the advent of moving away
from monoliths to microservices, you

25
00:01:25,190 --> 00:01:27,290
still have extremely complicated.

26
00:01:27,660 --> 00:01:29,730
Code basis and development environment.

27
00:01:30,390 --> 00:01:33,030
And that requires extremely
heavy tool chains.

28
00:01:33,030 --> 00:01:37,420
If you're doing I development
Android web development or some

29
00:01:37,420 --> 00:01:40,070
ML AI work, you need to install.

30
00:01:40,500 --> 00:01:43,630
And set up those tools and you need
to make sure that they continue to

31
00:01:43,630 --> 00:01:45,610
work, and that is a huge undertaking.

32
00:01:46,510 --> 00:01:50,769
So that's why this move
to cloud IDs is preferred.

33
00:01:51,100 --> 00:01:54,549
Cloud IDs are remote cloud
hosted development environments.

34
00:01:54,789 --> 00:01:58,630
They're usually accessed via remote
IDE that is connected to your

35
00:01:58,630 --> 00:02:00,910
machine using a secure SSH channel.

36
00:02:01,209 --> 00:02:02,919
So you get access to a terminal.

37
00:02:03,179 --> 00:02:05,309
Just as you would of your laptop.

38
00:02:05,309 --> 00:02:09,019
So you can run commands you can
run, get commands and any other

39
00:02:09,019 --> 00:02:12,559
things any local CLI tools that
you would run at your laptop.

40
00:02:12,559 --> 00:02:13,129
You'll do it at eight.

41
00:02:13,784 --> 00:02:19,444
On the virtual machine you get a a
numbered development environment.

42
00:02:19,774 --> 00:02:24,514
So you can use any regular browser
to be able to test your changes.

43
00:02:25,244 --> 00:02:28,604
So you know, the idea is that this
offloads the heavy computing bit

44
00:02:28,604 --> 00:02:32,764
to the cloud which scales really
well thereby making a much more

45
00:02:32,764 --> 00:02:34,204
pleasant development experience.

46
00:02:35,169 --> 00:02:39,619
So I think I did cover this, just to
enumerate it further, the motivation

47
00:02:39,619 --> 00:02:45,349
of you moving to cloud IDs is mostly
to navigate large code bases and these

48
00:02:45,349 --> 00:02:49,909
heavy workloads to be able to work
in a more performant, efficient way.

49
00:02:50,179 --> 00:02:52,969
But also I think the more
important point is reliability.

50
00:02:53,479 --> 00:02:54,864
If you're working off of your laptop.

51
00:02:55,364 --> 00:02:58,754
There's going to be some tool chain
that is going to break with every

52
00:02:58,754 --> 00:03:00,764
patch, every update that you make.

53
00:03:01,314 --> 00:03:04,164
And everyone will have their
own unique sets of challenges.

54
00:03:04,164 --> 00:03:08,724
So you will have end up with things like,
it works on my machine but not on yours.

55
00:03:09,024 --> 00:03:14,499
So the idea is to have a consistent
development experience across enterprise.

56
00:03:15,139 --> 00:03:21,069
Where the setup, the development setup
is more reliable because the VM and

57
00:03:21,069 --> 00:03:22,959
the OS version there doesn't change.

58
00:03:23,169 --> 00:03:24,549
If it changes for everyone.

59
00:03:24,549 --> 00:03:28,149
So that means the remediation and
changes can be made to make sure

60
00:03:28,149 --> 00:03:29,919
your tool chain stays stable.

61
00:03:30,419 --> 00:03:33,849
So let's talk about the
particular problem at slack.

62
00:03:34,099 --> 00:03:34,159
We.

63
00:03:35,109 --> 00:03:39,529
We had a already complicated
rather complex development setup.

64
00:03:39,979 --> 00:03:42,889
But then what happens is when you
acquire new companies, which is the

65
00:03:42,889 --> 00:03:46,199
case, slack itself is an acquisition,
but when you're integrating with

66
00:03:46,539 --> 00:03:50,289
other novel products, which were
not built as part of your code base.

67
00:03:50,289 --> 00:03:54,429
So now you're left with features that
have footprint in multiple code bases,

68
00:03:54,429 --> 00:03:59,059
often in different GitHub accounts, even
different GitHub enterprise accounts.

69
00:03:59,654 --> 00:04:04,354
You still need to make sure you provide
your developers a rather manageable

70
00:04:04,354 --> 00:04:09,014
development environment but still navigate
these different code bases and, you

71
00:04:09,014 --> 00:04:13,454
allow them to have end-to-end testing
so that, the development can be smooth.

72
00:04:13,964 --> 00:04:19,834
So it's going to be tough if you just,
if you're making changes to one repo,

73
00:04:19,834 --> 00:04:22,864
then you wait for it to sync, then
you make changes to the other side.

74
00:04:23,544 --> 00:04:26,484
You use some feature flags or
some versioning to be able to

75
00:04:26,484 --> 00:04:29,724
test things together, that's going
to slow you down considerably.

76
00:04:30,234 --> 00:04:35,634
So to solve that problem in particular,
we had a product that had this

77
00:04:35,634 --> 00:04:39,924
problem that developing that product
required managing both code bases.

78
00:04:40,344 --> 00:04:44,944
So what we did was we built this custom
development environment wherein we had.

79
00:04:45,499 --> 00:04:49,339
We had two docker containers
running both code bases side by

80
00:04:49,339 --> 00:04:53,359
side, and then we relied on port to
port communication so that the two

81
00:04:53,359 --> 00:04:54,919
containers can talk to each other.

82
00:04:55,309 --> 00:05:00,169
So that gave us a environment where
the product can be tested holistically.

83
00:05:00,799 --> 00:05:04,789
And we had the tool chains to be
able to manage both code bases also.

84
00:05:05,119 --> 00:05:10,569
So this was really transformational in
that suddenly you can iterate and develop

85
00:05:10,569 --> 00:05:12,639
features for this product much quicker.

86
00:05:13,139 --> 00:05:16,019
What are the benefits over
traditional locals setups?

87
00:05:16,069 --> 00:05:20,249
For one scalability and speed,
like I said, you get high-end

88
00:05:20,249 --> 00:05:22,229
compute, they're much more elastic.

89
00:05:22,349 --> 00:05:25,439
Depending on your use case,
you might get like a much more.

90
00:05:25,829 --> 00:05:31,340
The VM that is provisioned to you much
might be much higher compute versus when

91
00:05:31,340 --> 00:05:36,809
you're doing something simple like maybe
some STML JavaScript development you might

92
00:05:36,809 --> 00:05:38,969
get a, a sort of lightweight machine.

93
00:05:39,239 --> 00:05:40,590
Depends on what you're doing.

94
00:05:40,929 --> 00:05:43,570
It makes for a consistent
development experience.

95
00:05:43,765 --> 00:05:48,865
You have your entire development team
working on a setup that is consistent.

96
00:05:48,865 --> 00:05:50,935
No, everyone's experience is the same.

97
00:05:51,505 --> 00:05:57,155
It leads to much more secure and
auditable development environment because

98
00:05:57,275 --> 00:06:02,145
you're not having to pull oftentimes
confidential company artifacts to your

99
00:06:02,145 --> 00:06:04,080
local laptop, rather you working on a vm.

100
00:06:04,770 --> 00:06:08,309
That is much more hardened when
it comes to security practices.

101
00:06:08,859 --> 00:06:13,659
You have the principle of least privilege
and all other IEM role-based access

102
00:06:13,659 --> 00:06:17,920
controls are enabled there and most
importantly, least to a faster onboarding.

103
00:06:17,980 --> 00:06:21,730
You have new engineers who are not
spending time setting their laptops.

104
00:06:21,920 --> 00:06:26,030
With one CLI command, they get
a VM that is fully provisioned,

105
00:06:26,060 --> 00:06:29,630
fully set up with everything that
is required to development so they

106
00:06:29,630 --> 00:06:31,250
can be productive from the day one.

107
00:06:31,750 --> 00:06:35,560
So if you look at what is the, like a
high level architecture overview for

108
00:06:35,560 --> 00:06:37,240
these remote development environments?

109
00:06:37,720 --> 00:06:42,790
So each developer gets a personal
remote workspace that has isolated

110
00:06:42,790 --> 00:06:47,610
resources that doesn't share, it shares
resources with the other VMs, but

111
00:06:47,610 --> 00:06:49,980
it doesn't share any logic or data.

112
00:06:50,250 --> 00:06:52,440
So it's completely isolated and it's as.

113
00:06:52,965 --> 00:06:55,695
As good as working on your own
laptop, except it's faster.

114
00:06:56,215 --> 00:07:00,465
You get, you're connected to
these VMs through TLS encrypted

115
00:07:00,465 --> 00:07:03,225
tunnels, usually through secure SSH.

116
00:07:03,885 --> 00:07:09,615
The VMs that power this development
experience usually are, they are

117
00:07:09,705 --> 00:07:11,595
made off of like standard images.

118
00:07:11,865 --> 00:07:14,715
So what you do is, let's say if
you, even if you're supporting

119
00:07:14,715 --> 00:07:17,145
three to four development
environments the flavors of it.

120
00:07:17,655 --> 00:07:20,775
You can identify the commonalities,
like maybe you need Linux

121
00:07:20,775 --> 00:07:21,825
installed on all of them.

122
00:07:21,825 --> 00:07:24,465
Maybe you need some other
binaries installed on all them.

123
00:07:24,825 --> 00:07:29,355
So you can distill all of the common
parts and bake those in into an image.

124
00:07:29,565 --> 00:07:33,805
So you use these base images to
build these development environments.

125
00:07:34,165 --> 00:07:38,215
So again, that just means like those
things are hardened and not left,

126
00:07:38,425 --> 00:07:40,225
to be dealt with by the developer.

127
00:07:40,465 --> 00:07:43,525
So that means like you're gonna have a
much more smooth development experience.

128
00:07:44,025 --> 00:07:46,905
Again, it's gonna be, it will by default.

129
00:07:46,905 --> 00:07:50,445
It is going to be a much more secure
experience just by the fact that you're

130
00:07:50,445 --> 00:07:53,805
not using your own laptop for development.

131
00:07:54,325 --> 00:07:58,075
Because it, it comes most of these
development platforms, it's gonna have.

132
00:07:58,735 --> 00:07:59,785
SSO enabled.

133
00:07:59,965 --> 00:08:03,015
So you can have these VMs are
mostly going to be in your

134
00:08:03,015 --> 00:08:05,765
corp intranet behind firewall.

135
00:08:06,125 --> 00:08:10,315
So without proper accesses they're
not gonna be accessible to anyone.

136
00:08:10,695 --> 00:08:15,025
And again, the usual privileges
and access control mechanisms

137
00:08:15,025 --> 00:08:16,345
will also be available here.

138
00:08:16,845 --> 00:08:21,625
In terms of performance optimization
you're not gonna have cold starts because

139
00:08:21,805 --> 00:08:25,405
you'll be able to pre-built things
or, and have things like remote cache.

140
00:08:25,735 --> 00:08:30,085
So usually in a couple of minutes your
machine is ready because when because of

141
00:08:30,085 --> 00:08:35,665
the shared VM and shared pool, you will
have prebuilt and the images that have

142
00:08:35,665 --> 00:08:37,405
those dependencies already installed.

143
00:08:37,985 --> 00:08:43,355
You will have a pool of VMs, some a warm
pool of VMs ready where we basically,

144
00:08:43,355 --> 00:08:47,625
these environments are ready to go
because depending on your usage in you

145
00:08:47,625 --> 00:08:53,705
might have a set of VMs that are already
provisioned and they're just like.

146
00:08:54,355 --> 00:08:56,995
Provide it to the developer
when it is requested.

147
00:08:57,055 --> 00:09:00,885
So you don't need, really need to
wait for the developer to issue the

148
00:09:00,885 --> 00:09:03,835
command before you start building
these images these machines.

149
00:09:04,585 --> 00:09:06,135
So we are, slack.

150
00:09:06,135 --> 00:09:08,265
We used AWS auto scaling Group.

151
00:09:08,625 --> 00:09:13,675
And like in that we have like sub two
minute, around 92nd startup times.

152
00:09:14,145 --> 00:09:17,325
Like I said, you can cash dependencies
and builds so you don't have

153
00:09:17,325 --> 00:09:18,855
to do everything all the time.

154
00:09:19,065 --> 00:09:21,025
Only when something things change.

155
00:09:21,525 --> 00:09:25,275
So what is a developer flow
for while using these remote

156
00:09:25,335 --> 00:09:26,445
development environments?

157
00:09:26,775 --> 00:09:29,965
So first, you're going to request a new
development development environment.

158
00:09:29,995 --> 00:09:32,515
You'll do it with a simple CLI command.

159
00:09:32,515 --> 00:09:36,275
You'll go to your terminal and maybe
you'll write, get remote dev, your

160
00:09:36,275 --> 00:09:38,255
branch name and some configuration.

161
00:09:38,255 --> 00:09:39,905
Let's say you wanna do
front end developments.

162
00:09:39,905 --> 00:09:42,755
You'll say get remote dev branch name.

163
00:09:43,265 --> 00:09:48,245
Front end or backend ml or any other
configuration that you wanna provide,

164
00:09:48,515 --> 00:09:52,615
depending on that per configuration
the system will then, like our

165
00:09:52,615 --> 00:09:56,905
platform, at least a Slack, it
automatically provisions these VMs.

166
00:09:57,465 --> 00:09:59,685
It's going to install all
the required dependencies.

167
00:09:59,685 --> 00:10:06,585
So if development environment requires
Xcode utilities, or some secure

168
00:10:06,615 --> 00:10:11,795
cryptographic utilities to for key
encryption data encryption, those kind

169
00:10:11,795 --> 00:10:17,325
of things get pre-commit hooks, post-it
hooks any linkers that you might need

170
00:10:17,325 --> 00:10:19,185
or any other tools that you might need.

171
00:10:19,585 --> 00:10:21,325
Those kind of things will be installed.

172
00:10:21,475 --> 00:10:23,545
So usually you have to
write a script for these.

173
00:10:23,900 --> 00:10:27,320
We and every enterprise can
will have these things specific

174
00:10:27,320 --> 00:10:29,150
to them for for at Slack.

175
00:10:29,370 --> 00:10:34,320
We had our own sort of shell scripts
and chef recipes that when these VMs

176
00:10:34,320 --> 00:10:36,610
came up, those volumes are mounted.

177
00:10:36,820 --> 00:10:41,150
The secrets are first from the
secret store and and everything that

178
00:10:41,270 --> 00:10:43,910
needs to be set up and installed
on these machines was done.

179
00:10:44,410 --> 00:10:44,620
Okay.

180
00:10:44,620 --> 00:10:47,020
When it's provisioned, which
like I mentioned, takes 90

181
00:10:47,020 --> 00:10:50,260
seconds, it's done, your remote
environment is now ready for use.

182
00:10:50,590 --> 00:10:53,650
You can connect to it via SSH from vs.

183
00:10:53,650 --> 00:10:55,510
Code cursor, wherever you know.

184
00:10:55,510 --> 00:10:57,550
And this, you get access to a terminal.

185
00:10:57,970 --> 00:11:03,410
So it's like working at your own laptop
except you have access to a vm, which is

186
00:11:03,590 --> 00:11:05,780
much more reliable and much more powerful.

187
00:11:06,020 --> 00:11:07,355
And then, you can code away.

188
00:11:07,930 --> 00:11:12,500
It's you get a branch checked out with
the branch name you provided, and you

189
00:11:12,500 --> 00:11:17,340
can start checking things and merging
code because you're also integrated.

190
00:11:17,400 --> 00:11:21,450
The VM is integrated with git
with your source control system.

191
00:11:21,950 --> 00:11:26,080
You can in, it at Slack at least, we
have dynamic provisioning, which means.

192
00:11:26,840 --> 00:11:31,070
In the config, in the CLI
command, we indicate what kind of

193
00:11:31,070 --> 00:11:32,420
development environment we need.

194
00:11:32,900 --> 00:11:36,380
If it is front end development,
maybe you will get a machine

195
00:11:36,380 --> 00:11:37,670
with different parameters.

196
00:11:37,700 --> 00:11:41,480
It's going to be, maybe you'll get
like MX large or something like

197
00:11:41,690 --> 00:11:43,660
I'm talking about Amazon ESGs.

198
00:11:44,210 --> 00:11:46,850
And if you indicate you need
machine learning data sounds

199
00:11:46,850 --> 00:11:49,185
assigned backend, you can predefine.

200
00:11:49,840 --> 00:11:53,500
Like what, how many cores of
CPU, what kind of gigabits of

201
00:11:53,500 --> 00:11:55,180
rams that should be provisioned?

202
00:11:55,510 --> 00:11:57,730
And according to your
enterprise development needs,

203
00:11:58,030 --> 00:11:59,680
you can set these parameters.

204
00:11:59,890 --> 00:12:03,950
So this gives you that level of
control where if you doing something

205
00:12:03,950 --> 00:12:07,350
really compute intensive, you can
ask for a bigger much more powerful

206
00:12:07,350 --> 00:12:10,400
machine in terms of accessing code.

207
00:12:10,935 --> 00:12:11,925
On these VMs.

208
00:12:12,315 --> 00:12:15,825
So obviously you, the first thing,
once everything is set up on these VMs,

209
00:12:15,825 --> 00:12:17,565
you wanna download your code, right?

210
00:12:17,565 --> 00:12:20,095
You wanna check out your git repository.

211
00:12:20,425 --> 00:12:22,855
So there are few ways to do that.

212
00:12:22,855 --> 00:12:28,040
You can do that by on laptops you
basically run your Git commands.

213
00:12:28,040 --> 00:12:31,505
So what you can do is one of the
options, at least when we were

214
00:12:31,685 --> 00:12:35,515
thinking about this at Slack, we
were evaluating these two approaches.

215
00:12:35,515 --> 00:12:37,195
One is S agent for wording.

216
00:12:38,030 --> 00:12:42,450
When we work at laptop, basically we
use our SSH keys which are added to the

217
00:12:42,660 --> 00:12:48,280
GitHub repo, and we are able to fetch
and pull and push, merge our GitHub repo.

218
00:12:48,690 --> 00:12:54,320
So we just basically for our SSH
credentials to the vm, and then

219
00:12:54,380 --> 00:12:55,970
we run these commands from V vm.

220
00:12:56,025 --> 00:12:58,545
It uses our SSH credentials
from the laptop.

221
00:12:58,545 --> 00:13:01,425
And it's done over a security
LS connection, this is

222
00:13:01,425 --> 00:13:03,345
encrypted and completely safe.

223
00:13:03,745 --> 00:13:08,135
And it doesn't require any other setup
because it's as if you are issuing these

224
00:13:08,165 --> 00:13:10,215
git commands from your local laptop.

225
00:13:10,605 --> 00:13:12,070
The other way to do that is basically.

226
00:13:12,695 --> 00:13:15,575
Authenticate to GitHub to be
able to use the code is you

227
00:13:15,575 --> 00:13:17,375
can create a GitHub oath app.

228
00:13:17,585 --> 00:13:21,625
It is a managed way of doing things
very easy setup and integration.

229
00:13:21,875 --> 00:13:26,955
But you do have to be mindful of token
scopes, revocation, making sure you,

230
00:13:27,325 --> 00:13:31,695
the tokens are not expiring or you
are renewing your secrets and keys.

231
00:13:32,275 --> 00:13:34,975
And with token there is
always this potential of

232
00:13:34,975 --> 00:13:36,685
misuse if they're compromised.

233
00:13:37,045 --> 00:13:40,465
So we ended up going with the
SSS agent for all these reasons.

234
00:13:40,965 --> 00:13:45,465
Now because you're building these features
with this development and environment

235
00:13:45,465 --> 00:13:50,175
yourself, you can build some unique
features that cater to your use cases.

236
00:13:50,385 --> 00:13:52,005
So I'm going to talk
about one of them here.

237
00:13:52,770 --> 00:13:56,640
So one, one of the features that we
implemented for this is frontend grafting.

238
00:13:57,000 --> 00:14:02,210
So frontend grafting is allows
us to basically graft or put the

239
00:14:02,240 --> 00:14:07,760
frontend assets or bundles, which
means J-H-T-M-L, JavaScript or

240
00:14:07,820 --> 00:14:10,550
react, all of that from another vm.

241
00:14:11,085 --> 00:14:16,215
Onto, let's say, a different development
environment or even staging or prod code.

242
00:14:16,725 --> 00:14:21,145
So oftentimes we build something, but we
are not able to test it with production

243
00:14:21,145 --> 00:14:25,585
like data or shapes or configuration
and the development environments we

244
00:14:25,585 --> 00:14:29,875
use, they just lack that sort of data
to be able to confidently test things.

245
00:14:30,205 --> 00:14:31,165
So what this did was.

246
00:14:31,855 --> 00:14:36,865
We basically built a grafting mechanism
to test with like real world data

247
00:14:37,195 --> 00:14:42,755
where you can go to your pro and then
you can u using special query paras.

248
00:14:43,385 --> 00:14:49,705
You are able to tell that fetch all the
front end assets and bundles from this vm.

249
00:14:50,275 --> 00:14:54,125
The VM that you are using, the
remote development environment that

250
00:14:54,125 --> 00:14:55,775
you are using to build front end.

251
00:14:56,405 --> 00:14:57,905
Again, this is all secure.

252
00:14:58,445 --> 00:15:03,030
It's a, it, you have to be within the
company firewall and so there's no

253
00:15:03,030 --> 00:15:07,700
potential of misuse here, but it's
a very innovative way of basically

254
00:15:07,700 --> 00:15:12,540
using front end that is supported
from one environment and back end

255
00:15:12,540 --> 00:15:13,860
that is from another environment.

256
00:15:14,360 --> 00:15:15,950
And there's obvious benefits here.

257
00:15:16,000 --> 00:15:16,140
You.

258
00:15:16,850 --> 00:15:20,360
Because for our product we had to
do it because the front end is from,

259
00:15:20,420 --> 00:15:24,390
it lives in one code base at least
some of the assets were, and the back

260
00:15:24,390 --> 00:15:26,080
end of the services is in another.

261
00:15:26,650 --> 00:15:30,790
So yeah, that was one innovative sort
of solution that we came up with.

262
00:15:31,150 --> 00:15:34,390
But building our own custom
remote development of that

263
00:15:34,390 --> 00:15:38,950
environment is what enabled us to
be able to build this No other.

264
00:15:39,850 --> 00:15:40,600
Off the shelf.

265
00:15:41,400 --> 00:15:43,440
Cloud IDE would provide this.

266
00:15:43,940 --> 00:15:47,420
So yeah, these development
environments, they are integrated

267
00:15:47,420 --> 00:15:50,900
with your usual enterprise systems
that you need for development,

268
00:15:51,260 --> 00:15:53,030
version control, pr, workflow.

269
00:15:53,060 --> 00:15:54,230
I already mentioned that.

270
00:15:54,540 --> 00:15:59,150
They, when the VMs come up you use Visual
Studio Code, you already have your Git

271
00:15:59,490 --> 00:16:01,530
code checked out, so you're able to.

272
00:16:01,885 --> 00:16:02,995
Look at GI history.

273
00:16:02,995 --> 00:16:08,215
We are able to create branches, forks
do the usual things that you do, create,

274
00:16:08,455 --> 00:16:10,165
pull requests, all sorts of things.

275
00:16:10,675 --> 00:16:14,505
And they're also aligned integrated
with the CICD systems because

276
00:16:14,505 --> 00:16:15,585
you are doing it yourself.

277
00:16:16,005 --> 00:16:19,965
It's like a bare metal vm and you
can in, you can do anything on it.

278
00:16:20,315 --> 00:16:24,345
Yeah, you you can have
integration with CI CD pipelines.

279
00:16:24,345 --> 00:16:27,455
You can run your tests issue
commands to run test in your

280
00:16:27,505 --> 00:16:29,185
Jenkins, if that's what you use.

281
00:16:29,725 --> 00:16:31,495
You can trigger CI workflow.

282
00:16:31,820 --> 00:16:36,020
From the cloud id any other
tool that you might be needing?

283
00:16:36,090 --> 00:16:40,290
Let's say if you have custom tools for
code reviews, issue trackers, let's say

284
00:16:40,320 --> 00:16:46,010
Jira, or triggers or hooks any other
dashboards, everything can be accessed

285
00:16:46,220 --> 00:16:49,100
because it's basically another computer
that you've been given access to.

286
00:16:49,650 --> 00:16:51,840
The integration with
Enterprise Secret Management.

287
00:16:52,170 --> 00:16:56,280
Most enterprise software companies,
like there is some sort of secret store

288
00:16:56,380 --> 00:17:01,330
that is used where the keys are pulled
from the secret store at runtime.

289
00:17:01,880 --> 00:17:04,250
And these keys are rotated at a cadence.

290
00:17:04,460 --> 00:17:07,250
But yeah, that integration is also done.

291
00:17:07,250 --> 00:17:09,150
And we did that for our use case.

292
00:17:09,650 --> 00:17:13,010
In terms of how do you, so there
needs to be a operational playbook

293
00:17:13,040 --> 00:17:14,570
and like a rollout strategy.

294
00:17:14,930 --> 00:17:19,010
If you build this from the ground up,
it's not going to be like you certainly

295
00:17:19,010 --> 00:17:23,680
announce it and that, it's ga you have
to treat it like a product that just

296
00:17:23,680 --> 00:17:25,690
happens to be used inter internally.

297
00:17:26,200 --> 00:17:28,270
So maybe start with the small pilot team.

298
00:17:28,600 --> 00:17:34,150
Get them to use this as they're using
it because developers are your users.

299
00:17:34,360 --> 00:17:38,590
They're going to have feedback that you
can inculcate in the product lifecycle.

300
00:17:38,980 --> 00:17:42,160
You can prioritize the features
that developers need the most.

301
00:17:42,160 --> 00:17:47,030
Maybe they need some tooling that is
missing, or maybe they need linkers

302
00:17:47,100 --> 00:17:51,570
that is extremely important, or the
ability to run tests from these IDs.

303
00:17:51,870 --> 00:17:53,290
So this kind of feedback you will get.

304
00:17:53,950 --> 00:17:58,460
And you're gonna have these teams
onboard in phases and that will allow

305
00:17:58,460 --> 00:18:02,640
you the time and the feedback necessary
to be able to build something useful.

306
00:18:03,140 --> 00:18:08,300
You we have, you have Redfin playbooks
for OP operational tasks, because this

307
00:18:08,300 --> 00:18:12,120
is going to be new vm maybe some of
the developers have only worked on

308
00:18:12,120 --> 00:18:16,800
Windows or Mac, and suddenly they have
to work with a Unix or a you, or open

309
00:18:16,800 --> 00:18:18,870
to OS depending on what your VM has.

310
00:18:19,170 --> 00:18:22,400
So you need to have these operational
tasks, these scripts these life,

311
00:18:22,550 --> 00:18:25,820
maybe even docker lifecycle
commands, everything documented.

312
00:18:26,285 --> 00:18:28,775
In a playbook so that
developers can do that.

313
00:18:28,965 --> 00:18:32,395
So yeah, that sort of is connected
to the training and documentation

314
00:18:32,395 --> 00:18:37,735
bit as, and when you get irate you
can add more features to it because

315
00:18:37,735 --> 00:18:39,235
there is some barrier to entry here.

316
00:18:39,235 --> 00:18:41,725
There is a considerable
in initial investment.

317
00:18:42,115 --> 00:18:45,605
So you were not going to be able
to build everything at once.

318
00:18:45,605 --> 00:18:49,945
You have to prioritize what parts
of the code, base or the development

319
00:18:49,945 --> 00:18:51,775
flow can you support first.

320
00:18:52,175 --> 00:18:54,785
And that is where the feedback
is going to be important.

321
00:18:55,335 --> 00:19:00,275
Obviously like for something like
this you have VMs and you have these

322
00:19:00,645 --> 00:19:03,040
these essentially autoscale groups.

323
00:19:03,540 --> 00:19:06,360
And that are being shared, but
you want to make sure that you

324
00:19:06,360 --> 00:19:07,980
do it in a cost effective manner.

325
00:19:08,430 --> 00:19:13,860
So what are some strategies that you can
use to make sure there is no overspend?

326
00:19:14,340 --> 00:19:16,110
There are a few strategies that we use.

327
00:19:16,260 --> 00:19:20,040
Obviously these development
environments are provisioned on

328
00:19:20,040 --> 00:19:22,420
demand and they are ephemeral.

329
00:19:22,580 --> 00:19:24,710
By default they will have
a life cycle, let's say.

330
00:19:25,370 --> 00:19:29,790
Maybe a week or two weeks, and then
you get warnings and then they are

331
00:19:29,840 --> 00:19:34,210
they, they're killed and you know that
space is available for someone else.

332
00:19:34,570 --> 00:19:36,810
But even other than that you can have.

333
00:19:37,515 --> 00:19:44,095
In dev environments suspend or,
may go to sleep when there is idle

334
00:19:44,095 --> 00:19:47,035
time detected like 30 minutes,
one hour, things like that.

335
00:19:47,485 --> 00:19:51,295
You also have to be mindful of what
size of instances you're using, so

336
00:19:51,295 --> 00:19:53,595
if that's where the config comes in.

337
00:19:53,595 --> 00:19:57,610
So if it's important that you map
the hardware that you're providing.

338
00:19:58,210 --> 00:20:03,160
To the use case that the developer
has if they're doing some simple front

339
00:20:03,160 --> 00:20:06,820
end development, you have to use the
right size instance to make sure that

340
00:20:07,030 --> 00:20:10,990
you're not just throwing hardware at
a problem that doesn't require it.

341
00:20:11,690 --> 00:20:13,520
This is multi-tenant by default because.

342
00:20:14,000 --> 00:20:17,840
Behind the scenes is basically
one machine that is serving these

343
00:20:18,200 --> 00:20:19,920
that is using virtualization.

344
00:20:19,920 --> 00:20:24,390
You have multiple VMs and they're
all running these docker containers

345
00:20:24,390 --> 00:20:25,900
that is helping you develop.

346
00:20:26,400 --> 00:20:30,215
And yeah we need to be, you're
keeping an eye on the cloud costs.

347
00:20:30,215 --> 00:20:34,535
So you have to have dashboards
billing and need to have some

348
00:20:34,535 --> 00:20:39,075
alert set up to make sure that
you are not crossing your budgets.

349
00:20:39,075 --> 00:20:41,955
And if you are, you might need
to provision more capacity.

350
00:20:42,435 --> 00:20:45,615
It's a good problem to have if
you get that kind of adoption.

351
00:20:45,615 --> 00:20:49,335
It's a good problem to have, and, but
it certainly requires preparedness.

352
00:20:49,835 --> 00:20:53,565
And yeah, like I said, you cannot just
throw like realistically speaking,

353
00:20:53,565 --> 00:20:55,590
just more hardware at things.

354
00:20:55,950 --> 00:21:00,140
So while you want, faster performance
for your developments, you also

355
00:21:00,140 --> 00:21:02,150
have to balance it with cost.

356
00:21:02,570 --> 00:21:06,715
So every organization will
stumble upon the right trade off.

357
00:21:06,960 --> 00:21:10,020
That is good for them,
depending on where they are.

358
00:21:10,890 --> 00:21:12,330
But it's just something to keep in mind.

359
00:21:12,830 --> 00:21:17,640
Having sort of these enterprise
cloud IDE platforms you can, because

360
00:21:17,640 --> 00:21:21,640
this is a consistent development
experience provides parity.

361
00:21:21,880 --> 00:21:26,560
You can enforce po policy guardrails,
you can have auditing, you can have

362
00:21:26,590 --> 00:21:28,450
access and compliance management.

363
00:21:28,775 --> 00:21:32,215
For every audit because if you're
creating an audit trail you can

364
00:21:32,215 --> 00:21:34,915
be sock to compliant by default.

365
00:21:35,365 --> 00:21:39,955
Admins will be able to restrict the
images, machine sizes, the network access.

366
00:21:40,255 --> 00:21:42,625
There's a lot more control
that you will have.

367
00:21:43,055 --> 00:21:47,270
When the development is happening on these
remote development environments there

368
00:21:47,270 --> 00:21:51,230
is going to be some level of developer
autonomy for sure, because eventually what

369
00:21:51,230 --> 00:21:55,250
you wanna do is you wanna give them a VM
with their terminal where they can install

370
00:21:55,250 --> 00:21:57,220
things if they need to for their use case.

371
00:21:57,920 --> 00:22:01,310
And they want, let's say if there
is ID extension they want, or they

372
00:22:01,310 --> 00:22:05,360
want a custom linter or a DING
package, they can do all of that.

373
00:22:05,360 --> 00:22:06,980
So there's that level of autonomy too.

374
00:22:07,470 --> 00:22:10,700
But the core pieces of the
product are going to be hardened.

375
00:22:11,200 --> 00:22:14,590
So let's talk about some of the lessons
learned and some recommendations

376
00:22:14,590 --> 00:22:15,880
that came out of this project.

377
00:22:16,450 --> 00:22:21,010
So it's because there is some investment
it, there is some barrier for entry here.

378
00:22:21,700 --> 00:22:25,720
Yeah, it's probably more
suited to a bigger code basis.

379
00:22:26,030 --> 00:22:30,530
If, like for it to be a justifiable
decision, you have to have

380
00:22:30,530 --> 00:22:34,530
real issues scaling on your
laptop development code flow.

381
00:22:35,010 --> 00:22:38,010
So if you're having that, those issues,
this is the right choice for you.

382
00:22:38,010 --> 00:22:43,415
But if it is still manageable, because
of the effort the effort is non-trivial.

383
00:22:44,065 --> 00:22:49,025
It might not justify right away though if
your company grows your code base grows.

384
00:22:49,055 --> 00:22:51,035
Eventually you will end up using this.

385
00:22:51,575 --> 00:22:53,495
Always I trade with feedback.

386
00:22:53,615 --> 00:22:57,215
Prioritize the things that matters
to the development team, to the

387
00:22:57,215 --> 00:22:58,775
developers in your organization.

388
00:22:58,775 --> 00:23:02,175
First provide environment
FLA flavors, which meant.

389
00:23:02,940 --> 00:23:07,290
Have these, category or different
categories of development environments

390
00:23:07,390 --> 00:23:12,220
where the, you have the right size of
VM and compute resources available for.

391
00:23:12,940 --> 00:23:17,470
The kind of work you're doing that will
may help you be more cost effective.

392
00:23:17,950 --> 00:23:22,120
Just as a sort of a side note, Uber
created six flavors of these dev

393
00:23:22,120 --> 00:23:24,280
environments to cater to different needs.

394
00:23:24,410 --> 00:23:27,620
We, at Slack we also have at
least four four or that I can

395
00:23:27,620 --> 00:23:29,190
think of for different things.

396
00:23:29,690 --> 00:23:31,160
Some real world success story.

397
00:23:31,290 --> 00:23:34,840
I'm proud to say at Slack we've
been very successful for these I.

398
00:23:35,410 --> 00:23:41,980
Don't think I, there are many developers
who use local laptop development for

399
00:23:41,980 --> 00:23:48,100
this product in particular because it's
just di very difficult to, I manage those

400
00:23:48,100 --> 00:23:50,180
two code bases on the single laptop.

401
00:23:50,180 --> 00:23:54,575
So around 90% reduction rate
has been very successful for us.

402
00:23:55,340 --> 00:23:57,430
And again, some other benchmarks.

403
00:23:57,530 --> 00:24:03,410
Around 75% build time reduction,
because you are using a bigger machine

404
00:24:03,690 --> 00:24:08,100
and multiple machines that are able to
have cashed bills and a remote cash.

405
00:24:08,570 --> 00:24:12,470
So you're able to reduce that
time, which is a huge boost.

406
00:24:12,990 --> 00:24:15,750
Then there is a case study
came out of Uber where they

407
00:24:15,750 --> 00:24:17,550
had a internal dev PO system.

408
00:24:17,960 --> 00:24:21,260
It allows choosing large
machines up to 48 CPU codes.

409
00:24:21,380 --> 00:24:24,190
That must be for a specific use case.

410
00:24:24,705 --> 00:24:28,615
And then, obviously a laptop can never
scale to that kind of requirement.

411
00:24:29,155 --> 00:24:32,515
And the biggest plus
is you are productive.

412
00:24:32,545 --> 00:24:35,875
Your engineers are productive from
day one because they're not spending

413
00:24:35,875 --> 00:24:37,675
time just setting up machine.

414
00:24:38,175 --> 00:24:43,125
So to conclude what it offers, I
think the key takeaway is that moving

415
00:24:43,125 --> 00:24:47,225
to enterprise development with cloud
IDs, remote development environment.

416
00:24:48,105 --> 00:24:51,645
It's going to speed up your engineering
and while making your development

417
00:24:51,645 --> 00:24:57,585
workflows extremely secure you, it'll
enable us to you to leverage powerful

418
00:24:57,585 --> 00:25:02,295
infrastructure and have some sort
of centralized control to solve all

419
00:25:02,295 --> 00:25:05,945
those reliability issues where things
are working on once one developer's

420
00:25:05,945 --> 00:25:07,475
computer, laptop, but not another.

421
00:25:07,475 --> 00:25:11,785
So those kind of things that you
can completely take out by moving

422
00:25:11,785 --> 00:25:13,285
to remote development environments.

423
00:25:13,990 --> 00:25:17,110
Yeah, and you can architect and
cater it for your own requirements.

424
00:25:18,040 --> 00:25:18,580
That's the thing.

425
00:25:18,970 --> 00:25:21,670
So yeah, I'd a it's a very
transformative project.

426
00:25:21,730 --> 00:25:23,860
If it is successful, it changes.

427
00:25:23,920 --> 00:25:27,890
It's a complete overhaul of
your development experience.

428
00:25:28,280 --> 00:25:32,060
It might have long lasting permanent
changes to your engineering culture

429
00:25:32,060 --> 00:25:37,560
even because if it improves development,
velocity, productivity it it's a good

430
00:25:37,560 --> 00:25:39,210
thing for the organization overall.

431
00:25:39,800 --> 00:25:41,900
That's what, that's all I had for today.

432
00:25:42,290 --> 00:25:47,510
Thank you for allowing me the opportunity
to present at Platform Engineering Con 42.

433
00:25:47,510 --> 00:25:47,780
Thank you.

434
00:25:48,280 --> 00:25:48,570
Okay.

