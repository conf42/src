1
00:00:00,000 --> 00:00:04,170
Hello and welcome in this presentation,
why and how Build Your Own Web

2
00:00:04,170 --> 00:00:09,729
Server in C I'm Luka and I will
present you as the last project I

3
00:00:09,729 --> 00:00:12,639
work on it, how I did and why I did

4
00:00:13,139 --> 00:00:17,279
before starting talking about the
project, maybe some introduction about my

5
00:00:17,279 --> 00:00:24,329
developer journey that we explain you why
I starting to be in West about burning my.

6
00:00:24,575 --> 00:00:25,355
own web server.

7
00:00:25,854 --> 00:00:31,654
I think that my journey will feel
familiar to many of you, because I first

8
00:00:31,694 --> 00:00:35,084
started to explore IT very broadly.

9
00:00:35,655 --> 00:00:40,705
I learned what is computer, how server
work, how internet function, what is

10
00:00:40,705 --> 00:00:42,705
a website, all this kind of stuff.

11
00:00:43,705 --> 00:00:49,920
of course, after that, I would like
to create my own website, so I'm

12
00:00:49,930 --> 00:00:52,860
starting to use a CMS to build one.

13
00:00:53,360 --> 00:01:03,779
Then I began to learn code, HTML, CSS,
JavaScript, PHP, a lot of other language.

14
00:01:04,679 --> 00:01:10,339
And naturally, the next step for me was
to use my coding skill to create my own.

15
00:01:11,159 --> 00:01:14,589
Our own website, but this time
from scratch, without any CMS.

16
00:01:15,089 --> 00:01:22,009
but when we have our own website
that presents you safe, we need

17
00:01:22,009 --> 00:01:26,159
to think about, okay, what else
we can do, what else we can build.

18
00:01:26,659 --> 00:01:29,479
at this moment, you have
different possibility.

19
00:01:30,069 --> 00:01:35,709
And I think is where our path start
probably to go in different direction.

20
00:01:36,269 --> 00:01:42,289
Most of us, and including myself, the next
step is that to build more application.

21
00:01:42,639 --> 00:01:48,044
So you have the CastingTutories project,
you have a booking system, and so on.

22
00:01:48,824 --> 00:01:50,424
But it's not the only part.

23
00:01:51,044 --> 00:01:55,374
some prefer focus on infrastructure,
and so we underlist server

24
00:01:55,394 --> 00:01:56,804
and services themselves.

25
00:01:57,634 --> 00:02:00,954
But in fact, we could continue
to go deeper, like why

26
00:02:00,954 --> 00:02:02,944
stop here building website?

27
00:02:03,324 --> 00:02:08,434
Why not trying to create your own
services and your own web server?

28
00:02:08,934 --> 00:02:11,844
the main reason is probably that
because we are software engineers.

29
00:02:12,604 --> 00:02:16,544
And as a software engineer, we
are focused usually on building

30
00:02:16,714 --> 00:02:20,994
applications, developing new
features, implementing business

31
00:02:21,194 --> 00:02:23,894
logic, but not really about systems.

32
00:02:24,824 --> 00:02:29,734
In my career, I made the transition
from software engineer to situability

33
00:02:29,904 --> 00:02:34,424
engineer, and it's at this moment
that systems become truly important

34
00:02:34,434 --> 00:02:40,889
to me, because like my focus shift
Towards service, how to monitor them,

35
00:02:40,919 --> 00:02:43,679
how to automate action to the service.

36
00:02:44,309 --> 00:02:47,939
And it's at this moment that it hit me.

37
00:02:48,399 --> 00:02:52,169
Why I do not build my own web server.

38
00:02:52,549 --> 00:02:57,609
One that will solve maybe my biggest
frustration with existing web server.

39
00:02:58,109 --> 00:03:00,359
before the, the first thing.

40
00:03:00,704 --> 00:03:03,864
Okay, is to understand why we
want to build a web server,

41
00:03:04,234 --> 00:03:05,244
and not something else.

42
00:03:05,524 --> 00:03:11,924
Okay, it's very challenging to
build a system and you have many

43
00:03:12,524 --> 00:03:15,164
things to consider before starting.

44
00:03:15,664 --> 00:03:19,724
first, it's a great opportunity, okay,
to learn about a fundamental service.

45
00:03:20,224 --> 00:03:25,904
it will help you to better understand
how the current system works and why they

46
00:03:25,904 --> 00:03:28,674
are designed this way and not another.

47
00:03:29,174 --> 00:03:33,234
Like any project, of course, it's a
great way to showcase your software

48
00:03:33,254 --> 00:03:37,804
engineering skills, especially if
you are a backend engineer, where it

49
00:03:37,804 --> 00:03:41,754
could be more difficult than when you
are frontend and can create websites.

50
00:03:42,254 --> 00:03:43,414
but why a web server?

51
00:03:43,804 --> 00:03:46,084
Why not like a database, for example?

52
00:03:46,584 --> 00:03:51,124
the reason it's simple is because
a web server is relatively simple,

53
00:03:52,064 --> 00:03:53,754
if you compare it to a database.

54
00:03:54,254 --> 00:03:57,854
but even if it's simple, you
have a variety of complex

55
00:03:57,904 --> 00:03:59,934
problems that you need to solve.

56
00:04:00,434 --> 00:04:03,394
So before the whole,
let's talk about the what.

57
00:04:03,494 --> 00:04:04,294
Even if.

58
00:04:04,879 --> 00:04:09,099
I think we all know what is a web server,
but it's still important to define what

59
00:04:09,179 --> 00:04:12,749
we want built before jumping on the code.

60
00:04:13,249 --> 00:04:19,849
a web server can be described through a
few key functionality and non functional.

61
00:04:20,349 --> 00:04:21,699
first, it's a service.

62
00:04:22,144 --> 00:04:27,434
running on the host, is listening
on a port, usually the AT.

63
00:04:27,934 --> 00:04:33,164
it can manage HTTP requests and
it will generate HTTP response.

64
00:04:33,504 --> 00:04:35,094
So that is for the functionality.

65
00:04:35,094 --> 00:04:39,574
The non functionality will be a web
server is secure with authentication,

66
00:04:40,074 --> 00:04:45,544
is reliable, that means it will not
crash when it will have heavy usage.

67
00:04:46,044 --> 00:04:51,174
it's performance and have, a good
scalability, and, it's not necessary

68
00:04:51,174 --> 00:04:55,844
too, but I had it for my WAMP server,
it need to be easy to operate,

69
00:04:56,414 --> 00:04:57,974
especially for administrator or SRE.

70
00:04:58,474 --> 00:05:04,594
The first challenge is, even before
you start to build it, the first

71
00:05:04,594 --> 00:05:06,284
challenge, it's about the platform.

72
00:05:06,784 --> 00:05:10,944
Most of web servers today run on Linux,
so if you are building one today,

73
00:05:10,994 --> 00:05:12,494
you need to work on that platform.

74
00:05:13,204 --> 00:05:17,684
But at the same time, I personally
use Windows, and I remember that my

75
00:05:17,684 --> 00:05:23,354
first web server that I installed,
that was Apache with the WAMP stack.

76
00:05:24,074 --> 00:05:29,564
was on Windows, and so I want that my
web server be available also for people

77
00:05:29,634 --> 00:05:33,294
that didn't migrate yet on Linux.

78
00:05:33,794 --> 00:05:35,024
So that is the third challenge.

79
00:05:35,224 --> 00:05:41,254
Fortunately, today, at NET Core, you can
write your code in C Sharp, and write

80
00:05:41,609 --> 00:05:44,839
and run it both on Linux and Windows.

81
00:05:45,169 --> 00:05:48,709
It was not the case before, so I'm
really happy today to be able to do that

82
00:05:48,729 --> 00:05:50,819
in C Sharp is a huge progress for us.

83
00:05:51,319 --> 00:05:55,459
Of course, there is still some platform
specific consideration, okay, like

84
00:05:55,739 --> 00:06:01,099
the path, the metric, or everything
about the scripting, but we can

85
00:06:01,819 --> 00:06:06,989
handle this challenge with the right
architecture and the proper abstraction.

86
00:06:07,489 --> 00:06:10,149
So now, let's see Let's
take a look, at the code.

87
00:06:10,699 --> 00:06:13,709
Building a server and connecting to it.

88
00:06:14,209 --> 00:06:15,569
is in fact pretty simple.

89
00:06:16,069 --> 00:06:19,149
What we call a server is
essentially just a TCP listener,

90
00:06:19,409 --> 00:06:22,529
defined by an address and a port.

91
00:06:23,509 --> 00:06:24,249
And that's it.

92
00:06:24,279 --> 00:06:28,589
You can start it, and it will begin
to listen for incoming connection.

93
00:06:29,089 --> 00:06:33,319
It's so simple that, someone
recently tweeted, wait, a web server

94
00:06:33,319 --> 00:06:35,519
is basically an infinite loop.

95
00:06:36,259 --> 00:06:41,689
And while, of course, the real
answer is more complex, It's not

96
00:06:41,849 --> 00:06:47,089
entirely wrong, we can define it
like an infinite loop and that's all.

97
00:06:47,589 --> 00:06:52,809
The step two, okay, I connect to
my server, it's pretty cool, but

98
00:06:53,279 --> 00:06:57,019
to really be a web server, you
need to do what a web server do.

99
00:06:57,389 --> 00:07:01,419
That means respond with an HTTP response,
otherwise it's not a web server,

100
00:07:01,419 --> 00:07:03,109
it can be another kind of server.

101
00:07:03,609 --> 00:07:07,779
HTTP requests and responses are
actually quite simple to understand.

102
00:07:08,699 --> 00:07:10,739
They consist, in three parts.

103
00:07:11,029 --> 00:07:14,719
The status line, the header, and the body.

104
00:07:15,179 --> 00:07:19,049
Each part will be separated by
an empty line, so they are pretty

105
00:07:19,049 --> 00:07:20,879
easy to parse or even to read.

106
00:07:21,379 --> 00:07:25,559
to test that, we can create
a basic response and send

107
00:07:25,749 --> 00:07:27,809
it back to every connection.

108
00:07:28,309 --> 00:07:33,639
And with a simple, GET request, we can
see here the GET request to my localhost

109
00:07:33,719 --> 00:07:38,879
port 8080, we can see that my server
a response with hello world, just as

110
00:07:38,999 --> 00:07:45,659
expected, and the HTTP response is
understood by the program that call it.

111
00:07:46,159 --> 00:07:49,739
Of course, we need to add
more logic to our service.

112
00:07:50,259 --> 00:07:54,719
That means we need to pass the
HTTP request that, again, is like

113
00:07:54,729 --> 00:08:00,594
the response very simple in, three
part separate by a blank line.

114
00:08:01,504 --> 00:08:01,944
Okay.

115
00:08:02,514 --> 00:08:08,354
with this passing and especially the HTTP
request line, we can start to introduce

116
00:08:08,354 --> 00:08:14,284
some logic to handle different requests
instead of always returning hello world.

117
00:08:14,784 --> 00:08:15,134
Okay.

118
00:08:15,604 --> 00:08:18,324
challenge number two,
underlying connection.

119
00:08:18,824 --> 00:08:22,334
How server receive connection and
we need to manage them properly.

120
00:08:22,894 --> 00:08:25,704
So let's set the following route.

121
00:08:26,229 --> 00:08:31,579
a requirement for how connection model,
as a component that's under the connection

122
00:08:31,589 --> 00:08:38,469
should be modular to make it easy to
integrate, remove or change in the future.

123
00:08:38,969 --> 00:08:45,269
When we receive a connection, we need to
decide if we will accept or reject the

124
00:08:45,269 --> 00:08:50,909
connection as a hunter, entire life cycle
of the connection must also be, managed.

125
00:08:51,894 --> 00:08:55,504
That means we must accept the
connection, but we must also

126
00:08:55,704 --> 00:08:58,284
ensure it gets closed properly.

127
00:08:58,784 --> 00:09:01,114
And of course, the
request should be shared.

128
00:09:01,719 --> 00:09:05,469
And an HTTP response must be
sent back, because after all,

129
00:09:05,709 --> 00:09:07,659
we are building a web server.

130
00:09:08,159 --> 00:09:14,739
our service, that is the main program,
will have, in fact, different modules.

131
00:09:15,319 --> 00:09:18,159
And the first one, we will
call it the web module.

132
00:09:18,899 --> 00:09:28,334
This module will include functions like,
start, run, Stop, and with the when

133
00:09:28,334 --> 00:09:31,334
function, we will undo the connection.

134
00:09:31,834 --> 00:09:36,794
the previous code is now moved in
the when function of the module.

135
00:09:37,294 --> 00:09:42,144
And we can see that when a
connection arrives, we, we accept

136
00:09:42,154 --> 00:09:48,784
the socket and we call the accept
connection async to manage it.

137
00:09:49,284 --> 00:09:54,644
Connection is the first challenge because
it's a consumer resource to your server.

138
00:09:55,394 --> 00:09:59,464
This means we need to set a limit
of the number of connections

139
00:09:59,554 --> 00:10:01,174
we can accept at the same time.

140
00:10:01,674 --> 00:10:04,104
So we'll implement tool limit.

141
00:10:04,444 --> 00:10:07,654
the first one is the number
of connection we will serve.

142
00:10:08,284 --> 00:10:10,504
That mean the connection arrive.

143
00:10:11,504 --> 00:10:18,104
we accept the connection, and we will
do, regarding the path in the request,

144
00:10:18,424 --> 00:10:21,284
what the client asks to our server.

145
00:10:22,194 --> 00:10:27,644
When this limit is reached, that
means we are starting to serve too

146
00:10:27,644 --> 00:10:32,554
many clients at the same time, we
will start to reject the connection.

147
00:10:33,054 --> 00:10:37,774
But, still with a limit, a second
threshold for the connection that

148
00:10:37,824 --> 00:10:43,114
we can't serve, but we can still
respond with a good HTTP response.

149
00:10:43,614 --> 00:10:49,894
And finally, if we are really overwhelmed,
why would we simply close Or a new

150
00:10:49,914 --> 00:10:52,064
connection without any response.

151
00:10:52,514 --> 00:10:57,924
It's a little brutal for the client,
but it's needed for the server because

152
00:10:57,924 --> 00:11:00,254
it really cannot just transfer.

153
00:11:00,754 --> 00:11:06,324
We will start with the connection that
we reject, nicely, because it's the

154
00:11:06,944 --> 00:11:14,814
shorter path to So when we receive a
connection that we cannot serve, we will

155
00:11:14,814 --> 00:11:19,564
return an HTTP response, and in this
case, we will use the status code 500.

156
00:11:20,064 --> 00:11:25,304
This way, we manage the connection
quickly, and so we use minimal

157
00:11:25,514 --> 00:11:30,114
resources, but the client still
knows what happened on this side.

158
00:11:30,614 --> 00:11:33,629
When we decide to accept the
request, the process is completed.

159
00:11:34,099 --> 00:11:35,779
become a little more complex.

160
00:11:36,249 --> 00:11:42,289
So first, we need to know module has
a specific attribute called pipeline.

161
00:11:42,289 --> 00:11:48,779
This pipeline is a reference to a
function, and after passing the request

162
00:11:48,779 --> 00:11:54,669
and before sending back the HTTP response,
we must pass through the pipeline.

163
00:11:55,169 --> 00:11:58,679
when a connection arrives, we have
many actions to perform on the request.

164
00:11:59,519 --> 00:12:01,629
and also the response, in fact.

165
00:12:01,999 --> 00:12:07,559
For example, we need to know Maybe, to
need, to log that a request arrives.

166
00:12:08,039 --> 00:12:13,799
We need to check for the authorization
or the authentication if he asks

167
00:12:13,799 --> 00:12:16,199
for resources that is protected.

168
00:12:16,779 --> 00:12:20,164
We need, of course, to vote
the request in the right order.

169
00:12:20,294 --> 00:12:24,904
resources or endpoint, and we
can do like many other stuff.

170
00:12:25,204 --> 00:12:32,564
in this request of response, each action,
in a web server is under by what we call

171
00:12:32,834 --> 00:12:40,404
middleware, and the pipeline is the trend
of execution of this middleware here,

172
00:12:40,584 --> 00:12:45,319
a visual example of the pipeline and
all the middleware that are composed.

173
00:12:45,819 --> 00:12:50,109
Each middleware receives as parameter
what we call a HTTP context.

174
00:12:50,699 --> 00:12:53,959
It will contain all information
about the current request

175
00:12:54,029 --> 00:12:56,209
and the response, everything.

176
00:12:56,579 --> 00:13:01,119
When the first middleware finishes what
it needs to do with the HTTP context,

177
00:13:01,669 --> 00:13:03,889
it will call the next middleware.

178
00:13:03,889 --> 00:13:07,369
Each middleware is called in seconds.

179
00:13:07,869 --> 00:13:14,079
To configure the pipeline, we can look
at the init function of the server,

180
00:13:14,489 --> 00:13:16,259
not of the module of the server.

181
00:13:17,219 --> 00:13:18,729
So where we create the module.

182
00:13:19,229 --> 00:13:23,929
we will first set a first
pipeline, that is a web.

183
00:13:24,429 --> 00:13:31,889
we will create all the necessary
middleware and link them together, okay?

184
00:13:32,109 --> 00:13:36,739
So we start with the terminal middleware,
because we start by the last one, and

185
00:13:36,759 --> 00:13:41,159
then we create the routing middleware
that will be connected to the terminal

186
00:13:41,159 --> 00:13:45,409
middleware, the directory middleware
that will be connected to the routing

187
00:13:45,409 --> 00:13:47,169
middleware we just created before.

188
00:13:47,839 --> 00:13:49,149
Same thing for the auth.

189
00:13:49,679 --> 00:13:53,859
authentication middleware and the
logger middleware that is the first one.

190
00:13:54,359 --> 00:14:00,879
Then the web module gets the reference
only to the first middleware, in

191
00:14:00,879 --> 00:14:02,489
this case the logger middleware.

192
00:14:02,989 --> 00:14:05,609
We can have a look, how middleware work.

193
00:14:06,279 --> 00:14:09,969
So here is a simplified version
of the router middleware.

194
00:14:10,589 --> 00:14:17,239
We will check the HTTP context for
the request and what verb is used.

195
00:14:18,019 --> 00:14:21,299
If it's a GET request, we will undo it.

196
00:14:21,799 --> 00:14:26,479
Otherwise, we will not manage in
our case, so we will just, return

197
00:14:26,499 --> 00:14:29,449
a HTTP response with the code 404.

198
00:14:29,949 --> 00:14:35,749
After, we call the next middleware
in the pipeline with a wait next and

199
00:14:35,749 --> 00:14:36,979
passing the context in parameter.

200
00:14:37,479 --> 00:14:42,779
Since we are in the middleware, let's take
a moment also to see how, we create an

201
00:14:42,789 --> 00:14:45,529
HTTP response for a resource that exists.

202
00:14:46,029 --> 00:14:49,459
Let's imagine that the
request, is for the file index.

203
00:14:49,459 --> 00:14:50,079
html.

204
00:14:50,079 --> 00:14:54,119
The router middleware
will look for this file.

205
00:14:54,619 --> 00:14:59,319
is in the main directory, so the
www directory for your web server.

206
00:15:00,034 --> 00:15:05,304
And we find it, it will generate an HTTP
response with all the necessary metadata.

207
00:15:05,804 --> 00:15:10,654
The metadata is like what is, the meme
type, of the resource that you return.

208
00:15:11,034 --> 00:15:18,089
So based on the file extension, is
The content length of the body, and of

209
00:15:18,089 --> 00:15:25,119
course the content of the file in the
body and the ft TP code that is 200.

210
00:15:25,119 --> 00:15:31,509
Because we find the resources, if
we, if it doesn't find the file in

211
00:15:31,509 --> 00:15:37,389
this case, we will again generate
a 400 for response in state of.

212
00:15:37,889 --> 00:15:38,879
content of the file.

213
00:15:39,379 --> 00:15:47,479
However, even if the response is
ready now, we will not send it yet.

214
00:15:47,979 --> 00:15:55,179
We simply add it to the HTTP context
because we don't know if other middleware

215
00:15:55,339 --> 00:15:59,929
need to perform some action on this
response before sending it back.

216
00:16:00,429 --> 00:16:06,649
Pipeline and middleware are very common
in web services and in this architecture.

217
00:16:07,619 --> 00:16:13,929
he had many advantage, such
like modality and visibility.

218
00:16:14,699 --> 00:16:16,589
We will explore that just later.

219
00:16:17,019 --> 00:16:18,369
it is really easy to extend.

220
00:16:18,369 --> 00:16:23,989
So because you can add any middleware
to the pipeline without much, at any

221
00:16:23,989 --> 00:16:30,019
place, it's easy to maintain because each
meter wear has only one responsibility.

222
00:16:30,289 --> 00:16:32,569
So it's easy to maintain and also to test.

223
00:16:33,069 --> 00:16:37,289
It can also help with the security,
because the request must pass

224
00:16:37,509 --> 00:16:38,399
through all the middleware.

225
00:16:38,899 --> 00:16:40,189
It doesn't have choice.

226
00:16:40,199 --> 00:16:45,679
So in our case, for example, we
include, authentication middleware.

227
00:16:45,809 --> 00:16:47,609
it's like the second
middleware that we call.

228
00:16:48,149 --> 00:16:53,279
like that, we ensure that each
request go through it and we know if

229
00:16:53,339 --> 00:16:55,589
the request is authenticated or not.

230
00:16:56,289 --> 00:17:00,889
You can also put a weight limiting if
you want a specific middleware for that.

231
00:17:01,779 --> 00:17:05,689
Again, you can add any
security layer that you want.

232
00:17:06,189 --> 00:17:08,919
Okay, let's look at
another challenge number 3.

233
00:17:09,679 --> 00:17:13,949
how to administrate and
operate a modern web server.

234
00:17:14,449 --> 00:17:19,889
So by administrate and operate, like,
how I do to change the configuration,

235
00:17:20,139 --> 00:17:26,149
if I want to restart the service,
or stop it, if I want to get the

236
00:17:26,159 --> 00:17:28,609
log, of my service, all this action.

237
00:17:29,289 --> 00:17:33,549
For most web server, it's
required to connect directly

238
00:17:33,549 --> 00:17:35,309
to the server, so to the host.

239
00:17:35,809 --> 00:17:40,279
and to perform some, b permission,
to get this information.

240
00:17:41,139 --> 00:17:44,499
But okay, we are in 2025 now.

241
00:17:44,969 --> 00:17:48,839
and we don't usually
manage one web server.

242
00:17:48,839 --> 00:17:50,459
We often manage thousand.

243
00:17:50,909 --> 00:17:53,699
So I want to be able to
do everything remotely.

244
00:17:53,999 --> 00:17:56,399
And when I say remotely, I didn't say.

245
00:17:56,899 --> 00:18:02,599
Connecting remotely to the host, I mean
to an HTTP endpoint for my application.

246
00:18:03,429 --> 00:18:08,089
I want to operate my web
server to HTTP endpoint.

247
00:18:08,729 --> 00:18:11,959
And that's great because we're
building a web server, so we already

248
00:18:11,969 --> 00:18:13,429
have everything in the heart, no?

249
00:18:14,189 --> 00:18:15,879
We just need to add some endpoint.

250
00:18:16,059 --> 00:18:17,119
for administration.

251
00:18:18,049 --> 00:18:23,429
So we could do that, but another
requirement we want also is to have

252
00:18:23,429 --> 00:18:27,489
an administration services that
is independent of our main module,

253
00:18:27,879 --> 00:18:32,689
the web module, to be able to
have a better control on the both.

254
00:18:33,189 --> 00:18:38,719
in fact, I want, a transition from
my architecture where I have one web

255
00:18:38,719 --> 00:18:46,349
model with the TCP, listening on the
port 80 80, I want past two, two model,

256
00:18:46,909 --> 00:18:52,829
one web model and one admin model
listening, one on the port, 80 80,

257
00:18:52,919 --> 00:18:55,529
and on the other, on the port 40 40.

258
00:18:56,029 --> 00:18:58,169
Again, the port is just an example.

259
00:18:58,669 --> 00:19:04,609
So each module will listen on
its own port and be completely

260
00:19:04,819 --> 00:19:06,029
independent of the other.

261
00:19:06,029 --> 00:19:09,909
That means we can run one without
running the other, it will be okay.

262
00:19:10,409 --> 00:19:15,574
So Don't worry, we will reuse what we
already done in the first web module.

263
00:19:15,964 --> 00:19:18,974
We will just need to make few adjustments.

264
00:19:18,974 --> 00:19:22,864
First, let's talk about the pipeline.

265
00:19:23,364 --> 00:19:27,500
there will be of course very similar the
web, pipeline and the admin pipeline.

266
00:19:28,000 --> 00:19:32,940
But we will replace, the routing
middleware that is used here.

267
00:19:33,230 --> 00:19:38,380
To get the source on the server with
the handin middleware to handle the

268
00:19:38,380 --> 00:19:40,300
operation like tasks that we want.

269
00:19:40,800 --> 00:19:43,440
So stay in the innate
function of the server.

270
00:19:44,160 --> 00:19:46,200
we will create our new pipeline.

271
00:19:46,610 --> 00:19:47,000
Okay.

272
00:19:47,150 --> 00:19:50,740
We can reuse most of the
middleware we already had, so the

273
00:19:50,770 --> 00:19:52,890
terminal, middleware, for example.

274
00:19:53,390 --> 00:19:54,770
or the logo even.

275
00:19:55,560 --> 00:19:59,550
But at this time we will
have our hand admin module.

276
00:20:00,060 --> 00:20:00,510
Okay.

277
00:20:01,040 --> 00:20:01,340
that's.

278
00:20:01,840 --> 00:20:08,710
Will, start with the admin logger
middleware, and this log admin logger

279
00:20:08,710 --> 00:20:13,650
middleware will be, connect of course to
the hot middleware that it didn't change.

280
00:20:14,230 --> 00:20:18,730
and the hot middleware will be
connect to the directory middleware.

281
00:20:19,320 --> 00:20:22,830
And the directory middleware will
not be connected to the water

282
00:20:22,830 --> 00:20:26,900
middleware this time, but to the admin
middleware, We train to middleware.

283
00:20:27,400 --> 00:20:31,060
So we have a connection
manager, that is a model.

284
00:20:31,270 --> 00:20:35,290
so the connection manager had
me this time inside of web.

285
00:20:35,560 --> 00:20:40,030
So we have two module two connection
manager, no, with two different pipeline.

286
00:20:40,530 --> 00:20:42,960
let's take a look on the admin middleware.

287
00:20:43,560 --> 00:20:45,630
It is very similar to
the water middleware.

288
00:20:46,300 --> 00:20:50,620
a little more long maybe because
this time we will not look for five.

289
00:20:51,190 --> 00:20:55,520
Okay, or for resource, we
will look for endpoint.

290
00:20:56,020 --> 00:21:02,260
So we have, the main endpoint,
like status, reload, restart, logs.

291
00:21:03,010 --> 00:21:09,120
And when we hit this endpoint,
we will execute the corresponding

292
00:21:09,130 --> 00:21:11,020
function of our web server.

293
00:21:11,520 --> 00:21:15,040
and return the result of the
function on the HTTP response.

294
00:21:15,400 --> 00:21:21,060
For the status, for example, we have
the viable status, in our server, so

295
00:21:21,060 --> 00:21:27,790
we will get this value, put it in the
body of an HTTP response, and return it.

296
00:21:28,290 --> 00:21:29,640
same thing for the reload.

297
00:21:29,835 --> 00:21:36,325
We will execute the reload function
that go with the configuration file

298
00:21:36,945 --> 00:21:40,485
and return that the configuration
is reloaded when it's done.

299
00:21:40,985 --> 00:21:46,605
Since authentication is very crucial
for the admin section, even if it

300
00:21:46,605 --> 00:21:52,205
was implemented before, let's have
a look now how we handle this part.

301
00:21:53,145 --> 00:21:57,405
here we've implemented the
simplest authentication method.

302
00:21:58,045 --> 00:22:01,824
Because, remember, it's
always good to start simple

303
00:22:01,824 --> 00:22:04,593
before going in complex, area.

304
00:22:04,593 --> 00:22:07,361
So we use basic authentication.

305
00:22:08,291 --> 00:22:13,481
Okay, it's not the most secure option,
but it serves our purpose right now.

306
00:22:13,521 --> 00:22:18,071
Okay, it protects the endpoint
with an authentification.

307
00:22:18,091 --> 00:22:23,391
What we ask, we didn't ask
to use the more secure one.

308
00:22:23,771 --> 00:22:26,471
But of course, in production,
you could not use that.

309
00:22:26,971 --> 00:22:32,381
So to make this work, what we
do, we have an HTTP request.

310
00:22:32,611 --> 00:22:38,061
And in this HTTP request, We
have in the header, if we're

311
00:22:38,091 --> 00:22:41,841
sending an authentication, we will
have the header authorization.

312
00:22:42,341 --> 00:22:47,011
And from this header, we can get
the username and the password.

313
00:22:47,511 --> 00:22:52,801
We can then check, if it matches
with the username and the password

314
00:22:52,801 --> 00:22:53,941
we have in an access file.

315
00:22:54,441 --> 00:22:55,241
in the server.

316
00:22:55,661 --> 00:22:59,631
If yes, the user is authenticate.

317
00:22:59,811 --> 00:23:00,711
If no, is not.

318
00:23:01,211 --> 00:23:08,691
We will, so just had in the context,
in the HTTP context, that the user

319
00:23:08,871 --> 00:23:14,066
get Authenticate correctly, for
the directory he asked, at least.

320
00:23:14,926 --> 00:23:19,696
And like that, in the next middleware,
okay, we have this information,

321
00:23:19,746 --> 00:23:21,226
we don't need to check ourself.

322
00:23:21,726 --> 00:23:25,586
one of the current challenge
with administration endpoint,

323
00:23:26,086 --> 00:23:28,276
introduce a sub problem.

324
00:23:28,776 --> 00:23:35,276
How do we provide enough handpon to
ensure that the administrator can

325
00:23:35,276 --> 00:23:40,186
perform all necessary tasks without
accessing directly to the server?

326
00:23:40,716 --> 00:23:46,046
Okay, so sure, we have some handpon for
log, for stopping, restarting the server.

327
00:23:46,626 --> 00:23:51,326
But what if the admin, I don't know,
won't check some permission or handle,

328
00:23:51,856 --> 00:23:58,636
other custom scenario, like we do
with bash, for example, we cannot

329
00:23:58,706 --> 00:24:01,046
anticipate every possible scenario.

330
00:24:01,396 --> 00:24:05,586
So we need to find a way to offer
flexibility to the administrator,

331
00:24:06,086 --> 00:24:08,166
but still to HTTP endpoint.

332
00:24:08,666 --> 00:24:11,766
That's why we have another
endpoint called script.

333
00:24:12,196 --> 00:24:15,056
This endpoint can do many stuff.

334
00:24:15,156 --> 00:24:18,326
Either it can list all the
scripts present on the machine.

335
00:24:18,716 --> 00:24:23,266
So if you just hit the handpwn
script, this is what it will do.

336
00:24:24,256 --> 00:24:29,194
There is a specific, folder, in the
server and all the scripts that are

337
00:24:29,194 --> 00:24:31,276
in this server will be displayed.

338
00:24:31,776 --> 00:24:37,701
And if you use this handpwn with what
we call a param, a query parameter,

339
00:24:38,201 --> 00:24:44,991
while we will execute the script based
on his name and his name is what is a

340
00:24:44,991 --> 00:24:47,291
value passed in the query parameter.

341
00:24:47,946 --> 00:24:54,796
the administrator now will be able to
upload any script they want, and later,

342
00:24:55,416 --> 00:25:00,806
execute it via an HTTP request, with
of course the result of the script that

343
00:25:00,806 --> 00:25:03,001
will be returned as an HTTP request.

344
00:25:03,501 --> 00:25:08,431
Since the script depends on the
platform, we naturally need a different

345
00:25:08,431 --> 00:25:10,981
implementation for both Linux and Windows.

346
00:25:11,411 --> 00:25:14,381
But that is always more issue,
like I said at the beginning.

347
00:25:14,731 --> 00:25:16,561
It's just abstraction.

348
00:25:17,246 --> 00:25:20,246
and different implementations
depending on the platform.

349
00:25:20,746 --> 00:25:24,736
Okay, now we solved the issue,
with, the admin endpoint.

350
00:25:24,736 --> 00:25:26,966
Let's talk about the
challenge number four.

351
00:25:27,426 --> 00:25:29,656
logging and effective logging.

352
00:25:30,546 --> 00:25:33,706
logging is crucial for
administrators or SREs.

353
00:25:34,506 --> 00:25:38,006
And a good logging is even more important.

354
00:25:38,821 --> 00:25:42,621
of course, our application, okay,
need to handle it very well.

355
00:25:43,121 --> 00:25:46,951
since we have different
and independent module.

356
00:25:47,451 --> 00:25:53,571
The logger of this module, so the
logging system, must reflect also that.

357
00:25:54,071 --> 00:26:00,331
For me, a good log should include
at least the following information.

358
00:26:01,011 --> 00:26:06,721
The date, the module, the thread ID, the
level, and of course the error message.

359
00:26:07,221 --> 00:26:12,441
okay, to fully understand the issue we
have with the login, we need to keep in

360
00:26:12,441 --> 00:26:18,816
mind that The two modules, Web and Admin,
are two instances of the same class.

361
00:26:19,536 --> 00:26:25,146
And this instance can call the same
function, the logger middleware and,

362
00:26:25,226 --> 00:26:31,046
the logger middleware, when he logs
his information, must be able to

363
00:26:31,346 --> 00:26:36,266
distinguish between which module is
calling it when he's writing the log.

364
00:26:36,766 --> 00:26:42,226
Since both modules are essentially
the same, we need a way to identify

365
00:26:42,666 --> 00:26:47,936
which module is interacting with
the logger at any given time.

366
00:26:48,436 --> 00:26:53,866
This means that the logging system
should be capable of tracking

367
00:26:53,886 --> 00:26:57,146
the context where it's from.

368
00:26:58,076 --> 00:27:03,626
If it's from the web module, if it's
from the admin module, to answering

369
00:27:03,686 --> 00:27:06,206
that the correct information is a log.

370
00:27:06,706 --> 00:27:11,866
To solve this, we must first understand
the concept of execution context.

371
00:27:12,726 --> 00:27:16,436
Each part of the code
run in its own context.

372
00:27:16,946 --> 00:27:21,916
When the server run, okay, we are in
the main function, we are in the main

373
00:27:21,956 --> 00:27:23,856
execution context of the program.

374
00:27:24,576 --> 00:27:29,966
When a new task is created, it
forms a tried execution context.

375
00:27:30,616 --> 00:27:35,476
And something important to know, of
course, is that when we run the server,

376
00:27:35,506 --> 00:27:39,576
so here is a function runAsync, not of
the module, but of the server itself.

377
00:27:40,076 --> 00:27:45,156
the server will start
its model in a new task.

378
00:27:45,656 --> 00:27:52,326
When we enter in a tried execution
context, it inherit from the parent.

379
00:27:52,596 --> 00:27:56,356
In most of the case, we won't
care about this information, but

380
00:27:56,526 --> 00:27:59,606
it's actually one of the solutions
we can implement for our model.

381
00:28:00,546 --> 00:28:05,636
We can create a static class named
ExecutionContext, which contains a

382
00:28:05,686 --> 00:28:08,176
static variable of type AsyncLocal.

383
00:28:08,676 --> 00:28:14,766
In our case, it's a local AsyncLocal,
but it could be any AsyncLocal.

384
00:28:15,266 --> 00:28:19,256
This variable will have a getter
and setter, allowing us to

385
00:28:19,266 --> 00:28:21,436
modify the value and to get it.

386
00:28:22,366 --> 00:28:26,606
What is great about this approach
is that because the class is static,

387
00:28:27,016 --> 00:28:28,906
it will be accessible everywhere.

388
00:28:29,516 --> 00:28:35,926
But Important, the value his hold
will be unique to each executant

389
00:28:36,536 --> 00:28:39,076
context because of the async locale.

390
00:28:39,576 --> 00:28:42,826
Let's take a look, how it works
in practice in the module.

391
00:28:43,326 --> 00:28:46,146
So let's come back to the start method.

392
00:28:47,016 --> 00:28:48,086
of one of the modules.

393
00:28:48,586 --> 00:28:52,656
either if it's a web or the admin
module anyway, it's the same start

394
00:28:53,086 --> 00:28:54,796
method that is called, so it's okay.

395
00:28:55,276 --> 00:29:00,686
at this point, we will set a new
logger, and we will save this

396
00:29:00,686 --> 00:29:06,146
new logger that has the module
name, tbkt, in this constructor.

397
00:29:06,366 --> 00:29:07,516
We will save it.

398
00:29:08,271 --> 00:29:09,391
in the executionContext.

399
00:29:09,541 --> 00:29:10,711
logger variable.

400
00:29:11,211 --> 00:29:15,601
from here, this logger value
will be specific to the execution

401
00:29:15,641 --> 00:29:18,801
context in which it was set.

402
00:29:19,711 --> 00:29:27,061
All tried execution contexts such as
task, or asynchronous operation, with

403
00:29:27,571 --> 00:29:31,451
that context we inherit this logger value.

404
00:29:32,131 --> 00:29:37,071
This answers that each execution
context has its own logger instance,

405
00:29:37,631 --> 00:29:42,401
and can log with the appropriate
module specific information, without

406
00:29:42,431 --> 00:29:44,451
interfering with other contexts.

407
00:29:44,951 --> 00:29:49,636
What that means is that when we are
in our web module, our admin module.

408
00:29:50,226 --> 00:29:54,166
The logger use is always tied to
the specific execution context.

409
00:29:54,666 --> 00:29:59,453
This happens because, the, what we
set up with the async yokai variable

410
00:29:59,453 --> 00:30:00,936
in the execution context class.

411
00:30:01,176 --> 00:30:04,546
We ensure that each execution
context has its own logger.

412
00:30:04,896 --> 00:30:08,376
So when you log a message
using execution context.

413
00:30:08,796 --> 00:30:13,816
logger, it will always use the logger
that was defined for the current module

414
00:30:13,816 --> 00:30:18,036
execution context, whether you are
in the web module or admin module.

415
00:30:18,606 --> 00:30:22,766
This is true, no matter where you
are in the code, as long as you are

416
00:30:22,766 --> 00:30:25,336
within the context of that module.

417
00:30:26,126 --> 00:30:29,626
Even if you call a function or use
a class that are part of a module.

418
00:30:30,206 --> 00:30:35,676
of another class outside of a module,
they will inherit the logger from

419
00:30:35,676 --> 00:30:37,126
the current execution context.

420
00:30:37,586 --> 00:30:42,846
This way, your logs stay consistent
and specific to the module from

421
00:30:42,856 --> 00:30:48,866
which they are generated, and so it
makes it easier to trace or to debug.

422
00:30:49,716 --> 00:30:56,531
So When you call the, any kind of
middleware, like the logger middleware,

423
00:30:57,121 --> 00:31:00,641
and you do execution context.

424
00:31:00,651 --> 00:31:00,761
logger.

425
00:31:01,511 --> 00:31:08,621
loginfo, we know which logger it
is because we inherit from the

426
00:31:08,621 --> 00:31:10,311
execution context of the module.

427
00:31:10,811 --> 00:31:15,681
So there is, of course, a lot of other
challenges that I didn't mention here.

428
00:31:16,381 --> 00:31:22,601
you can take this, totally like an
introduction of how the problem you will

429
00:31:22,601 --> 00:31:28,311
need to solve when you will start to build
your own services after, depending what

430
00:31:28,311 --> 00:31:34,221
interests you the most you could consider
to investigate performance topic, so like

431
00:31:34,221 --> 00:31:37,101
with the caching or the multiplex request.

432
00:31:37,331 --> 00:31:41,821
maybe more a security feature
like the HTTPS because for the

433
00:31:41,821 --> 00:31:43,701
moment everything was in HTTP.

434
00:31:43,741 --> 00:31:48,771
That's why basic authentication
was really not secure in our case.

435
00:31:49,321 --> 00:31:52,021
also maybe other, authentication methods.

436
00:31:52,521 --> 00:31:58,181
or if you are more interested, about,
what also do we say, we think about

437
00:31:58,481 --> 00:32:02,111
the monitoring of your application,
so how you can generate metric,

438
00:32:02,601 --> 00:32:07,351
what new hand point you can provide
to get this metric, et cetera.

439
00:32:07,851 --> 00:32:09,171
There is one bonus challenge.

440
00:32:09,671 --> 00:32:15,251
to finish this presentation, I would
actually mention it so because it is what

441
00:32:15,251 --> 00:32:17,691
name you will give to your web server.

442
00:32:18,061 --> 00:32:21,001
Of course, you create a web server,
you need to give a name is the

443
00:32:21,011 --> 00:32:22,691
most interesting part I think.

444
00:32:23,281 --> 00:32:28,571
it's a really interesting exercise
because, it unlocks your creativity

445
00:32:29,361 --> 00:32:34,351
and Myself, I would be really pleased
to have some idea you have in mind.

446
00:32:34,361 --> 00:32:38,531
If you need to create your own web
server, what name you will give it.

447
00:32:39,031 --> 00:32:39,771
the mine.

448
00:32:40,271 --> 00:32:44,141
Because I build mine, took
inspiration of the most.

449
00:32:44,141 --> 00:32:48,111
No, that is AP Apache, and
that I really like ponder.

450
00:32:48,801 --> 00:32:50,781
I decide to name it, ponder Apache.

451
00:32:51,381 --> 00:32:56,991
So if you want to explore the code of
a web server in C Shop, you can easily

452
00:32:56,991 --> 00:33:00,591
find it on GitHub and the name pastry.

453
00:33:01,091 --> 00:33:03,341
Thank you for your
attention and your time.

454
00:33:03,581 --> 00:33:08,731
I hope I gave you interest on this
topic, and is the rest of the conference.

455
00:33:08,761 --> 00:33:09,121
Thank you.

