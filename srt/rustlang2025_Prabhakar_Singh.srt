1
00:00:00,720 --> 00:00:01,500
Hello everyone.

2
00:00:01,860 --> 00:00:05,520
I am PR Singh, a senior
software in Unit Meta.

3
00:00:06,510 --> 00:00:12,660
Today we are going to talk about something
that's both a technical challenge and a

4
00:00:12,660 --> 00:00:18,500
real world business necessity building
real time AI powered fraud prevention

5
00:00:18,500 --> 00:00:21,410
systems for gate platforms in Rust.

6
00:00:22,400 --> 00:00:26,090
And his exciting part,
this is not just a theory.

7
00:00:26,930 --> 00:00:31,940
I will share some systems that are already
in production, blocking millions in frauds

8
00:00:32,000 --> 00:00:37,520
every month, processing tens of thousands
of transactions per hour, and doing

9
00:00:37,520 --> 00:00:39,740
it within millisecond decision times.

10
00:00:40,240 --> 00:00:41,380
So let's deep dive into it.

11
00:00:41,880 --> 00:00:43,470
So here is our roadmap for today.

12
00:00:44,460 --> 00:00:47,160
We'll start with fraud
challenge in the gig economy.

13
00:00:47,850 --> 00:00:53,490
What makes it so much harder than fraud
in traditional banking or e-commerce?

14
00:00:53,990 --> 00:01:01,130
Then we'll see why Rust, specifically
rust is a perfect fit for solving it.

15
00:01:01,630 --> 00:01:06,570
I will walk you through a multi-layer
architecture that's battle tested, we'll

16
00:01:06,600 --> 00:01:12,150
type div into real world results from
food delivery and ride sharing platforms.

17
00:01:12,990 --> 00:01:18,300
And finally, I will share some emerging
applications where Rust can push

18
00:01:18,300 --> 00:01:20,130
the fraud prevention even further.

19
00:01:20,630 --> 00:01:25,070
By the end, I hope you'll see
why the next generation of fraud

20
00:01:25,070 --> 00:01:27,320
prevention could be written in rust.

21
00:01:27,820 --> 00:01:30,700
So let's look into what's the
gig economy fraud challenge.

22
00:01:31,200 --> 00:01:35,370
Fraud prevention in gig platforms
is a game of millisecond.

23
00:01:36,360 --> 00:01:41,160
Imagine you are ordering food on
DoorDash or booking a ride on Uber.

24
00:01:42,045 --> 00:01:46,155
If our system takes even one 50
millisecond longer than expected

25
00:01:46,305 --> 00:01:50,685
to approve your transaction, you
might abandon the order, or the

26
00:01:50,685 --> 00:01:52,815
driver assignment might time out.

27
00:01:53,315 --> 00:01:56,135
That's a revenue lost instantly.

28
00:01:56,635 --> 00:02:02,850
On top of that, Gigi is hyper
distributed, meaning workers and

29
00:02:03,130 --> 00:02:07,645
customers are scattered across
cities, countries, even continents.

30
00:02:08,395 --> 00:02:12,595
Meaning fraud patterns are geographically
different and constantly evolving.

31
00:02:13,095 --> 00:02:14,325
Payments are instant.

32
00:02:14,685 --> 00:02:17,955
Once the money is sent to a
driver or courier, it's gone.

33
00:02:18,645 --> 00:02:22,485
There is no hold period to investigate
suspicious activity like in banking

34
00:02:22,985 --> 00:02:24,455
and the throughput requirements.

35
00:02:25,025 --> 00:02:28,685
We're talking about AI models
analyzing thousands of transactions

36
00:02:28,685 --> 00:02:30,695
every minute without even choking.

37
00:02:31,195 --> 00:02:32,065
Where is the problem?

38
00:02:32,785 --> 00:02:37,285
The Python, Java, node js, they can work.

39
00:02:37,495 --> 00:02:41,605
These are popular framework, but
under these constraints, they

40
00:02:41,605 --> 00:02:45,055
often force painful trade offs
between a speed and accuracy.

41
00:02:45,565 --> 00:02:49,465
We need both, and that's where
the rust changes the game.

42
00:02:49,965 --> 00:02:52,715
Let's look at the common fraud
pat fraud patterns we have seen.

43
00:02:53,215 --> 00:02:55,405
So fraud frauds are very creative.

44
00:02:56,035 --> 00:02:57,085
And relentless.

45
00:02:57,865 --> 00:03:01,615
Let's look at a few common attack patterns
that we have seen in gig platforms.

46
00:03:02,395 --> 00:03:09,025
So one commonly is known as account
takeover, where attackers buy leaked

47
00:03:09,025 --> 00:03:13,495
credentials and brute force their way
into legitimate systems or accounts.

48
00:03:13,995 --> 00:03:15,825
Synthetic identity is another type.

49
00:03:16,365 --> 00:03:20,145
Think of it as a Frank Tine
accounts, it stitch together

50
00:03:20,145 --> 00:03:21,855
from real and fake details.

51
00:03:22,815 --> 00:03:25,915
Another one is work
worker customer collusion.

52
00:03:26,635 --> 00:03:32,055
A driver and a customer work together
to fake trips or deliveries, another one

53
00:03:32,115 --> 00:03:38,145
called GPSS spoofing or geo spoofing,
where they fake their location to get

54
00:03:38,145 --> 00:03:40,635
better jobs or to trick the payout system.

55
00:03:41,265 --> 00:03:46,005
And finally, another type is payment
method fraud, where stolen credit

56
00:03:46,005 --> 00:03:47,805
cards are used for instant payouts.

57
00:03:48,305 --> 00:03:49,595
And here is the scary part.

58
00:03:50,095 --> 00:03:54,355
Fraud tactics evolve
weekly, sometimes daily.

59
00:03:54,855 --> 00:03:59,505
A fraud ring can exploit your platform,
make hundreds of fraudulent transactions

60
00:03:59,505 --> 00:04:03,195
and vanish before your old detection
rules even notice something is wrong.

61
00:04:03,695 --> 00:04:10,505
That's why our system have to be fast,
adaptive, and accurate all at once.

62
00:04:11,005 --> 00:04:13,315
So why rust for fraud prevention?

63
00:04:13,815 --> 00:04:18,225
So there are three big regions
for that first memory, safety

64
00:04:18,315 --> 00:04:19,695
without garbage collection.

65
00:04:20,595 --> 00:04:22,905
Fraud prevention systems
are security critical.

66
00:04:23,745 --> 00:04:28,305
A buffer overflow, or use after
free bug is not just a crash.

67
00:04:28,665 --> 00:04:29,895
It could be an exploit.

68
00:04:30,395 --> 00:04:35,225
Rust eliminates those classes of
bug at compile time without runtime.

69
00:04:35,345 --> 00:04:35,710
GC pauses.

70
00:04:36,210 --> 00:04:39,030
Second c plus labor performance.

71
00:04:39,570 --> 00:04:43,230
As we know, c plus is very
popular programming language.

72
00:04:43,730 --> 00:04:45,890
So Rust has geo cost abstraction.

73
00:04:46,190 --> 00:04:49,910
It has multiple L-L-M-V-M optimization.

74
00:04:50,410 --> 00:04:56,470
You can hit near c plus speed while
writing safer and more expressive code.

75
00:04:56,970 --> 00:04:58,950
Third, fearless concurrency.

76
00:04:59,450 --> 00:05:03,920
The ownership and the borrowing
model prevents data races by design.

77
00:05:04,400 --> 00:05:08,630
That means we can confidently run
fraud checks on many concurrent

78
00:05:08,630 --> 00:05:13,990
transactions without corrupting the
shared estate in sort the rust gives

79
00:05:13,990 --> 00:05:17,200
us a speed, safety and scalability.

80
00:05:17,410 --> 00:05:18,970
The trifecta for prevention.

81
00:05:19,470 --> 00:05:21,030
Let's look at the performance results.

82
00:05:21,530 --> 00:05:26,180
In production benchmarks from a
major food delivery company, rust

83
00:05:26,180 --> 00:05:29,240
reached 93% of c plus raw performance.

84
00:05:29,510 --> 00:05:36,290
It was 6.2 times faster than Java and 2.4
times faster than Python with TensorFlow.

85
00:05:37,130 --> 00:05:41,545
What is the P 90 latency Under
35 millisecond consistently.

86
00:05:42,045 --> 00:05:45,255
And these are not just a synthetic test.

87
00:05:46,035 --> 00:05:50,495
Even CPU ation was dropped
by 90% compared to Python.

88
00:05:50,995 --> 00:05:55,085
These are real world numbers from a live
fraud perform fraud prevention pipeline.

89
00:05:55,585 --> 00:06:00,565
And why and when you multiply tho that
efficiency across thousands of request

90
00:06:00,565 --> 00:06:03,325
per second, the cost savings are huge.

91
00:06:03,825 --> 00:06:06,045
Let's look at a multilayered
rust architecture.

92
00:06:06,545 --> 00:06:09,575
So our rust based architecture
uses five layers mainly.

93
00:06:10,310 --> 00:06:15,650
One real time stream processing where
Tokyo ingest transaction streams

94
00:06:15,650 --> 00:06:19,100
and process them asynchronously
cutting latency dramatically.

95
00:06:20,030 --> 00:06:22,250
Second rule-based detection.

96
00:06:23,060 --> 00:06:27,220
Simple if else rules and fr
on pattern matching for known

97
00:06:27,220 --> 00:06:29,140
fraud signals are sufficient.

98
00:06:29,590 --> 00:06:33,760
Think if same card used in
three countries in one hour.

99
00:06:33,760 --> 00:06:33,940
Flag it.

100
00:06:34,440 --> 00:06:38,900
Third statistical OMA detection
time series models to spot unusual

101
00:06:38,900 --> 00:06:40,850
spikes or dips in user behavior.

102
00:06:41,570 --> 00:06:46,510
ML classification candle deep learning
models used with code exhalation

103
00:06:46,510 --> 00:06:52,580
for GP inference, graph analysis pet
graph algorithm to detect sources,

104
00:06:52,580 --> 00:06:54,620
clusters of users working together.

105
00:06:55,220 --> 00:06:58,040
Each layer acts as a safety net.

106
00:06:58,940 --> 00:07:01,550
Catching what others might miss.

107
00:07:02,050 --> 00:07:04,930
Let's look at Rust Power in innovations.

108
00:07:05,430 --> 00:07:07,890
Two things made a huge difference here.

109
00:07:08,770 --> 00:07:14,050
Async Stream processing with Tokyo,
which lets us handle thousands of events

110
00:07:14,050 --> 00:07:16,690
per second with almost no idle time.

111
00:07:17,190 --> 00:07:23,220
And the second zero copy digitalization
with ade, which passes J or proto

112
00:07:23,220 --> 00:07:29,160
above straight from bytes without
extra memory allocations on their own.

113
00:07:29,220 --> 00:07:34,170
These are nice to haves, but in real time
fraud pipeline, they are the difference

114
00:07:34,470 --> 00:07:39,000
between hitting your SLA or missing
it by 30 millisecond and losing money.

115
00:07:39,500 --> 00:07:42,680
You can look at the some code snippet
here that have attached in this slide.

116
00:07:43,505 --> 00:07:47,195
That you can use directly in your
code to use these frameworks.

117
00:07:47,695 --> 00:07:49,645
Let's look at ML inference with candle.

118
00:07:50,515 --> 00:07:54,735
If you have used PyTorch candle will
feel very familiar very familiar.

119
00:07:55,535 --> 00:07:57,995
It's a pure rushed ML framework.

120
00:07:58,535 --> 00:08:04,505
Supports ONNX, imports from PyTorch
or TensorFlow, and runs on cuda

121
00:08:04,625 --> 00:08:08,825
and metal For GP insurance, the
best part, no python in production.

122
00:08:09,785 --> 00:08:14,885
That means the whole fraud detection
pipeline is memory safe from end to end.

123
00:08:15,305 --> 00:08:18,005
No language boundaries, no GIL.

124
00:08:18,515 --> 00:08:20,255
No extra process overhead.

125
00:08:20,765 --> 00:08:21,665
Isn't that amazing?

126
00:08:22,165 --> 00:08:24,385
Let's look into graph
analysis with pet graph.

127
00:08:24,885 --> 00:08:29,175
So as we know, fraud does not
always happen in isolation.

128
00:08:29,445 --> 00:08:31,275
It's often coordinated.

129
00:08:31,775 --> 00:08:34,205
Pet graph lets us map out.

130
00:08:34,705 --> 00:08:40,465
Transaction graphs and run
algorithms to find what one connected

131
00:08:40,465 --> 00:08:44,125
components, two centrality scores.

132
00:08:44,605 --> 00:08:45,115
Three.

133
00:08:45,445 --> 00:08:48,915
Structural similarities
over time, one real case.

134
00:08:49,605 --> 00:08:55,605
32 drivers and 18 customers ran
a fake order scam for weeks where

135
00:08:55,665 --> 00:08:57,795
a standard ML models missed it.

136
00:08:58,295 --> 00:09:01,145
The graph analysis from
PET Graph caught it.

137
00:09:01,645 --> 00:09:02,545
Isn't that amazing?

138
00:09:03,425 --> 00:09:07,020
I have linked a code snippet here
again for you, for your reference.

139
00:09:07,520 --> 00:09:08,150
Let's move on.

140
00:09:08,930 --> 00:09:10,460
Privacy preserving techniques.

141
00:09:11,110 --> 00:09:13,840
We can't fight fraud at
the expense of privacy.

142
00:09:14,170 --> 00:09:18,570
In rust, we have implemented
homomorphic encryption, computational

143
00:09:18,570 --> 00:09:22,400
encrypted data t learning, which
is like training across devices

144
00:09:22,400 --> 00:09:24,410
without centralizing sensitive data.

145
00:09:25,410 --> 00:09:30,000
Differential privacy, which is adding
control noise to protect identities.

146
00:09:30,910 --> 00:09:34,990
Secure incls, which is running code
in hardware isolated environments.

147
00:09:35,830 --> 00:09:40,480
And thanks to Rust performance, these are
not just slow, they're production ready.

148
00:09:40,980 --> 00:09:43,180
Let's look at the guide
sharing case study here.

149
00:09:43,680 --> 00:09:50,760
A right sharing platform was losing around
$3.2 million per month to Jupe spoofing

150
00:09:50,760 --> 00:09:53,220
or GPS spoofing and fake identities.

151
00:09:53,720 --> 00:09:59,450
We replaced their Python fraud stack
with rusted microservices, for example,

152
00:09:59,690 --> 00:10:05,510
used Tokyo for Async, STTP, custom
device fingerprinting and rust,

153
00:10:06,440 --> 00:10:09,320
WASM modules for distributed rules.

154
00:10:09,820 --> 00:10:12,550
And we used candle for ML inference.

155
00:10:13,210 --> 00:10:14,020
What's the result?

156
00:10:14,980 --> 00:10:23,540
87% less fraud loss, 65% fewer
false positives enforcements.

157
00:10:23,840 --> 00:10:28,280
And 99.98% uptime of
services over 12 months.

158
00:10:28,520 --> 00:10:30,770
Isn't that unbelievable?

159
00:10:31,270 --> 00:10:33,410
Let's look next at emerging applications.

160
00:10:34,130 --> 00:10:35,030
So what's next?

161
00:10:35,530 --> 00:10:40,250
So these are the four use cases that
we can use for us, and I think the

162
00:10:40,250 --> 00:10:41,810
way rust can shape the industry.

163
00:10:42,020 --> 00:10:48,310
So one is behavioral bi biometrics
typing, swiping motion patterns as

164
00:10:48,310 --> 00:10:50,140
continuous authentication are possible.

165
00:10:50,140 --> 00:10:54,720
Now with rust explainable AI
pipelines, which are under 12

166
00:10:54,720 --> 00:10:57,690
to six to 12 months of pipeline.

167
00:10:58,410 --> 00:11:02,550
In the roadmap, you can have sap
lime in rust for transparent fraud

168
00:11:02,550 --> 00:11:07,670
decision, advanced fully homomorphic
encryption, also known as advanced

169
00:11:07,670 --> 00:11:14,130
FHE, which is like 12 to 24 months in
the roadmap which for making a privacy

170
00:11:14,130 --> 00:11:16,950
preserving fraud detection practical.

171
00:11:17,450 --> 00:11:22,015
A NA native GPU acceleration, which is
around two plus years in the roadmap

172
00:11:22,345 --> 00:11:26,395
where rust, GP, U, and candle can
be used for even faster inference.

173
00:11:26,895 --> 00:11:28,635
So what are the key takeaways?

174
00:11:29,135 --> 00:11:32,255
There are three main
key takeaways from this.

175
00:11:33,035 --> 00:11:35,075
So one, performance matters.

176
00:11:35,825 --> 00:11:40,505
So Rust gives us C plus label
speed and developer productivity.

177
00:11:41,005 --> 00:11:43,825
Second, safety is non-negotiable.

178
00:11:44,515 --> 00:11:48,325
Memory, safety and race free
concurrency reduces risks.

179
00:11:48,825 --> 00:11:50,895
And third, the ecosystem is ready.

180
00:11:51,675 --> 00:11:56,715
Tokyo Candle, pet Craft are
production proven ready today.

181
00:11:57,215 --> 00:11:58,055
So thank you.

182
00:11:58,295 --> 00:12:01,175
Let's build a safer
gig platforms together.

183
00:12:01,475 --> 00:12:02,105
Thank you for listening.

