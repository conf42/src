1
00:00:00,000 --> 00:00:00,390
Hello everyone.

2
00:00:00,990 --> 00:00:03,180
Good morning, good afternoon,
good evening, depending on

3
00:00:03,180 --> 00:00:04,200
where you are joining from.

4
00:00:04,440 --> 00:00:09,090
My name is Dne j Prakash, and I'm a senior
application developer at Address Calls.

5
00:00:09,420 --> 00:00:13,380
It's a real pleasure to be here
at Count 42 JavaScript 2025 track.

6
00:00:13,830 --> 00:00:17,550
I'm really excited to speak about
this topic, API, integration with

7
00:00:17,640 --> 00:00:20,340
JavaScript, scalable, secure,
and a future ready system.

8
00:00:21,180 --> 00:00:24,960
Over the last few years, a P have
become the backbone of modern software.

9
00:00:25,290 --> 00:00:29,250
Connecting the applications, platforms,
and users more seamlessly than ever.

10
00:00:29,820 --> 00:00:33,710
But as systems keep growing and
getting more complex, making sure these

11
00:00:33,739 --> 00:00:37,339
APIs are integrated in a way that's
scalable, secure, and ready for the

12
00:00:37,339 --> 00:00:39,199
future has become a real challenge.

13
00:00:39,699 --> 00:00:43,355
Today I will be sharing some practical
strategies for building a Level

14
00:00:43,510 --> 00:00:48,010
API, integrations, using JavaScript
approaches that can help your system

15
00:00:48,190 --> 00:00:52,150
handle skill, maintain security, and
stay adaptable for what's coming next.

16
00:00:52,650 --> 00:00:54,780
The A PS driven visual transformation.

17
00:00:54,990 --> 00:00:59,160
That means APOs have come a long way
from being just simple data connectors.

18
00:00:59,160 --> 00:01:03,420
Today they serve as the backbone
of modern digital ecosystem in

19
00:01:03,420 --> 00:01:04,800
our JavaScript driven world.

20
00:01:04,920 --> 00:01:09,000
APIs, orchestrate microservices,
facilitator, real time data

21
00:01:09,000 --> 00:01:13,080
exchange, and integrate diverse
cloud platforms effortlessly.

22
00:01:13,680 --> 00:01:17,190
In this session, I'll share a
data driven blueprint for building

23
00:01:17,190 --> 00:01:19,199
an enterprise grade API systems.

24
00:01:19,680 --> 00:01:24,760
System that's not only scalable unsecured,
but also agile enough to keep a pace with

25
00:01:24,910 --> 00:01:27,640
constantly evolving technology landscapes.

26
00:01:28,140 --> 00:01:31,350
In our today's journey, we'll
start by looking at restful API

27
00:01:31,589 --> 00:01:35,130
architecture, understanding the
core principles and why it remains

28
00:01:35,130 --> 00:01:36,779
the backbone of modern development.

29
00:01:37,289 --> 00:01:42,450
Then we'll compare API paradigms
rest, so GraphQL and even some hybrid

30
00:01:42,479 --> 00:01:45,539
approaches to understand each makes sense.

31
00:01:46,020 --> 00:01:47,550
From there, we will dive into.

32
00:01:47,985 --> 00:01:51,585
From there, we'll drive into the
middleware solutions exploring how modern

33
00:01:51,645 --> 00:01:56,415
platforms simplify integration complexity
and a isolates enterprise connectivity.

34
00:01:56,985 --> 00:02:01,515
Next, we'll cover the security
framework, focusing on what API

35
00:02:01,515 --> 00:02:05,205
gateways and how a layered defense
help protector critical data.

36
00:02:05,835 --> 00:02:09,344
We'll then walk through some production
best practices and that ensures

37
00:02:09,344 --> 00:02:12,735
the reliability per performance
and a great developer experience.

38
00:02:12,735 --> 00:02:14,029
Once your API go live.

39
00:02:14,940 --> 00:02:19,289
And finally we'll look ahead at the
future trends, including even driven

40
00:02:19,289 --> 00:02:24,659
architecture and ER assisted testing to
see where the industry is headed next.

41
00:02:25,440 --> 00:02:29,055
So by the end of this session, you
will have a complete end-to-end

42
00:02:29,190 --> 00:02:33,870
view of how to design secure and
a future proof your API ecosystem.

43
00:02:34,370 --> 00:02:36,650
Why restful API dominates.

44
00:02:37,070 --> 00:02:41,000
Let's talk about the why Restful
API continues to dominate

45
00:02:41,000 --> 00:02:42,410
the modern API landscape.

46
00:02:42,830 --> 00:02:47,300
Even with the rise of newer
technologies like GraphQL and GRPC,

47
00:02:48,020 --> 00:02:50,120
first and foremost, rest is simple.

48
00:02:50,570 --> 00:02:56,420
It's uses standard HTP protocol methods
like get put post and delete, which every

49
00:02:56,420 --> 00:03:02,030
developer is aware of it and understands
that simplicity makes it easier to build,

50
00:03:02,360 --> 00:03:04,579
test, and scale applications quickly.

51
00:03:05,300 --> 00:03:09,829
Test APAs are also stateless, which
means each request contains all

52
00:03:09,829 --> 00:03:11,329
the information the server needs.

53
00:03:12,065 --> 00:03:15,605
This makes them highly scalable,
perfect for cloud native

54
00:03:15,665 --> 00:03:16,985
and a distributed systems.

55
00:03:17,405 --> 00:03:22,535
There is also a massive ecosystem behind
rest because it's been around for so long.

56
00:03:23,135 --> 00:03:27,965
There are countless tools, frameworks,
and libraries that support across

57
00:03:28,025 --> 00:03:29,825
every language and platform.

58
00:03:30,325 --> 00:03:30,445
Tell.

59
00:03:30,445 --> 00:03:34,195
Now we spoke about why API dominates.

60
00:03:34,435 --> 00:03:37,614
Now we'll see what are the
architecture benefits of it, which

61
00:03:37,614 --> 00:03:40,105
is scalability, interoperability.

62
00:03:40,450 --> 00:03:42,310
Flexibility and performance.

63
00:03:42,810 --> 00:03:48,330
Let's compare the three A P paradigms,
which is rest soap, GraphQL, to

64
00:03:49,290 --> 00:03:50,400
understand the ENT and trade offs.

65
00:03:50,640 --> 00:03:51,810
Let's start with the rest.

66
00:03:52,230 --> 00:03:55,800
It's resource based, lightweight
and widely rafted it.

67
00:03:56,430 --> 00:04:00,390
It mainly uses a JSON and for
data exchange and works great

68
00:04:00,390 --> 00:04:02,070
for web mobile applications.

69
00:04:02,400 --> 00:04:05,070
Its stateless design also
makes it easy to scale.

70
00:04:05,550 --> 00:04:06,190
On the other hand.

71
00:04:06,435 --> 00:04:09,495
SOAP is more traditional
protocol based approach.

72
00:04:09,584 --> 00:04:14,535
It's heavier because it lays on XML
and as a step may say structures.

73
00:04:15,105 --> 00:04:19,185
However, it's still used in the
enterprise and legacy systems where

74
00:04:19,515 --> 00:04:24,315
reliability and builtin security like
wwe, service security are crucial.

75
00:04:24,815 --> 00:04:28,325
Then we have a GraphQL, the
newer query based model.

76
00:04:28,865 --> 00:04:33,545
Unlike rest, you get fixed data
from each endpoint graph, queue led.

77
00:04:34,055 --> 00:04:39,335
Client specify exactly what data
they need, no more, no less.

78
00:04:39,545 --> 00:04:43,145
That makes it very efficient for
modern applications that handle

79
00:04:43,475 --> 00:04:45,665
complex or nest data structures.

80
00:04:46,165 --> 00:04:49,075
In short, rest is simple and scalable.

81
00:04:49,405 --> 00:04:51,415
So is a robust but heavy.

82
00:04:51,805 --> 00:04:54,295
Now, graphic is flexible and modern.

83
00:04:54,775 --> 00:04:58,284
The best choice really depends
on your projects context

84
00:04:58,284 --> 00:04:59,940
and needs, when to choose.

85
00:05:00,810 --> 00:05:05,190
And approaches now that we have
compared rest, soap and graph, let's

86
00:05:05,190 --> 00:05:07,290
talk about when to choose each one.

87
00:05:07,380 --> 00:05:12,660
In a real world scenarios, SOAP still
matters, especially in industries.

88
00:05:13,020 --> 00:05:15,570
Security really takes a key role.

89
00:05:16,080 --> 00:05:18,570
Reliability and compliance
on non-negotiable.

90
00:05:19,110 --> 00:05:22,350
Think about banking,
healthcare, government systems.

91
00:05:22,710 --> 00:05:27,060
These environments play on soap
because it enforce strict standards

92
00:05:27,060 --> 00:05:28,440
like web service, security.

93
00:05:28,935 --> 00:05:33,345
And support reliable messaging and
formal contracts between the services.

94
00:05:33,705 --> 00:05:39,255
So even though REST dominates most
modern web APIs, SOAP continues to be

95
00:05:39,255 --> 00:05:43,515
the backbone for a mission critical
and regulated workflows that can't

96
00:05:43,515 --> 00:05:45,795
afford a failure or inconsistency.

97
00:05:46,605 --> 00:05:50,805
On the other hand, we have a graph
QS rise, particularly in the modern

98
00:05:50,805 --> 00:05:53,295
JavaScript world, frontend applications.

99
00:05:53,685 --> 00:05:55,270
GraphQL gives the client.

100
00:05:55,650 --> 00:05:58,980
Fine grain control over
exactly what they really need.

101
00:05:59,460 --> 00:06:04,260
Reducing the number of round trips
to the server that makes it ideal for

102
00:06:04,260 --> 00:06:08,670
mobile applications where performance
and a bandwidth efficiency are key.

103
00:06:09,450 --> 00:06:12,180
Instead of fetching
too much or too little.

104
00:06:12,180 --> 00:06:16,530
Data GraphQL allows you to get
precisely what's required, which

105
00:06:16,530 --> 00:06:20,880
translates directly into faster,
more responsive user experience.

106
00:06:21,870 --> 00:06:25,020
So to summarize, SOAP is still the choice.

107
00:06:25,035 --> 00:06:29,015
For a strict enterprise
grade transactions, rest fits

108
00:06:29,015 --> 00:06:30,455
the most general purpose.

109
00:06:30,755 --> 00:06:35,105
APIs and graph cure shines when
you need a flexible, efficient

110
00:06:35,135 --> 00:06:39,035
data fetching, especially in a
modern web and mobile applications.

111
00:06:39,535 --> 00:06:42,745
Middleware platforms reducing
integration complexity.

112
00:06:42,745 --> 00:06:43,705
How was it doing?

113
00:06:44,245 --> 00:06:49,105
As organization build more and more
APIs and connect more systems together?

114
00:06:49,465 --> 00:06:52,975
One of the biggest challenge they
face is integration complexity.

115
00:06:53,815 --> 00:06:57,475
Traditionally integrating multiple
system meant writing, a lot of

116
00:06:57,565 --> 00:07:01,825
custom code, dealing with different
data formats, maintaining fragile

117
00:07:02,095 --> 00:07:03,865
connections and between services.

118
00:07:04,315 --> 00:07:07,645
Middleware platforms have
completely changed the landscape.

119
00:07:08,125 --> 00:07:12,835
These platforms have come with a visual
tools and a prebuilt connectors, for

120
00:07:12,835 --> 00:07:19,555
example, to say connectors to Salesforce,
S-A-P-A-W-S, or databases, which can

121
00:07:19,555 --> 00:07:24,765
reduce integration time by nearly a.
Instead of spending weeks, months,

122
00:07:24,855 --> 00:07:30,375
coding, point to point integrations,
teams can now configure, map and

123
00:07:30,375 --> 00:07:35,015
deploy connections through intuitive
interfaces, and it's just not just

124
00:07:35,015 --> 00:07:36,995
about the speed that I'm talking about.

125
00:07:37,085 --> 00:07:41,255
These enterprise middleware platforms
also provide elastic scalability

126
00:07:41,525 --> 00:07:46,175
to handle reading workloads and
real time monitoring to ensure the

127
00:07:46,175 --> 00:07:47,555
reliability and the performance.

128
00:07:48,185 --> 00:07:52,535
In other words, middleware has turned
integration from a painful manual

129
00:07:52,535 --> 00:07:58,505
process into a strategic exercise
focused on configuration and optimization

130
00:07:58,625 --> 00:08:00,545
rather than a raw development effort.

131
00:08:01,045 --> 00:08:02,875
Key middleware capabilities.

132
00:08:03,025 --> 00:08:07,195
Now let's look let's look some of the
key capabilities that make a modern

133
00:08:07,415 --> 00:08:09,094
middleware platform so powerful.

134
00:08:09,725 --> 00:08:11,555
Firstly, a pre-built connectors, the.

135
00:08:12,055 --> 00:08:16,255
Platforms come with an extensive
libraries of ready to use integrations,

136
00:08:16,314 --> 00:08:20,455
for example, connected to connect
us to Salesforce and SAPA Ws, or

137
00:08:20,455 --> 00:08:22,284
databases, which I mentioned earlier.

138
00:08:22,615 --> 00:08:26,574
These eliminates a reputative
coding and dramatically accelerates

139
00:08:26,574 --> 00:08:30,985
time to market because teams can
focus on configurations rather than

140
00:08:30,985 --> 00:08:32,895
building the code from scratch.

141
00:08:33,375 --> 00:08:38,744
Next, elastic scalability, middleware
platforms automatically scale up or down

142
00:08:38,744 --> 00:08:40,905
based on the traffic or seasonal demand.

143
00:08:41,264 --> 00:08:45,165
So whether it's an end of year sales
spike or an unexpected surge of

144
00:08:45,165 --> 00:08:49,029
traffic on the API calls the system
maintenance consistent performance

145
00:08:49,089 --> 00:08:52,829
without a manual tuning, then we
have a real time monitoring system.

146
00:08:53,249 --> 00:08:58,079
These tools provided deep observability
tracking metrics, logs, and

147
00:08:58,079 --> 00:09:00,299
alerts across distributed systems.

148
00:09:00,599 --> 00:09:05,579
That means team can detect the
issues way ahead and fix them

149
00:09:05,579 --> 00:09:07,079
before they impact the users.

150
00:09:07,469 --> 00:09:09,099
And finally, visual design tools.

151
00:09:09,914 --> 00:09:12,344
This is where the low
code revolution comes in.

152
00:09:13,004 --> 00:09:17,854
Middleware now allows developers and
even a technical business users to

153
00:09:17,854 --> 00:09:22,504
design, test, and deploy integration
workflows visually with a minimal coding.

154
00:09:23,464 --> 00:09:27,304
This tool bridges a gap between
a technical and non-technical

155
00:09:27,334 --> 00:09:30,214
teams making an integration,
a shared collaborative effort.

156
00:09:30,964 --> 00:09:35,494
All together, these capabilities turn a
middleware into a true integration engine.

157
00:09:35,869 --> 00:09:39,859
Simplifying complexity while
boosting speed, scalability and

158
00:09:39,859 --> 00:09:44,529
reliability, security that plays
a non-negotiable foundation.

159
00:09:44,709 --> 00:09:48,189
Now, let's talk about something
that's ab absolutely non-negotiable

160
00:09:48,189 --> 00:09:49,629
in any API ecosystem.

161
00:09:49,629 --> 00:09:54,579
Secure API ecosystem too often,
security is as afterthought.

162
00:09:54,669 --> 00:09:58,749
That means we all think that we can
build in security later in time.

163
00:09:58,809 --> 00:10:02,649
Once a P is all complete design and
double, but that's really wrong.

164
00:10:03,069 --> 00:10:03,549
Something.

165
00:10:03,969 --> 00:10:07,689
That which really need to take it at the
first priority than being at the end.

166
00:10:08,169 --> 00:10:09,489
But in reality it has.

167
00:10:09,759 --> 00:10:13,929
It has to be designed in every layer
of your a p architecture from day one.

168
00:10:14,589 --> 00:10:19,599
When we combine measures like what for
security authentication, robust API

169
00:10:19,599 --> 00:10:23,109
gateways for managing and filtering
your traffic and comprehensive

170
00:10:23,109 --> 00:10:27,339
lifecycle management to track
every stage from the deployment and

171
00:10:27,339 --> 00:10:32,229
deprecation, we can dramatically
reduce endpoint vulnerabilities.

172
00:10:32,769 --> 00:10:38,049
These layers work together to protect
sensitive data, ensure regulatory

173
00:10:38,469 --> 00:10:42,759
complaints, and maintain trust,
especially in the industries like

174
00:10:42,759 --> 00:10:45,339
finance, healthcare, or government else.

175
00:10:45,909 --> 00:10:49,079
Rest rest on without its
skill, performance and

176
00:10:49,319 --> 00:10:50,849
innovations, we don't matter.

177
00:10:51,349 --> 00:10:56,299
Multi-layered security framework,
modern APIs rely on multi-layered

178
00:10:56,299 --> 00:10:57,794
security framework to stay safe.

179
00:10:58,699 --> 00:11:03,979
We use OAuth for secure token based
access API gateways to handle the

180
00:11:03,979 --> 00:11:07,939
rate limiting validations and the
threat detections and lifecycle

181
00:11:07,939 --> 00:11:11,809
management to enforce versioning,
deprecation, and continuous auditing.

182
00:11:12,309 --> 00:11:17,079
Together these layers form a defense
in depth strategy, predicting

183
00:11:17,079 --> 00:11:21,459
against evolving threats while
keeping APIs usable for legitimate

184
00:11:21,459 --> 00:11:23,669
clients production best practices.

185
00:11:24,374 --> 00:11:27,884
When it comes to running an a p in
prod, what do we really need to do?

186
00:11:28,184 --> 00:11:32,154
Following making an A PIA best
pro best followed approaches.

187
00:11:32,634 --> 00:11:36,684
These are the following best practices,
ensures reliability, security,

188
00:11:36,684 --> 00:11:38,184
and a great developer experience.

189
00:11:38,544 --> 00:11:40,884
First is standardizing
pandemic conventions.

190
00:11:41,154 --> 00:11:42,534
Consistent your patterns.

191
00:11:42,534 --> 00:11:46,209
Clear resource hierarchies,
unpredictable endpoints makes an

192
00:11:46,209 --> 00:11:51,804
API easier to understand and foster
for new developers to onboard next.

193
00:11:52,329 --> 00:11:55,689
Rigorous testing that plays
a key role where we can catch

194
00:11:55,689 --> 00:11:58,119
the major defects beforehand.

195
00:11:58,659 --> 00:12:02,949
Automated integration tests,
performance benchmarking and security

196
00:12:02,949 --> 00:12:06,219
vulnerability scans catch issues
before they reach a production,

197
00:12:06,699 --> 00:12:08,589
reducing a downtime under risk.

198
00:12:09,069 --> 00:12:14,309
Finally, a detailed documentation
interacted API explores multi-language

199
00:12:14,309 --> 00:12:17,789
core examples, and a clear visualing log.

200
00:12:18,044 --> 00:12:22,334
Help developers adopt your APIs
quickly, and then user support overhead.

201
00:12:23,174 --> 00:12:27,524
In short, standardization testing
and documentations are the pillars

202
00:12:27,524 --> 00:12:29,684
of producing production ready APIs.

203
00:12:30,434 --> 00:12:35,174
They make your APIs reliable,
secure, and easy to use and scary.

204
00:12:35,674 --> 00:12:37,084
Emerging trends.

205
00:12:37,114 --> 00:12:38,434
Event driven architecture.

206
00:12:38,584 --> 00:12:39,274
What do you mean?

207
00:12:39,274 --> 00:12:41,254
What do you mean by event
driven architecture?

208
00:12:42,189 --> 00:12:47,259
The key, a key trend in modern JavaScript
ecosystem is event driven architectures.

209
00:12:47,319 --> 00:12:52,149
Unlike a traditional request response
models, event driven systems, decouple

210
00:12:52,149 --> 00:12:57,129
services and use a synchronous messaging,
enabling a real time data flows

211
00:12:57,279 --> 00:12:59,229
improve resilience and dynamic scaling.

212
00:12:59,529 --> 00:13:00,279
How does it work?

213
00:13:00,759 --> 00:13:04,419
We all know we, we pub there,
there are ways where you can

214
00:13:04,419 --> 00:13:07,014
just publish it and subscribe it.

215
00:13:07,659 --> 00:13:11,229
When of any of the event or
any change on that state?

216
00:13:11,949 --> 00:13:16,149
So firstly, the event producers
service emits the event whenever

217
00:13:16,149 --> 00:13:17,259
there is a change in the state.

218
00:13:17,619 --> 00:13:23,049
Second message Brokers tools
like Kafka topic, rapid mq.

219
00:13:23,379 --> 00:13:25,869
Route these events to
the right subscribers.

220
00:13:26,409 --> 00:13:30,699
Event consumers, other services react
independently to the events they

221
00:13:30,699 --> 00:13:33,069
care about without tight coupling.

222
00:13:33,669 --> 00:13:36,849
By adopting these patterns,
system can respond.

223
00:13:37,269 --> 00:13:42,189
In a real time scale, dynamically
under load and isolate of failures,

224
00:13:42,339 --> 00:13:46,329
making an architecture more robust
and flexible for modern applications.

225
00:13:46,829 --> 00:13:51,929
Now coming to the AI assisted testing
and a Future innovations, the biggest,

226
00:13:52,169 --> 00:13:57,029
the big wave in API development and
an operations is AI assisted testing.

227
00:13:57,149 --> 00:14:01,469
And it's already reshaping how we
ensure a quality and a reliability.

228
00:14:02,429 --> 00:14:06,749
We are now seeing a machine learning,
models that automatically generate test

229
00:14:06,749 --> 00:14:11,519
cases, predict potential failure points
and optimize the coverage strategies.

230
00:14:11,759 --> 00:14:16,439
This means less manual testing effort,
faster release cycles, and higher

231
00:14:16,439 --> 00:14:21,239
bug detection rates, especially in
a complex multi-service integrations

232
00:14:21,239 --> 00:14:23,549
where human testing alone can't keep up.

233
00:14:24,269 --> 00:14:27,359
Looking ahead, we are moving
towards even smarter systems.

234
00:14:28,004 --> 00:14:32,714
Imagine a self feeling, APIs that
automatically adapt to failures

235
00:14:33,014 --> 00:14:37,424
or intelligent rate limiting that
are just based on usage behavior

236
00:14:37,544 --> 00:14:38,864
rather than fixed thresholds.

237
00:14:39,554 --> 00:14:44,504
We also see a automated security patching
and predictive performance optimization

238
00:14:44,834 --> 00:14:49,544
where AI can identify potential
bottlenecks before the impact users.

239
00:14:49,904 --> 00:14:51,614
In short, AI isn't just.

240
00:14:51,974 --> 00:14:53,444
Helping US test better.

241
00:14:53,504 --> 00:14:58,964
It's redefining how APIs evolve, recover,
and optimize themselves in real time.

242
00:14:59,464 --> 00:15:01,894
Building a future ready API Systems.

243
00:15:02,524 --> 00:15:07,369
To wrap up my talk, let's look at what
it takes to build a future ready api.

244
00:15:07,474 --> 00:15:12,104
API System First Skill takes
the first priority designed

245
00:15:12,104 --> 00:15:15,044
for growth from day one use.

246
00:15:15,554 --> 00:15:20,084
Stateless architecture, elastic
infrastructure, so your APIs can

247
00:15:20,084 --> 00:15:22,514
scale seamlessly as demand increase.

248
00:15:22,694 --> 00:15:24,584
Secondly, security by design.

249
00:15:24,734 --> 00:15:26,414
Like I said, security takes a key role.

250
00:15:26,954 --> 00:15:30,734
Make security an integral part of
every stage of the API lifecycle.

251
00:15:31,004 --> 00:15:34,904
Implement multi-layered protections
and proactive vulnerability

252
00:15:34,904 --> 00:15:37,154
management and stay ahead of threats.

253
00:15:37,724 --> 00:15:39,824
And finally, the future
adapt, adaptability.

254
00:15:40,324 --> 00:15:44,884
Stay competitive by embracing emerging
patterns like event driven architecture

255
00:15:45,214 --> 00:15:46,744
and AI assisted tool testing.

256
00:15:47,284 --> 00:15:51,784
These innovations will shape how
API APIs evolve and interact in

257
00:15:51,784 --> 00:15:54,239
the ES ahead with these strategies.

258
00:15:54,424 --> 00:15:59,314
Strategies you are ready to design and
operate APIs that are scalable, secure,

259
00:15:59,374 --> 00:16:04,204
and interoperable and resilient, even
as technology continues to change.

260
00:16:04,504 --> 00:16:06,904
I would like to conclude
my talk with the statement.

261
00:16:07,114 --> 00:16:10,654
The APIs we build today are
the connections that powers

262
00:16:10,654 --> 00:16:11,854
tomorrow's innovation.

263
00:16:12,184 --> 00:16:15,994
Let's design them not just to
function, but to evolve, adapt,

264
00:16:16,084 --> 00:16:17,884
and inspire what comes next.

265
00:16:18,544 --> 00:16:20,159
Thank you for listening to me for.

