1
00:00:00,810 --> 00:00:05,580
Speaker 34: And in embedded system, we
are often told we must choose either

2
00:00:05,580 --> 00:00:11,010
deterministic, realtime behavior,
or intelligent AI driven systems.

3
00:00:11,510 --> 00:00:16,250
Today I want to show you
why this trade off is false.

4
00:00:16,750 --> 00:00:18,340
Hello, one second.

5
00:00:18,400 --> 00:00:21,085
I am Raja, a senior
software engineer in A SML.

6
00:00:21,900 --> 00:00:26,850
I work in realtime embedded system where
missing deadlines are unacceptable, yet

7
00:00:26,850 --> 00:00:30,059
intelligent and becoming unavoidable.

8
00:00:30,559 --> 00:00:33,334
So let's move on to the next one.

9
00:00:33,834 --> 00:00:38,604
So this is called the embedded
paradox or embedded AI paradox.

10
00:00:39,024 --> 00:00:40,494
Let's start with the core challenges.

11
00:00:41,064 --> 00:00:42,174
Limited compute.

12
00:00:42,594 --> 00:00:50,744
So that means we cannot have enough power
or we cannot have powerful CPUs or CPUs.

13
00:00:51,074 --> 00:00:56,894
So embedded system is made for only one
task to do so we cannot have more power.

14
00:00:57,385 --> 00:00:59,005
And that too, we have light.

15
00:00:59,089 --> 00:01:01,520
Or tight memory budgets.

16
00:01:01,639 --> 00:01:06,830
So we cannot go for a lot of memory
because then that becomes more expensive

17
00:01:06,889 --> 00:01:10,789
and that is also not easy to handle
as well, because we want to do limited

18
00:01:10,789 --> 00:01:12,830
time things in limited time actually.

19
00:01:13,160 --> 00:01:14,414
So that is where the
time comes to picture.

20
00:01:15,120 --> 00:01:16,710
So millisecond latency.

21
00:01:17,190 --> 00:01:22,290
So anything goes beyond here
until a little bit in the time.

22
00:01:23,160 --> 00:01:25,020
Then time is a big catch problem there.

23
00:01:25,560 --> 00:01:29,670
So embedded system is always
bound within the time limit.

24
00:01:30,480 --> 00:01:34,920
So I can say that millisecond
latency requirements, like in

25
00:01:34,980 --> 00:01:39,480
real time system, the AI decision
that arrives, let, it's a failure.

26
00:01:39,630 --> 00:01:42,165
It has to be on time in traditional ai.

27
00:01:43,140 --> 00:01:45,480
Optimizes for accuracy and throughput.

28
00:01:46,020 --> 00:01:49,200
Real time systems optimize
for predictability.

29
00:01:49,700 --> 00:01:51,110
Let's move on to the next one.

30
00:01:51,770 --> 00:01:57,399
So introduction to ai, sorry,
ri, introduction to re A IF.

31
00:01:58,210 --> 00:02:00,850
So there was a little bit
of hiccups here and there.

32
00:02:00,940 --> 00:02:03,919
So REAI chemic kind of thing.

33
00:02:03,919 --> 00:02:08,410
Anyways, so let's go ahead with
introduction to a sorry, one second.

34
00:02:08,680 --> 00:02:09,699
R-E-A-I-F.

35
00:02:10,120 --> 00:02:12,435
This challenge led to the decision.

36
00:02:12,990 --> 00:02:17,279
Of RE A IF, the realtime
embedded AI framework.

37
00:02:17,779 --> 00:02:21,679
A re A IF is built on a simple principle.

38
00:02:22,009 --> 00:02:25,980
AI must adopt the realtime
constraint not break them.

39
00:02:26,220 --> 00:02:28,799
So here you can see that lot
of, interface, user interface,

40
00:02:28,799 --> 00:02:31,809
web client, mobile client,
they all are trying to access.

41
00:02:32,450 --> 00:02:36,079
And this is the biggest thing, like an
application server that is the ai, but

42
00:02:36,409 --> 00:02:40,009
ev, everything sits here and that takes
the decision of where to go and where

43
00:02:40,009 --> 00:02:41,450
to then grab the data and all that.

44
00:02:41,450 --> 00:02:44,029
So it has to happen in the real time.

45
00:02:44,899 --> 00:02:48,409
So it provides intelligent functionality
without compromising reliability.

46
00:02:48,909 --> 00:02:51,729
Safety or responsiveness.

47
00:02:52,029 --> 00:02:55,299
The goal is not maximum intelligence.

48
00:02:55,299 --> 00:02:57,039
The goal is predictable intelligence.

49
00:02:57,039 --> 00:03:02,309
So AI is the main, the biggest
factor for AI is not to maximize

50
00:03:02,309 --> 00:03:06,839
the intelligence, but we have to
be more and more smart actually.

51
00:03:07,339 --> 00:03:07,699
Okay.

52
00:03:07,939 --> 00:03:09,979
So that we can understand what
is going to happen next, what

53
00:03:09,979 --> 00:03:10,969
it's going to happen next.

54
00:03:11,209 --> 00:03:14,389
So charge G pt, the way it works
actually, so similar to that.

55
00:03:15,304 --> 00:03:17,284
So next, move on to the next page.

56
00:03:17,784 --> 00:03:18,624
Architecture overview.

57
00:03:19,124 --> 00:03:25,204
So the real time AI framework follows
the hierarchal design philosophy.

58
00:03:25,474 --> 00:03:29,314
The system is organized into three
layers, operate in a synchronized

59
00:03:29,314 --> 00:03:33,324
control loop, precipitate precipitation
layer perception layer, sorry,

60
00:03:33,534 --> 00:03:35,654
perception layer, cognition layer.

61
00:03:36,174 --> 00:03:37,074
Execution layer.

62
00:03:37,464 --> 00:03:41,244
So perception layer, the perception
layer handles deterministic sensor

63
00:03:41,744 --> 00:03:47,414
acquisition and pre-processing
sensor fusion ensures that all data,

64
00:03:47,804 --> 00:03:49,814
it's time aligned and reliable.

65
00:03:50,234 --> 00:03:52,154
So everything has to be
in a time-based actually.

66
00:03:52,154 --> 00:03:53,719
So that's the main thing.

67
00:03:53,979 --> 00:03:54,994
And cognition layer.

68
00:03:55,024 --> 00:03:59,664
The cognition layer performs AI interface
using embedded, optimized model.

69
00:04:00,144 --> 00:04:04,694
And, these models are quantized
and hardware accelerated

70
00:04:05,084 --> 00:04:07,514
to ensure bounded latency.

71
00:04:07,544 --> 00:04:10,304
So the latency is the major factor here.

72
00:04:11,024 --> 00:04:15,699
Okay, so the key idea here is coordination
without sacrificing determination.

73
00:04:16,199 --> 00:04:20,039
So basically you have to determine
what is going to happen next,

74
00:04:20,039 --> 00:04:22,049
what might going to happen next.

75
00:04:22,259 --> 00:04:26,275
So we need a lot of examples lot of,
in our models actually, so that, it

76
00:04:26,365 --> 00:04:28,465
keeps on working on that actually.

77
00:04:28,965 --> 00:04:34,695
So the execution layer, as I told
you, like it has to be more of free.

78
00:04:34,875 --> 00:04:37,365
Every action is scheduled and verified.

79
00:04:37,865 --> 00:04:40,385
So next, move on to the next one.

80
00:04:41,325 --> 00:04:44,684
Which is basically hard hybrid
architecture when natural

81
00:04:44,834 --> 00:04:49,034
questions come to our mind,
why not just Python everywhere?

82
00:04:49,424 --> 00:04:52,064
Because Python is not, that is
one of our favorite language.

83
00:04:52,064 --> 00:04:53,144
Everybody likes that.

84
00:04:53,534 --> 00:04:56,914
You just writing English, you're not
writing programming language when it

85
00:04:56,914 --> 00:05:01,564
comes to Python, actually, and it is
very easy to write the code in Python

86
00:05:02,074 --> 00:05:03,604
and understand the Python and all that.

87
00:05:04,234 --> 00:05:07,984
But Python, let me say, Python is
an excellent and rapid development

88
00:05:07,984 --> 00:05:11,584
and AI workflow, but it is not
suitable for a hard realtime system.

89
00:05:11,974 --> 00:05:13,594
So hard I've been here.

90
00:05:13,594 --> 00:05:16,314
I want to give you some kind of
example of what is the hard realtime

91
00:05:16,314 --> 00:05:18,174
system and soft realtime system.

92
00:05:18,744 --> 00:05:22,884
Hard realtime system means if
something has been meant to be

93
00:05:23,004 --> 00:05:27,324
completed in, supposed in two
millisecond, that has to be completed.

94
00:05:27,384 --> 00:05:30,894
Completed in two milliseconds, but
soft railing, the realtime system

95
00:05:30,894 --> 00:05:35,414
means something has scheduled
to be reached on time, but if it

96
00:05:35,504 --> 00:05:36,914
gets delayed, that is also fine.

97
00:05:36,914 --> 00:05:38,174
Like we have message.

98
00:05:38,174 --> 00:05:40,809
Or text messages in the phone.

99
00:05:40,959 --> 00:05:45,159
Sometimes we send now, but it
is it reaches around 20 minutes

100
00:05:45,159 --> 00:05:46,299
later, that's still fine.

101
00:05:47,109 --> 00:05:52,279
But in the real time in hard, real
time, systems that is not acceptable.

102
00:05:53,119 --> 00:05:57,869
So in real time AI framework, c
plus forms a deterministic core.

103
00:05:58,369 --> 00:06:02,749
It handles control loops scheduling,
sensor fusion management, mystery

104
00:06:02,749 --> 00:06:04,579
memory management, and hardware access.

105
00:06:05,329 --> 00:06:10,819
Python is used for, Python is used for
model development, training, pipelines

106
00:06:11,029 --> 00:06:16,639
and analytics optimized bindings
connect, optimize optimized bindings.

107
00:06:16,819 --> 00:06:19,714
Connector, two worlds
with minimal overhead.

108
00:06:20,524 --> 00:06:24,604
The hybrid approach each gives us
both performance and productivity.

109
00:06:25,589 --> 00:06:30,179
As I told you in c plus we have again
sensor fusion pipelines, deterministic,

110
00:06:30,179 --> 00:06:31,319
and we have task scheduling.

111
00:06:31,319 --> 00:06:34,619
We have process scheduling, we have
memory management, we have shared

112
00:06:34,619 --> 00:06:38,029
pointers, and we have nowadays
we have c plus 11, C plus 30.

113
00:06:38,329 --> 00:06:44,629
17, 23, 20. Which makes the c plus was
also easy to write and write the code.

114
00:06:44,719 --> 00:06:50,909
And it is, it is more secure safety
and it is more of working towards

115
00:06:50,999 --> 00:06:56,389
getting more robust system actually
and where, whereas Python is always for

116
00:06:56,389 --> 00:06:59,239
training the module and data analysis.

117
00:06:59,249 --> 00:07:03,389
Training pipelines, advanced analytic
analytics and visualization, and all

118
00:07:03,389 --> 00:07:05,009
those things you can do in Python.

119
00:07:05,009 --> 00:07:08,239
And that is also a biggest
advantage, by using Python.

120
00:07:08,739 --> 00:07:09,459
So next slide.

121
00:07:09,804 --> 00:07:11,184
So embedded intelligence talk.

122
00:07:11,684 --> 00:07:17,804
Let's say making this, making making this
work request, aggressive optimization,

123
00:07:18,224 --> 00:07:21,554
quantized, CNN, reduced memory usage by.

124
00:07:21,619 --> 00:07:23,029
Up to four times.

125
00:07:23,029 --> 00:07:28,939
Preserving accuracy, hardware
acceleration, using our neon and GPUs,

126
00:07:28,939 --> 00:07:35,539
provide up to 10 times interface,
sorry, inference 10 times inference

127
00:07:35,599 --> 00:07:38,199
speed ups, compile times scheduling.

128
00:07:39,024 --> 00:07:40,044
Random time uncertainty.

129
00:07:40,544 --> 00:07:41,444
Lock free.

130
00:07:41,944 --> 00:07:43,174
Yeah, lock free.

131
00:07:43,224 --> 00:07:46,854
Queues eliminates priority inversion
and synchronization bottleneck.

132
00:07:47,814 --> 00:07:51,204
So I would like to give you one
example of priority inversion.

133
00:07:51,564 --> 00:07:53,514
So priority inversion.

134
00:07:53,574 --> 00:07:55,014
What is, what does that mean actually?

135
00:07:55,554 --> 00:07:57,714
So priority inversion is
basically, like one task.

136
00:07:58,214 --> 00:08:01,394
Has given highest priority or the
task has given lowest priority.

137
00:08:02,174 --> 00:08:03,224
So what happens?

138
00:08:03,284 --> 00:08:07,229
Lowest priority task is doing some work
and higher priority task is coming.

139
00:08:07,729 --> 00:08:11,089
But it cannot able to take that work
because lowest priority is already

140
00:08:11,599 --> 00:08:16,280
accessing that particular module or that
particular resource, so it cannot able

141
00:08:16,280 --> 00:08:18,109
to take what it has supposed to take.

142
00:08:18,169 --> 00:08:21,829
So now what to do
actually, now what happens?

143
00:08:21,889 --> 00:08:23,994
This high spare task inherits, its.

144
00:08:24,974 --> 00:08:28,244
Priority to low priority task and then
low priority task gets higher priority

145
00:08:28,244 --> 00:08:32,954
task, and then it does its job and
lifts the resource and gives the task

146
00:08:33,054 --> 00:08:34,599
priority to highest priority task again.

147
00:08:35,259 --> 00:08:41,254
So that is bit complex thing, but I
hope I could able to make that, I make

148
00:08:41,254 --> 00:08:44,984
that thing to understand to you guys
anyways moving on to the next one.

149
00:08:45,034 --> 00:08:48,099
Every optimization exists in one
region to protect real time guarantee.

150
00:08:48,359 --> 00:08:52,189
So all this optimization we are doing
to protect our real time guarantees.

151
00:08:53,060 --> 00:08:54,109
Move to the next one.

152
00:08:54,619 --> 00:08:57,229
So this is energy, our operation.

153
00:08:57,829 --> 00:08:59,419
Performance alone is not enough.

154
00:08:59,599 --> 00:09:00,204
Energy matters.

155
00:09:00,539 --> 00:09:00,749
Basically.

156
00:09:01,249 --> 00:09:06,169
So dynamic voltage scaling reduces power
consumption during load demand periods.

157
00:09:06,769 --> 00:09:10,759
Intelligent hibernation shuts down
a new subsystem without impacting

158
00:09:10,759 --> 00:09:15,789
wake up latency memory pooling
eliminates fragmentation and

159
00:09:15,789 --> 00:09:18,369
reduces energy port transaction.

160
00:09:18,869 --> 00:09:22,199
This mechanism extend
operational endurance without

161
00:09:22,199 --> 00:09:23,494
violating time constraint.

162
00:09:23,849 --> 00:09:26,415
So the thing is that if something
we are not using like in a computer.

163
00:09:27,074 --> 00:09:28,005
We are not using computer.

164
00:09:28,005 --> 00:09:31,814
The computer was going into hibernation
more so that it can save the battery.

165
00:09:32,235 --> 00:09:36,194
And yeah, so in real time also
like something, we are not using it

166
00:09:36,194 --> 00:09:40,734
for a long time, we can move it to
hibernation thing so that we don't

167
00:09:40,734 --> 00:09:43,374
have to really reuse the battery.

168
00:09:43,374 --> 00:09:46,194
Actually, like if you
see language, Tesla cars.

169
00:09:46,704 --> 00:09:52,205
Or all these, battery operated, I,
items, they basically have they basically

170
00:09:52,205 --> 00:09:54,055
have energy saving mechanism actually.

171
00:09:54,555 --> 00:09:56,210
Okay, so next, move on to the next one.

172
00:09:56,710 --> 00:10:01,805
So are we missing something or no?

173
00:10:02,305 --> 00:10:08,105
So now moving this one, so it is nothing
but our manufacturing applications.

174
00:10:08,165 --> 00:10:09,935
So that is nothing but
industrial applications.

175
00:10:10,110 --> 00:10:10,330
Yes.

176
00:10:11,020 --> 00:10:16,660
So in manufacturing environment, real
time AI framework enables a real impact,

177
00:10:16,660 --> 00:10:22,240
actually vision guided precisions,
assembly chips, sub millimeter

178
00:10:22,450 --> 00:10:25,865
accuracy with the 99.7 success threat.

179
00:10:26,125 --> 00:10:28,385
So if you see nowadays, Google Maps.

180
00:10:28,745 --> 00:10:28,895
And all.

181
00:10:29,885 --> 00:10:34,885
So as soon as you miss one exit,
it automatically, it just within

182
00:10:34,885 --> 00:10:38,905
a fraction of seconds or within
few seconds very limited time.

183
00:10:39,325 --> 00:10:42,505
It just tracks you know how far you
went, so you went to a different road

184
00:10:42,505 --> 00:10:44,525
so it can reroute in a different way.

185
00:10:45,035 --> 00:10:46,805
So similarly, those kind of things.

186
00:10:46,805 --> 00:10:50,675
And in vision, guided precision, like
nowadays, automotive the cars, so

187
00:10:50,675 --> 00:10:52,145
when the cars are going on the road.

188
00:10:52,660 --> 00:10:54,670
So they see which is
in the front actually.

189
00:10:55,150 --> 00:10:58,090
So immediately they take the decision
whether I have to go to right or left

190
00:10:58,140 --> 00:11:00,360
or I have to be on my lane or something.

191
00:11:00,900 --> 00:11:02,730
So those decisions, it has been taken.

192
00:11:02,730 --> 00:11:05,470
So those kind of things, we can take
the advantage of those learnings.

193
00:11:05,975 --> 00:11:10,775
And we can, proceed actually at real
time inspection increases throughout by

194
00:11:10,985 --> 00:11:14,465
35% while reducing the false positive.

195
00:11:14,945 --> 00:11:19,015
So by training our models and all,
we can, get rid of all these false

196
00:11:19,015 --> 00:11:23,835
positive things actually, and predictive
maintenance reduces unplanned downtime.

197
00:11:23,835 --> 00:11:25,390
60% maintenance reduces.

198
00:11:25,890 --> 00:11:29,900
Unplanned downtime by 60% through
continuous system health monitoring.

199
00:11:30,199 --> 00:11:35,180
This proactive approach optimizes
operational efficiency and extend

200
00:11:35,449 --> 00:11:39,229
equipment lifespan so that basically,
in the downtime, if you're continuously

201
00:11:39,439 --> 00:11:42,919
checking the health monitoring, in
monitoring the health, this could

202
00:11:42,919 --> 00:11:46,099
able to optimize the operational
efficiency and extend the equipment

203
00:11:46,099 --> 00:11:48,399
lifespan in the defense applications.

204
00:11:49,024 --> 00:11:52,724
So in the defense applications, nowadays,
everywhere, every country is trying

205
00:11:52,724 --> 00:11:55,054
to go beyond, do something extra.

206
00:11:55,114 --> 00:11:55,954
Do something extra.

207
00:11:55,954 --> 00:11:59,744
So in defense environment, reliability
is non-negotiable actually.

208
00:11:59,744 --> 00:12:01,514
So there, the real hard, real time.

209
00:12:02,234 --> 00:12:05,514
System comes together without, in my
previous slides I told, hard realtime

210
00:12:05,514 --> 00:12:06,744
system and software, realtime system.

211
00:12:07,134 --> 00:12:08,935
So this is where the hard
realtime system comes.

212
00:12:08,935 --> 00:12:12,024
Now, if you want to hit
somewhere, you have to use, you

213
00:12:12,024 --> 00:12:13,314
have to use that in real time.

214
00:12:13,764 --> 00:12:18,199
And where system and you have to be there
and you cannot go somewhere else as well.

215
00:12:18,699 --> 00:12:23,620
So there GPS, location it has to be
a hundred percent or near to 99.99%.

216
00:12:24,080 --> 00:12:24,365
Okay, anyways.

217
00:12:24,595 --> 00:12:24,985
Moving on.

218
00:12:25,295 --> 00:12:28,675
So real time AI framework
supports autonomous navigation

219
00:12:29,215 --> 00:12:31,775
in GPS in GPS denied environment.

220
00:12:32,255 --> 00:12:36,805
Through sensor fusion, swarm
coordination emerge from distributed

221
00:12:36,805 --> 00:12:38,185
deterministic decision making.

222
00:12:38,725 --> 00:12:43,765
Systems were evaluated in
contested scenario with a dynamic

223
00:12:43,765 --> 00:12:45,835
obstacle and bandwidth constraint.

224
00:12:46,335 --> 00:12:47,440
I want to the next one.

225
00:12:47,860 --> 00:12:50,080
So implementation and tape time.

226
00:12:50,710 --> 00:12:51,340
So c plus.

227
00:12:51,340 --> 00:12:53,710
This is my favorite topic actually,
how to implement because I'm a

228
00:12:53,710 --> 00:12:56,940
developer, so I basically know,
develop the core and let's see.

229
00:12:57,090 --> 00:12:59,080
So yeah, c plus sensor fusion.

230
00:12:59,580 --> 00:13:02,970
Loops are to one kilohertz
with AF scheduling.

231
00:13:03,600 --> 00:13:05,610
So that is one of the scheduling.

232
00:13:05,610 --> 00:13:07,889
When it comes to scheduling,
we have to be very careful.

233
00:13:07,889 --> 00:13:10,599
With respect to priority
priority scheduling.

234
00:13:10,805 --> 00:13:12,624
Or the round run scheduling
and all those things.

235
00:13:12,624 --> 00:13:13,314
We have to take care.

236
00:13:13,524 --> 00:13:14,785
The different threats comes into picture.

237
00:13:15,114 --> 00:13:19,724
That is a multithread data acquisition
for con, concurrent sensor input, adaptive

238
00:13:19,754 --> 00:13:23,024
calm filtering for state estimations.

239
00:13:23,524 --> 00:13:27,744
Then we have inference latency
is under eight milliseconds.

240
00:13:28,164 --> 00:13:31,644
AC actuator jitter remains
below 50 milliseconds.

241
00:13:31,914 --> 00:13:36,194
These numbers matters, especially
for safety certifications.

242
00:13:36,694 --> 00:13:39,845
So next is future capabilities.

243
00:13:40,345 --> 00:13:42,345
Looking forward, a, sorry.

244
00:13:42,495 --> 00:13:46,395
Looking forward re digital time
AI framework opens the door to

245
00:13:46,665 --> 00:13:52,105
federated learning, neuro moic
hardware and formal verification.

246
00:13:52,465 --> 00:13:57,115
It also enables intelligent workload
distribution between edge and cloud.

247
00:13:57,615 --> 00:13:58,035
The next one.

248
00:13:58,035 --> 00:13:58,845
So key takeaways.

249
00:13:58,845 --> 00:13:59,685
So what did what?

250
00:13:59,775 --> 00:14:01,155
What did we learn from here?

251
00:14:01,215 --> 00:14:01,605
Basically?

252
00:14:02,145 --> 00:14:04,185
So let me leave you with three takeaways.

253
00:14:04,485 --> 00:14:08,505
Deterministic control and
adaptive AI can coexist.

254
00:14:09,005 --> 00:14:10,115
We believe that, right?

255
00:14:10,655 --> 00:14:13,535
So next one, embedded optimization.

256
00:14:13,745 --> 00:14:14,195
Max.

257
00:14:14,195 --> 00:14:14,825
Realtime ai.

258
00:14:14,825 --> 00:14:16,375
Practical energy.

259
00:14:16,875 --> 00:14:18,940
Our energy, our decision, oh, sorry.

260
00:14:18,940 --> 00:14:19,270
Energy.

261
00:14:19,270 --> 00:14:23,095
Our design ensure sustainability in field.

262
00:14:23,595 --> 00:14:23,895
Okay

263
00:14:24,395 --> 00:14:26,225
and I think I forgot why I missed one.

264
00:14:26,225 --> 00:14:27,485
That is product production.

265
00:14:27,485 --> 00:14:31,685
Production ready blueprint validates
across industrial and defense application.

266
00:14:32,285 --> 00:14:33,365
A ar real time.

267
00:14:33,865 --> 00:14:38,155
Provides a practical framework for
next generation autonomous system.

268
00:14:38,655 --> 00:14:40,995
And that's all from my end.

269
00:14:40,995 --> 00:14:42,135
Thank you so much.

270
00:14:42,705 --> 00:14:46,600
And ai, sorry again, I'm just
getting confused with these words.

271
00:14:46,620 --> 00:14:52,360
But anyways real time, ai f. It is
not just a framework, it's a blueprint

272
00:14:52,960 --> 00:14:57,190
for next generation for the next
generation embedded intelligence.

273
00:14:57,820 --> 00:14:58,690
Thank you so much.

