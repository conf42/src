1
00:00:00,500 --> 00:00:01,099
Speaker 11: Good morning.

2
00:00:01,160 --> 00:00:02,269
Good afternoon, everyone.

3
00:00:02,599 --> 00:00:02,840
I'm

4
00:00:02,840 --> 00:00:05,539
Speaker 12: Gu Deep Gill
technical leader at Cisco Systems.

5
00:00:05,810 --> 00:00:07,549
Thank you for joining today.

6
00:00:07,549 --> 00:00:12,919
I'll shared a practical way to build
security into your DevOps pipeline for

7
00:00:12,919 --> 00:00:18,200
AI workloads so you get strong protection
without giving up deployment velocity.

8
00:00:18,904 --> 00:00:20,855
Imagine it's a normal Tuesday.

9
00:00:21,544 --> 00:00:28,325
Your team ships a small update to an a i
endpoint, maybe a recommendation model,

10
00:00:28,775 --> 00:00:31,895
LLM assistant, an image classifier.

11
00:00:32,375 --> 00:00:35,795
It's simple release until
it becomes a feature.

12
00:00:36,005 --> 00:00:36,850
Everyone depends on.

13
00:00:37,350 --> 00:00:38,340
Traffic ramps.

14
00:00:38,460 --> 00:00:42,180
Customers are happy, leadership
is thrilled, and then the pattern

15
00:00:42,180 --> 00:00:45,660
changes, not an outage, not a crash.

16
00:00:46,200 --> 00:00:47,160
Just request that.

17
00:00:47,160 --> 00:00:49,260
Feel a little too curious.

18
00:00:50,220 --> 00:00:53,070
That's the moment the session is for.

19
00:00:53,700 --> 00:00:59,880
I'm going to talk about why AI
shift security from static code.

20
00:01:00,345 --> 00:01:03,814
To runtime behavior, but
next donation firewalls.

21
00:01:03,874 --> 00:01:06,904
Add beyond IP and port rules.

22
00:01:07,744 --> 00:01:16,354
How to wire NGFW controls into CICD and
runtime, and how to roll it out safely.

23
00:01:16,559 --> 00:01:20,280
Monitor first, then
enforce, then optimize.

24
00:01:20,780 --> 00:01:22,430
So let's name the tension.

25
00:01:22,520 --> 00:01:24,080
Every modern team fails.

26
00:01:24,580 --> 00:01:27,010
Talent, velocity versus security.

27
00:01:27,510 --> 00:01:28,320
Let's meet Maya.

28
00:01:28,740 --> 00:01:30,720
Maya runs a DevOps team.

29
00:01:31,380 --> 00:01:31,830
They deploy.

30
00:01:32,330 --> 00:01:35,960
They deploy several times a day
because the business expects

31
00:01:35,960 --> 00:01:38,150
it, and honestly, it works.

32
00:01:38,840 --> 00:01:42,290
Shipping fast is a competitive
advantage now Miro.

33
00:01:42,790 --> 00:01:44,590
Rook is not trying to slow anyone down.

34
00:01:44,830 --> 00:01:47,050
Rook is trying to prevent the headline.

35
00:01:47,620 --> 00:01:48,610
Here's a conflict.

36
00:01:49,270 --> 00:01:52,330
Traditional security is
built like a toll booth.

37
00:01:52,720 --> 00:01:57,670
It assumes changes are rare
and traffic is low, but Maya's

38
00:01:57,670 --> 00:01:59,440
world is a multi-lane highway.

39
00:01:59,830 --> 00:02:03,940
If every release must stop for a
manual review, two things happen.

40
00:02:04,440 --> 00:02:11,009
Delivery slows and trust breaks down Teams
route around the checkpoint just this

41
00:02:11,009 --> 00:02:14,190
month, and that becomes shadow security.

42
00:02:14,730 --> 00:02:16,170
You have seen the symptoms.

43
00:02:16,560 --> 00:02:20,220
Temporary allow rules
that never get removed.

44
00:02:20,580 --> 00:02:21,870
One off exceptions.

45
00:02:21,870 --> 00:02:26,760
With no owner earth
approvals, done with no audit.

46
00:02:26,760 --> 00:02:31,740
Trail security controls that
only exist in production because

47
00:02:31,830 --> 00:02:33,375
they're too painful earlier.

48
00:02:33,915 --> 00:02:36,600
And with ai, the tension spikes.

49
00:02:36,840 --> 00:02:40,110
You're not only protecting
code anymore, you're protecting

50
00:02:40,680 --> 00:02:43,050
the model, the data pipeline.

51
00:02:43,845 --> 00:02:48,465
Prompts and unstructured input
where runtime attacks live and

52
00:02:48,465 --> 00:02:52,365
the outputs which can accidentally
reveal more than you intended.

53
00:02:53,115 --> 00:02:58,984
So the requirement changes from
approve occasionally to validate

54
00:02:58,984 --> 00:03:05,315
continuously, security has to move
at DevOps speed, or it won't be used.

55
00:03:05,825 --> 00:03:06,214
Okay.

56
00:03:06,874 --> 00:03:11,765
Why does AI make this harder
than a normal web app?

57
00:03:12,265 --> 00:03:16,765
AI systems are powerful, but they
have a very different security

58
00:03:16,765 --> 00:03:18,799
personality than traditional apps.

59
00:03:19,299 --> 00:03:21,549
First inputs and unstructured.

60
00:03:22,120 --> 00:03:25,030
In a typical app, inputs
are forms and fields.

61
00:03:25,299 --> 00:03:31,989
In an AI system, the input might be a
paragraph of text and image or audio

62
00:03:32,620 --> 00:03:37,150
Ambiguity is a part of the design,
which means old school validation rules

63
00:03:37,150 --> 00:03:41,679
taught help much, and unstructured
input is exactly where attackers love

64
00:03:41,679 --> 00:03:46,559
to hide instructions inside normal
looking text payloads that look.

65
00:03:46,995 --> 00:03:48,795
Harmless to RegX rules.

66
00:03:49,454 --> 00:03:53,355
Prompts that try to trick a system
into breaking its own rules.

67
00:03:54,075 --> 00:03:57,974
Second outputs are non-deterministic.

68
00:03:58,334 --> 00:04:01,605
With classic software, you
can baseline behavior easily.

69
00:04:02,055 --> 00:04:06,045
Same input, same output,
but AI can be probabilistic.

70
00:04:06,584 --> 00:04:11,084
That complicates testing,
monitoring, and even incident

71
00:04:11,084 --> 00:04:15,555
response because reproducible bug
is not always straightforward.

72
00:04:16,055 --> 00:04:18,065
Third, the model is high value.

73
00:04:18,815 --> 00:04:20,795
IP intellectual property.

74
00:04:21,335 --> 00:04:27,695
Your model may represent months of
training time and competitive advantage.

75
00:04:27,755 --> 00:04:31,295
And attacker doesn't need your training
data if they can learn enough by

76
00:04:31,295 --> 00:04:33,880
observing your model through its API.

77
00:04:34,380 --> 00:04:36,150
Fourth, the pipeline matters.

78
00:04:36,840 --> 00:04:39,000
Poisoning does not always show up on day.

79
00:04:39,570 --> 00:04:45,810
Sometimes it's septal, a bias, a back
door, a behavior that only appears later.

80
00:04:46,710 --> 00:04:51,175
Data province becomes a security
requirement, not a paperwork.

81
00:04:51,535 --> 00:04:51,775
Exercise.

82
00:04:52,645 --> 00:04:53,135
Finally.

83
00:04:53,635 --> 00:04:55,585
New attack classes show up at run time.

84
00:04:56,365 --> 00:05:01,225
Prompt injection, AL inputs
membership inference.

85
00:05:01,615 --> 00:05:05,695
The theme is the attack surface
is no longer just static code.

86
00:05:06,235 --> 00:05:07,765
It's a production behavior.

87
00:05:08,725 --> 00:05:11,815
Maya thought she was shipping software.

88
00:05:12,625 --> 00:05:13,860
Suddenly she's operating.

89
00:05:14,785 --> 00:05:22,075
A living system that learns, peruse, and
gets poke at in ways normal apps don't.

90
00:05:22,575 --> 00:05:26,085
So what kind of control can
understand behavior, not just sports.

91
00:05:26,535 --> 00:05:29,445
That's where next generation
firewalls come in.

92
00:05:29,945 --> 00:05:33,215
Let's talk about the difference
between a traditional firewall

93
00:05:33,455 --> 00:05:35,015
and a next donation firewall.

94
00:05:35,045 --> 00:05:38,885
In a plain language, a
legacy firewall is created.

95
00:05:39,155 --> 00:05:43,695
One question, is traffic
allowed from this IP to that ip?

96
00:05:44,195 --> 00:05:48,845
But in cloud native AI environments,
those data change constantly.

97
00:05:49,325 --> 00:05:54,395
Bonds move services, scale ips are
temporary, and the real question

98
00:05:54,395 --> 00:05:56,675
becomes, what service is this?

99
00:05:57,005 --> 00:05:58,595
What API, is it calling?

100
00:05:59,285 --> 00:06:00,650
Who is making the requests?

101
00:06:01,150 --> 00:06:02,690
What's inside the request?

102
00:06:03,350 --> 00:06:05,645
And is this behavior normal?

103
00:06:06,145 --> 00:06:10,495
That's what Next Generation Firewall
brings in layer seven awareness,

104
00:06:11,365 --> 00:06:17,155
understanding APIs and application
protocols, payload and content inspection,

105
00:06:17,785 --> 00:06:22,790
spotting malicious content and exfil
patterns, Terra inspection strategies.

106
00:06:22,790 --> 00:06:28,700
So encryption does not become
invisibility, behavioral anomaly detection

107
00:06:28,880 --> 00:06:30,680
because AI threats are often novel.

108
00:06:31,180 --> 00:06:37,240
Identity context, policy based on
workload, service, identity, not

109
00:06:37,510 --> 00:06:39,805
network location, a legacy firewall.

110
00:06:40,645 --> 00:06:46,615
You can think it as checks the address on
the envelope, whereas the next donation

111
00:06:46,615 --> 00:06:51,175
firewall can also understand what kind
of delivery it is, who signed for it,

112
00:06:51,175 --> 00:06:53,095
and whether the contents match policy.

113
00:06:53,595 --> 00:06:58,605
So this is the moment R stops being the
checkpoint and becomes a person who gives

114
00:06:58,605 --> 00:07:00,975
Maya guardrails that don't break velocity.

115
00:07:01,475 --> 00:07:06,035
Now you might say, we already
shift left, we scan everything.

116
00:07:06,665 --> 00:07:08,585
True, but it's not enough.

117
00:07:09,085 --> 00:07:09,685
Shift left.

118
00:07:09,685 --> 00:07:14,515
Security is one of the best things
DevOp brought to the industry.

119
00:07:14,755 --> 00:07:19,705
We scan code dependencies,
containers, ISC, and that

120
00:07:19,705 --> 00:07:21,475
absolutely prevents incidents.

121
00:07:22,435 --> 00:07:24,325
But let's go back to Mayas Tuesday.

122
00:07:25,075 --> 00:07:27,055
Everything in CI is green.

123
00:07:27,595 --> 00:07:29,035
No critical cvs.

124
00:07:29,575 --> 00:07:31,375
Terraform looks compliant.

125
00:07:31,615 --> 00:07:35,365
Hand charts validate,
so the release ships.

126
00:07:35,860 --> 00:07:38,860
Spend time passes and
runtime Reality shows up.

127
00:07:39,360 --> 00:07:43,770
An egress path is misrouted and a
service can talk to places It should not.

128
00:07:43,980 --> 00:07:46,530
A workload has more
permissions than intended.

129
00:07:47,030 --> 00:07:51,615
A microservice becomes an unexpected
bridge for lateral moment.

130
00:07:52,185 --> 00:07:58,125
API users slowly shifts into abusive
patterns, a time delayed condition

131
00:07:58,305 --> 00:08:00,315
triggers unexpected behavior.

132
00:08:01,155 --> 00:08:04,935
These are the problems that
don't look like bad code.

133
00:08:05,295 --> 00:08:12,660
They look like perfectly valid behavior
used in a. Bad way and AI amplifies this.

134
00:08:12,930 --> 00:08:18,120
A model serving service might
suddenly become a high value target.

135
00:08:18,810 --> 00:08:23,010
A connected to a data store
might become an X Excel part.

136
00:08:23,790 --> 00:08:29,220
A new feature flag might expose
an internal endpoint, so the fix

137
00:08:29,220 --> 00:08:31,740
is not shift left versus runtime.

138
00:08:32,340 --> 00:08:32,910
It's sport.

139
00:08:33,410 --> 00:08:35,210
Shift left plus shield.

140
00:08:35,210 --> 00:08:40,130
Right next donation firewall becomes
a continuous control plane in

141
00:08:40,130 --> 00:08:44,330
production, enforcing policy while
the system is actually running.

142
00:08:44,830 --> 00:08:50,695
So how do we embed this without bolting
it on Here is integration framework.

143
00:08:51,195 --> 00:08:54,225
Comprehensive next donation
firewall integration.

144
00:08:54,915 --> 00:08:58,605
Think of this framework like
weaving security into the fabric of

145
00:08:58,605 --> 00:09:01,785
delivery, not adding it at the end.

146
00:09:02,505 --> 00:09:05,565
There are five pieces and
they work best together.

147
00:09:06,065 --> 00:09:09,365
First, identity based
access control policies.

148
00:09:09,365 --> 00:09:11,970
Talk about services and roles, not ips.

149
00:09:12,660 --> 00:09:13,735
The survives.

150
00:09:14,065 --> 00:09:15,535
This survives Cuban needs.

151
00:09:15,535 --> 00:09:15,955
John.

152
00:09:16,750 --> 00:09:18,785
Out scaling and multi-region deployments.

153
00:09:19,735 --> 00:09:24,805
Policy is code with ci validation
firewall policy lives in kit.

154
00:09:24,895 --> 00:09:28,135
It gets reviewed, tested,
and promoted like software.

155
00:09:28,855 --> 00:09:32,725
This is how you eliminate mystery
rules and configuration drift.

156
00:09:33,415 --> 00:09:35,875
Next, crypto traffic inspection strategy.

157
00:09:36,445 --> 00:09:42,385
We decide what to decrypt and
inspect based on risk and compliance.

158
00:09:43,050 --> 00:09:46,920
Selective targeted visibility
not to grip everything.

159
00:09:47,490 --> 00:09:53,430
AI specific threat detection is the next
rules and baselines tailored to model

160
00:09:53,640 --> 00:10:00,450
serving, training pipelines and inference
APIs, extraction signals, injection

161
00:10:00,810 --> 00:10:02,850
patterns, and suspicious behavior.

162
00:10:03,350 --> 00:10:08,600
Alert optimization and aggregation
because a noisy system gets ignored,

163
00:10:08,689 --> 00:10:16,010
we want high confidence signals that
engineers trust and ca can act un quickly.

164
00:10:16,790 --> 00:10:18,829
Simple mental model.

165
00:10:19,175 --> 00:10:21,575
You can think as CCI.

166
00:10:21,575 --> 00:10:25,595
CD is where we prevent and
standardized runtime is where we

167
00:10:25,595 --> 00:10:27,995
observe and enforce continuously.

168
00:10:28,835 --> 00:10:32,285
So Maya gets speed and repeatability.

169
00:10:32,915 --> 00:10:39,095
Luke gets enforcement and auditability
and both gets few late night surprises.

170
00:10:39,725 --> 00:10:45,395
Now, before we enforce anything,
we need a safe rollout in line

171
00:10:45,395 --> 00:10:50,075
versus out of event, let's talk
about the safest way to introduce

172
00:10:50,140 --> 00:10:51,930
a control that can block traffic.

173
00:10:52,680 --> 00:10:53,760
Inline is powerful.

174
00:10:54,540 --> 00:10:58,980
The next donation firewalls sits
directly in the path and can allow

175
00:10:59,190 --> 00:11:01,440
block or modify traffic in real time.

176
00:11:01,940 --> 00:11:03,380
That's full enforcement.

177
00:11:03,560 --> 00:11:09,200
Great when policies are mature, but
inline also carries operational risk.

178
00:11:09,830 --> 00:11:15,260
Misconfigurations can create down time,
so you don't start then there blindly

179
00:11:15,760 --> 00:11:17,740
out of band is your learning mode.

180
00:11:18,625 --> 00:11:24,145
Your mirror traffic to the next donation
firewall so it can inspect, build

181
00:11:24,145 --> 00:11:29,395
baselines, and show you what it would
have done without impacting production.

182
00:11:30,325 --> 00:11:32,185
This is a trust building phase.

183
00:11:32,455 --> 00:11:37,190
You learn, but normal looks like
at different times of day, but

184
00:11:37,190 --> 00:11:40,670
to release data, day traffic
looks like which services are

185
00:11:40,670 --> 00:11:42,800
chatty for legitimate reasons.

186
00:11:43,300 --> 00:11:46,990
And what performance
headroom you actually have.

187
00:11:47,740 --> 00:11:52,000
When you do move in line, say
the reassuring part out loud.

188
00:11:52,390 --> 00:11:56,130
You design for high availability,
clear failover behavior,

189
00:11:56,130 --> 00:11:57,449
and performance budgets.

190
00:11:57,600 --> 00:12:03,145
Security can't be fragile, single
point of failure, so Maya may wonders I

191
00:12:03,145 --> 00:12:06,775
can't risk breaking production and may.

192
00:12:07,270 --> 00:12:08,469
Say good.

193
00:12:08,680 --> 00:12:14,380
We want, we'll botch first, tune
only then enforce the critical parts.

194
00:12:15,310 --> 00:12:18,610
So to make any of this table
in cloud native environments,

195
00:12:18,610 --> 00:12:21,010
we anchor policy on identity.

196
00:12:21,510 --> 00:12:23,790
Identity based access
for dynamic environments.

197
00:12:24,360 --> 00:12:28,560
In modern environments, IP
dresses are not identity.

198
00:12:28,950 --> 00:12:33,720
They're temporary coordinates in
Kubernetes and serverless systems.

199
00:12:34,380 --> 00:12:41,280
Parts restart, node scale services move,
and IP based rules becomes the BRI fast.

200
00:12:41,280 --> 00:12:44,130
So we switch the anchor from where to who?

201
00:12:44,630 --> 00:12:46,400
Identity becomes the new parameter.

202
00:12:47,060 --> 00:12:48,829
Where does that identity come from?

203
00:12:49,369 --> 00:12:51,020
Service mesh identity.

204
00:12:51,680 --> 00:12:52,819
MTLS Certificate.

205
00:12:52,819 --> 00:12:56,150
Proving a workload is who it says it is.

206
00:12:56,750 --> 00:12:58,369
API, gateway Identity.

207
00:12:58,880 --> 00:13:00,020
OAuth tokens.

208
00:13:00,020 --> 00:13:01,430
M-T-L-S-A-P-I.

209
00:13:01,430 --> 00:13:02,989
Keys validated centrally.

210
00:13:03,949 --> 00:13:05,359
Cloud Workload identity.

211
00:13:05,900 --> 00:13:09,079
Im roles and managed
identities attached to compute.

212
00:13:09,579 --> 00:13:10,780
What does this enable?

213
00:13:11,380 --> 00:13:13,510
Least privilege at the service level.

214
00:13:14,199 --> 00:13:18,430
This service can call that endpoint
using this method for this purpose.

215
00:13:18,930 --> 00:13:26,460
So my inference service should talk to
the model, store and feature store, but

216
00:13:26,460 --> 00:13:31,370
it should not have open egress to the
internet with identity-based policies.

217
00:13:31,370 --> 00:13:34,280
That rule travels with the
service across clusters,

218
00:13:34,730 --> 00:13:36,740
regions, and auto-scaling events.

219
00:13:37,240 --> 00:13:39,960
And bonus benefit here is audit.

220
00:13:39,960 --> 00:13:44,340
It becomes easier when an alert
fires if you don't see a random ip.

221
00:13:44,910 --> 00:13:48,780
You see a real identity
engineer can act on.

222
00:13:49,280 --> 00:13:53,630
So once the identity is the foundation
policy can be treated like code.

223
00:13:53,960 --> 00:13:56,810
That's where CICD integration shines.

224
00:13:57,310 --> 00:13:59,290
Here's a mindset shift.

225
00:13:59,875 --> 00:14:03,175
Firewall policy should
not be a special case.

226
00:14:03,675 --> 00:14:07,335
It should follow the same
discipline as application code.

227
00:14:07,665 --> 00:14:11,865
Policy as code means policy
lives in version control.

228
00:14:12,645 --> 00:14:14,445
Changes come through pulled requests.

229
00:14:15,135 --> 00:14:16,785
CI runs automated checks.

230
00:14:17,415 --> 00:14:21,315
Deployment is synchronized
with infrastructure changes.

231
00:14:22,125 --> 00:14:25,305
Rollback is coordinated
with application rollback.

232
00:14:25,805 --> 00:14:28,045
When do we testing CI syntax?

233
00:14:28,045 --> 00:14:30,115
Validation Issued bars.

234
00:14:30,685 --> 00:14:32,335
Conflict detection.

235
00:14:32,335 --> 00:14:36,925
Two rules fighting each other for
forbidden patterns, like overly

236
00:14:36,955 --> 00:14:42,135
broad egress compliance checks,
like where data is allowed to go.

237
00:14:42,635 --> 00:14:46,445
Drift detection, but running matches.

238
00:14:46,520 --> 00:14:47,460
Get now.

239
00:14:48,335 --> 00:14:53,395
Maya's team adds a new microservice
endpoint in the old world.

240
00:14:53,995 --> 00:14:58,915
They will open a ticket, wait days,
push a heart change in the new world,

241
00:14:59,155 --> 00:15:04,915
open a pr that includes the service
change and the policy change and run

242
00:15:04,915 --> 00:15:10,680
tests automatically review once, deploy
together and roll back together if needed.

243
00:15:11,180 --> 00:15:14,180
This is how security becomes
boring in the best way,

244
00:15:14,690 --> 00:15:17,480
predictable, repeatable, auditable.

245
00:15:17,965 --> 00:15:23,240
Now let's do, now let's zoom into
AI specific threats, starting

246
00:15:23,240 --> 00:15:27,350
with the one that treats your
AP API like a copy machine

247
00:15:27,850 --> 00:15:31,600
protecting AI APIs,
model extraction attacks.

248
00:15:32,410 --> 00:15:34,540
Model extraction is a unique risk.

249
00:15:34,990 --> 00:15:38,170
Attacker does not need access
to your training pipeline.

250
00:15:38,500 --> 00:15:43,450
They can learn a surprising amount
by querying your interference API

251
00:15:43,450 --> 00:15:49,180
repeatedly and systematically trying
to map behavior from the outside can

252
00:15:49,180 --> 00:15:52,570
look like unusually high query volume.

253
00:15:53,260 --> 00:15:59,370
Very uniform automated request shapes
repeated probing of edge cases.

254
00:15:59,870 --> 00:16:05,390
Loss of requests that don't match
Normal custom workflows spikes from new

255
00:16:05,390 --> 00:16:08,090
identities that appear and disappear.

256
00:16:08,590 --> 00:16:13,570
Now, Maya sees the user, Maya
sees the users, uses graph,

257
00:16:13,570 --> 00:16:15,700
and thinks great adoption.

258
00:16:16,330 --> 00:16:20,500
Luke looks at it and thinks
that pattern is not human.

259
00:16:21,000 --> 00:16:22,805
What can NWS do here?

260
00:16:23,305 --> 00:16:28,975
Rate limiting and quotas detect
suspicious sequences and exploration

261
00:16:28,975 --> 00:16:35,125
patterns, automation and bot blocking
signals, reduce accidental information

262
00:16:35,125 --> 00:16:40,604
leakage, and the key operation
ideas is graduated enforcement.

263
00:16:41,104 --> 00:16:45,394
You don't want to break legitimate
customers who are simply heavy users.

264
00:16:45,604 --> 00:16:50,434
So you start with first detect,
then one next throttle, and then

265
00:16:50,434 --> 00:16:55,444
you challenge, and then you block
based on a confidence and impact.

266
00:16:55,944 --> 00:17:01,784
So treat your model API like a
premium resource because it's now the

267
00:17:01,784 --> 00:17:04,154
extraction, tries to copy the model.

268
00:17:04,634 --> 00:17:07,694
Prompt is action, tries to
take control of the model.

269
00:17:08,194 --> 00:17:13,314
So how do we protect LMS
from the Prompt Injections?

270
00:17:13,814 --> 00:17:15,434
LMS have a charming flaw.

271
00:17:15,824 --> 00:17:17,654
They are designed to follow instructions.

272
00:17:17,954 --> 00:17:23,384
That's why they're useful, and
it's why Prompt Injection exists.

273
00:17:24,134 --> 00:17:30,134
Prompt injection attempts often try to
overnight system instructions, trick

274
00:17:30,134 --> 00:17:36,494
the model into revealing sensitive
context, manipulate tool, use austere

275
00:17:36,644 --> 00:17:38,564
outputs into unsafe territory.

276
00:17:39,064 --> 00:17:44,374
How to explain simply is it's
social engineering, but aimed at

277
00:17:44,374 --> 00:17:46,564
the model, at the network layer.

278
00:17:46,564 --> 00:17:49,714
Next generation firewalls can
help in four practical ways.

279
00:17:50,214 --> 00:17:55,554
Prompt sanitization signals pattern
based detection of obvious instruction,

280
00:17:55,554 --> 00:18:02,144
override attempt, luque baselining, prompt
length structure, abnormal correctors,

281
00:18:02,534 --> 00:18:06,154
sudden format changes, output monitoring.

282
00:18:06,154 --> 00:18:09,349
Were visible indicators of data leakage.

283
00:18:09,849 --> 00:18:14,799
Identities with the repeated, rejected
jailbreak like patterns, get thro out.

284
00:18:15,299 --> 00:18:16,709
Network controls are one layer.

285
00:18:16,919 --> 00:18:18,899
You still need application guardrails.

286
00:18:19,409 --> 00:18:25,019
Strong system prompts, tool permissions
as safe by design workflows.

287
00:18:25,519 --> 00:18:31,104
So if your LLM can call internet
tools like a ticking system, a CRM

288
00:18:31,194 --> 00:18:33,354
or a database, the biggest risk.

289
00:18:33,969 --> 00:18:38,679
The biggest risk is not only what
it says, it's what it can reach.

290
00:18:39,179 --> 00:18:43,469
Identity-based network policy can
ensure the model service cannot

291
00:18:43,469 --> 00:18:49,859
directly access seeker stores metadata
endpoints or sensitive databases,

292
00:18:50,729 --> 00:18:52,469
even if a prompt tries to trick it.

293
00:18:52,859 --> 00:18:59,939
So now almost all of this traffic
is encrypted, so we need visibility

294
00:18:59,939 --> 00:19:02,189
without sacrificing performance.

295
00:19:02,689 --> 00:19:04,099
Encryption is a win.

296
00:19:04,429 --> 00:19:10,549
It protects users and data in transit,
but it also creates a visibility gap

297
00:19:11,449 --> 00:19:14,209
that can hide inside encrypted sessions.

298
00:19:14,749 --> 00:19:16,369
The goal is not decrypt everything.

299
00:19:16,549 --> 00:19:22,669
The goal is to crypt what matters based
on risk, compliance, and practicality.

300
00:19:23,169 --> 00:19:27,609
We want selective visibility,
not blanket surveillance.

301
00:19:28,109 --> 00:19:33,709
So high ation and crypto offload
are the few tactics that we can use.

302
00:19:33,889 --> 00:19:36,439
So inspection keeps up with throughput.

303
00:19:36,939 --> 00:19:40,689
Next, selective decryption
focus on high risk parts.

304
00:19:40,899 --> 00:19:43,809
Internet facing sensitive APIs.

305
00:19:44,319 --> 00:19:48,159
Session optimization review
sessions and reduce handshake

306
00:19:48,159 --> 00:19:50,219
overload, ate pinning awareness.

307
00:19:50,309 --> 00:19:52,439
Some apps will reject inspections.

308
00:19:52,439 --> 00:19:58,289
Those may need exemptions or
out ofAnd monitoring, capacity

309
00:19:58,289 --> 00:20:01,694
planning, defined performance
budgets, and size for peak traffic.

310
00:20:02,194 --> 00:20:05,944
Now let's go back to Maya Miami Wonders.

311
00:20:05,944 --> 00:20:07,149
Will this slow us down?

312
00:20:07,649 --> 00:20:11,609
You may support by saying only if
we design it like an afterthought.

313
00:20:11,819 --> 00:20:15,959
We design it like production
infrastructure with metrics,

314
00:20:16,319 --> 00:20:17,849
load tests, and headroom.

315
00:20:18,349 --> 00:20:20,629
Pesty planning is a security requirement.

316
00:20:20,959 --> 00:20:24,289
If the control can't keep
up, people will bypass it.

317
00:20:24,789 --> 00:20:26,889
And while we are planning the

318
00:20:26,889 --> 00:20:30,579
Speaker 11: present, we also need
to plan for the crypto future.

319
00:20:31,079 --> 00:20:32,129
PQC Redness.

320
00:20:32,639 --> 00:20:34,619
Speaker 12: Let's do a
quick thought experiment.

321
00:20:35,459 --> 00:20:39,689
If you had sensitive data that
must remain confidential for 10

322
00:20:39,689 --> 00:20:42,329
or 20 years, what would you do?

323
00:20:42,329 --> 00:20:46,219
If someone could record it today
and crack it later, that's.

324
00:20:46,719 --> 00:20:51,609
The risk we call harvest now
decry later, even before large

325
00:20:51,609 --> 00:20:53,199
scale quantum machines exist.

326
00:20:53,679 --> 00:20:56,199
High value encrypted
data can be collected.

327
00:20:56,769 --> 00:20:59,289
What does readiness look
like in practical steps?

328
00:21:00,099 --> 00:21:02,289
Build a cryptographic inventory.

329
00:21:02,789 --> 00:21:08,579
Where RSA and ECC are used, identify
long lived sensitive data flows.

330
00:21:08,909 --> 00:21:14,189
Those are the highest priority pilot
hybrid approaches were available.

331
00:21:14,549 --> 00:21:18,179
Classical plus post quantum
together during transition

332
00:21:18,679 --> 00:21:20,749
plan for performance impact.

333
00:21:21,169 --> 00:21:25,249
Larger keys and more competition
means you measure early.

334
00:21:25,749 --> 00:21:29,799
Your next, ensure your next
generation firewall platform

335
00:21:29,799 --> 00:21:34,209
can evolve by firmware software
updates to support new algorithms.

336
00:21:34,689 --> 00:21:37,689
This is a planning message,
not a panic message.

337
00:21:38,229 --> 00:21:40,449
Should don't migrate everything overnight.

338
00:21:40,449 --> 00:21:44,919
You start with pilots, measure
and prioritize systems handling

339
00:21:44,919 --> 00:21:46,124
long-lived, sensitive data.

340
00:21:46,624 --> 00:21:48,784
So Maya wants to ship this quarter.

341
00:21:49,444 --> 00:21:52,894
RU wants to make sure the data is
still protected years from now.

342
00:21:53,394 --> 00:21:55,374
So we go in phases.

343
00:21:55,674 --> 00:22:00,864
Now let's come back to day-to-day
reality alerts, because security

344
00:22:00,864 --> 00:22:03,174
that cries falls gets ignored.

345
00:22:03,674 --> 00:22:07,154
If your alerting system is
noisy, people stop trusting it.

346
00:22:07,514 --> 00:22:11,144
It's like a smoke alarm that goes
off every time you make toast.

347
00:22:11,264 --> 00:22:15,584
Eventually someone disables
it to avoid that outcomes.

348
00:22:16,424 --> 00:22:20,379
Baseline first out of band monitoring
teaches you normal behavior.

349
00:22:20,879 --> 00:22:22,624
Use a normally coding.

350
00:22:23,164 --> 00:22:25,619
Not every deviation deserves an alert.

351
00:22:26,119 --> 00:22:27,259
Aggregate events.

352
00:22:27,259 --> 00:22:29,329
Into instance, tell a story.

353
00:22:29,329 --> 00:22:35,749
Instead of dumping logs, enrich
alerts with context service, identity

354
00:22:35,779 --> 00:22:40,039
criticality, destination repetition,
and recent deployment changes.

355
00:22:40,939 --> 00:22:45,759
Continuous tuning feedback loops
improve precision over time.

356
00:22:46,749 --> 00:22:48,084
Make it tangible within.

357
00:22:48,584 --> 00:22:50,925
Some example, alert narrative.

358
00:22:51,344 --> 00:22:58,304
For example, service interference,
API identity, surface account change

359
00:22:58,304 --> 00:23:07,544
context, deploy version 1.2 0.3, 10
minutes ago, absorbed unusual egress

360
00:23:07,604 --> 00:23:10,215
to new destination confidence high.

361
00:23:10,965 --> 00:23:12,225
So justed action.

362
00:23:12,284 --> 00:23:13,995
Confirm destination.

363
00:23:14,654 --> 00:23:20,475
Block if un unapproved or rollback,
that's an alert an engineer can act on.

364
00:23:21,434 --> 00:23:22,394
This matters.

365
00:23:22,514 --> 00:23:23,774
For DevOps adoption.

366
00:23:24,524 --> 00:23:29,110
My team will only embrace security
telemetry if it helps them decide quickly.

367
00:23:29,610 --> 00:23:31,740
Not if it creates a second on-call job.

368
00:23:32,700 --> 00:23:36,899
Luke's best moment is when an engineer
says, this alert is actually useful.

369
00:23:37,740 --> 00:23:40,200
So what's the practical rollout?

370
00:23:40,530 --> 00:23:43,590
Here's a roadmap you can
take back to your team.

371
00:23:44,090 --> 00:23:45,040
Let's close this story.

372
00:23:46,030 --> 00:23:50,894
Maya and Luke dot fix this with
one giant security project.

373
00:23:51,225 --> 00:23:55,425
They do it in phases and
each phase earns trust.

374
00:23:56,279 --> 00:24:02,399
Phase one outand monitoring four
to eight peak middle traffic.

375
00:24:02,399 --> 00:24:03,599
Build baselines.

376
00:24:03,869 --> 00:24:10,199
Tune detection, blue performance
assumptions drive false positives down.

377
00:24:10,699 --> 00:24:18,709
Phase two policy as code plus selective
enforcement approximately six to 12 weeks.

378
00:24:19,370 --> 00:24:22,070
Move policies into Git validating ci.

379
00:24:22,570 --> 00:24:25,149
Begin in line enforcement on low risk path

380
00:24:25,649 --> 00:24:29,214
practice rollback like a
fire drill, so it's a calm.

381
00:24:29,894 --> 00:24:36,824
When you need phase three, AI specific
detections, eight to 16 weeks add

382
00:24:36,824 --> 00:24:42,134
protections for moderate extraction,
prompt injection patterns, and ai.

383
00:24:42,134 --> 00:24:48,254
API of use expand coverage with
graduated enforcement, phase

384
00:24:48,254 --> 00:24:50,534
four performance optimization.

385
00:24:51,034 --> 00:24:52,174
Most quantum pilots.

386
00:24:52,674 --> 00:24:56,154
TS inspection throughout
an expression if needed.

387
00:24:56,874 --> 00:25:02,924
Start PQC redness testing for long LI
lived sensitive data deployment velocity.

388
00:25:02,924 --> 00:25:06,944
Unchanged or improved because
policy changes are automated.

389
00:25:07,444 --> 00:25:13,629
Pause, positive rates drops over time,
not up Latency stays within budget.

390
00:25:14,359 --> 00:25:17,179
Clear audit trail for
security policy changes.

391
00:25:17,809 --> 00:25:20,449
Fear emergency allow all exceptions.

392
00:25:20,569 --> 00:25:27,349
So main key take takeaways are security
can be continuous and automated

393
00:25:28,039 --> 00:25:33,199
without slowing delivery shift left
is necessary, but runtime protection

394
00:25:33,239 --> 00:25:34,879
is where real exploits happen.

395
00:25:35,864 --> 00:25:37,574
AI changes the threat model.

396
00:25:37,814 --> 00:25:42,224
So controls must be identity
aware and behavior aware.

397
00:25:42,724 --> 00:25:48,994
Security works best when it moves at
the speed of DevOps because it's a built

398
00:25:48,994 --> 00:25:52,354
into the system, not bolted on later.

399
00:25:53,314 --> 00:25:53,794
Thank you.

