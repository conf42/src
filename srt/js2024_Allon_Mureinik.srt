1
00:00:00,270 --> 00:00:01,550
Good morning, everyone.

2
00:00:01,640 --> 00:00:02,690
Welcome to CONF42.

3
00:00:03,630 --> 00:00:08,200
My name is Alon Mironik and I work
for Blackduck, where I manage the

4
00:00:08,200 --> 00:00:11,090
R& D efforts for the Seeker agents.

5
00:00:11,530 --> 00:00:15,749
Seeker, in case you haven't heard
about it or rather haven't heard

6
00:00:15,749 --> 00:00:21,910
about it yet, is probably the
best IAST tool out there today.

7
00:00:22,799 --> 00:00:28,830
But as fascinating as IAST is,
it's just not my topic today.

8
00:00:29,300 --> 00:00:32,460
So this is the last time
I'm going to mention Seeker.

9
00:00:32,960 --> 00:00:39,230
Instead, Today, I want to talk about
DOS attacks, what they are, and how

10
00:00:39,230 --> 00:00:40,910
we can prevent them in our Node.

11
00:00:40,940 --> 00:00:42,139
js applications.

12
00:00:42,639 --> 00:00:48,120
Now, if you're my age or older, when
you hear DOS, you're probably thinking

13
00:00:48,139 --> 00:00:51,010
of a really outdated operating system.

14
00:00:52,004 --> 00:00:54,805
One would argue that running your Node.

15
00:00:54,805 --> 00:01:01,544
js application on this operating
system is a vulnerability as of, as

16
00:01:01,724 --> 00:01:07,814
in itself, but this isn't the type
of DOS I'm talking about today.

17
00:01:08,314 --> 00:01:11,884
Today I want to talk
about denial of service.

18
00:01:12,384 --> 00:01:17,574
For those of you unfamiliar with this
concept, let's go straight to the source

19
00:01:17,604 --> 00:01:20,524
and see what OWASP has to say about this.

20
00:01:21,444 --> 00:01:26,164
So the denial of service or
DOS attack is focused on making

21
00:01:26,164 --> 00:01:30,574
a resource such as a site, an
application, or server unavailable

22
00:01:30,614 --> 00:01:32,284
for the purpose it was designed.

23
00:01:32,784 --> 00:01:39,514
And of course, a lot of you, when thinking
about DOS, instinctively think about DDoS.

24
00:01:39,979 --> 00:01:45,699
distributed denial of service, which is
an attack where you hit an application or

25
00:01:45,699 --> 00:01:53,619
server or whatever with multiple requests
from multiple sources and essentially

26
00:01:53,799 --> 00:01:58,779
crash it or bring it to a grinding halt
just by the sheer volume of requests.

27
00:01:59,279 --> 00:02:01,229
This is a very real problem.

28
00:02:01,599 --> 00:02:06,139
And a very interesting topic to
discuss, but since we are in the

29
00:02:06,249 --> 00:02:11,119
JavaScript conference today, I will
not be talking about DDoS at all.

30
00:02:11,879 --> 00:02:15,129
Today, I will be focusing
on the application.

31
00:02:15,629 --> 00:02:20,159
What can we do from the
applicative side in our Node.

32
00:02:20,159 --> 00:02:21,369
js applications?

33
00:02:22,019 --> 00:02:27,979
to prevent for argument's sake
a single request from creating a

34
00:02:27,999 --> 00:02:30,379
denial of service or DOS effect.

35
00:02:30,879 --> 00:02:35,679
Now, this won't fully
solve all of our problems.

36
00:02:35,879 --> 00:02:40,399
Our applications may still be vulnerable
to distributed denial of service

37
00:02:40,399 --> 00:02:48,089
attacks, but by making our application
secure from DOS attacks, first of all,

38
00:02:48,099 --> 00:02:53,769
we are reducing the attack surface for
distributed denial of service attacks.

39
00:02:54,269 --> 00:03:01,179
And secondly, we try to follow
the principle of solving the

40
00:03:01,289 --> 00:03:03,039
right problem in the right place.

41
00:03:03,539 --> 00:03:08,149
On the application side that we
will discuss today, we will see how

42
00:03:08,149 --> 00:03:14,429
to make our application resilient
against a single request that causes

43
00:03:14,509 --> 00:03:17,679
a malicious denial of service.

44
00:03:18,179 --> 00:03:23,569
Solving distributed denial of service
attacks is usually done not in the

45
00:03:23,859 --> 00:03:30,599
application level, but in the deployment
level, with rate limits and size limits

46
00:03:31,069 --> 00:03:37,729
and load balancers and things like that,
which again is just not the topic today.

47
00:03:38,229 --> 00:03:41,129
And we will not focus on that too much.

48
00:03:41,629 --> 00:03:45,619
let's reel it back in and
let's focus on the application.

49
00:03:45,669 --> 00:03:47,679
Specifically, our Node.

50
00:03:47,679 --> 00:03:48,819
js application.

51
00:03:49,319 --> 00:03:53,669
let's start with a quick
reminder on how Node.

52
00:03:53,699 --> 00:03:55,109
js even works.

53
00:03:55,609 --> 00:03:58,629
And this is a gross oversimplification.

54
00:03:59,129 --> 00:04:03,109
There's actually really good
documentation in the Node.

55
00:04:03,109 --> 00:04:05,009
js project about this.

56
00:04:05,109 --> 00:04:10,119
So if you want all the gory details,
please don't take my word for it,

57
00:04:10,169 --> 00:04:17,129
but read up yourself, but very
briefly and very oversimplified node

58
00:04:17,579 --> 00:04:20,519
is designed to scale really well.

59
00:04:21,189 --> 00:04:29,829
The basic design for node is a single
main thread called the event loop, which

60
00:04:29,979 --> 00:04:32,539
should handle all of your user requests.

61
00:04:33,179 --> 00:04:41,424
And the design tailors to applications
where you have really small chunks of

62
00:04:41,424 --> 00:04:48,294
work on the event loop, and anything
that takes a longer time, usually

63
00:04:48,324 --> 00:04:54,164
IO, but not necessarily, is delegated
to a worker thread, which is then

64
00:04:54,194 --> 00:04:58,474
executed by a limited number of
threads out of a given worker pool.

65
00:04:58,974 --> 00:05:04,254
Now, this design helps node,
excuse me, scale in two ways.

66
00:05:04,255 --> 00:05:11,169
First of all, by having a limited
number of threads, We don't waste system

67
00:05:11,169 --> 00:05:17,899
resources on opening and closing and
managing threads like older designs

68
00:05:18,149 --> 00:05:20,469
and older web servers might do.

69
00:05:20,969 --> 00:05:26,859
Second, and what Node got right here
in my mind, is the responsiveness.

70
00:05:27,419 --> 00:05:31,529
When a request comes in, you want
to handle it really quickly, be

71
00:05:31,529 --> 00:05:36,889
able to take it in, understand what
you need to do, and then delegate

72
00:05:36,919 --> 00:05:42,589
whatever long work you have, and maybe
respond a bit later, asynchronously.

73
00:05:43,089 --> 00:05:47,619
But the idea is that every chunk
of work, every tick on the event

74
00:05:47,649 --> 00:05:49,699
loop needs to be really small.

75
00:05:50,354 --> 00:05:55,964
And that way you can always get a
new one whenever a user request comes

76
00:05:55,964 --> 00:05:57,834
in, you are not blocking anything.

77
00:05:58,334 --> 00:06:01,434
This is something crucial to remember.

78
00:06:01,994 --> 00:06:07,664
This design is the core
of Node's performance.

79
00:06:08,374 --> 00:06:12,284
That is the core of why
Node can scale this well.

80
00:06:13,264 --> 00:06:21,124
And, unfortunately, it's also the
core reason of why Node can, Node.

81
00:06:21,184 --> 00:06:26,654
js applications at least, can be
really vulnerable to DOS attacks if

82
00:06:26,654 --> 00:06:28,194
you don't write them the right way.

83
00:06:28,694 --> 00:06:33,524
Just to hammer this point back home,
a lot of people when they think about

84
00:06:33,814 --> 00:06:36,354
DOS, they think about performance.

85
00:06:36,354 --> 00:06:36,424
Thanks.

86
00:06:36,894 --> 00:06:38,784
which is a good correlation to make.

87
00:06:39,284 --> 00:06:45,584
But preventing DOS attacks is
not about speed, or at least

88
00:06:45,584 --> 00:06:47,764
it's not just about speed.

89
00:06:48,344 --> 00:06:53,074
Of course, however faster your
application is, it's more difficult

90
00:06:53,114 --> 00:06:54,904
to create a DOS attack on it.

91
00:06:55,464 --> 00:07:01,009
But the core point here isn't
slowing things down, It is

92
00:07:01,069 --> 00:07:06,689
blocking other requests, legitimate
requests, from being served.

93
00:07:07,559 --> 00:07:15,319
So if a malicious request takes two
hours to fulfill, that might be okay.

94
00:07:15,819 --> 00:07:22,579
The core issue here is not that it
took two hours, but whether during

95
00:07:22,649 --> 00:07:27,099
these two hours, we are able to
serve legitimate user requests.

96
00:07:27,599 --> 00:07:30,209
how can we block a Node.

97
00:07:30,209 --> 00:07:31,059
js application?

98
00:07:31,069 --> 00:07:33,519
How can we tie up the event loop?

99
00:07:34,009 --> 00:07:38,099
it sounds really fancy and really
dangerous and really far fetched.

100
00:07:38,689 --> 00:07:39,799
It really isn't.

101
00:07:40,299 --> 00:07:46,389
We will see a few examples of
really common practices, things

102
00:07:46,389 --> 00:07:53,089
we are used to find in virtually
any application that could tie

103
00:07:53,089 --> 00:07:56,029
us up if implemented incorrectly.

104
00:07:56,529 --> 00:08:02,469
Probably the most obvious
example is JSON parsing.

105
00:08:02,969 --> 00:08:11,899
We get the JSON, we get, sorry,
we get a request with a body.

106
00:08:12,429 --> 00:08:14,519
This body is in JSON format.

107
00:08:15,309 --> 00:08:19,129
the HTTP client will save
that, of course, as a string.

108
00:08:19,629 --> 00:08:21,704
And then we want to parse it.

109
00:08:21,834 --> 00:08:26,414
In this example, we have the
express middleware doing it for

110
00:08:26,414 --> 00:08:28,714
us, but that's beside the point.

111
00:08:29,174 --> 00:08:33,864
The body is parsed into a
JSON, and here we have a simple

112
00:08:33,864 --> 00:08:38,294
application that just prints out
the number of keys in this JSON.

113
00:08:38,794 --> 00:08:41,334
Now, this is a sneaky example.

114
00:08:41,334 --> 00:08:42,454
It isn't obvious here.

115
00:08:42,954 --> 00:08:48,774
Our callback function in the post
handler is running very fast.

116
00:08:48,774 --> 00:08:50,104
It doesn't do anything.

117
00:08:50,604 --> 00:08:53,784
The sneaky part here is the JSO passing.

118
00:08:53,844 --> 00:08:58,214
That happens in the express
model way, and the obvious way

119
00:08:58,214 --> 00:09:04,224
to overload this middleware is
to just send a really large JSON.

120
00:09:04,724 --> 00:09:10,034
Now, I was trying to figure out
how I can illustrate this and

121
00:09:10,034 --> 00:09:12,764
show you how bad this really is.

122
00:09:13,264 --> 00:09:17,524
And as a DOS geek, I was
struggling to find a way.

123
00:09:18,254 --> 00:09:22,434
But then I remembered I'm
not really a DOS geek.

124
00:09:22,684 --> 00:09:24,044
I'm a DOS nerd.

125
00:09:25,014 --> 00:09:29,134
The difference is a geek will tell you
about something they're passionate about.

126
00:09:29,614 --> 00:09:33,384
A nerd will tell you about
something they're passionate about.

127
00:09:33,654 --> 00:09:34,604
With a graph.

128
00:09:35,144 --> 00:09:37,924
So indeed, I graphed this out.

129
00:09:38,894 --> 00:09:47,544
I graphed out the time it takes to serve
this request as a function of the length

130
00:09:47,714 --> 00:09:50,784
of the body of the JSON in the body.

131
00:09:51,384 --> 00:09:56,644
in kilobytes for argument's sake, and
we can see it is more or less linear.

132
00:09:57,144 --> 00:10:01,574
Now, I know I said it isn't about
speed, but again, the key point here

133
00:10:01,604 --> 00:10:08,534
is that this JSON passing, which
under the hood, under all of Express's

134
00:10:08,964 --> 00:10:11,734
bells and whistles, just calls Node.

135
00:10:11,734 --> 00:10:12,841
js's JSON.

136
00:10:12,841 --> 00:10:17,064
pass is executed on the event loop.

137
00:10:17,204 --> 00:10:21,594
however long this takes, It will
block any other requests from

138
00:10:21,594 --> 00:10:23,694
being served during this time.

139
00:10:24,194 --> 00:10:29,474
as an attacker, if I can have my
application handle an arbitrary

140
00:10:29,474 --> 00:10:35,434
long JSON, I can tie it up
for a linear amount of time.

141
00:10:35,934 --> 00:10:38,674
depending on the size
of the JSON I send over.

142
00:10:39,174 --> 00:10:44,214
As defenders, as application
authors, what can we do about this?

143
00:10:44,714 --> 00:10:45,364
quite a bit.

144
00:10:46,134 --> 00:10:52,734
First of all, obviously, if we don't
allow tainted input or user controlled

145
00:10:52,764 --> 00:10:56,624
input to be parsed as JSON, no problem.

146
00:10:57,124 --> 00:10:57,974
This is great.

147
00:10:58,074 --> 00:11:00,014
It's not really realistic.

148
00:11:00,554 --> 00:11:02,904
JSON parsing is ubiquitous.

149
00:11:03,404 --> 00:11:05,534
JavaScript is in general and Node.

150
00:11:05,534 --> 00:11:13,434
js in particular, a lot of applications
or services pass information

151
00:11:13,434 --> 00:11:16,464
between them in a JSON format.

152
00:11:16,494 --> 00:11:23,684
So just saying never pass any string
you get from an outside untrusted

153
00:11:23,684 --> 00:11:27,084
source as a JSON is not realistic.

154
00:11:27,834 --> 00:11:31,154
More realistically, you
can just limit the size.

155
00:11:31,654 --> 00:11:39,194
A length check is a very cheap operation,
and if you can just limit the size and

156
00:11:39,404 --> 00:11:46,144
double check the length before you try
to pass this long string as a JSON,

157
00:11:46,904 --> 00:11:48,864
you have solved a lot of the problem.

158
00:11:49,364 --> 00:11:52,864
The key here is to know your applications.

159
00:11:53,364 --> 00:11:55,724
Get to know how your applications behave.

160
00:11:55,964 --> 00:12:02,154
Get to know what a reasonable,
valid user input is.

161
00:12:02,614 --> 00:12:10,204
Maybe Add some buffers for
extreme cases, but limit the size.

162
00:12:10,314 --> 00:12:14,624
Don't allow the application or
the model way in this case to

163
00:12:14,624 --> 00:12:17,834
just pass arbitrary long strings.

164
00:12:18,334 --> 00:12:22,509
This is a real example I saw in
a customer a couple of years ago.

165
00:12:23,029 --> 00:12:25,909
They had a very
straightforward login screen.

166
00:12:26,429 --> 00:12:28,709
You type in your username, your password.

167
00:12:29,119 --> 00:12:34,119
The front end takes these values,
puts them together in the jsun,

168
00:12:34,779 --> 00:12:36,189
sends over to the backend.

169
00:12:36,219 --> 00:12:40,969
The backend either authenticates
or doesn't, and sets a cookie.

170
00:12:41,469 --> 00:12:46,379
They had eight character
usernames and I think passwords

171
00:12:46,379 --> 00:12:48,359
were limited to 12 characters.

172
00:12:49,189 --> 00:12:51,739
Let's say the JSON
format has some overhead.

173
00:12:52,239 --> 00:13:00,069
For argument's sake, 40 characters
together, 50 to handle extreme

174
00:13:00,069 --> 00:13:01,519
cases, and I don't know what.

175
00:13:02,409 --> 00:13:08,299
Why in the world would you allow your
backend for a simple username password

176
00:13:08,299 --> 00:13:12,869
login screen to parse a 2MB long JSON?

177
00:13:13,369 --> 00:13:14,619
Absolutely no reason.

178
00:13:15,209 --> 00:13:17,779
The only reason to do
that is just carelessness.

179
00:13:17,809 --> 00:13:20,009
It's forgetting to set a size limit.

180
00:13:20,509 --> 00:13:22,109
set your size limits.

181
00:13:22,609 --> 00:13:28,129
Where you can't set your size
limits, where you do expect really

182
00:13:28,179 --> 00:13:34,089
long, big JSONs, because this is
the protocol, this is how your

183
00:13:34,089 --> 00:13:35,709
application shares information.

184
00:13:36,209 --> 00:13:39,109
Maybe don't do it on the event loop.

185
00:13:39,609 --> 00:13:41,089
Don't use express.

186
00:13:41,139 --> 00:13:41,909
json.

187
00:13:41,909 --> 00:13:44,349
Definitely don't use json.

188
00:13:44,349 --> 00:13:46,259
parse yourself.

189
00:13:46,989 --> 00:13:52,589
But use a different library
that can process large JSONs.

190
00:13:53,044 --> 00:13:58,664
In the background as an asynchronous
task libraries like JSON stream or

191
00:13:59,174 --> 00:14:05,464
BFJ that stands for Big Friendly JSON
and no, you will not convince me the

192
00:14:05,494 --> 00:14:07,564
F stands for anything but friendly.

193
00:14:08,064 --> 00:14:13,554
Now, just to hammer this home
again, this is not necessarily fast.

194
00:14:14,174 --> 00:14:19,574
Using BFJ for argument's sake is
explicitly slower than using JSON.

195
00:14:19,574 --> 00:14:20,784
parse.

196
00:14:21,274 --> 00:14:24,424
They even say so themselves
in the documentation.

197
00:14:25,334 --> 00:14:27,974
But, speed isn't really the point here.

198
00:14:28,474 --> 00:14:33,279
We don't care if this parsing takes
a bit longer, as long as it's done

199
00:14:33,539 --> 00:14:38,729
in a worker thread and does not
prevent us from accepting or serving

200
00:14:39,039 --> 00:14:40,669
the next request that comes in.

201
00:14:41,169 --> 00:14:43,189
But okay, enough about JSON.

202
00:14:44,189 --> 00:14:45,319
This was boring.

203
00:14:45,589 --> 00:14:51,339
An attacker can only get a linear
effect to the size of their input.

204
00:14:51,839 --> 00:14:56,439
It's a threat, it's not a terrible
threat, and it's still pretty

205
00:14:56,439 --> 00:14:58,039
hard to do damage like this.

206
00:14:58,539 --> 00:15:00,729
Let's look at something a bit different.

207
00:15:01,229 --> 00:15:05,969
Let's say we aren't just overloading
our parser, we're bombing it.

208
00:15:06,469 --> 00:15:09,899
And the classic example is XML.

209
00:15:10,399 --> 00:15:13,439
So again, I have a very
simple application.

210
00:15:13,499 --> 00:15:21,079
It takes a request, a POST request,
retrieves the body, parses it

211
00:15:21,569 --> 00:15:27,349
as XML, and returns the number
of child nodes in the payload.

212
00:15:27,759 --> 00:15:27,849
Thank you.

213
00:15:28,349 --> 00:15:32,829
Not super interesting, but I
threatened that we are going to

214
00:15:32,999 --> 00:15:38,579
bomb our parser, which sounds quite
serious, actually too serious.

215
00:15:38,579 --> 00:15:39,559
It's frightening.

216
00:15:39,569 --> 00:15:41,619
So let's relax.

217
00:15:41,969 --> 00:15:43,859
Let's have a couple of laughs.

218
00:15:44,339 --> 00:15:47,539
In fact, let's have a billion laughs.

219
00:15:48,039 --> 00:15:55,189
This is the XML variant of an attack
called the billion laughs attack.

220
00:15:56,139 --> 00:16:03,454
And what this attack essentially
does It takes advantage of, if

221
00:16:03,454 --> 00:16:07,014
you'll excuse the phrase, XML
being too smart for its own good.

222
00:16:07,514 --> 00:16:13,034
XML isn't just about angular
brackets, it's a really smart

223
00:16:13,044 --> 00:16:16,724
format with a lot of functionality.

224
00:16:17,224 --> 00:16:23,264
One of the things that allows you
to do is define entities, and even

225
00:16:23,264 --> 00:16:29,334
worse, it allows you to reference
these entities by other entities.

226
00:16:29,834 --> 00:16:36,914
So this really small, textually
wise, really small XML has a

227
00:16:36,914 --> 00:16:39,824
content of the lol9 entity.

228
00:16:40,764 --> 00:16:47,264
But if we look at the definition,
lol9 is made out of, made up,

229
00:16:47,344 --> 00:16:51,434
excuse me, out of 10 lol8 elements.

230
00:16:52,404 --> 00:16:55,554
lol8 is made up of 10 lol7 elements.

231
00:16:56,144 --> 00:17:02,594
And so on and so forth till you go back
to the 10 by the power of 10 elements.

232
00:17:03,094 --> 00:17:04,954
And it's really hard.

233
00:17:05,894 --> 00:17:10,724
It's really not hard to imagine
that with a textually really

234
00:17:10,724 --> 00:17:17,314
small XML, you can expand this to
something really large in memory.

235
00:17:17,814 --> 00:17:21,094
So once again, I'm not a DOS geek.

236
00:17:21,164 --> 00:17:22,414
I'm a DOS nerd.

237
00:17:23,039 --> 00:17:32,979
So I graphed this out, and in this graph,
I have two, two lines, the size of the XML

238
00:17:33,569 --> 00:17:43,679
as a function of the number of LUL levels,
and the size this expands to in memory as

239
00:17:43,679 --> 00:17:46,639
a function of the number of LUL levels.

240
00:17:47,139 --> 00:17:51,099
And we can see the discrepancy
here really quickly.

241
00:17:52,059 --> 00:17:52,179
Okay.

242
00:17:52,679 --> 00:17:54,749
Up to four low levels.

243
00:17:55,059 --> 00:17:55,699
It's really small.

244
00:17:55,699 --> 00:17:56,849
Nobody really cares.

245
00:17:57,349 --> 00:17:59,099
Six, it starts kicking up.

246
00:17:59,779 --> 00:18:04,639
With seven levels, you still have
a tiny, teeny, tiny textual XML.

247
00:18:04,639 --> 00:18:07,409
It's just 650 bytes.

248
00:18:07,799 --> 00:18:10,069
It doesn't, not even a kilobyte.

249
00:18:10,819 --> 00:18:14,324
But this expands in
memory to about 30 megs.

250
00:18:14,824 --> 00:18:18,784
If you continue this graph in your
imagination, which I didn't do because

251
00:18:18,784 --> 00:18:21,304
it would just be impossible to see,

252
00:18:21,804 --> 00:18:28,964
eight levels kicks up to about a gig, nine
levels kicks up to something ridiculously

253
00:18:28,964 --> 00:18:32,474
large with a really small payload.

254
00:18:32,974 --> 00:18:35,284
So what can we do?

255
00:18:35,784 --> 00:18:38,394
Again, let's start with obvious solutions.

256
00:18:38,894 --> 00:18:43,274
If you don't use XML, you are
not vulnerable to DOS attacks

257
00:18:43,354 --> 00:18:45,434
that rely on XML expansion.

258
00:18:45,934 --> 00:18:47,444
If you can do this, great.

259
00:18:47,454 --> 00:18:51,454
If you're designing a system from
scratch, just decide that you

260
00:18:51,454 --> 00:18:54,164
will not use XMLs and you're fine.

261
00:18:54,664 --> 00:19:00,394
Quite often can't do this because
your system or service is part of

262
00:19:00,704 --> 00:19:07,854
something larger, some whole flow,
a new microservice in an Existing

263
00:19:07,864 --> 00:19:13,824
mesh of services, and the XML
transport is predetermined for you.

264
00:19:14,324 --> 00:19:19,354
Similarly, even if you absolutely have
to parse XMLs because that's how your

265
00:19:19,374 --> 00:19:25,354
configuration is built, that doesn't
mean you need to allow XML parsing from

266
00:19:25,464 --> 00:19:27,884
tainted, external, untrusted sources.

267
00:19:28,384 --> 00:19:30,144
Again, if possible.

268
00:19:30,809 --> 00:19:34,799
If an attacker can't inject an
XML into the system, even though

269
00:19:34,829 --> 00:19:39,379
the system uses XMLs in other
places, you're probably fine.

270
00:19:39,989 --> 00:19:43,669
But again, this is not
always possible or plausible.

271
00:19:44,169 --> 00:19:45,409
If you can't do this,

272
00:19:45,909 --> 00:19:51,199
Learn about the parser you use,
learn about the library you use.

273
00:19:52,159 --> 00:20:00,479
Quite often, you can configure this
library and switch features on and off.

274
00:20:01,409 --> 00:20:09,674
For example, if you don't need the
capability to define entities, And I must

275
00:20:09,674 --> 00:20:16,404
admit, I've been a software engineer and
an engineering manager for about 24 years.

276
00:20:16,564 --> 00:20:23,304
I think I remember one case where I saw
a system that really needed to define

277
00:20:23,344 --> 00:20:25,064
entities like that on the fly in XML.

278
00:20:25,564 --> 00:20:34,799
So if you don't need it, switch it off for
the common libxml wrappers like libxml.

279
00:20:34,799 --> 00:20:36,849
js in our example.

280
00:20:37,339 --> 00:20:42,489
You can set no int to false or
huge to false and you're good.

281
00:20:42,989 --> 00:20:47,469
Of course, you can always use a library
that just doesn't support these features.

282
00:20:48,199 --> 00:20:53,049
Again, if you can, if you don't
need these features, just do it.

283
00:20:53,549 --> 00:20:57,939
If you don't need the power
to define entities, don't give

284
00:20:57,989 --> 00:20:59,509
your attackers this power.

285
00:21:00,009 --> 00:21:04,399
And of course, the cardinal
law of application security.

286
00:21:04,809 --> 00:21:11,009
If you're getting any tainted input from
an external source, input that you do not

287
00:21:11,019 --> 00:21:14,379
trust or should not trust, sanitize it.

288
00:21:15,159 --> 00:21:19,905
Go over it, make sure there's
nothing funky or malicious

289
00:21:19,905 --> 00:21:22,659
there before you try parsing it.

290
00:21:23,159 --> 00:21:27,329
Not after, that would be too
late, before you try passing it.

291
00:21:27,829 --> 00:21:33,669
And I know this is a recorded talk,
but even if, even though it is, and

292
00:21:33,669 --> 00:21:39,299
even though I'm just sitting here in my
study recording this with no audience,

293
00:21:39,629 --> 00:21:41,399
I can already hear the Snickers.

294
00:21:42,074 --> 00:21:48,914
of people writing more modern applications
in modern formats who don't use xml

295
00:21:48,974 --> 00:21:54,374
and never used xml and never wish
to use xml and think they are safe.

296
00:21:54,874 --> 00:22:02,054
you are safe, of course, from any attacks
based on XML if you don't use XML, but

297
00:22:02,604 --> 00:22:05,314
I'm sorry to be the harbinger of bad news.

298
00:22:06,174 --> 00:22:11,524
If you are using YAML, you probably
have the exact same problem.

299
00:22:12,024 --> 00:22:18,324
YAML also allows defining entities, again,
parser, of course, but generally speaking,

300
00:22:18,664 --> 00:22:21,714
the format also allows defining entities.

301
00:22:22,084 --> 00:22:23,754
It allows recursively.

302
00:22:24,254 --> 00:22:26,664
referencing entities from other entities.

303
00:22:27,154 --> 00:22:31,964
And just as we have XML
bombs, we have YAML bombs.

304
00:22:32,464 --> 00:22:39,994
Luckily, the same tactics we discussed to
prevent DOS by XML or DOS, or excuse me,

305
00:22:40,094 --> 00:22:43,024
XML bombs will of course work for YAMLs.

306
00:22:43,524 --> 00:22:48,974
But okay, enough about annoying
formats that we all love to hate or

307
00:22:48,984 --> 00:22:51,854
hate to love, your dealer's choice.

308
00:22:52,354 --> 00:22:56,994
Let's talk about something even
more ubiquitous to JavaScript.

309
00:22:57,864 --> 00:23:00,104
Let's talk about regexes.

310
00:23:00,604 --> 00:23:06,444
I dare you to write any good sized
application without a regex somewhere.

311
00:23:06,964 --> 00:23:11,744
And if it isn't in your code, It's
probably in some third party you're using.

312
00:23:12,574 --> 00:23:18,994
In fact, even this most basic
Express application, even without the

313
00:23:18,994 --> 00:23:22,614
callback, has regexes baked in there.

314
00:23:23,514 --> 00:23:29,764
Because Express needs to take the
URL, break it up, and understand

315
00:23:30,054 --> 00:23:32,884
what handler to match this request.

316
00:23:33,884 --> 00:23:35,344
So the regexes are there.

317
00:23:36,264 --> 00:23:41,774
But anyway, let's talk about,
let's focus on the user code here.

318
00:23:42,774 --> 00:23:43,704
The user code.

319
00:23:44,524 --> 00:23:46,044
It's really simple.

320
00:23:46,544 --> 00:23:53,524
It takes two query parameters, regex and a
text to test this, to test by this regex.

321
00:23:54,184 --> 00:23:59,834
Performs this test and returns whether the
text matches or did not match the regex.

322
00:24:00,334 --> 00:24:02,284
Sounds straightforward enough.

323
00:24:02,784 --> 00:24:09,964
The problem here is that, and this
is a recurring theme, regexes can

324
00:24:09,964 --> 00:24:11,864
be too smart for their own good.

325
00:24:12,104 --> 00:24:15,294
Or more importantly, too
smart for your own good.

326
00:24:15,794 --> 00:24:20,724
Javascript tricaxes, which are PCRAs,
Perl Compliant Regular Expressions,

327
00:24:21,404 --> 00:24:23,194
have a feature called backtracking.

328
00:24:23,744 --> 00:24:29,434
You can define a capturing
group, and then a wildcard, that

329
00:24:29,434 --> 00:24:31,184
applies to this capturing group.

330
00:24:31,964 --> 00:24:35,094
And this capturing group
can have its own wildcard.

331
00:24:36,074 --> 00:24:41,654
So consider for example a regex
like the regex in the comment here.

332
00:24:42,154 --> 00:24:46,624
Open, open parentheses, a
plus, close parentheses, plus.

333
00:24:47,124 --> 00:24:54,314
Now this regex in layman terms means
A series of one or more As, one

334
00:24:54,314 --> 00:24:59,274
or more times, which, excuse the
language, is a really stupid way

335
00:24:59,774 --> 00:25:02,574
of saying a string made up of As.

336
00:25:02,954 --> 00:25:08,344
We could have defined this as just
A But for the example's sake, we

337
00:25:08,544 --> 00:25:10,489
purposely define it like this.

338
00:25:10,989 --> 00:25:16,049
Now, think about the poor regex
engine that needs to take a

339
00:25:16,059 --> 00:25:18,229
string and test with this regex.

340
00:25:18,729 --> 00:25:22,279
Consider your input is 10 characters.

341
00:25:22,779 --> 00:25:28,699
The poor regex engine will need to
test if it's 1a followed by 9a's,

342
00:25:29,149 --> 00:25:35,779
if it's 2a's followed by 8a's,
2 groups of 1a's followed by a

343
00:25:35,779 --> 00:25:39,819
group of 8a's, 2 groups of 1a's.

344
00:25:40,354 --> 00:25:45,554
Followed by two groups of four
A's and so on and so forth.

345
00:25:46,054 --> 00:25:48,934
It gets really ugly really quickly.

346
00:25:49,434 --> 00:25:50,054
How ugly?

347
00:25:50,114 --> 00:25:50,944
How quickly?

348
00:25:51,574 --> 00:25:55,104
Again, as I said, I am a DOS nerd.

349
00:25:55,104 --> 00:25:56,504
we graphed it out.

350
00:25:57,004 --> 00:26:02,824
In this benchmark, I took a string
which is made up of a series of A's

351
00:26:02,824 --> 00:26:04,744
followed by a single B character.

352
00:26:05,599 --> 00:26:10,699
This is to prevent the Regex
engine from failing fast and saying

353
00:26:10,789 --> 00:26:12,719
there's no possible combination.

354
00:26:13,219 --> 00:26:18,599
By doing this, I have forced the Regex
engine to check all the permutations

355
00:26:18,689 --> 00:26:20,669
up to the length of the string.

356
00:26:21,169 --> 00:26:28,039
And I just tied this regex with
increasingly long strings, so a

357
00:26:28,099 --> 00:26:32,779
followed by a b, two a's followed by
a b, three a's followed by a b, and so

358
00:26:32,779 --> 00:26:35,819
on, and graphed out how slow this is.

359
00:26:36,319 --> 00:26:42,564
And again, I am, I want to emphasize,
this Speed itself isn't the issue.

360
00:26:42,564 --> 00:26:44,184
the time itself isn't the issue.

361
00:26:44,274 --> 00:26:48,564
The issue is that evaluating Techn,
RegX happens on the Event Loop.

362
00:26:49,334 --> 00:26:54,514
So however long or short list takes
will type up the event loop and make

363
00:26:54,514 --> 00:26:59,064
you make your application at least
unable to serve other requests.

364
00:26:59,564 --> 00:27:02,534
So how bad is it up to about.

365
00:27:02,794 --> 00:27:09,024
28, 29, let's say, for argument's
sake, even 30, 31 A's followed

366
00:27:09,024 --> 00:27:11,724
by a B, it's not too bad.

367
00:27:12,224 --> 00:27:14,244
under half a second,
we can live with that.

368
00:27:14,744 --> 00:27:16,384
And of course not.

369
00:27:16,884 --> 00:27:23,374
50, 000 milliseconds is 50 seconds,
but under 50 seconds, under a minute,

370
00:27:23,414 --> 00:27:25,334
we can probably live with that.

371
00:27:25,834 --> 00:27:31,424
But at about the 31 A's
mark, it really kicks up.

372
00:27:32,124 --> 00:27:37,074
In 33 seconds, it takes 50
milliseconds, which is almost a minute.

373
00:27:37,424 --> 00:27:38,244
Okay.

374
00:27:38,744 --> 00:27:44,774
With 35 As, it takes a bit shy of 300.

375
00:27:45,274 --> 00:27:48,294
milliseconds, which is 300 minutes,

376
00:27:48,794 --> 00:27:51,974
300 seconds, which is about five minutes.

377
00:27:52,464 --> 00:27:56,704
As you can see, this presentation
has lost my ability to do math.

378
00:27:57,204 --> 00:28:04,514
So I will rephrase in 35 characters, we
get about 300 seconds, which is under

379
00:28:04,514 --> 00:28:11,764
five, but under 300 seconds, which is
a bit under five minutes, which is It's

380
00:28:11,764 --> 00:28:17,394
slow and annoying and let's say it's
the outer edge of what you'd be able to

381
00:28:17,394 --> 00:28:21,734
expect when I'm trying to go up to 36 A's.

382
00:28:22,234 --> 00:28:24,464
This simple Node.

383
00:28:24,464 --> 00:28:32,134
js application just took up so much
memory, so much CPU power, it completely

384
00:28:32,134 --> 00:28:37,064
killed my computer to the point where
the music I was listening to while

385
00:28:37,064 --> 00:28:39,664
making this graph started lagging.

386
00:28:40,254 --> 00:28:43,454
So I just killed the benchmark
and said, okay, that's it.

387
00:28:43,954 --> 00:28:48,634
And if you think about it, An
attacker being able to send a

388
00:28:48,634 --> 00:28:54,684
payload that is 35 or 36 characters
long has not that far fetched.

389
00:28:54,704 --> 00:28:56,524
It is not a big payload.

390
00:28:56,864 --> 00:29:00,744
This is a really easy attack if your
application is vulnerable to it.

391
00:29:01,244 --> 00:29:03,884
So what can we do to prevent this?

392
00:29:04,804 --> 00:29:10,004
First of all, if you have a regex,
baked into your application.

393
00:29:10,104 --> 00:29:11,784
Just check your regex.

394
00:29:12,414 --> 00:29:18,494
Make double sure, triple sure,
quadruple sure that this regex does

395
00:29:18,494 --> 00:29:21,934
not have a backtracking part in it.

396
00:29:22,434 --> 00:29:24,984
There's tons of tools to do this.

397
00:29:25,094 --> 00:29:29,974
Generally speaking, SAST,
static analysis security testing

398
00:29:29,974 --> 00:29:32,504
tools, are really good at this.

399
00:29:33,004 --> 00:29:34,044
Test your regexes.

400
00:29:34,544 --> 00:29:38,484
make sure that you don't have
something super dangerous

401
00:29:38,574 --> 00:29:39,864
baked into your application.

402
00:29:40,364 --> 00:29:46,574
Now, if this isn't your regex, which is
hardcoded coded in your code, if it's

403
00:29:46,624 --> 00:29:52,894
some valuable input, first of all, If
you can, don't allow tainted input,

404
00:29:52,964 --> 00:29:55,354
user controlled input, as a regex.

405
00:29:55,854 --> 00:30:00,194
This isn't always possible, especially
if you think about applications that

406
00:30:00,194 --> 00:30:03,754
have search capabilities with wildcards.

407
00:30:04,254 --> 00:30:10,594
It isn't always possible, but if you are
going that way, maybe don't allow the end

408
00:30:10,694 --> 00:30:19,054
user to input a straight up regex, but
have some a simplified wildcard syntax

409
00:30:19,054 --> 00:30:27,304
like allow asterisks and that's about it
where you take the string and convert it

410
00:30:27,314 --> 00:30:29,914
to a regex in the back end in your code.

411
00:30:30,414 --> 00:30:35,794
So clearly it's still affected by
user input but you can't say it's

412
00:30:35,814 --> 00:30:41,074
completely controlled by it and if a
user can't input any arbitrary regex

413
00:30:41,624 --> 00:30:44,524
with backtracking It could be okay.

414
00:30:45,024 --> 00:30:48,949
Kind of following up on
that, if you to have a regex.

415
00:30:49,679 --> 00:30:55,159
Maybe don't allow a regex that
you know can be dodgy to evaluate

416
00:30:55,399 --> 00:30:57,159
user input, tainted input.

417
00:30:57,799 --> 00:31:00,569
Okay, this is usually not possible.

418
00:31:01,389 --> 00:31:05,539
We usually don't use regexes to
evaluate data we know, but data

419
00:31:05,539 --> 00:31:09,109
we don't know, which usually
comes from some external source.

420
00:31:09,609 --> 00:31:14,274
But if you are doing this, and you can't
avoid having a tainted input, dodgy

421
00:31:14,274 --> 00:31:18,754
regex, at least, again, use length limits.

422
00:31:18,984 --> 00:31:24,414
We've seen in the graph that the
time we tie up a regex is really

423
00:31:24,414 --> 00:31:26,584
dependent on the length of the input.

424
00:31:27,114 --> 00:31:32,444
So even if it is a really bad regex,
but you limit the length of the input,

425
00:31:33,034 --> 00:31:39,074
a user, or in our case, an attacker can
fail it on this regex, it could be okay.

426
00:31:39,574 --> 00:31:44,874
And of course, as always, maybe don't
use regex, maybe use some alternatives.

427
00:31:45,374 --> 00:31:51,794
First of all, still in the Regex realm,
instead of using JavaScripts built in

428
00:31:51,894 --> 00:31:54,934
Regex, you can use a package like RE2.

429
00:31:55,434 --> 00:31:58,494
RE2 is not a PCRE.

430
00:31:58,844 --> 00:32:01,954
It is not a Perl compliant
regular expression.

431
00:32:02,534 --> 00:32:05,614
It is much, much less powerful.

432
00:32:06,114 --> 00:32:14,134
But, if you don't need all of this power,
and you can suffice with the functionality

433
00:32:14,134 --> 00:32:18,774
that RE2 gives you, RE2, because it
doesn't have all the bells and whistles,

434
00:32:18,854 --> 00:32:25,374
because it doesn't have bell tracking,
backtracking is not vulnerable to Redos.

435
00:32:26,134 --> 00:32:30,224
So maybe that's a valid
alternative in your use case.

436
00:32:30,724 --> 00:32:33,494
Also, maybe don't invent the wheel.

437
00:32:33,994 --> 00:32:37,744
A lot of the times you don't
need a general purpose regex.

438
00:32:37,934 --> 00:32:44,144
A lot of the time you use
regex for really scoped tasks.

439
00:32:44,519 --> 00:32:50,429
Like checking input, if something is
a valid email, valid address, valid

440
00:32:50,429 --> 00:32:53,419
URL, then write your own regexes.

441
00:32:53,919 --> 00:33:00,159
Use proven tools that someone else
wrote and tested and verified are safe.

442
00:33:00,819 --> 00:33:01,059
Validator.

443
00:33:01,559 --> 00:33:03,019
js, for example, in the Node.

444
00:33:03,379 --> 00:33:08,029
js ecosystem, has a ton of
regexes, a ton of regexes.

445
00:33:08,049 --> 00:33:09,589
validators.

446
00:33:10,169 --> 00:33:17,099
Most of them are implemented by regexes
to check inputs for a ton of needs,

447
00:33:17,579 --> 00:33:26,014
including All sorts of ISO standards, I
admit, I never heard about, like standard

448
00:33:26,014 --> 00:33:29,044
for shipping container identifiers.

449
00:33:29,544 --> 00:33:33,414
If you can avoid writing your
own regex, by all means do Now,

450
00:33:33,914 --> 00:33:39,454
the last type of DOS attack is
something near and dear to my heart.

451
00:33:39,954 --> 00:33:44,464
Having done storage professionally
for a lot of years before

452
00:33:44,464 --> 00:33:46,054
moving to application security.

453
00:33:46,554 --> 00:33:50,034
this again is a really simple application.

454
00:33:50,534 --> 00:33:56,444
Once It gets a request, it
reads the file from disk.

455
00:33:56,744 --> 00:33:58,634
There's no user input involved here.

456
00:33:59,584 --> 00:34:03,974
Reads the file from disk and
returns it back to the response.

457
00:34:04,804 --> 00:34:08,144
Now, of course, this is a
really stupid application.

458
00:34:08,604 --> 00:34:12,134
If this were a real use case,
I'd read this file once,

459
00:34:12,144 --> 00:34:13,964
store it in memory, cache it.

460
00:34:14,704 --> 00:34:20,354
But for the demonstration's
sake, This is a valid way to

461
00:34:20,384 --> 00:34:21,964
implement such an application.

462
00:34:22,654 --> 00:34:27,314
And if this weren't a demo, you can
think about an application that has

463
00:34:27,324 --> 00:34:29,314
various files to read or whatever.

464
00:34:29,814 --> 00:34:32,894
Now, the Tosya is really sneaky.

465
00:34:33,394 --> 00:34:41,484
Who's If we think about storage
in no js, there are two ways

466
00:34:41,544 --> 00:34:43,934
we can do storage operations.

467
00:34:44,434 --> 00:34:52,974
We have the Async way, such as FS three
deal, or Fs right file, which delegates

468
00:34:52,974 --> 00:34:58,924
the IO to a worker thread and all
sorts of third party libraries like F.

469
00:34:58,924 --> 00:35:04,624
S, extra Graceful Affairs, A
DMZ also have the same patterns,

470
00:35:05,124 --> 00:35:06,084
perform a call.

471
00:35:06,544 --> 00:35:09,164
You provide a callback, the IER happens.

472
00:35:09,934 --> 00:35:14,284
In a worker thread, in the
background, does not block the event

473
00:35:14,294 --> 00:35:18,184
loop, and once the IR is done, you
get a callback with the result.

474
00:35:18,684 --> 00:35:25,044
Now, if the first way of handling
storage is the async way, the

475
00:35:25,044 --> 00:35:27,884
second way is clearly the wrong way.

476
00:35:27,964 --> 00:35:35,174
So any API and specifically storage
that declares that's a sync API,

477
00:35:35,194 --> 00:35:42,584
so FS read deal sync, FS write file
sync, same goes for ADM zip APIs, for

478
00:35:42,584 --> 00:35:48,234
FS extra APIs, for any API, frankly,
not even necessarily storage related.

479
00:35:48,734 --> 00:35:54,644
is explicitly telling you that it will
be performing its work on the event loop.

480
00:35:55,144 --> 00:35:59,664
Now, it's often more convenient to code
like this because you aren't messing

481
00:35:59,664 --> 00:36:04,414
around with callbacks or promises and
everything is just straightforward.

482
00:36:05,154 --> 00:36:09,284
But the price you're paying is that
you are blocking the event loop.

483
00:36:09,784 --> 00:36:14,599
Now, this Sometimes can be okay,
especially in the context of the

484
00:36:14,599 --> 00:36:19,189
application starting up and it's
not serving user requests, etc.

485
00:36:19,689 --> 00:36:25,299
But if you are in the context of a user
request, any API that declares that it's

486
00:36:25,419 --> 00:36:30,529
synchronous and blocking the event loop,
should simply be out of the question.

487
00:36:30,579 --> 00:36:35,439
Should be something that you don't
use and don't even consider using.

488
00:36:35,939 --> 00:36:41,599
Now, this form of DOS is sneaky because
we have become very accustomed to

489
00:36:41,729 --> 00:36:48,929
personal computers, which have SSD
and NVMe and all manner of really

490
00:36:48,929 --> 00:36:55,129
fast drives, that we don't always have
this in the forefront of our mind.

491
00:36:55,629 --> 00:37:02,729
But storage can be slow, and especially
outside of our development environment,

492
00:37:02,759 --> 00:37:10,529
while we deploy our code to some third
party cloud provider, which uses some

493
00:37:10,859 --> 00:37:17,619
third party storage, which we have no
control over and no idea how fast or more

494
00:37:17,619 --> 00:37:20,859
often than not slow it is, don't trust it.

495
00:37:21,439 --> 00:37:23,999
Don't give it the chance
to block your event loop.

496
00:37:24,499 --> 00:37:27,619
Delegate everything to async APIs.

497
00:37:28,119 --> 00:37:30,879
And yes, it is a bit more complicated.

498
00:37:31,289 --> 00:37:34,659
It does arguably make
the code a bit uglier.

499
00:37:34,839 --> 00:37:39,199
It does arguably make it a bit
harder to debug and maintain.

500
00:37:39,699 --> 00:37:46,199
But from a DOS perspective, this isn't
just a better way of writing code.

501
00:37:46,559 --> 00:37:48,619
It's the right way of writing code.

502
00:37:49,119 --> 00:37:54,814
Don't make your users suffer
because As a developer, you were

503
00:37:54,904 --> 00:38:00,384
a tad lazy and wanted to just call
a sync API and be done with it.

504
00:38:00,884 --> 00:38:03,194
Put in the extra couple of minutes.

505
00:38:03,374 --> 00:38:04,994
It usually isn't much more than that.

506
00:38:05,024 --> 00:38:11,704
Couple of minutes of effort and do
your storage calls or do whatever call.

507
00:38:12,094 --> 00:38:18,854
If there's a sync and async variant of
the API do it with the async variant.

508
00:38:19,154 --> 00:38:20,624
Your users will thank you

509
00:38:21,124 --> 00:38:23,369
with this, I think, Nearing the end.

510
00:38:23,869 --> 00:38:30,829
So just want to sum up here and give
you some takeaways from this talk

511
00:38:31,329 --> 00:38:37,659
when we're thinking about application
security, especially if we are web

512
00:38:37,659 --> 00:38:44,489
developers or application developers
that don't usually focus on application

513
00:38:44,489 --> 00:38:47,479
security, we focus on our applications.

514
00:38:47,739 --> 00:38:50,869
of course, we want them to
be secure, but we focus.

515
00:38:51,519 --> 00:38:53,669
first and foremost on functionality.

516
00:38:54,169 --> 00:38:58,649
We usually think about instinctively
about injection attacks, about our

517
00:38:58,649 --> 00:39:04,849
SQL injections and XSS malicious
payloads, doing malicious things

518
00:39:04,849 --> 00:39:07,659
to applications, which is all true.

519
00:39:07,699 --> 00:39:12,009
And if you're thinking about those and
defending against those, That's great.

520
00:39:12,509 --> 00:39:14,829
But don't forget about DOS.

521
00:39:14,879 --> 00:39:16,819
Don't forget about denial of service.

522
00:39:17,319 --> 00:39:23,049
Quite often, from an attacker's
perspective, it is considerably

523
00:39:23,109 --> 00:39:29,009
easier to exploit DOS vulnerability
than an injection vulnerability.

524
00:39:29,459 --> 00:39:32,899
It takes considerably less
skill to do so successfully.

525
00:39:33,399 --> 00:39:39,189
And while it might not be possible to
steal all your data by DOS vulnerability,

526
00:39:39,689 --> 00:39:44,334
it is relatively easy to Bring your
application to a screeching halt where

527
00:39:44,334 --> 00:39:46,524
it cannot serve its legitimate users.

528
00:39:47,024 --> 00:39:53,644
So you may have not lost anything,
nothing was stolen, but your

529
00:39:53,674 --> 00:39:55,094
business isn't working anymore.

530
00:39:55,594 --> 00:39:58,604
How do we defend against DOS applications?

531
00:39:59,104 --> 00:40:03,404
There's a couple of really
simple takeaways to remember.

532
00:40:04,124 --> 00:40:09,514
First of all, if we already are thinking
about security, we do not allow user

533
00:40:09,514 --> 00:40:13,204
inputs or tainted inputs to places
where they have no business to be.

534
00:40:13,704 --> 00:40:20,764
If we do, we sanitize them, specifically
in the DOS perspective, we sanitize

535
00:40:20,794 --> 00:40:27,924
them against attacks that might exploit
our parser, being XML, YAML, whatever.

536
00:40:28,424 --> 00:40:35,074
Regardless of sanitation, we use
length limits and size limits.

537
00:40:35,654 --> 00:40:37,674
These are really easy to implement.

538
00:40:38,439 --> 00:40:44,959
They won't prevent 100 percent of the
attacks, but they do make DOS attacks

539
00:40:45,009 --> 00:40:48,249
considerably more difficult to pull off.

540
00:40:48,749 --> 00:40:54,039
Also, even regardless of DOS
attacks, mistakes happen, users

541
00:40:54,039 --> 00:40:58,629
do crazy stuff, don't allow them
to bombard you with huge inputs if

542
00:40:58,629 --> 00:41:00,399
there's no business value for it.

543
00:41:00,899 --> 00:41:05,689
And lastly, think about the libraries,
think about the APIs you're using.

544
00:41:06,569 --> 00:41:12,029
Think about whether they're running in
the event loop or in a worker thread.

545
00:41:12,519 --> 00:41:17,439
And if they are running in an event
loop, in the event loop, chances are

546
00:41:17,509 --> 00:41:21,289
there's either a different library or
a different API within that library you

547
00:41:21,289 --> 00:41:23,279
can use to delegate to a worker thread.

548
00:41:23,779 --> 00:41:29,059
and learn the configurations quite
often really easy to set up an

549
00:41:29,099 --> 00:41:33,179
application that would just work
with the default configurations.

550
00:41:33,679 --> 00:41:38,619
Quite often these configurations
aren't only not geared towards

551
00:41:38,629 --> 00:41:43,199
security, they aren't geared
towards production usage in general.

552
00:41:43,859 --> 00:41:48,789
So once you have your prototype working,
take a minute to review the configuration.

553
00:41:49,109 --> 00:41:51,179
Maybe you want to switch
off feature flags.

554
00:41:51,229 --> 00:41:52,999
Maybe you want to add a length limit.

555
00:41:53,549 --> 00:41:55,869
Maybe you want to add
some built in sanitation.

556
00:41:56,369 --> 00:41:57,294
Get to know your project.

557
00:41:57,574 --> 00:42:02,994
The APIs and libraries you're using, it
won't only make you more security aware,

558
00:42:03,864 --> 00:42:07,704
it will make you a better programmer and
it will make your application better.

559
00:42:08,204 --> 00:42:10,454
With that, I am really done.

560
00:42:10,934 --> 00:42:16,744
If any of this resonates with you,
I do invite you to keep in touch.

561
00:42:16,794 --> 00:42:18,954
I am not a hard person to find.

562
00:42:19,374 --> 00:42:26,124
Can reach me on LinkedIn, on X, Twitter,
by email, by all means, reach out.

563
00:42:26,524 --> 00:42:28,194
Let's keep this conversation going.

564
00:42:28,694 --> 00:42:30,224
And thank you.

565
00:42:30,724 --> 00:42:31,904
Thank you for listening.

566
00:42:32,634 --> 00:42:33,814
Thank you for your time.

567
00:42:34,314 --> 00:42:37,654
Thank you for considering the
security of your applications

568
00:42:37,994 --> 00:42:39,674
and not just the functionality.

569
00:42:40,174 --> 00:42:42,134
And have a great conference.

