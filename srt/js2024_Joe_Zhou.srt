1
00:00:00,200 --> 00:00:00,820
Hi, everyone.

2
00:00:00,840 --> 00:00:05,819
My name is Joe, and welcome to
my CON42 JavaScript 2024 session.

3
00:00:06,660 --> 00:00:10,950
Today, I'm going to talk about the
TypeScript magic, like how to achieve end

4
00:00:10,950 --> 00:00:12,870
to end type safety across the full stack.

5
00:00:13,370 --> 00:00:16,430
First off, please allow me to
introduce myself a little bit.

6
00:00:16,570 --> 00:00:19,970
As I said, my name is Joe
and I'm currently a developer

7
00:00:20,000 --> 00:00:21,159
advocate at Dragonfly.

8
00:00:21,839 --> 00:00:23,919
And I'm a huge fan of K pop as well.

9
00:00:23,970 --> 00:00:28,089
And sometimes I just feel that I
attended too many K pop concerts.

10
00:00:29,049 --> 00:00:31,920
Before Dragonfly, I mostly
do backend development.

11
00:00:31,949 --> 00:00:35,914
So I've been doing that with different
languages, JavaScript, TypeScript.

12
00:00:36,165 --> 00:00:39,315
Go Rust, just to name
some of my favorites.

13
00:00:39,875 --> 00:00:44,144
And from there, I also developed a
very strong interest in databases.

14
00:00:44,644 --> 00:00:49,904
So yeah, today I'm going to talk about,
backend and, like the type safety.

15
00:00:50,134 --> 00:00:54,794
And I'm very passionate about what
I do and I like memes as well.

16
00:00:54,804 --> 00:00:58,664
I'm going to be using memes in this
talk and I hope you enjoy them as well.

17
00:00:59,165 --> 00:01:02,825
Before that, please allow me to
introduce a little bit about the

18
00:01:02,825 --> 00:01:04,125
project I'm working on right now.

19
00:01:04,375 --> 00:01:05,335
It's called Dragonfly.

20
00:01:05,825 --> 00:01:08,185
So Dragonfly is an in memory data store.

21
00:01:08,645 --> 00:01:10,505
it is compatible to Redis.

22
00:01:10,515 --> 00:01:14,595
So it can be used as a dropping
replacement, but the architecture

23
00:01:14,605 --> 00:01:16,164
is built from scratch.

24
00:01:16,164 --> 00:01:18,474
So it's just happened to be compatible.

25
00:01:18,494 --> 00:01:20,304
It's not a fork of Redis, right?

26
00:01:20,664 --> 00:01:24,694
Because of the new modern multi
threaded architecture, Dragonfly is

27
00:01:24,695 --> 00:01:30,045
able to handle 25 times more throughput
on a single multi core instance.

28
00:01:30,545 --> 00:01:35,915
So because of that, because Dragonfly can
fully utilize your multi core hardware.

29
00:01:36,224 --> 00:01:40,795
If you take one If you take the
binary of Dragonfly, you take the

30
00:01:40,795 --> 00:01:45,715
binary and you put it on a multi core,
powerful multi core server and that

31
00:01:45,744 --> 00:01:51,015
one Dragonfly instance is going to be
able to fully utilize your hardware.

32
00:01:51,435 --> 00:01:56,785
Whereas in comparison for Redis, because
Redis is single threaded mostly, Redis

33
00:01:56,805 --> 00:01:59,605
can only utilize, like a single core.

34
00:01:59,985 --> 00:02:05,425
That's why if you put Redis on a
multiple machine, even on that one

35
00:02:05,455 --> 00:02:08,685
machine, some sort of clustering
solution is needed for Redis.

36
00:02:09,185 --> 00:02:10,365
So awesome.

37
00:02:10,415 --> 00:02:14,235
it's a, to me, it's like a great, it's
one of my favorite data store right now.

38
00:02:14,545 --> 00:02:18,405
And, it is like the next chain in
memory, the story, if you have, if you're

39
00:02:18,405 --> 00:02:23,115
interested, yeah, feel free to check us
out and, we have a cloud offering as well.

40
00:02:23,615 --> 00:02:28,315
And, yeah, I'm going to go, I'm
going to be showing like TypeScript,

41
00:02:28,455 --> 00:02:29,285
JavaScript code right now.

42
00:02:29,685 --> 00:02:34,575
just, One more note for the
compatibility of Dragonfly, just like how

43
00:02:34,585 --> 00:02:36,555
compatible we're talking about, right?

44
00:02:37,005 --> 00:02:38,735
So this is a snippet.

45
00:02:38,775 --> 00:02:44,765
You can use this IO Redis library to
create a client and that client will

46
00:02:44,765 --> 00:02:48,665
be able to talk to a Redis instance
and you can send commands from there.

47
00:02:49,165 --> 00:02:53,690
So if you ever want to switch
to Dragonfly, The only code

48
00:02:53,690 --> 00:02:55,710
you need to change is the URL.

49
00:02:55,750 --> 00:02:59,480
So you pointed to a
different, dragonfly URL.

50
00:02:59,480 --> 00:03:02,800
In this case, I'm using a
dragonfly cloud instance.

51
00:03:03,350 --> 00:03:04,930
And that's it from there.

52
00:03:04,930 --> 00:03:09,410
You can start to send the familiar
commands that you use for Redis.

53
00:03:09,910 --> 00:03:10,380
Cool.

54
00:03:10,800 --> 00:03:13,250
And, let's talk about
programming languages, right?

55
00:03:13,260 --> 00:03:18,720
So I do believe in the saying of using
the right tools for the right things.

56
00:03:19,220 --> 00:03:24,480
And, yeah, for instance, Python
has like a huge ecosystem of,

57
00:03:24,530 --> 00:03:27,450
data analysis, AI, everything.

58
00:03:27,750 --> 00:03:28,870
So if you're in that.

59
00:03:29,370 --> 00:03:32,170
domain or sector, it's
natural just to use Python.

60
00:03:33,140 --> 00:03:38,020
But for me, as a backend developer, I
think I personally have a very strong

61
00:03:38,020 --> 00:03:43,560
preference of strong and statically
typed languages because when I

62
00:03:43,570 --> 00:03:45,270
receive, let's say we use JSON, right?

63
00:03:45,420 --> 00:03:49,850
When I receive a JSON payload from
the client, it's so crucial for

64
00:03:49,850 --> 00:03:56,785
me to Make sure that the payload
conforms the request, the shape

65
00:03:56,785 --> 00:03:58,545
of the request that we want.

66
00:03:58,595 --> 00:04:01,895
And we also validate each of
the fields in there, right?

67
00:04:02,195 --> 00:04:07,235
So this strong and static typing
and all the validations we do.

68
00:04:07,735 --> 00:04:10,655
that just makes me feel like
sleep much better at nights.

69
00:04:11,155 --> 00:04:13,405
So let's dive in, TypeScript.

70
00:04:13,455 --> 00:04:17,455
yeah, as you can tell, TypeScript
is, is, strongly typed.

71
00:04:17,455 --> 00:04:21,665
And if you ask me what's the, what
like, what's one of the most important,

72
00:04:22,165 --> 00:04:26,855
project within the JavaScript ecosystem,
I would argue that it is TypeScript

73
00:04:26,875 --> 00:04:32,645
because, it gives like, So many
guarantees, right now than before, right?

74
00:04:32,935 --> 00:04:35,755
TypeScript provides something
called the utility type.

75
00:04:35,755 --> 00:04:36,835
what does it mean?

76
00:04:37,335 --> 00:04:39,125
Let's take a look at the example.

77
00:04:39,125 --> 00:04:43,395
Imagine we are building like
a bookstore, a website, maybe

78
00:04:43,425 --> 00:04:45,015
like the next Amazon, right?

79
00:04:45,325 --> 00:04:50,875
this is a type we can define and we can
define so that we, we can use in our code.

80
00:04:51,205 --> 00:04:55,355
We want all our book record
to look like this, right?

81
00:04:55,975 --> 00:04:59,375
By saying book record, because
we are trying to save this

82
00:04:59,565 --> 00:05:00,985
object in the database as well.

83
00:05:00,985 --> 00:05:02,015
So it needs an ID.

84
00:05:02,515 --> 00:05:06,575
But what if I'm just receiving the
request from the client, like adding

85
00:05:06,635 --> 00:05:09,035
a new book to the store, right?

86
00:05:09,880 --> 00:05:12,490
We don't want the client
to specify the ID, right?

87
00:05:12,510 --> 00:05:15,940
Because, we want to generate
the ID in the backend.

88
00:05:15,990 --> 00:05:19,360
It's more secure, maybe using
a serial, maybe using like

89
00:05:19,360 --> 00:05:21,290
a UID or something, right?

90
00:05:21,300 --> 00:05:26,830
So when that happens, what we
can do is that we can use this

91
00:05:26,860 --> 00:05:28,490
utility type from TypeScript.

92
00:05:29,050 --> 00:05:32,670
One example is called
the omit utility type.

93
00:05:32,990 --> 00:05:35,260
So as you can see, we're using angle.

94
00:05:35,655 --> 00:05:36,935
brackets here, right?

95
00:05:36,945 --> 00:05:40,765
So the mindset would be if we're
using round brackets, that's calling

96
00:05:40,765 --> 00:05:42,835
a function or calling a method.

97
00:05:42,835 --> 00:05:45,755
So we're operating on
the object or the value.

98
00:05:46,355 --> 00:05:50,995
But when we see angle brackets,
we're operating on the types.

99
00:05:51,455 --> 00:05:53,115
like on a higher level, right?

100
00:05:53,355 --> 00:05:57,885
So in this case, we're using the
omit utility type to remove the

101
00:05:57,885 --> 00:06:03,405
ID field from book record and it
returns a new type we can assign

102
00:06:03,405 --> 00:06:05,625
to, a new type called book request.

103
00:06:06,105 --> 00:06:11,425
By doing that, this book request
type has everything in book

104
00:06:11,425 --> 00:06:14,405
record except for ID, right?

105
00:06:14,615 --> 00:06:20,060
So yeah, if you want to add a new
book, to the store, we need all

106
00:06:20,060 --> 00:06:26,020
this information, but we're going to
generate the ID on the backend, right?

107
00:06:26,420 --> 00:06:30,580
So similarly, we can, we have other
utility types in TypeScript as well.

108
00:06:31,330 --> 00:06:34,980
Another example would be the peak
utility type, it's doing the reverse.

109
00:06:35,000 --> 00:06:40,000
In this case, we want to have a new
type called book preview, right?

110
00:06:40,190 --> 00:06:43,040
So what we do is that we
use the peak utility type.

111
00:06:43,570 --> 00:06:49,860
And we take only one field, the title
field from book record, and the end

112
00:06:49,870 --> 00:06:51,990
result will look like this, right?

113
00:06:52,000 --> 00:06:56,370
So we're, operating, playing
with the types, we're using

114
00:06:56,370 --> 00:06:59,180
composition to generate new types.

115
00:06:59,730 --> 00:07:00,420
And, Yeah.

116
00:07:00,420 --> 00:07:05,370
And they can be used like whenever
necessary and appropriate in your code.

117
00:07:05,870 --> 00:07:09,430
And the final example would be the
read only utility type, where if

118
00:07:09,430 --> 00:07:14,170
you use that all the fields within
the original book record type

119
00:07:14,800 --> 00:07:17,790
became read only and immutable.

120
00:07:17,840 --> 00:07:18,850
So yeah.

121
00:07:19,400 --> 00:07:21,220
And, that's just like three of them.

122
00:07:21,250 --> 00:07:23,890
We have like many other
utility types in there as well.

123
00:07:24,390 --> 00:07:24,660
Cool.

124
00:07:24,660 --> 00:07:30,570
So now we have types, but, We
defined the shape of the JSON

125
00:07:30,810 --> 00:07:32,150
objects that we want, right?

126
00:07:32,150 --> 00:07:34,380
But we haven't talked about validation.

127
00:07:34,380 --> 00:07:39,030
For instance, ISBN, that's a
standard for, a serial for the books.

128
00:07:39,070 --> 00:07:42,150
And, it is a string, but it needs to meet.

129
00:07:42,555 --> 00:07:44,005
certain criteria, right?

130
00:07:44,025 --> 00:07:45,385
So how do we do that?

131
00:07:45,885 --> 00:07:49,825
Let me introduce you to one of my
favorite libraries in TypeScript

132
00:07:49,875 --> 00:07:51,935
that is called Zod, right?

133
00:07:51,935 --> 00:07:53,425
So this is general Zod.

134
00:07:53,915 --> 00:07:57,025
And this is actually
the logo of the library.

135
00:07:57,525 --> 00:08:03,205
So what Zod does is that let's take a look
at this code snippet using Zod, right?

136
00:08:03,205 --> 00:08:08,205
So we're, yeah, as you can see,
it's quite intuitive API, right?

137
00:08:08,475 --> 00:08:08,895
It looks.

138
00:08:09,880 --> 00:08:13,680
like similar to our type
definition for book record before,

139
00:08:13,680 --> 00:08:15,400
but, it's actually different.

140
00:08:16,390 --> 00:08:21,310
First off, obviously we import the
library, we import the Zed object.

141
00:08:21,310 --> 00:08:23,380
I'm saying Zed, you can
tell that I live in Canada.

142
00:08:24,150 --> 00:08:28,020
We're importing the Zed object
from the library, right?

143
00:08:28,500 --> 00:08:34,070
And from there, we're using , like
z the string, Z, the date and

144
00:08:34,070 --> 00:08:36,020
everything, and z the object, right?

145
00:08:36,410 --> 00:08:41,070
So we're calling methods, and as
you can see here, it's a account.

146
00:08:41,070 --> 00:08:46,710
So what we get here, the book record is
actually an object, not a type, right?

147
00:08:46,710 --> 00:08:48,690
Because it's a value, right?

148
00:08:48,780 --> 00:08:52,950
And as you can see here, we are
specifying the I-S-B-N-S string as well.

149
00:08:52,950 --> 00:08:54,405
So all this API.

150
00:08:55,035 --> 00:08:59,325
The that object, the that string
and that thing which we're just

151
00:08:59,325 --> 00:09:05,015
telling, using Z that for my book
record, I want it to be an object.

152
00:09:05,435 --> 00:09:09,485
And within this object, I want
to have these fields, right?

153
00:09:09,905 --> 00:09:14,675
And for each of the fields, I want it
to be a string, and not only string

154
00:09:14,675 --> 00:09:16,985
for id, I want it to be UU ID as well.

155
00:09:17,345 --> 00:09:20,345
Similarly for other id, right?

156
00:09:20,525 --> 00:09:23,255
For ISPN, we're doing a string right now.

157
00:09:24,045 --> 00:09:29,265
We can actually do better by
adding a regex validation, right?

158
00:09:29,285 --> 00:09:33,125
I took this from, LLM, I don't
remember which one, it's probably

159
00:09:33,125 --> 00:09:37,995
not the most strict, regex, but,
it's, it's a good enough regex to

160
00:09:37,995 --> 00:09:42,405
know that, your, the stream being
passed in is a valid ISBN, right?

161
00:09:42,955 --> 00:09:45,095
we're not only doing type.

162
00:09:45,485 --> 00:09:50,105
Here, we're on, we're also doing
validation, like how we want the string

163
00:09:50,105 --> 00:09:52,895
to look like when I get the payload.

164
00:09:53,465 --> 00:09:56,825
And again, remember that it is constant.

165
00:09:57,155 --> 00:09:59,145
And this is a value, right?

166
00:09:59,145 --> 00:10:01,635
It is an object, not type yet.

167
00:10:02,135 --> 00:10:02,555
Cool.

168
00:10:02,725 --> 00:10:07,855
So we have, once we have this
object called book record, what

169
00:10:07,855 --> 00:10:12,655
we can do is that we can use that
to validate, other objects, right?

170
00:10:12,875 --> 00:10:15,375
In this case, I'm using
the book record object.

171
00:10:15,745 --> 00:10:19,005
object and I call the
parse function on it.

172
00:10:19,345 --> 00:10:23,265
And then I'm giving it a
like arbitrary object, right?

173
00:10:23,635 --> 00:10:26,955
This object, obviously it
won't pass because first off

174
00:10:26,955 --> 00:10:28,385
it's missing a few fields.

175
00:10:28,895 --> 00:10:33,145
And secondly, the other ID is supposed
to be a new ID, not a one, two,

176
00:10:33,145 --> 00:10:34,985
three, another random string, right?

177
00:10:35,175 --> 00:10:43,010
So if I call book record up parse, and
I pass in this object, the validation

178
00:10:43,010 --> 00:10:48,940
will fail so that we know that this
particular, single field object

179
00:10:49,300 --> 00:10:51,690
with other ID is not what we want.

180
00:10:51,700 --> 00:10:55,220
You cannot send this to
my backend server, right?

181
00:10:55,720 --> 00:10:56,150
Cool.

182
00:10:56,350 --> 00:10:59,365
So we have this book record.

183
00:10:59,725 --> 00:11:05,315
Again, it is an object and we're using
all the magic from the Zot library.

184
00:11:06,285 --> 00:11:09,945
And I'm about to show you
like more magic over here.

185
00:11:10,355 --> 00:11:15,415
So what we can do is that book
record, with the smaller case

186
00:11:15,415 --> 00:11:20,985
letter B, that is the validator
object we can use to validate.

187
00:11:21,545 --> 00:11:22,925
other objects, right?

188
00:11:23,405 --> 00:11:26,025
But we can also use the z.

189
00:11:26,805 --> 00:11:32,845
infer method from the library as well,
and I pass in type of, this object.

190
00:11:33,225 --> 00:11:35,375
It will return me a type.

191
00:11:35,525 --> 00:11:38,765
I'm talking about type Right
now, not object anymore, right?

192
00:11:39,035 --> 00:11:45,865
So Zot can infer a type from the
validator object that we defined earlier.

193
00:11:46,395 --> 00:11:49,625
And the type, as you can
guess, it looks like this.

194
00:11:49,995 --> 00:11:55,075
It has all the field and
type requirements, right?

195
00:11:55,395 --> 00:11:57,665
So, where to use that?

196
00:11:57,705 --> 00:12:03,035
obviously, we use this book record
validator object to validate.

197
00:12:03,850 --> 00:12:05,080
other objects, right?

198
00:12:05,400 --> 00:12:10,660
Whereas this book record with type
capital B, we use this type, we can use

199
00:12:10,660 --> 00:12:15,820
that to specify, in our methods, in our
handlers, where we're never appropriate.

200
00:12:15,860 --> 00:12:21,220
So that we know that we're expecting
such a type in TypeScript, right?

201
00:12:21,250 --> 00:12:26,930
So Zot gives you both the power of
doing validation as well as inferring,

202
00:12:27,430 --> 00:12:29,550
types from those validator objects.

203
00:12:29,550 --> 00:12:29,590
Okay.

204
00:12:29,590 --> 00:12:29,630
Thanks.

205
00:12:30,130 --> 00:12:30,590
Cool.

206
00:12:30,790 --> 00:12:34,380
So another example, similar to
before, what if I'm creating a

207
00:12:34,380 --> 00:12:36,350
new book in the store, right?

208
00:12:36,850 --> 00:12:40,460
So it's very similar to utility
types, but this time around we're

209
00:12:40,460 --> 00:12:42,670
doing again, the object first.

210
00:12:42,950 --> 00:12:47,340
So we already have the book
record validator object, right?

211
00:12:47,590 --> 00:12:49,740
So it has all the fields, including ID.

212
00:12:50,240 --> 00:12:55,370
Right now I can create another
object called book request.

213
00:12:56,125 --> 00:13:01,005
And I'm calling the omit method
from the, the book record object,

214
00:13:01,305 --> 00:13:05,135
and I'm just kicking the ID
field out of the thing, right?

215
00:13:05,625 --> 00:13:11,544
Then this book request, it is also a
validator object that can be used to

216
00:13:11,545 --> 00:13:16,310
validate in this case request, because
in the request, We don't want ID.

217
00:13:16,370 --> 00:13:20,260
We don't want the client
to specify an ID, right?

218
00:13:21,160 --> 00:13:26,729
And then again, we can use the infer
to infer what, infer a type for

219
00:13:26,729 --> 00:13:29,489
the book request validator object.

220
00:13:29,720 --> 00:13:33,030
And that gives us the book
request type, as expected.

221
00:13:33,550 --> 00:13:34,540
so super powerful.

222
00:13:35,040 --> 00:13:36,940
And, that's just scratching the surface.

223
00:13:36,940 --> 00:13:40,200
You, if you go through the Zot
documentation, you see a lot of

224
00:13:40,220 --> 00:13:44,760
like magical combinations, helpers,
different methods that you can use

225
00:13:44,760 --> 00:13:49,520
to, construct your validator objects
and infer type from the objects.

226
00:13:50,020 --> 00:13:50,540
That's awesome.

227
00:13:50,550 --> 00:13:51,410
so far, so good.

228
00:13:51,460 --> 00:13:55,300
What we have right now, we,
by writing the code, we.

229
00:13:55,945 --> 00:13:57,785
We have the request validator object.

230
00:13:57,805 --> 00:14:00,275
We have one for book, you
can define like many more.

231
00:14:00,335 --> 00:14:06,405
So we have the validator object as
well as, the inferred type definitions

232
00:14:06,775 --> 00:14:09,315
of the book record the book request.

233
00:14:09,515 --> 00:14:12,455
So yeah, we're about to, get there.

234
00:14:12,535 --> 00:14:19,935
We have things to validate for,
things like request, And I'm

235
00:14:19,935 --> 00:14:20,711
going to show you how to use it.

236
00:14:20,711 --> 00:14:21,786
So this is a, an API that
I'm going to show you.

237
00:14:21,786 --> 00:14:22,555
It's called drizzle.

238
00:14:22,955 --> 00:14:25,635
And it's actually this drizzle.

239
00:14:25,965 --> 00:14:28,495
it is, one of the hottest, ORM right now.

240
00:14:29,045 --> 00:14:30,885
So let's see what drizzle can do.

241
00:14:31,195 --> 00:14:33,095
So drizzle is an ORM.

242
00:14:33,105 --> 00:14:37,505
So it is supposed to be used
to work with databases, right?

243
00:14:38,005 --> 00:14:40,525
And as you can see, the API is similar.

244
00:14:40,525 --> 00:14:44,970
We're creating like a
book table, called books.

245
00:14:45,790 --> 00:14:49,000
And what should be contained
in this, book table?

246
00:14:49,030 --> 00:14:53,310
We have similar things, the ID,
the title, the other ID, right?

247
00:14:53,600 --> 00:14:58,190
And this API, it's very intuitive
because, it matches what we

248
00:14:58,190 --> 00:14:59,700
would see, in the database.

249
00:14:59,700 --> 00:15:04,465
So we specify the primary key, all the
fields are non null, I like non null.

250
00:15:04,845 --> 00:15:08,885
And, We have like different
mode for, for the types as well.

251
00:15:08,935 --> 00:15:11,705
because this could be a stream,
but we're specifying like,

252
00:15:11,705 --> 00:15:13,915
treat this as a date, right?

253
00:15:14,415 --> 00:15:14,705
Yeah.

254
00:15:14,715 --> 00:15:16,325
So that's cool.

255
00:15:16,485 --> 00:15:21,105
but it is the kind of the table
we define in the database, right?

256
00:15:21,155 --> 00:15:26,655
So yes, database can have like many
constraints, like primary key, like

257
00:15:26,655 --> 00:15:30,795
not no, but It will be a little bit
hard to do the validation, like what

258
00:15:30,795 --> 00:15:33,345
we did with ISBN on the database.

259
00:15:33,900 --> 00:15:35,120
level, right?

260
00:15:35,390 --> 00:15:35,640
Yeah.

261
00:15:35,640 --> 00:15:39,710
You can, in, in Postgres, you
may be able to, define like

262
00:15:39,710 --> 00:15:41,820
a custom type to, to do that.

263
00:15:42,010 --> 00:15:45,820
But, yeah, another way to do this,
to do the things that we add a

264
00:15:45,820 --> 00:15:48,800
validation layer for our table as well.

265
00:15:49,110 --> 00:15:54,140
So again, this is, code
snippet using drizzle and we're

266
00:15:54,140 --> 00:15:57,100
defining the table format.

267
00:15:57,600 --> 00:16:00,590
Once we have the table
format over here, right?

268
00:16:01,570 --> 00:16:03,820
That's the table format we
defined in the previous slide.

269
00:16:04,160 --> 00:16:08,910
We can also use the integration,
Drizzle and Zod, the two libraries,

270
00:16:08,910 --> 00:16:10,350
like they were very considerate.

271
00:16:10,350 --> 00:16:13,290
Drizzle made this, integration
with Zod as well, right?

272
00:16:13,510 --> 00:16:15,860
So we have the table layer, right?

273
00:16:16,070 --> 00:16:22,140
But we can also define an insert
schema that adds more validation

274
00:16:22,420 --> 00:16:24,350
before the insertion, right?

275
00:16:24,630 --> 00:16:28,935
And it will be based on the
table schema that we define.

276
00:16:29,435 --> 00:16:32,765
So again, we're using, we're
manipulating this object.

277
00:16:32,785 --> 00:16:36,325
We're using composition and
we're making them, more powerful.

278
00:16:36,335 --> 00:16:38,795
And in this case, we're building
from the ground up because we

279
00:16:38,795 --> 00:16:41,905
started at the database layer, right?

280
00:16:41,905 --> 00:16:43,475
So we define the table first.

281
00:16:43,785 --> 00:16:48,665
Once we have the table here,
we're adding validation before

282
00:16:48,665 --> 00:16:52,245
insertion for this table, right?

283
00:16:52,245 --> 00:16:53,775
So what we do here.

284
00:16:54,175 --> 00:16:59,295
is that, we specified if the ID is
not provided, the in source schema

285
00:16:59,295 --> 00:17:02,585
will do a default of UUIDV7, right?

286
00:17:03,055 --> 00:17:07,705
We also want the book title to be to
have like at least one characters, right?

287
00:17:08,265 --> 00:17:11,195
And maybe this for some reason,
the online bookstore, we care

288
00:17:11,195 --> 00:17:13,805
about books only after 2000, right?

289
00:17:13,825 --> 00:17:16,375
So it's random, but as
you can see, we can add.

290
00:17:16,875 --> 00:17:22,495
More constraint in code as the validation
layer before we do an insertion.

291
00:17:23,405 --> 00:17:27,075
Similarly, we're doing like
a regex for ISBN as well.

292
00:17:27,435 --> 00:17:33,655
And, yeah, obviously if you want to
add a, new book category in the store,

293
00:17:34,155 --> 00:17:39,505
like a new book title, we want the, we
want to have zero copy or more, right?

294
00:17:39,555 --> 00:17:40,555
Not negative.

295
00:17:40,555 --> 00:17:44,965
So stuff like this, some of them can
be done, in the database layer as well.

296
00:17:44,965 --> 00:17:50,355
But, just to show an example, we're
doing the validation, here in code.

297
00:17:50,695 --> 00:17:55,265
And again, this is the
insert schema object, right?

298
00:17:55,295 --> 00:18:00,045
And we're adding validation, but based
on the table definition that we have.

299
00:18:00,545 --> 00:18:00,945
Cool.

300
00:18:00,975 --> 00:18:04,695
yeah, this is just showing that,
something to remember that the book

301
00:18:04,735 --> 00:18:11,615
insert schema will use a default, UIDV7
and, we won't use, whatever been passed.

302
00:18:11,705 --> 00:18:15,365
And yeah, here are the validations
that I just talk about.

303
00:18:15,735 --> 00:18:17,125
we can add over here as well.

304
00:18:17,625 --> 00:18:18,015
Cool.

305
00:18:18,115 --> 00:18:22,335
So now we have the books, the
table schema definition, right?

306
00:18:22,875 --> 00:18:24,185
From the previous slide.

307
00:18:24,405 --> 00:18:27,865
And this insert schema is what
we have, from the previous slide.

308
00:18:28,365 --> 00:18:36,415
So what, so again, book insert, we
have the ID, using default UIDV7

309
00:18:36,665 --> 00:18:42,115
already, but for the book request,
for a request that is creating a

310
00:18:42,115 --> 00:18:47,760
new book title in our system, we
still don't have And the ID, right?

311
00:18:47,830 --> 00:18:48,620
So that's one thing.

312
00:18:48,950 --> 00:18:53,670
Another thing is that in the
insert schema, we're already

313
00:18:53,670 --> 00:18:58,240
specifying that the publication
date needs to be a date, right?

314
00:18:58,570 --> 00:19:02,400
But when the JSON comes
in, from the request as the

315
00:19:02,400 --> 00:19:03,940
payload, maybe it is a string.

316
00:19:04,910 --> 00:19:11,500
So what we can do is that we, again,
we operate on this object again, right?

317
00:19:11,510 --> 00:19:16,420
So based on the book insert schema,
because insert that's the last step

318
00:19:16,500 --> 00:19:19,240
already, before the insertion, right?

319
00:19:19,500 --> 00:19:23,750
So the request is what's, what
we get, from the, from HTTP, from

320
00:19:23,750 --> 00:19:26,050
the client as the payload, right?

321
00:19:26,260 --> 00:19:31,350
So what we do is that we kick
the ID field again, We also keep

322
00:19:31,350 --> 00:19:33,150
the publication date, right?

323
00:19:33,150 --> 00:19:38,590
Because in book insert schema,
this field is off type daytime,

324
00:19:38,620 --> 00:19:39,910
it's not string anymore.

325
00:19:40,570 --> 00:19:43,110
And then here we reset the key.

326
00:19:43,110 --> 00:19:47,670
This is dumb, but just show like what you
can do with, with Zod and drizzle, right?

327
00:19:47,670 --> 00:19:51,790
So we set the key back
again and we parse it.

328
00:19:52,120 --> 00:19:54,780
From the original string from the request.

329
00:19:55,010 --> 00:19:59,550
And if the parse successful, then
it turns to a date, but if it

330
00:19:59,550 --> 00:20:02,260
failed, then, we reject that, right?

331
00:20:02,420 --> 00:20:04,530
So now we have three objects.

332
00:20:05,165 --> 00:20:06,165
not types yet, right?

333
00:20:06,165 --> 00:20:11,035
So we have this books, the table
definition, we have an insert schema,

334
00:20:11,075 --> 00:20:15,295
that is what we need, what we can,
do validation before insertion.

335
00:20:15,705 --> 00:20:20,345
And we also derived like the request
schema from insertion by, kicking

336
00:20:20,345 --> 00:20:24,115
some of the fields and doing some
like transformation in here, right?

337
00:20:24,945 --> 00:20:30,295
as you can guess, now
we can infer the type.

338
00:20:30,795 --> 00:20:35,965
that from the objects from the validation
objects that we defined before right

339
00:20:35,965 --> 00:20:41,065
for book insert for book request we
can infer the type as book insert and

340
00:20:41,065 --> 00:20:45,715
book request and as you can tell as
you can guess this is equivalent to

341
00:20:46,635 --> 00:20:51,505
this if you write it by hand it has
everything it has the title but it doesn't

342
00:20:51,515 --> 00:20:54,745
have id right yeah, that's amazing.

343
00:20:55,285 --> 00:20:57,735
Let's recap again, what we have, right?

344
00:20:57,735 --> 00:21:03,665
So by doing the, by doing Zod and by
doing Drizzle with Zod, what we achieve

345
00:21:03,715 --> 00:21:06,585
is that we have two layers of validator.

346
00:21:07,420 --> 00:21:10,680
objects and their corresponding
type definitions, right?

347
00:21:10,680 --> 00:21:14,740
So one layer is for request is
like what we get from the client.

348
00:21:15,220 --> 00:21:18,650
And one layer is what
we do before insertion.

349
00:21:19,130 --> 00:21:23,450
one may argue that do you need those
like many layers of validation?

350
00:21:23,950 --> 00:21:26,910
Yeah, it will consume like some
of the computation for sure.

351
00:21:26,910 --> 00:21:30,370
But, depending on like how
paranoid you are or like you're

352
00:21:30,390 --> 00:21:31,780
the system requirement, right?

353
00:21:31,780 --> 00:21:35,250
So I do validation
everywhere when necessary.

354
00:21:35,350 --> 00:21:39,900
And this is just showing that from
the request layer down to the.

355
00:21:40,745 --> 00:21:45,335
Database layer, we all have validators
and their corresponding type

356
00:21:45,335 --> 00:21:47,805
definitions and the type definitions.

357
00:21:47,805 --> 00:21:49,025
We didn't write by hand, right?

358
00:21:49,075 --> 00:21:52,375
They're all inferred from
those validator objects.

359
00:21:52,875 --> 00:21:53,315
Cool.

360
00:21:53,545 --> 00:21:59,405
Next up, let's put this, these things that
we have into a more, into a server, right?

361
00:21:59,405 --> 00:22:03,145
So the server, library I'm
going to use is called Hono.

362
00:22:03,365 --> 00:22:07,905
And, it is, getting traction now
as well, because this framework

363
00:22:07,915 --> 00:22:10,995
uses only standard web APIs, right?

364
00:22:11,005 --> 00:22:15,535
So it runs on all the JavaScript,
TypeScript runtimes, like node,

365
00:22:15,535 --> 00:22:17,405
like DNO, like BOM, right?

366
00:22:17,415 --> 00:22:22,615
Like whole node is like right ones
run anywhere in the JavaScript,

367
00:22:22,645 --> 00:22:23,965
TypeScript runtime world.

368
00:22:24,465 --> 00:22:24,875
Awesome.

369
00:22:25,125 --> 00:22:29,575
So here is a simple, whole new
app and, it's quite intuitive.

370
00:22:29,605 --> 00:22:35,915
We create an app and we define the route
and the handlers for this app, right?

371
00:22:36,315 --> 00:22:39,615
So we have because we've been
talking about the bookstore, right?

372
00:22:39,615 --> 00:22:44,685
We have one endpoint that allows,
maybe our internal user to create

373
00:22:44,685 --> 00:22:47,055
a new book title in our system.

374
00:22:47,555 --> 00:22:53,265
So we accept it as the post method,
and we're using another yet another

375
00:22:53,265 --> 00:22:57,325
integration called the, the whole nose
odd validator integration over here.

376
00:22:57,915 --> 00:23:03,485
So what we're doing here right now is that
we use the, we're buying the validator.

377
00:23:03,795 --> 00:23:08,605
So when the request comes in, It
will validate the JSON payload using

378
00:23:08,605 --> 00:23:11,075
the book request schema, right?

379
00:23:11,715 --> 00:23:15,855
So if it doesn't pass, if it doesn't
pass, the, it doesn't have like

380
00:23:15,855 --> 00:23:21,055
enough fields, and maybe the ISBN
doesn't match the regex, it will get

381
00:23:21,105 --> 00:23:23,825
rejected before moving forward, right?

382
00:23:24,135 --> 00:23:25,525
So that's like the guard here.

383
00:23:25,835 --> 00:23:31,945
Now we feel so confident that whatever
we get out from the C request valid,

384
00:23:32,445 --> 00:23:36,395
Method is a valid book request, right?

385
00:23:36,735 --> 00:23:40,325
So again, here I'm using
the validator object.

386
00:23:40,390 --> 00:23:43,370
And I pass it to the
Zot validator for Hono.

387
00:23:43,370 --> 00:23:45,570
So it does the validation automatically.

388
00:23:46,180 --> 00:23:52,190
And here, this is the book request
that book request type that we

389
00:23:52,220 --> 00:23:58,560
inferred from the book request
schema validator object, right?

390
00:23:58,560 --> 00:24:01,810
This is quite amazing
because we do the validation.

391
00:24:02,310 --> 00:24:03,940
This is just an object, right?

392
00:24:03,940 --> 00:24:09,470
It's just like a validator object, but
we can know that after the validation

393
00:24:09,470 --> 00:24:14,460
is done, we should get a valid object
called, validate the request and it

394
00:24:14,470 --> 00:24:18,430
has to be of this inferred type, right?

395
00:24:18,930 --> 00:24:19,200
Cool.

396
00:24:19,220 --> 00:24:21,450
So that's the request validation layer.

397
00:24:21,750 --> 00:24:25,340
And moving along, we can,
this is automatic, right?

398
00:24:25,340 --> 00:24:29,760
But before insertion, if you're
paranoid, you can use the book

399
00:24:29,820 --> 00:24:34,600
insert schema validator object
to parse this request again.

400
00:24:34,960 --> 00:24:36,120
Remember what this does?

401
00:24:36,470 --> 00:24:38,650
This actually adds the UUID.

402
00:24:39,115 --> 00:24:40,875
for the ID field, right?

403
00:24:40,875 --> 00:24:44,465
Because in the book request,
we don't have that, right?

404
00:24:44,465 --> 00:24:49,715
But for the book insert
type, we have the ID, right?

405
00:24:49,725 --> 00:24:54,835
So yeah, you can say that it is a
parse or a validate, but it's not.

406
00:24:55,115 --> 00:24:58,325
Yeah, it does the, yeah,
it does the validation we

407
00:24:58,325 --> 00:25:01,115
defined for the insert schema.

408
00:25:01,115 --> 00:25:05,605
And one of the things that it does is
to add the UID field there as well.

409
00:25:06,105 --> 00:25:06,415
Cool.

410
00:25:06,615 --> 00:25:10,785
So here I'm not actually doing the
insertion, but you have to grasp, right?

411
00:25:11,285 --> 00:25:11,645
Cool.

412
00:25:11,735 --> 00:25:17,385
So this is the one endpoint server app
that we built and it's folded, right?

413
00:25:17,675 --> 00:25:19,475
So what else we can do?

414
00:25:19,545 --> 00:25:24,515
I talk about the validation and the
request layer and the database layer, but

415
00:25:24,535 --> 00:25:26,035
we're talking about full stack, right?

416
00:25:26,535 --> 00:25:28,365
So that's for this code here as well.

417
00:25:28,615 --> 00:25:34,555
What we can do is that we can actually
export a type and we just directly

418
00:25:34,555 --> 00:25:40,380
call the type of function on the route
that we defined for our application.

419
00:25:40,380 --> 00:25:44,240
In this case, we have only one
endpoint and it needs to, it

420
00:25:44,260 --> 00:25:50,600
accept a request that conforms with
the book request schema, right?

421
00:25:50,850 --> 00:25:54,960
So we can export this type
and that's the server side.

422
00:25:55,460 --> 00:26:01,310
On the client side, Hono also provides
this tool where, this is the server type

423
00:26:01,330 --> 00:26:04,570
we import, from the export over here.

424
00:26:05,130 --> 00:26:09,100
And then Hono also provides
you a client, right?

425
00:26:09,880 --> 00:26:14,950
And with those two things, what we can
do is that we can use this Hono client.

426
00:26:15,945 --> 00:26:20,005
And we specify by using the
angle brackets, the server

427
00:26:20,005 --> 00:26:21,915
type, we just export it.

428
00:26:22,605 --> 00:26:24,215
And then we give it an endpoint.

429
00:26:24,275 --> 00:26:27,735
In this case, the server
was running here, right?

430
00:26:27,735 --> 00:26:28,585
So 3000.

431
00:26:28,585 --> 00:26:31,445
So we specify the endpoint here as well.

432
00:26:32,065 --> 00:26:39,135
What we get this client is a strong
type strongly typed client, right?

433
00:26:39,445 --> 00:26:42,895
It knows that it has
endpoints like dark books.

434
00:26:43,400 --> 00:26:45,520
And you can call post on that.

435
00:26:46,020 --> 00:26:48,990
And, this endpoint only
accept a JSON like this.

436
00:26:49,000 --> 00:26:53,440
So if I make any mistakes, say
if I mistyped, I'm using the S

437
00:26:54,000 --> 00:26:59,210
I'm using a get, or I'm, using a
different field name or whatever.

438
00:27:00,165 --> 00:27:04,485
From a type perspective, it
will immediately know that

439
00:27:04,495 --> 00:27:06,185
I made a mistake, right?

440
00:27:06,595 --> 00:27:13,245
Because again, this type is inferring,
like from the server, like what

441
00:27:13,265 --> 00:27:15,785
I can do, it is that powerful.

442
00:27:16,335 --> 00:27:21,725
So if you code this, from your server
side, switching to client side, all the

443
00:27:21,725 --> 00:27:26,285
validations we just built, you feel so
confident building applications, right?

444
00:27:26,785 --> 00:27:28,315
And again, let's recap.

445
00:27:28,625 --> 00:27:33,485
So before we have this, we have the
request validator object, we have the

446
00:27:33,495 --> 00:27:38,455
record, the before insert validator object
and their corresponding types, right?

447
00:27:38,455 --> 00:27:42,455
And it talks to say your primary
database Postgres in this case.

448
00:27:43,235 --> 00:27:47,015
Now we also have a front
end client object, this guy,

449
00:27:47,515 --> 00:27:49,305
which is also strongly typed.

450
00:27:49,685 --> 00:27:54,770
And he knows like which methods, which
endpoints, It is allowed to call and

451
00:27:54,770 --> 00:27:56,840
what kind of objects you need to pass in.

452
00:27:57,750 --> 00:27:59,950
So yeah, it is that powerful.

453
00:28:00,450 --> 00:28:00,790
Cool.

454
00:28:00,900 --> 00:28:04,740
So since I'm working with dragonfly,
I wonder if, there's such a thing

455
00:28:04,740 --> 00:28:09,350
for cash as well, because we have to
request and, we do the validation and

456
00:28:09,350 --> 00:28:12,550
before insertion, we do the validation
and it goes to the primary database.

457
00:28:12,620 --> 00:28:17,780
What about, what if like we need to cash
some of the data and does it have some

458
00:28:17,780 --> 00:28:19,290
sort of things that's similar as well?

459
00:28:19,840 --> 00:28:22,260
it turns out that we have library, called.

460
00:28:22,570 --> 00:28:28,360
Redis OM, and it is an object mapper
for, in memory data stores like,

461
00:28:28,380 --> 00:28:31,650
Redis, but because Dragonfly is
compatible with Redis, you can use

462
00:28:31,650 --> 00:28:33,360
this library with Dragonfly as well.

463
00:28:33,890 --> 00:28:38,930
But unfortunately, yeah, we can define
schema very similarly, but unfortunately,

464
00:28:38,930 --> 00:28:41,080
we don't have integrations with libraries.

465
00:28:41,080 --> 00:28:43,650
We like Zod at the moment, yet.

466
00:28:43,790 --> 00:28:45,690
So with that said, we can still.

467
00:28:46,190 --> 00:28:51,840
Define a schema and you can do it stores
the data as the Jason data type, in ready.

468
00:28:51,890 --> 00:28:56,210
readies uses modules to support
things like Jason search time

469
00:28:56,210 --> 00:28:57,650
series and those kinds of stuff.

470
00:28:57,990 --> 00:29:01,850
Whereas in dragonfly, Jason
and search are native building.

471
00:29:01,860 --> 00:29:04,720
So you don't need to install
additional modules on dragonfly.

472
00:29:04,720 --> 00:29:10,630
back here, RedisOM is, can be used to
manipulate the JSON type, not the string

473
00:29:10,630 --> 00:29:13,960
type, in, in Dragonfly or in Redis, right?

474
00:29:14,730 --> 00:29:19,890
yeah, so we don't have the validation
integration yet, but I would

475
00:29:19,900 --> 00:29:21,700
argue that, this is also good.

476
00:29:22,055 --> 00:29:24,365
and also sometimes you
don't really need to.

477
00:29:24,505 --> 00:29:28,795
So you need to use like the JSON type
in Redis or in Dragonfly when you need

478
00:29:28,805 --> 00:29:30,705
to manipulate those individual fields.

479
00:29:30,705 --> 00:29:35,395
But if you're doing like a cache, if you
don't care about modifying individual

480
00:29:35,395 --> 00:29:40,185
fields, then the string data type of
Dragonfly might be the way to go as well.

481
00:29:40,275 --> 00:29:45,395
I would argue that So yeah, depending
on your use case, I feel that,

482
00:29:45,495 --> 00:29:50,775
the strongly typed and validated
thing, like across the client down

483
00:29:50,775 --> 00:29:52,505
to the primary database is enough.

484
00:29:52,795 --> 00:29:55,895
The caching layer, we don't have
such a thing yet, it's, it's a

485
00:29:55,895 --> 00:29:57,395
good to have maybe in the future.

486
00:29:57,715 --> 00:29:59,335
And, you can also cache your.

487
00:29:59,975 --> 00:30:03,605
your data as a blob, in a string
data type of Dragonfly as well.

488
00:30:04,305 --> 00:30:10,955
So with that, you have a quite strong
and safe and typed and validated,

489
00:30:11,845 --> 00:30:17,435
safety from your client side to the
server side and then to your data layer

490
00:30:17,535 --> 00:30:19,785
like Dragonfly or Postgres, right?

491
00:30:20,285 --> 00:30:20,675
Cool.

492
00:30:20,845 --> 00:30:25,635
So yeah, if I work in code base like
this, at the beginning, it's a little

493
00:30:25,775 --> 00:30:29,505
bit harder because you're always
thinking about the validator objects.

494
00:30:29,555 --> 00:30:34,075
And then, you use the infer function
to get the type definitions as well.

495
00:30:34,545 --> 00:30:40,505
But later on, you feel so confident
because you know that your code wouldn't.

496
00:30:40,885 --> 00:30:42,855
Like they're always validated, right?

497
00:30:43,195 --> 00:30:47,775
And you can't have a mistake by passing
an object that has a missing value that

498
00:30:47,775 --> 00:30:51,165
will be caught at the type level, right?

499
00:30:51,195 --> 00:30:53,995
if you're doing such a thing, cool.

500
00:30:54,165 --> 00:30:58,225
yeah, those are the tools that I
want to share with you and introduce.

501
00:30:58,830 --> 00:31:03,600
to you today, and, just to, maybe you've
heard like other solutions, as well,

502
00:31:03,620 --> 00:31:07,920
things like GraphQL and Swagger, so what's
the difference between the things, right?

503
00:31:08,230 --> 00:31:11,490
to me, GraphQL, Swagger,
they're awesome tools as well.

504
00:31:11,730 --> 00:31:14,700
And if you're using like
multiple languages, they help.

505
00:31:14,960 --> 00:31:19,230
But given the fact that it uses a
DSL, so they have like their own

506
00:31:19,240 --> 00:31:20,960
domain specific languages, right?

507
00:31:21,260 --> 00:31:23,750
So you need a way to work with them.

508
00:31:24,000 --> 00:31:28,230
Work with the GraphQL, schema, work
with your like Swagger schema and

509
00:31:28,240 --> 00:31:30,570
maybe do some code generation, right?

510
00:31:30,760 --> 00:31:34,540
Whereas in our case, we didn't use a DSL.

511
00:31:34,540 --> 00:31:37,610
So that's one less thing to worry about.

512
00:31:38,110 --> 00:31:41,960
Another alternative is maybe you've
also heard of is called TRPC.

513
00:31:42,240 --> 00:31:45,960
it can do the client
server type safety as well.

514
00:31:46,430 --> 00:31:50,420
but compared to the tools that
I introduced, one drawback of

515
00:31:50,650 --> 00:31:55,110
TRPC is that it doesn't, expose
a standard HTTP API, right?

516
00:31:55,440 --> 00:32:01,390
So what we use like whole node backend,
it still uses the standard HTTP API.

517
00:32:01,390 --> 00:32:06,205
So if you're the only consumer of your
API, then TRPC might be a better solution,

518
00:32:06,205 --> 00:32:11,405
but, in the future, if you anticipate
other people to consume your API as well,

519
00:32:11,765 --> 00:32:17,515
then you know, our way could be better
because, you as the consumer, you still

520
00:32:17,515 --> 00:32:23,765
have the full type safety, whereas other
consumers need to look at your, your API

521
00:32:23,765 --> 00:32:26,345
specification and code accordingly, right?

522
00:32:26,845 --> 00:32:27,315
Cool.

523
00:32:27,355 --> 00:32:32,815
With that said, yeah, I think that's a
small, simple example, but we did indeed,

524
00:32:33,195 --> 00:32:35,235
achieved full stack type safety today.

525
00:32:35,655 --> 00:32:41,065
And, yeah, please try those
awesome tools, you JSTS community.

526
00:32:41,065 --> 00:32:41,615
I love them.

527
00:32:42,335 --> 00:32:46,565
And then finally, if you're
interested in doing in memory data,

528
00:32:46,905 --> 00:32:51,475
like caching, like real time stats,
give Dragonfly a try as well.

529
00:32:51,695 --> 00:32:55,435
yeah, it's a great, awesome
project, very strong, very modern,

530
00:32:55,515 --> 00:32:57,635
multi threaded, Redis alternative.

531
00:32:58,055 --> 00:33:00,885
And here's my QR code of my LinkedIn.

532
00:33:00,885 --> 00:33:04,325
If you're want to get connected
with me, feel free as well.

533
00:33:04,835 --> 00:33:05,695
Thank you so much.

