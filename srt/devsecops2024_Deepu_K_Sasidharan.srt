1
00:00:00,200 --> 00:00:00,800
Hello, friends.

2
00:00:00,830 --> 00:00:02,009
thanks for joining my talk.

3
00:00:02,240 --> 00:00:05,310
let's see how we can master
Kubernetes, security.

4
00:00:05,740 --> 00:00:06,159
I'm Deepu K.

5
00:00:06,160 --> 00:00:07,050
Shashidharan.

6
00:00:07,089 --> 00:00:09,020
I'm a staff developer advocate at Okta.

7
00:00:09,479 --> 00:00:12,470
I'm also an open source, enthusiast
and a polycloud developer.

8
00:00:12,530 --> 00:00:14,829
I co lead the Jhipster project.

9
00:00:14,830 --> 00:00:17,790
I have built a Kubernetes
dashboard called Kdash.

10
00:00:18,270 --> 00:00:21,330
you can, find out more about
me on my website, deepu.

11
00:00:21,380 --> 00:00:24,470
tech, or you can find me
on BlueSky at, deepu105.

12
00:00:24,970 --> 00:00:26,870
So let's, get into the talk.

13
00:00:27,370 --> 00:00:31,149
So before we talk about, security best
practices in Kubernetes, I think it

14
00:00:31,150 --> 00:00:34,749
is important for us to have a basic
understanding of Kubernetes security.

15
00:00:34,750 --> 00:00:38,240
Like any other complex piece of software,
security in Kubernetes is multifold.

16
00:00:38,720 --> 00:00:41,210
So it can be broadly
categorized into four layers.

17
00:00:41,710 --> 00:00:46,280
so first we have, the transport layer
security, which is insured using, TLS.

18
00:00:46,460 --> 00:00:50,390
So all a p communication is done via
TLS using valid certificates that

19
00:00:50,390 --> 00:00:52,030
forms the base layer of security.

20
00:00:52,530 --> 00:00:56,160
Then we have the authentication layer,
and there is a flexible authentication

21
00:00:56,160 --> 00:00:59,940
layer with multiple supported mechanisms,
including open id, connect, token

22
00:00:59,955 --> 00:01:01,500
based authentication, and so on.

23
00:01:01,950 --> 00:01:04,800
So all a PA requests are
authenticated with one of these,

24
00:01:04,815 --> 00:01:06,315
several authentication mechanism.

25
00:01:06,815 --> 00:01:08,425
Then we have the authorization layer.

26
00:01:08,745 --> 00:01:12,715
And, again, all authenticated requests
are authorized using one or more of

27
00:01:12,735 --> 00:01:14,695
the supported, authorization models.

28
00:01:15,025 --> 00:01:17,305
We'll talk a little bit
more about this, later on.

29
00:01:17,805 --> 00:01:21,965
And finally, we also have a possibility
of adding custom admission control

30
00:01:22,095 --> 00:01:24,045
modules to further lockdown access.

31
00:01:24,265 --> 00:01:28,615
which means all authorized requests,
except read and get requests, are also

32
00:01:28,615 --> 00:01:30,135
validated by admission control modules.

33
00:01:30,635 --> 00:01:35,855
So Kubernetes comes with many security
options out of the box, but to bulletproof

34
00:01:35,855 --> 00:01:38,705
your infrastructure, you need to consider
many more security best practices.

35
00:01:39,415 --> 00:01:42,275
Today, we look into some of the
vital security best practices.

36
00:01:42,325 --> 00:01:45,905
You can also find a blog post
from me, with this content

37
00:01:45,945 --> 00:01:46,985
on the link provided here.

38
00:01:47,775 --> 00:01:51,300
Most of the security best practices,
are not enabled by default.

39
00:01:51,300 --> 00:01:53,020
So you would have to do this yourself.

40
00:01:53,060 --> 00:01:56,240
And, most of these, are
extremely important.

41
00:01:56,340 --> 00:01:58,420
So let's, get in and see what they are.

42
00:01:58,920 --> 00:02:01,730
first and foremost would be using RBAC.

43
00:02:02,230 --> 00:02:05,560
Kubernetes supports multiple,
authorization models for its, API server.

44
00:02:06,000 --> 00:02:08,820
so we have, ABAC or Attribute
Based Access Control.

45
00:02:08,860 --> 00:02:10,970
We have RBAC or Role Based Access Control.

46
00:02:10,990 --> 00:02:13,580
We have Node Authorization and Web Mode.

47
00:02:13,970 --> 00:02:17,670
out of all these, RBAC, I would
say, is the, most, secure option.

48
00:02:18,170 --> 00:02:22,330
It's also the most widely used, option
and it is ideal for enterprises and

49
00:02:22,340 --> 00:02:24,560
large to, medium to large organizations.

50
00:02:25,000 --> 00:02:29,040
So with the role based access
control, you can define, a control

51
00:02:29,050 --> 00:02:32,270
structure that closely resembles
your organization's business rules

52
00:02:32,270 --> 00:02:33,419
or access structure that you have.

53
00:02:33,589 --> 00:02:35,019
based on business, rules.

54
00:02:35,519 --> 00:02:39,989
So RBAC also works great with, OIDC
authentication, and it is easier to

55
00:02:39,989 --> 00:02:42,559
manage if you have, an OIDC provider.

56
00:02:42,609 --> 00:02:44,259
RBAC makes it easier as well.

57
00:02:44,569 --> 00:02:47,179
using RBAC would be the number
one, security best practice.

58
00:02:47,679 --> 00:02:50,999
So most Kubernetes distributions
have RBAC enabled by default.

59
00:02:51,299 --> 00:02:54,539
So you can check this by running
the kubectl command, kubectl cluster

60
00:02:54,539 --> 00:02:57,509
info dump, and then look for the
authorization mode, in the output.

61
00:02:58,249 --> 00:03:01,699
ideally, it should show
authorization mode equals RBAC.

62
00:03:02,124 --> 00:03:04,704
if not, you can enable it
using the, authorization mode

63
00:03:04,724 --> 00:03:08,554
flag for the API server, while
creating or patching the cluster.

64
00:03:09,044 --> 00:03:13,114
For example, setting the authorization
mode, flag to RBAC comma node

65
00:03:13,474 --> 00:03:16,844
will enable both RBAC and node
authorization on the cluster.

66
00:03:17,634 --> 00:03:21,754
Once RBAC is enabled, you can
create, roles, and, role bindings

67
00:03:21,764 --> 00:03:24,924
for either, role or cluster role, or
role binding or cluster role binding

68
00:03:25,314 --> 00:03:26,954
to control access to your resources.

69
00:03:27,454 --> 00:03:30,484
Here's an example of a role
and role binding that lets

70
00:03:30,484 --> 00:03:32,434
users view ports and services.

71
00:03:32,854 --> 00:03:35,554
I would recommend checking out
the Kubernetes documentation on

72
00:03:35,554 --> 00:03:37,104
our back for, for the learning.

73
00:03:37,384 --> 00:03:39,384
this is a very simple ex, example.

74
00:03:39,384 --> 00:03:42,664
You can do much more with,
role and, role bindings.

75
00:03:42,944 --> 00:03:47,535
you can, control, who has access
to what, on a namespace, level or

76
00:03:47,545 --> 00:03:49,375
at the resource level, for example.

77
00:03:49,875 --> 00:03:54,325
So next security best practice would be
to use OpenID Connect for authentication.

78
00:03:54,635 --> 00:03:56,765
So Kubernetes supports many
authentication mechanisms.

79
00:03:56,805 --> 00:03:59,395
Some of the most common ones are
like client certificate based

80
00:03:59,395 --> 00:04:03,085
authentication, basic authentication,
token based like service account

81
00:04:03,095 --> 00:04:07,055
tokens, bearer tokens, and so on,
proxy based authentication, and finally

82
00:04:07,055 --> 00:04:08,605
OpenID Connect based authentication.

83
00:04:09,105 --> 00:04:13,005
So out of all these authentication
mechanisms, OpenID Connect or OIDC is

84
00:04:13,005 --> 00:04:14,705
the most secure and scalable solution.

85
00:04:15,185 --> 00:04:19,225
So it is ideal for clusters accessed
by large teams as it provides a single

86
00:04:19,225 --> 00:04:23,135
sign on solution for all users and makes
it easy to onboard and offboard users.

87
00:04:23,645 --> 00:04:26,605
It is also way more secure than
other mechanisms as you don't

88
00:04:26,615 --> 00:04:29,765
have to store any sensitive
information on a user's computer,

89
00:04:29,985 --> 00:04:30,885
like client secrets and passwords.

90
00:04:31,715 --> 00:04:36,435
You can also use, advanced features like
multifactor authentication, pass keys,

91
00:04:36,465 --> 00:04:41,725
hardware, tokens, like UB keys, et cetera,
as most of IDC providers would be, might

92
00:04:41,725 --> 00:04:43,345
be supporting, these features as well.

93
00:04:43,825 --> 00:04:48,085
and YDC with R Bag gives you powerful
access control that can be managed in,

94
00:04:48,140 --> 00:04:50,520
Identity systems like Auth0 or Okta.

95
00:04:50,790 --> 00:04:54,190
for example, if you are using,
OpenID Connect along with, Okta, or

96
00:04:54,240 --> 00:04:57,070
Auth0, for your Kubernetes cluster,
you might, you will be able to use

97
00:04:57,080 --> 00:05:00,080
all the advanced security features
provided by these platforms.

98
00:05:00,080 --> 00:05:04,270
You would be able to configure, and
manage users in these systems instead of,

99
00:05:04,880 --> 00:05:06,430
meddling with the Kubernetes installation.

100
00:05:06,690 --> 00:05:09,880
You'll be able to manage your
RBAC setup, with these platforms.

101
00:05:10,180 --> 00:05:13,750
So it gives you a lot more flexibility
and it is ideal for larger teams.

102
00:05:14,250 --> 00:05:16,850
Here is how UIDC works with communities.

103
00:05:17,700 --> 00:05:22,990
When you run a command with, cube, CTL, it
uses, cube login, and opens a browser to

104
00:05:22,990 --> 00:05:25,000
authenticate you with your OIDC provider.

105
00:05:25,280 --> 00:05:29,930
once, you authenticate, with your YDC
provider, let's say, or zero in this case,

106
00:05:30,450 --> 00:05:35,070
you will get, authentication response, and
the odd response, the, the cube login will

107
00:05:35,070 --> 00:05:36,690
get no author response, from the browser.

108
00:05:36,930 --> 00:05:41,060
It'll then use that, response to make
a token request to your application

109
00:05:41,060 --> 00:05:43,250
server to get a access token.

110
00:05:43,550 --> 00:05:47,870
And then it'll use that, it'll
pass that access token to Cube CTL,

111
00:05:48,140 --> 00:05:52,975
which can use that token to make,
a PA requests here Banes cluster.

112
00:05:53,335 --> 00:05:57,520
This makes the entire, setup extremely
secure and, easy to, control.

113
00:05:58,020 --> 00:06:00,960
If you are interested in setting
this up, you can check out this blog

114
00:06:00,960 --> 00:06:03,110
post that I wrote some while ago.

115
00:06:03,830 --> 00:06:07,580
It shows how to set up OpenID
Connect on a Kubernetes cluster

116
00:06:07,580 --> 00:06:10,270
and how to use Okta to manage this.

117
00:06:10,375 --> 00:06:13,755
one of the most often overlooked aspects
of security in Kubernetes is secrets.

118
00:06:13,755 --> 00:06:17,965
And that's why, next best practice
would be to use secure secrets.

119
00:06:18,365 --> 00:06:20,865
So many don't set up proper
secret management and end up

120
00:06:20,865 --> 00:06:24,315
using stock Kubernetes secrets,
which are not technically secrets.

121
00:06:24,450 --> 00:06:27,460
because, the default Kubernetes
secret is nothing but, plain text,

122
00:06:27,460 --> 00:06:29,960
resource, with, base64 encoded strings.

123
00:06:30,130 --> 00:06:33,690
And base64 encoded is
not same as encrypted.

124
00:06:33,720 --> 00:06:38,540
So your secrets are in plain text
and anyone, can, decode base64.

125
00:06:38,590 --> 00:06:41,830
And you don't need any, private
keys or anything to decode base64,

126
00:06:42,010 --> 00:06:43,110
because it's not encrypted.

127
00:06:43,610 --> 00:06:46,990
which means you can't store them in your
version control, making GitOps difficult.

128
00:06:47,390 --> 00:06:50,160
And you will end up resorting
to environmental variables and

129
00:06:50,160 --> 00:06:52,560
stuff like that, unnecessarily
complicating your setup.

130
00:06:52,830 --> 00:06:55,950
Even worse would be accidental commit
of secret definitions, along with

131
00:06:55,980 --> 00:06:59,990
Kubernetes manifest to public Git
repos in case of open source software

132
00:07:00,010 --> 00:07:01,540
or source available, projects.

133
00:07:01,680 --> 00:07:08,740
And other disadvantages are that
Kubernetes secrets does not work

134
00:07:08,740 --> 00:07:10,030
with external secret managers.

135
00:07:10,530 --> 00:07:13,670
we have, multiple options,
here, to work around this issue.

136
00:07:14,010 --> 00:07:16,600
one of the option would be
to use a sealed secrets.

137
00:07:16,940 --> 00:07:21,670
sealed secrets are simplest to use as
it, encrypts, the secrets on developer

138
00:07:21,670 --> 00:07:25,320
machine, which can be decrypted only
by the cluster when it, will be used.

139
00:07:25,630 --> 00:07:28,910
This makes it possible to store, the
secrets along with other data in your

140
00:07:28,950 --> 00:07:30,430
version control as they are encrypted.

141
00:07:30,700 --> 00:07:32,660
This is ideal for smaller
setups and smaller teams.

142
00:07:33,160 --> 00:07:35,050
Here is how it will work.

143
00:07:35,050 --> 00:07:37,540
So you deploy a seal secret, controller.

144
00:07:38,330 --> 00:07:42,520
In your, cluster, the controller
generates a private public key pair.

145
00:07:42,770 --> 00:07:46,650
the developer, has access to,
developer can get the public key out

146
00:07:46,650 --> 00:07:48,870
of, this, generally extracted out.

147
00:07:49,450 --> 00:07:52,320
the private key is kept,
secret and, you should, have

148
00:07:52,320 --> 00:07:54,090
proper RBAC on this, resources.

149
00:07:54,270 --> 00:07:55,410
So that's not exposed.

150
00:07:56,230 --> 00:07:58,770
the developer then uses
the public key extracted.

151
00:07:59,265 --> 00:08:02,525
from the cluster to encrypt
any sensitive, data, in their

152
00:08:02,535 --> 00:08:05,155
machine using the kubeseal CLI.

153
00:08:05,585 --> 00:08:09,795
for example, if you have a secret YAML,
you can, encrypt that using this public

154
00:08:09,795 --> 00:08:12,315
key and make it into seal secret, YAML.

155
00:08:12,365 --> 00:08:14,825
the encrypted sealed secret
resource can now be committed

156
00:08:14,825 --> 00:08:15,875
and deployed to the server.

157
00:08:16,085 --> 00:08:16,685
to the cluster.

158
00:08:17,025 --> 00:08:18,195
the sealed secret controller.

159
00:08:18,355 --> 00:08:21,095
so when you, this is where you
will put it in the git repository.

160
00:08:21,095 --> 00:08:23,435
It is safe because it is encrypted now.

161
00:08:23,725 --> 00:08:26,375
when you apply or deploy
this to your cluster.

162
00:08:26,610 --> 00:08:30,550
the sealed secret controller will,
scan for any sealed secrets and when it

163
00:08:30,730 --> 00:08:36,350
detects one, it will use the private key,
stored on the sealed secret controller

164
00:08:36,490 --> 00:08:40,770
to decrypt the sealed secret and it
will create a normal Kubernetes secret

165
00:08:40,850 --> 00:08:43,380
with the, basics differ encoded, secret.

166
00:08:43,880 --> 00:08:45,670
It's simple and effective mechanism.

167
00:08:45,700 --> 00:08:49,680
Of course, you would still need RBAC to
restrict access to the created Kubernetes

168
00:08:49,680 --> 00:08:51,160
secrets on the cluster and so on.

169
00:08:51,490 --> 00:08:54,850
But at least this solves the
issue of not being able to

170
00:08:55,600 --> 00:08:59,860
commit your Git repo and so on.

171
00:09:00,090 --> 00:09:03,410
So at least until it reaches the
cluster, everything is encrypted.

172
00:09:04,310 --> 00:09:08,260
So this is simpler to set up and
this will work fine for smaller

173
00:09:08,300 --> 00:09:09,730
teams and for smaller projects.

174
00:09:10,230 --> 00:09:13,990
for bigger teams and projects, a better
solution is to use external secret

175
00:09:13,990 --> 00:09:15,710
operator, secrets operator, or ESO.

176
00:09:16,160 --> 00:09:20,080
So ESO lets you use external secret
managers like Hershey Cobb Vault, Google

177
00:09:20,080 --> 00:09:22,300
or AWS secret managers, Azure so on.

178
00:09:23,130 --> 00:09:26,620
So it can keep secrets synced with
the external manager and provide

179
00:09:26,620 --> 00:09:28,790
support for most of the well
known external secret managers.

180
00:09:29,330 --> 00:09:33,280
It's a bit more tedious to set up than
seal secrets, but it is worth for it, for

181
00:09:33,280 --> 00:09:35,150
the security and flexibility it offers.

182
00:09:35,450 --> 00:09:39,510
And this is also ideal for, bigger teams
as, seal secret requires individual

183
00:09:39,560 --> 00:09:44,070
developers to use the CLI to, create
the encrypted, seal secret and so on.

184
00:09:44,670 --> 00:09:48,610
and, yeah, and it's not that
scalable, whereas, external secret

185
00:09:48,610 --> 00:09:50,570
operator, have more flexibility.

186
00:09:50,570 --> 00:09:51,375
Let's see how it works.

187
00:09:51,875 --> 00:09:56,585
you deploy the, external secrets operator
on the cluster and, you, will generally

188
00:09:56,585 --> 00:10:00,075
create a secret store to define external
secret managers, connection details,

189
00:10:00,075 --> 00:10:04,165
like how you can connect to this and so
on, or what mechanism you will connect

190
00:10:04,205 --> 00:10:05,710
to the external secret store and so on.

191
00:10:05,930 --> 00:10:06,540
Stuff like that.

192
00:10:07,230 --> 00:10:10,510
you will, you can now create your
secrets in, in the external service,

193
00:10:10,510 --> 00:10:12,140
like for example, Vault, for example.

194
00:10:12,760 --> 00:10:16,370
now you create an external secret
resource, yaml file basically that

195
00:10:16,370 --> 00:10:18,240
defines what secrets to fetch from Vault.

196
00:10:18,260 --> 00:10:22,440
You won't define any sensitive data
here, you'll only define which data to

197
00:10:22,440 --> 00:10:24,470
fetch from your external secret manager.

198
00:10:24,685 --> 00:10:28,275
this can, so this files can be
committed to git as it does not

199
00:10:28,285 --> 00:10:29,705
have any sensitive information.

200
00:10:29,735 --> 00:10:33,305
So you can commit them
freely in git repose.

201
00:10:33,305 --> 00:10:36,535
and when you deploy this to the
cluster, the external secrets, so

202
00:10:36,535 --> 00:10:39,965
when you deploy this, the external
secret operator will be watching for

203
00:10:39,965 --> 00:10:41,465
any external secrets on the cluster.

204
00:10:41,940 --> 00:10:45,940
And it will, once it gets that, it will
use the secret source information and it

205
00:10:45,940 --> 00:10:50,190
will fetch the appropriate, sensitive data
from your external, secret manager vault.

206
00:10:50,610 --> 00:10:53,580
And it will create a normal
Kubernetes secret on the,

207
00:10:54,010 --> 00:10:55,940
cluster for the pods to access.

208
00:10:56,440 --> 00:10:59,960
again, you would have to define
RBAC and, so on to secure this.

209
00:11:00,505 --> 00:11:04,745
Because in the end, both these options
still use kubernetes secret and it

210
00:11:04,745 --> 00:11:09,705
has the same issues as kubernetes
secret being, base64 encoded string.

211
00:11:09,935 --> 00:11:16,235
But at least this is quite secure on
the, secure outside the cluster, like

212
00:11:16,385 --> 00:11:17,950
putting it in a git repository and so on.

213
00:11:17,950 --> 00:11:20,980
this is a good option for bigger
teams, and it's easier to manage

214
00:11:20,980 --> 00:11:25,120
secrets in a vault, setup like
an external secret manager, so it

215
00:11:25,210 --> 00:11:26,840
gives you much more flexibility.

216
00:11:26,940 --> 00:11:30,380
Of course, you would still, you have to
use RBAC and all other best practices

217
00:11:30,380 --> 00:11:34,680
here, but it's a better option compared
to sealed secrets or regular secrets.

218
00:11:35,180 --> 00:11:37,780
Another option is to use,
secret Store CSI driver.

219
00:11:37,930 --> 00:11:40,960
It's a native Kubernetes driver
and it lets you use, external

220
00:11:40,960 --> 00:11:43,440
secret managers, similar to ESO.

221
00:11:43,750 --> 00:11:48,555
so you can use Hashi wall, Google, AWS,
secret managers keywords and so on.

222
00:11:49,045 --> 00:11:51,385
so it uses a platform
authentication mechanism.

223
00:11:51,815 --> 00:11:54,455
it can also keep secret synced
with external manager and

224
00:11:54,455 --> 00:11:55,775
supports rotation and so on.

225
00:11:55,830 --> 00:11:58,650
it has providers for most of the
well known external secret managers

226
00:11:58,690 --> 00:12:02,470
and the CSI driver is the most
secure solution, and also the, but

227
00:12:02,470 --> 00:12:03,940
also the most tedious to set up.

228
00:12:04,640 --> 00:12:05,575
let's see how it works.

229
00:12:05,575 --> 00:12:09,735
you deploy the, the driver and external
secrets provider on the cluster.

230
00:12:09,855 --> 00:12:12,985
so generally, depending on the provider
you use, you would have to, deploy

231
00:12:12,985 --> 00:12:16,405
the specific provider, driver for the
specific provider as well on the cluster.

232
00:12:16,945 --> 00:12:18,655
this works at the APA server level.

233
00:12:18,705 --> 00:12:20,995
hence, this is not going to
create any actual issues.

234
00:12:21,210 --> 00:12:22,220
Kubernetes secrets here.

235
00:12:22,220 --> 00:12:25,510
So this is a slightly more secure option.

236
00:12:26,320 --> 00:12:30,470
so you can create a secret provider class,
CRD to define the details of the secret

237
00:12:30,470 --> 00:12:32,520
to be fetched from the secret manager.

238
00:12:33,020 --> 00:12:35,210
next you will create your
normal, deployments and

239
00:12:35,210 --> 00:12:36,300
pod definitions, et cetera.

240
00:12:36,340 --> 00:12:39,540
And here you will define, you
will, reference the SecretProvider

241
00:12:39,540 --> 00:12:41,440
class in the pods volume spec.

242
00:12:41,940 --> 00:12:45,950
when you deploy this, when you deploy
this, the driver will watch, for this.

243
00:12:45,950 --> 00:12:49,890
And when it finds the SecretProvider
class, it will fetch the actual

244
00:12:49,900 --> 00:12:52,780
secret from the external secret
manager and it will mount that,

245
00:12:53,370 --> 00:12:56,370
into the pod tempfs volume.

246
00:12:56,740 --> 00:12:59,950
So only the particular pod, which
references the secret provider

247
00:12:59,950 --> 00:13:03,350
class will have access to that
particular secret in the pod.

248
00:13:04,150 --> 00:13:07,590
and this volume will be removed when
the pod is scheduled for deletion.

249
00:13:07,590 --> 00:13:11,460
So this is nicer as nothing is
exposed as, Kubernetes secrets.

250
00:13:11,935 --> 00:13:16,265
So that even people who have access
to read KU Secrets, will not be

251
00:13:16,265 --> 00:13:18,640
able to, decode the sensitive data.

252
00:13:18,820 --> 00:13:23,245
So this is a much, secure option and
ideal for, large projects, enterprises,

253
00:13:23,245 --> 00:13:26,195
and, very, security savvy, tips.

254
00:13:26,745 --> 00:13:29,585
if you're, If you are interested,
you can also find a blog post

255
00:13:29,625 --> 00:13:33,525
where I, detail these options
and, provide, examples and so on.

256
00:13:33,965 --> 00:13:37,085
I'll also, I also talk about all
the pros and cons of these different

257
00:13:37,085 --> 00:13:38,985
options in more details here.

258
00:13:39,165 --> 00:13:40,245
So please do check it out.

259
00:13:40,745 --> 00:13:44,435
So next, best practice would be to
keep Kubernetes version up to date.

260
00:13:44,545 --> 00:13:47,745
Of course, this should be obvious
because like any other software, like

261
00:13:47,745 --> 00:13:50,525
any software, it is important to keep the
Kubernetes version up to date as well.

262
00:13:50,525 --> 00:13:54,035
and like any other software, Kubernetes
also has bugs and issues and from

263
00:13:54,035 --> 00:13:57,695
time to time, there might be high
severity bug that calls for a CV.

264
00:13:58,155 --> 00:14:01,055
Hence, it is important to keep the
Kubernetes version up to date for,

265
00:14:01,095 --> 00:14:03,165
the server and for the CLI client.

266
00:14:03,665 --> 00:14:06,955
you can check the Kubernetes security
and disclosure information website

267
00:14:06,995 --> 00:14:10,405
to see if there are known security
bugs for your Kubernetes version.

268
00:14:10,855 --> 00:14:15,025
And if you are using a managed
pass, GKE or, AKS, it should

269
00:14:15,025 --> 00:14:16,125
be pretty easy to upgrade.

270
00:14:16,155 --> 00:14:20,765
And, for on prem installations, there are
tools like COPS, KubeAdmin, and so on.

271
00:14:20,805 --> 00:14:22,585
So that makes it easy
to upgrade, clusters.

272
00:14:22,645 --> 00:14:26,515
So use any of these available options
to keep your cluster up to date.

273
00:14:27,015 --> 00:14:29,185
next is, restricting admin access.

274
00:14:29,685 --> 00:14:32,455
So kubelet is the primary node
agent running on each node.

275
00:14:32,485 --> 00:14:35,265
And by default, a kubelet's
HTTP endpoints are not secure.

276
00:14:35,555 --> 00:14:40,375
we need to restrict access to kubelet,
the API, and, restrict SSH access.

277
00:14:41,215 --> 00:14:44,325
this could allow unintended
access if it is not, secure.

278
00:14:44,595 --> 00:14:47,895
And hence, definitely should
be, number one, on the priority.

279
00:14:48,555 --> 00:14:51,475
furthermore, when someone access to
a Kubernetes cluster, they can access

280
00:14:51,475 --> 00:14:53,395
the k, Kubernetes API server and SSH.

281
00:14:53,410 --> 00:14:55,870
So this should not be allowed.

282
00:14:55,870 --> 00:14:58,860
all non admin users should
not have API and SSH access.

283
00:14:58,860 --> 00:15:00,600
So all this should be locked up.

284
00:15:01,100 --> 00:15:04,070
to limit node access, to limit
node access, cluster access should

285
00:15:04,080 --> 00:15:05,130
be limited as much as possible.

286
00:15:05,560 --> 00:15:11,250
So disable SSH access for non admin users,
secure the API using OIDC and RBAC, have

287
00:15:11,270 --> 00:15:16,660
proper, role based access control, set
up for AROIDC setup, as we saw earlier.

288
00:15:17,055 --> 00:15:19,635
So that only authenticated
users with sufficient roles have

289
00:15:19,635 --> 00:15:21,075
access to the Kubernetes API.

290
00:15:21,575 --> 00:15:25,075
Next on our list would be to control
traffic between pods and clusters.

291
00:15:25,575 --> 00:15:28,235
So generally, pods within the
same cluster will be able to

292
00:15:28,245 --> 00:15:29,105
communicate with each other.

293
00:15:29,595 --> 00:15:32,135
And if you have multiple clusters
in the same network, there may

294
00:15:32,135 --> 00:15:33,325
be traffic between them as well.

295
00:15:34,105 --> 00:15:34,965
do not leave this all open.

296
00:15:35,095 --> 00:15:38,785
in most cases, you don't want different
clusters to be talking to each other.

297
00:15:39,045 --> 00:15:41,815
And in most cases, You don't want
pods to be talking to each other

298
00:15:41,815 --> 00:15:44,605
unless you have a microservice setup.

299
00:15:44,655 --> 00:15:48,195
Even in that case, you would probably
have, proper ways for the pods to

300
00:15:48,195 --> 00:15:52,725
communicate with each other like service
registries and load balancers and so on.

301
00:15:52,725 --> 00:15:55,940
So you don't want them just
directly talking to each other.

302
00:15:56,400 --> 00:15:59,400
so do not leave this all open as it
could lead to a compromised cluster.

303
00:15:59,890 --> 00:16:04,590
and, when a particular pod, has a
vulnerability, this, open communication

304
00:16:04,590 --> 00:16:07,110
could lead to a bigger attack surface.

305
00:16:07,320 --> 00:16:10,070
So it is important to, reduce
the attack surface as much as

306
00:16:10,070 --> 00:16:11,450
possible in case of a breach.

307
00:16:11,790 --> 00:16:15,080
and it's important to isolate, as a attack
surface as much as possible as well.

308
00:16:15,290 --> 00:16:16,040
lock all this stuff.

309
00:16:16,540 --> 00:16:20,200
So you can use Kubernetes security
policies to control traffic

310
00:16:20,200 --> 00:16:23,980
between ports and clusters and
you only allow necessary traffic.

311
00:16:23,980 --> 00:16:27,140
So again, follow the principle
of least privileges, just

312
00:16:27,180 --> 00:16:29,370
allow exactly what is required.

313
00:16:29,420 --> 00:16:31,430
don't allow wider access.

314
00:16:31,930 --> 00:16:35,040
Next on the list would be to use
namespace to isolate workloads.

315
00:16:35,100 --> 00:16:37,100
This is often overlooked.

316
00:16:37,600 --> 00:16:40,060
Do not run all your workloads
in a single namespace.

317
00:16:40,150 --> 00:16:43,850
Isolating workloads in different
namespaces based on business needs is

318
00:16:43,850 --> 00:16:47,680
more secure and easier to manage with
RBAC so that you can control access

319
00:16:47,700 --> 00:16:52,190
to namespace based on requirements
and not have everything in the open.

320
00:16:52,690 --> 00:16:55,870
This way you can fine tune RBAC
even further to let users access

321
00:16:55,900 --> 00:16:57,270
only what they need to see.

322
00:16:57,580 --> 00:17:00,600
You can also use Kubernetes network
policies to isolate traffic between

323
00:17:00,600 --> 00:17:01,830
namespaces where applicable.

324
00:17:02,120 --> 00:17:06,390
So use all these tools at
your disposal and lock access

325
00:17:06,390 --> 00:17:09,415
between namespaces as well.

326
00:17:09,915 --> 00:17:11,835
Next will be to limit resource usage.

327
00:17:12,405 --> 00:17:15,605
So as with securing APIs and cluster
itself, it is also essential to

328
00:17:15,605 --> 00:17:19,375
set resource limits on how much
CPU, memory, and disk space can be

329
00:17:19,375 --> 00:17:21,225
used by resources and namespaces.

330
00:17:21,725 --> 00:17:24,975
this secures your cluster from denial
of service attacks when a particular

331
00:17:24,975 --> 00:17:26,385
container uses up all the resources.

332
00:17:26,765 --> 00:17:30,445
You don't want a single container in your
setup to use all the resources at once.

333
00:17:30,945 --> 00:17:35,985
This is often overlooked and it can easily
happen if you have a rogue application, if

334
00:17:35,985 --> 00:17:39,725
you have a rogue library in a particular
application, which might suddenly,

335
00:17:40,065 --> 00:17:41,655
you know, hog up all the resources.

336
00:17:42,155 --> 00:17:45,115
you can use resource quotas
and limit ranges, to set

337
00:17:45,115 --> 00:17:46,515
limits at the namespace level.

338
00:17:47,075 --> 00:17:49,605
you can use requests and
limits, to set resource limits

339
00:17:49,605 --> 00:17:50,575
at container level as well.

340
00:17:50,635 --> 00:17:53,605
So use all these and define,
resource quotas and limits.

341
00:17:54,105 --> 00:17:56,545
Next on our list would be
to use monitoring tools and

342
00:17:56,545 --> 00:17:57,555
to enable audit logging.

343
00:17:57,825 --> 00:18:00,925
it is extremely important to
monitor and audit our clusters.

344
00:18:01,650 --> 00:18:04,960
this way, we may be able to catch a
break in attempt before it happens.

345
00:18:05,050 --> 00:18:09,303
it can, it can help you to keep
an eye on the traffic, detect

346
00:18:09,303 --> 00:18:10,673
unauthorized access attempts.

347
00:18:11,213 --> 00:18:14,313
So enable audit logging for the
cluster and use monitoring tools to

348
00:18:14,313 --> 00:18:15,693
keep an eye on the network traffic.

349
00:18:16,198 --> 00:18:18,800
to and from within the cluster,
the egress and ingress traffic.

350
00:18:18,800 --> 00:18:21,798
Monitoring can be done using open
source tools like Prometheus,

351
00:18:21,828 --> 00:18:24,108
Grafana, or proprietary tools.

352
00:18:24,428 --> 00:18:28,778
So enable alerts for suspicious
activities, alerts for access,

353
00:18:28,938 --> 00:18:31,588
unknown access attempts
from unknown IPs and so on.

354
00:18:32,298 --> 00:18:36,438
So have an alert for all these
general, suspicious activities

355
00:18:36,648 --> 00:18:37,278
and irregular activities.

356
00:18:37,778 --> 00:18:42,498
Now that we, saw what can be done for
cluster security, we also have to consider

357
00:18:42,498 --> 00:18:46,138
the infrastructure best practices because
keeping the infrastructure, secure is also

358
00:18:46,138 --> 00:18:48,028
part of securing a Kubernetes cluster.

359
00:18:48,528 --> 00:18:51,358
So first and foremost, ensure that
all communication is done via TLS,

360
00:18:51,408 --> 00:18:55,728
Then protect ETCD with TLS, firewall
and encryption and restrict access

361
00:18:55,728 --> 00:18:58,098
to, ETCD using strong credentials.

362
00:18:58,608 --> 00:19:04,528
Set up IAM access policies in a supported,
PaaS environment like, EKS or GKE and AKS.

363
00:19:05,418 --> 00:19:08,538
Secure the Kubernetes control plane,
rotate infrastructure credentials

364
00:19:08,538 --> 00:19:13,238
frequently, restrict cloud, metadata,
API access when running in a pass

365
00:19:13,278 --> 00:19:17,068
like AWS, Azure, or GCP, as it
could expose sensitive metadata.

366
00:19:17,078 --> 00:19:20,848
And in, often it is the case that
these metadata APIs are not secured.

367
00:19:21,348 --> 00:19:22,058
So look into those.

368
00:19:22,558 --> 00:19:24,778
we also need to secure
our containers, right?

369
00:19:24,838 --> 00:19:27,569
It's not just, enough to secure
the cluster and the infrastructure.

370
00:19:27,569 --> 00:19:28,738
We also have to.

371
00:19:29,238 --> 00:19:33,098
go granular and secure
the containers as well.

372
00:19:33,098 --> 00:19:37,128
And securing the containers are as
important as securing the cluster itself.

373
00:19:37,208 --> 00:19:40,448
Let's look at some of the
best practices in that area.

374
00:19:40,448 --> 00:19:42,898
Number one would be to not
run containers as root.

375
00:19:43,618 --> 00:19:45,308
This is extremely overlooked.

376
00:19:45,773 --> 00:19:49,753
And it's very important, do not run
containers as root as this would give the

377
00:19:49,753 --> 00:19:51,473
container unlimited access to the host.

378
00:19:51,713 --> 00:19:54,724
So and in case of a compromised
container or, vulnerability in a

379
00:19:54,724 --> 00:19:58,193
particular container, this would
give, the attacker a wider, attack

380
00:19:58,193 --> 00:20:00,283
surface and root access to the host.

381
00:20:00,663 --> 00:20:01,833
So do not let this happen.

382
00:20:02,388 --> 00:20:04,438
avoid container escape
and privilege escalations.

383
00:20:05,078 --> 00:20:08,128
always run the containers using
a non root user to limit access.

384
00:20:08,148 --> 00:20:12,228
Use chown user, when using docker
copy commands, for example.

385
00:20:12,538 --> 00:20:16,028
Always set up a, least privilege
user for the container and use that.

386
00:20:16,528 --> 00:20:19,698
another often overlooked aspect,
is, Using minimal up to date

387
00:20:19,698 --> 00:20:21,098
official base images, right?

388
00:20:21,458 --> 00:20:26,588
So especially during development since
it's not very convenient, mostly Often

389
00:20:26,588 --> 00:20:32,088
you will just go with a standard os image
and just focus on the application But for

390
00:20:32,098 --> 00:20:37,553
production always consider starting with
a slim base image and adding what exactly

391
00:20:37,663 --> 00:20:42,193
you require there instead of going for a
fat, full fledged operating system image.

392
00:20:42,693 --> 00:20:45,783
use the minimal and up to date
official images as I mentioned.

393
00:20:46,103 --> 00:20:47,463
Don't use generic images.

394
00:20:47,463 --> 00:20:49,093
Go for slim or light versions.

395
00:20:49,143 --> 00:20:51,483
Maybe even start with the
bare bone version and add the

396
00:20:51,483 --> 00:20:52,923
required dependencies yourself.

397
00:20:53,003 --> 00:20:54,483
This will give you much more control.

398
00:20:54,893 --> 00:20:57,183
This will give you much more
control, if you want to replace

399
00:20:57,183 --> 00:21:01,213
a particular dependency or if you
want to upgrade a specific, library

400
00:21:01,213 --> 00:21:02,583
with vulnerability and so on.

401
00:21:02,813 --> 00:21:07,003
This will also make the overall
image lightweight, gives you latest

402
00:21:07,043 --> 00:21:09,853
bug fixes and security patches
and overall is much more secure.

403
00:21:10,353 --> 00:21:12,983
for example, use deterministic image tags.

404
00:21:12,983 --> 00:21:14,073
Don't go for generic ones.

405
00:21:14,083 --> 00:21:16,813
Use the exact specific
version that you want.

406
00:21:17,333 --> 00:21:19,183
don't give, ranges, et cetera.

407
00:21:19,723 --> 00:21:22,613
Remove all unwanted dependencies,
packages, and debugging tools from

408
00:21:22,613 --> 00:21:26,023
the images, to make the image lighter
as well as to reduce the attack

409
00:21:26,023 --> 00:21:27,843
surface in case of a vulnerability.

410
00:21:28,343 --> 00:21:31,543
only install production
dependencies, don't go for beta

411
00:21:31,563 --> 00:21:33,613
or, test dependencies and so on.

412
00:21:34,013 --> 00:21:37,933
use official verified images from
popular software for popular software,

413
00:21:38,303 --> 00:21:42,733
prefer LTS version when available, use a
trusted registry for non official images

414
00:21:42,833 --> 00:21:46,463
and always double check non official
images, look into the images that you

415
00:21:46,463 --> 00:21:48,653
are using and verify the image publisher.

416
00:21:49,173 --> 00:21:50,563
these are all extremely important.

417
00:21:51,063 --> 00:21:54,923
Next would be to prevent
loading unwanted kernel modules.

418
00:21:54,923 --> 00:21:56,303
This is similar to the previous one.

419
00:21:56,983 --> 00:22:00,753
If you're using a FAT, a full fledged
operating system, it might be loading

420
00:22:00,753 --> 00:22:04,323
a lot of unwanted kernel modules
that will unnecessarily use up your

421
00:22:04,333 --> 00:22:09,373
resources, reduce your performance,
increase the image size, increase

422
00:22:09,373 --> 00:22:10,433
the attack surface, and so on.

423
00:22:10,683 --> 00:22:14,273
use only the kernel modules that you
absolutely require for the application.

424
00:22:15,173 --> 00:22:17,213
This will reduce the attack surface
and give better performance.

425
00:22:17,848 --> 00:22:22,538
this can be restricted using rules in
the, Kubernetes blacklist conf, at the

426
00:22:22,538 --> 00:22:26,988
node level or by uninstalling unwanted
modules from the node, directly.

427
00:22:27,268 --> 00:22:30,818
this can also be done by using a
very bare minimum base image and

428
00:22:31,098 --> 00:22:35,048
controlling exactly what loads and,
what dependencies and modules are there.

429
00:22:35,548 --> 00:22:39,138
Next would be to enable container
image scanning in your CACD phase.

430
00:22:39,318 --> 00:22:42,628
If you haven't already add container
image scanning into your build

431
00:22:42,628 --> 00:22:44,328
pipelines, you would thank me later.

432
00:22:44,428 --> 00:22:45,708
This is extremely important.

433
00:22:46,268 --> 00:22:50,268
this can be helpful to detect known
vulnerabilities before they are exploited.

434
00:22:50,768 --> 00:22:55,123
So enable, container image scanning
in your CICD, to catch vulnerabilities

435
00:22:55,123 --> 00:22:56,713
before they become an attack vector.

436
00:22:57,043 --> 00:23:00,003
use OSS tools like Clayer or
Anchor or commercial tools

437
00:23:00,003 --> 00:23:01,313
like Snyk, it's up to you.

438
00:23:01,483 --> 00:23:05,393
But use one of these tools, to
enable, container image scanning.

439
00:23:05,803 --> 00:23:09,013
And, have, have your CICD
pipeline fail if, There is a

440
00:23:09,773 --> 00:23:11,133
vulnerability in your container.

441
00:23:11,973 --> 00:23:15,213
these are quite easy to set up and
they support most CACD, solutions.

442
00:23:15,223 --> 00:23:17,833
So there is no excuse to not do this.

443
00:23:18,333 --> 00:23:20,233
Next would be to audit the images.

444
00:23:20,243 --> 00:23:23,793
It is extremely important to monitor and
audit the container images periodically.

445
00:23:24,283 --> 00:23:26,173
check for security best practices.

446
00:23:26,193 --> 00:23:29,303
If possible, make this auditing
part of your CI CD pipeline.

447
00:23:30,013 --> 00:23:32,913
use Docker Bench for security
to audit your container images

448
00:23:32,923 --> 00:23:34,193
for security best practices.

449
00:23:34,263 --> 00:23:37,493
It's a great tool to ensure that
custom images you build for production

450
00:23:37,493 --> 00:23:38,813
are following best practices.

451
00:23:39,313 --> 00:23:42,943
Finally, use port security
policies for containers.

452
00:23:43,788 --> 00:23:47,718
So this will help reduce attack surface
and prevent privilege escalation.

453
00:23:48,118 --> 00:23:52,518
you can use the pod security admission to
limit the container's access to the host.

454
00:23:52,588 --> 00:23:55,328
This is the successor to pod
security policies from version 1.

455
00:23:55,328 --> 00:23:56,458
2 and onwards.

456
00:23:56,938 --> 00:24:00,758
This will help reduce attack surface
and prevent privilege escalations in

457
00:24:00,758 --> 00:24:02,358
case the container image is compromised.

458
00:24:02,533 --> 00:24:04,223
And this is more common than you think.

459
00:24:04,583 --> 00:24:06,893
More than a million Docker
images were found to be affected

460
00:24:06,893 --> 00:24:08,213
by malware at different times.

461
00:24:08,453 --> 00:24:11,353
this is nothing to be, nothing to, ignore.

462
00:24:11,803 --> 00:24:12,523
set this up.

463
00:24:13,163 --> 00:24:16,903
And, with that, we conclude all
the security best practice tips.

464
00:24:17,243 --> 00:24:18,253
thank you for joining.

465
00:24:18,263 --> 00:24:20,943
Hope you, had, some useful
information from here.

466
00:24:21,133 --> 00:24:23,833
Hope you follow some of these
and secure your clusters, better.

467
00:24:24,243 --> 00:24:24,593
thank you.

468
00:24:24,593 --> 00:24:27,613
You can reach me on, BlueSky,
Mastodon, and LinkedIn.

469
00:24:28,203 --> 00:24:28,733
Thank you for your time.

