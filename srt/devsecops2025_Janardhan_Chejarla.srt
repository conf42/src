1
00:00:00,500 --> 00:00:01,309
Hello everyone.

2
00:00:01,820 --> 00:00:03,710
My name is Jonathan Chela.

3
00:00:03,860 --> 00:00:09,800
And in this talk I'm gonna talk about
high frequency trading, where speed

4
00:00:09,800 --> 00:00:14,740
is everything, we are tackling a big
problem, how do you keep things secure

5
00:00:14,979 --> 00:00:16,630
when you have to be faster than lightning?

6
00:00:17,130 --> 00:00:21,050
And if we add security tools, they
basically, slow down the trading.

7
00:00:22,005 --> 00:00:25,445
We need a new way to be, both
fast and at the same time.

8
00:00:25,445 --> 00:00:25,985
Safe.

9
00:00:26,485 --> 00:00:28,555
Think of three main goals in trading.

10
00:00:28,675 --> 00:00:34,145
One is, speed scale where you have to,
process millions of orders per second.

11
00:00:34,685 --> 00:00:39,155
And at the same time, you cannot
compromise, security usually, when

12
00:00:39,155 --> 00:00:42,615
you focus on one thing it could turn
into sacrificing the other thing.

13
00:00:43,115 --> 00:00:49,455
The main issue is that, the latency
tax, every security check adds a delay.

14
00:00:50,025 --> 00:00:53,755
If a traditional firewall adds,
let's say, 50 microseconds, we

15
00:00:53,755 --> 00:00:54,865
are gonna lose some money, right?

16
00:00:55,625 --> 00:01:01,085
We have to design systems that handle
huge volume without getting slow.

17
00:01:01,385 --> 00:01:02,525
So that's the objective.

18
00:01:03,025 --> 00:01:07,965
So here comes the, even driven and
cloud native, architecture where you can

19
00:01:07,965 --> 00:01:12,315
design the systems, without compromising
the points that we just talked about.

20
00:01:12,815 --> 00:01:15,454
So let's talk about the latency killer.

21
00:01:16,095 --> 00:01:18,015
Why is the standard
competitor is too slow?

22
00:01:18,375 --> 00:01:24,435
Because the operating systems, for
example, you look at Linx or Windows

23
00:01:25,035 --> 00:01:27,045
gets in the way of the network card.

24
00:01:27,545 --> 00:01:35,215
We use a specialized tools DPDK
or RDME to skip the voice entirely

25
00:01:35,815 --> 00:01:37,795
and talk right to the network card.

26
00:01:38,470 --> 00:01:44,080
So this gives us the pure speed,
but it also means we bypass

27
00:01:44,080 --> 00:01:46,430
some of the, security measures.

28
00:01:46,880 --> 00:01:50,510
We must move securely
to the hardware itself.

29
00:01:51,010 --> 00:01:52,800
We use this, the concept of Aaron.

30
00:01:53,364 --> 00:01:55,824
Which will give a sub microsecond latency.

31
00:01:56,454 --> 00:02:00,574
So for the absolute fastest part
of the system, that, which is the,

32
00:02:00,574 --> 00:02:04,379
the order matching system we use,
the messaging system called Aaron.

33
00:02:04,879 --> 00:02:09,689
Aaron is like extremely reliable,
encrypted, instant messaging for machines.

34
00:02:10,109 --> 00:02:11,249
It's built for speed.

35
00:02:11,669 --> 00:02:17,069
And uses a method called raft
consensus to ensure all our trading

36
00:02:17,069 --> 00:02:21,479
computers agree on the order of the
trade, even if one computer breaks.

37
00:02:21,979 --> 00:02:26,619
So let's talk about, cloud native,
even bus and orchestration for

38
00:02:26,619 --> 00:02:31,780
slower and high volume tasks
like analyzing market data are.

39
00:02:32,280 --> 00:02:33,300
Settling trades.

40
00:02:33,940 --> 00:02:35,350
We use tools like, Kafka.

41
00:02:36,079 --> 00:02:41,069
This allows us, to handle huge
systems of information without

42
00:02:41,069 --> 00:02:42,539
slowing down the trading engine.

43
00:02:43,079 --> 00:02:47,640
We separate the tasks one part handles the
trade, which is which has to be very fast.

44
00:02:48,029 --> 00:02:51,179
And another handles, record keeping,
for example, which could be.

45
00:02:52,039 --> 00:02:55,619
High volume, it not necessarily
to be like, ultra fast, it

46
00:02:55,619 --> 00:02:56,699
still should handle huge volume.

47
00:02:57,199 --> 00:03:01,450
So the latency tax, let's look at
some of these security patterns and

48
00:03:01,510 --> 00:03:05,419
how each of them, will add security
latency in terms of like microseconds.

49
00:03:05,969 --> 00:03:10,140
So this chart will show how much
delay, common security tools will add.

50
00:03:10,690 --> 00:03:15,779
A common security pattern called, a
sidecar used in modern microservices

51
00:03:15,880 --> 00:03:17,799
adds about 150 microseconds.

52
00:03:18,289 --> 00:03:20,209
That's too much for
high frequency trading.

53
00:03:20,779 --> 00:03:24,689
We must bake security directly
into the application code using, in

54
00:03:24,719 --> 00:03:29,339
process library to keep the delay
to, five microseconds or even less.

55
00:03:29,839 --> 00:03:33,260
So at the same time, when we talk
about all these high frequency ratings

56
00:03:33,260 --> 00:03:37,130
and a bunch of other applications,
connected to that observability is also,

57
00:03:37,130 --> 00:03:38,810
one of the key aspect of the system.

58
00:03:39,269 --> 00:03:43,079
And at the same time, we have
to achieve this observability

59
00:03:43,379 --> 00:03:47,899
without, much penalty if you can't
use the standard security tools.

60
00:03:48,169 --> 00:03:49,879
So how do you watch, what's happening?

61
00:03:50,554 --> 00:03:56,314
We use a, a tool called EBPF,
which lets us hook directly into

62
00:03:56,314 --> 00:03:58,024
the kennel without adding a delay.

63
00:03:58,524 --> 00:04:03,934
It lets us observe every packet and every
action of the system that it takes for,

64
00:04:03,944 --> 00:04:09,394
for compliance, all while maintaining,
zero latency goal it's observation

65
00:04:09,814 --> 00:04:11,404
without the performance penalty.

66
00:04:12,214 --> 00:04:13,444
So that is the goal, basically.

67
00:04:13,944 --> 00:04:16,764
Determination itself is
the, is know security.

68
00:04:17,254 --> 00:04:17,944
Even sourcing.

69
00:04:18,524 --> 00:04:21,869
So anything that is happening in
the system, we, we need to capture

70
00:04:21,869 --> 00:04:23,399
that as a, as an immutable event.

71
00:04:24,009 --> 00:04:28,139
If you can't replay basically if
you have to replace a scenario,

72
00:04:28,139 --> 00:04:29,399
something happened in the system.

73
00:04:29,874 --> 00:04:32,234
These immutable events are very helpful.

74
00:04:32,604 --> 00:04:36,414
You can basically replay the event,
what happened in the past, and

75
00:04:36,474 --> 00:04:39,394
if you can't replay it, you can't
prove it, what happened, right?

76
00:04:39,734 --> 00:04:40,304
That's the key.

77
00:04:40,804 --> 00:04:40,984
Okay.

78
00:04:41,614 --> 00:04:45,044
And four and six, like for example,
if something happened in the system

79
00:04:45,104 --> 00:04:48,684
or something went wrong, you should be
able to do the, post-mortem analysis.

80
00:04:49,154 --> 00:04:52,704
Where you need to replay, the trading
sequence, what exactly happened,

81
00:04:53,044 --> 00:04:54,284
at a certain, time interval.

82
00:04:54,784 --> 00:04:56,854
And compliance is, another aspect.

83
00:04:57,274 --> 00:05:01,894
So nowadays, regulators are
demanding, proof of best execution.

84
00:05:02,544 --> 00:05:06,424
And deterministic logs provide, the
evidence of the, system behavior.

85
00:05:06,924 --> 00:05:12,204
So you know, com, let's talk about,
compliance as a code and real world

86
00:05:12,204 --> 00:05:16,304
scale by building security and
resilience into the architecture.

87
00:05:16,904 --> 00:05:18,764
We are calling it as a,
compliance as a code.

88
00:05:19,304 --> 00:05:21,104
We get some amazing results.

89
00:05:21,594 --> 00:05:23,844
For example, if you do, if
you look at some of these real

90
00:05:23,844 --> 00:05:25,074
world, real world examples.

91
00:05:25,404 --> 00:05:30,804
The London Ex Stock Exchange, can
handle, almost like close to, 15 million

92
00:05:30,804 --> 00:05:36,064
messages per second, and they cut out
the systems downtime from, 40 hours to,

93
00:05:36,404 --> 00:05:38,994
just about 2.5 years in the whole year.

94
00:05:39,494 --> 00:05:43,249
This shows that the speed and
reliability, goes hand in hand.

95
00:05:43,749 --> 00:05:49,549
And in short, when you talk about,
resilience and chaos engineering basically

96
00:05:49,579 --> 00:05:54,189
in a high frequency trading system a
system that cannot recover in milliseconds

97
00:05:54,549 --> 00:05:56,199
is a system that already failed.

98
00:05:56,199 --> 00:06:00,809
It's you can think of it as a quote,
but, so that's the core principle of

99
00:06:00,809 --> 00:06:02,239
the, high frequency trading system.

100
00:06:02,739 --> 00:06:07,529
And not only, what we talked, in this
talk, there is also, a future aspect

101
00:06:07,529 --> 00:06:09,459
of the high frequency trading systems.

102
00:06:10,089 --> 00:06:11,619
There is still a lot need to be improved.

103
00:06:11,859 --> 00:06:16,089
The next frontier is moving security
logic directly into the hardware and,

104
00:06:16,089 --> 00:06:18,329
we need to achieve, zero CPU overhead.

105
00:06:18,879 --> 00:06:23,449
We need to implement the firewalls, risk
checks and encryption, directly into the,

106
00:06:23,459 --> 00:06:27,399
FPGA gates and bump it, bump in the wire.

107
00:06:27,799 --> 00:06:32,649
Bad packets are dropped at the,
core level ensuring that they

108
00:06:32,649 --> 00:06:33,999
never consume the whole CPU.

109
00:06:34,499 --> 00:06:39,059
And of course we need to implement
all these things with the aspect of,

110
00:06:39,909 --> 00:06:43,179
public clouds and not only private
clouds, public clouds as well.

111
00:06:43,679 --> 00:06:45,179
That's the end of this talk.

112
00:06:45,889 --> 00:06:46,909
Thank you for attending.

