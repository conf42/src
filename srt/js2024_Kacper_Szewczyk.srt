1
00:00:00,190 --> 00:00:00,960
Hi everyone.

2
00:00:01,900 --> 00:00:04,699
My name is Kasper Szefcik
and today I would like to

3
00:00:04,700 --> 00:00:06,229
talk to you about TypeScript.

4
00:00:06,979 --> 00:00:10,639
And how TypeScript improves
developer experience.

5
00:00:11,139 --> 00:00:15,599
But before I start, let me just
talk a couple of words about myself.

6
00:00:16,099 --> 00:00:19,909
So I work as JS developer at RSC software.

7
00:00:20,409 --> 00:00:22,599
I work in Wroclaw, which is in Poland.

8
00:00:23,099 --> 00:00:24,979
I specialize in two technologies, Next.

9
00:00:24,979 --> 00:00:26,839
js and React Native.

10
00:00:27,139 --> 00:00:31,139
So as you probably already know, I'm
front end slash mobile developer.

11
00:00:31,639 --> 00:00:38,729
And a curious fact about myself is
that I am ex IT project manager.

12
00:00:38,839 --> 00:00:43,949
I was project manager for almost
five years and for the past three

13
00:00:43,949 --> 00:00:45,769
years, I'm back as a developer.

14
00:00:46,269 --> 00:00:48,849
But that's all about myself.

15
00:00:48,989 --> 00:00:51,059
Let's move to TypeScript.

16
00:00:51,559 --> 00:00:53,779
And today I was, I would
like to start with a story.

17
00:00:54,279 --> 00:00:58,649
A story that starts in 2008 and
in the company called Microsoft.

18
00:00:59,149 --> 00:01:03,829
Maybe you've heard about them and in
the year 2008 in Microsoft, there was

19
00:01:03,829 --> 00:01:09,219
an idea for a new project that initially
was analyzed by business analysts,

20
00:01:09,439 --> 00:01:11,479
architects, maybe somebody else.

21
00:01:11,979 --> 00:01:16,249
And they decided about the
technological stack and the

22
00:01:16,249 --> 00:01:17,969
requirements for this project.

23
00:01:18,469 --> 00:01:23,959
Later on, based on that, one of the team
was selected to work on this project.

24
00:01:24,459 --> 00:01:28,599
And the project manager came to
the team to announce them the

25
00:01:28,599 --> 00:01:30,139
news about their new project.

26
00:01:30,639 --> 00:01:34,649
And he said, dear team, I
have a good news for you.

27
00:01:35,149 --> 00:01:41,489
There is enormous opportunity for you
to work in the project in which you will

28
00:01:41,629 --> 00:01:45,359
utilize not only your beloved C sharp.

29
00:01:45,944 --> 00:01:49,934
But also another new
technology, Javascript.

30
00:01:50,434 --> 00:01:54,134
And when they heard about
that, it was silence.

31
00:01:54,634 --> 00:02:00,904
But after this short, brief moment
of silence, They were mad because

32
00:02:00,924 --> 00:02:08,164
why they require them to work in
this chaotic language, JavaScript,

33
00:02:08,664 --> 00:02:12,934
when on the other hand, they have
their beloved mature language.

34
00:02:13,784 --> 00:02:19,674
S as it is C sharp, but the
Microsoft, they were working

35
00:02:19,894 --> 00:02:22,144
as a professional developers.

36
00:02:22,859 --> 00:02:27,849
They don't regret or just throw
away any challenges they face.

37
00:02:28,629 --> 00:02:33,409
So they decided, okay, we'll do
this project, but we won't write

38
00:02:33,409 --> 00:02:34,699
a single line in JavaScript.

39
00:02:35,199 --> 00:02:40,399
So first of all, they sit
and made their own analysis.

40
00:02:40,919 --> 00:02:41,779
Maybe they were wrong.

41
00:02:41,859 --> 00:02:44,149
Maybe the JavaScript is
not needed in this project.

42
00:02:44,649 --> 00:02:47,369
But in the end, they found
out, okay, it's in it.

43
00:02:48,139 --> 00:02:50,229
It's, it has to be running.

44
00:02:50,939 --> 00:02:54,099
In the browser, the
JavaScript needs to be there.

45
00:02:54,599 --> 00:02:55,039
Okay.

46
00:02:55,539 --> 00:02:56,319
what they can do?

47
00:02:56,819 --> 00:02:57,839
They think, okay.

48
00:02:58,339 --> 00:03:00,049
We know C Sharp very well.

49
00:03:00,549 --> 00:03:06,649
What if We'll write the code in C Sharp
With the whole logic that has to be done

50
00:03:06,649 --> 00:03:13,559
on this browser side But whatever write
it in C Sharp we have all the tools

51
00:03:13,579 --> 00:03:19,469
all the libraries all the support that
we have in the C Sharp and We'll just

52
00:03:19,469 --> 00:03:26,979
write the tool that to translate the C
Sharp code into JavaScript And there was

53
00:03:26,979 --> 00:03:33,839
a tool you That's called script shop,
which was doing exactly as they expected.

54
00:03:34,594 --> 00:03:41,304
So you take the file, the class in C sharp
and just translates that into the function

55
00:03:41,454 --> 00:03:48,604
JS function It was a success for them
They meet the goal They wrote a project

56
00:03:48,604 --> 00:03:52,974
in C sharp, which requires JavaScript,
but they didn't have to write it.

57
00:03:53,474 --> 00:03:53,994
Success.

58
00:03:53,994 --> 00:03:59,334
But were there any problems?

59
00:03:59,834 --> 00:04:00,314
Of course.

60
00:04:01,254 --> 00:04:02,744
I would say that a lot of them.

61
00:04:03,244 --> 00:04:09,034
First of all, even though they
have a beautifully written code in

62
00:04:09,034 --> 00:04:14,379
mature language like C sharp, Maybe
even they have 100 percent code

63
00:04:14,379 --> 00:04:17,829
coverage, but they were testing
the code that is not on production.

64
00:04:18,329 --> 00:04:19,269
That is the first issue.

65
00:04:19,769 --> 00:04:27,679
So even if they have 100 percent certainty
that the code in C sharp works well,

66
00:04:28,179 --> 00:04:33,599
then it was translated by the tool
that maybe not been so well tested.

67
00:04:34,099 --> 00:04:38,879
And then they have to manually test that
when it was actually written in Javascript

68
00:04:39,379 --> 00:04:44,639
So the tests are false positive actually
so they have Certainty of uncertainty,

69
00:04:45,099 --> 00:04:49,959
because they weren't sure that JavaScript
itself is translated correctly.

70
00:04:50,249 --> 00:04:55,439
Maybe the tool itself contains error
that generates errors on the translation.

71
00:04:55,949 --> 00:04:58,869
Maybe even some functions
weren't implemented.

72
00:04:59,389 --> 00:05:03,009
And translate it correctly
from C sharp to JavaScript.

73
00:05:03,509 --> 00:05:06,919
And they have to do it basically
at each time of the release,

74
00:05:06,969 --> 00:05:09,829
each time of the translation that
they have to manually test that.

75
00:05:10,329 --> 00:05:16,239
And if there are any problems, it was
faster and more secure to fix that on

76
00:05:16,239 --> 00:05:22,129
the JS side, rather than fix that the
translator, this script sharp tool.

77
00:05:22,629 --> 00:05:22,979
Why?

78
00:05:23,379 --> 00:05:27,839
Because if they change something in
the scripture, maybe the problem that

79
00:05:27,839 --> 00:05:33,129
they had, they spotted, is fixed,
but they weren't sure if something

80
00:05:33,229 --> 00:05:35,759
else wasn't broken in the meantime.

81
00:05:36,259 --> 00:05:41,109
So they sit again to the table,
started wondering what they can do,

82
00:05:41,129 --> 00:05:43,229
we cannot work this way anymore.

83
00:05:43,729 --> 00:05:50,239
And, one brave team member asked them,
What if you just write it in JavaScript?

84
00:05:50,299 --> 00:05:51,569
We'll do it anyway.

85
00:05:51,769 --> 00:05:56,719
Maybe it will be faster, better
to write it pure in JavaScript.

86
00:05:57,219 --> 00:06:00,749
But the other team member
said, nah, let's not do it.

87
00:06:01,249 --> 00:06:06,689
So this one team member
asked, okay, but why?

88
00:06:07,189 --> 00:06:11,299
Why the JavaScript is so bad
in comparison to ScriptShark?

89
00:06:11,799 --> 00:06:12,929
And they started wondering.

90
00:06:13,429 --> 00:06:13,839
Why?

91
00:06:14,514 --> 00:06:16,514
Why they don't want to
write in JavaScript?

92
00:06:17,014 --> 00:06:19,514
Because everyone said that
the C language is bad?

93
00:06:20,014 --> 00:06:20,704
Probably yes.

94
00:06:21,204 --> 00:06:26,504
But they just try to point out
reasons why JavaScript is bad.

95
00:06:27,004 --> 00:06:31,274
And one of the things that they
highlighted is that they are not

96
00:06:31,274 --> 00:06:34,744
sure what will be the result of the
function that they are implementing.

97
00:06:35,244 --> 00:06:37,054
In the C Sharp they have
to write in JavaScript.

98
00:06:37,464 --> 00:06:43,444
declarer, the types of the parameters,
the output type of the function.

99
00:06:43,944 --> 00:06:50,304
So even if the function, if
you provide the arguments of

100
00:06:50,344 --> 00:06:54,334
wrong types to the function, the
compiler will say that it's wrong.

101
00:06:55,124 --> 00:06:58,914
If they expect different type of
the method after execution, the

102
00:06:58,914 --> 00:07:00,444
compiler will say that it's wrong.

103
00:07:00,944 --> 00:07:06,514
So the application itself is basically
verified even before they start to

104
00:07:06,514 --> 00:07:08,914
click on that or just execute anything.

105
00:07:09,414 --> 00:07:13,594
And they thought to themselves,
what if Javascript will have

106
00:07:13,634 --> 00:07:15,624
that, then we can work with it.

107
00:07:16,124 --> 00:07:20,954
Because the What the keywords like
the special words that they have

108
00:07:20,954 --> 00:07:23,634
in the JavaScript are not very
different from what they already know.

109
00:07:24,134 --> 00:07:28,974
The only this predictability of the
typescript of the JavaScript is.

110
00:07:29,474 --> 00:07:30,854
It's not existing actually.

111
00:07:31,354 --> 00:07:38,874
So later on in 2012, there was released
the first version of TypeScript with

112
00:07:38,874 --> 00:07:41,124
the version number zero point 0.8.

113
00:07:41,754 --> 00:07:45,234
It was the first version that
was publicly opened to the MPM.

114
00:07:45,734 --> 00:07:50,864
And what is very interesting about this
fact that when you, when we compare

115
00:07:51,254 --> 00:07:56,874
the types of other languages that
were released, that were developed

116
00:07:56,874 --> 00:08:01,684
as a new language, new big thing,
then it was, you can see that most

117
00:08:01,684 --> 00:08:07,474
of the languages that were released,
they took one problem or multiple

118
00:08:07,474 --> 00:08:10,724
problems that other technologies has.

119
00:08:11,224 --> 00:08:17,144
I didn't want to improve that, but this
problems that technology technologies

120
00:08:17,154 --> 00:08:21,894
has, I usually connected with, or
maybe different architecture and

121
00:08:21,894 --> 00:08:28,154
that's, we want to solve the issue with
microservices to have better support

122
00:08:28,164 --> 00:08:29,564
in the language for microservice.

123
00:08:30,359 --> 00:08:36,389
Maybe, we want to improve
memory management or, improve

124
00:08:37,209 --> 00:08:39,379
CPU usage of the language.

125
00:08:40,249 --> 00:08:46,829
in any cases, we want to improve
some problem that one language has.

126
00:08:47,329 --> 00:08:48,959
We want to make it better.

127
00:08:49,744 --> 00:08:53,654
But the TypeScript itself
doesn't do anything different.

128
00:08:54,154 --> 00:08:58,714
The applications written in JavaScript
and TypeScript works the same.

129
00:08:59,214 --> 00:09:01,024
They have the same memory usage.

130
00:09:01,524 --> 00:09:04,034
Basically, they are the same application.

131
00:09:04,534 --> 00:09:05,484
What difference?

132
00:09:05,714 --> 00:09:09,894
It's a developer experience in
writing in this specific language.

133
00:09:10,394 --> 00:09:14,324
The type itself was created to
improve developer experience.

134
00:09:14,824 --> 00:09:19,224
It was created for the love,
for the developers, or we can

135
00:09:19,224 --> 00:09:20,984
say for the hate of JavaScript.

136
00:09:21,484 --> 00:09:26,124
And it wasn't a huge success at
the very beginning, at least.

137
00:09:26,759 --> 00:09:35,399
Because TypeScript in 2012 was supported
only by one IDE, Visual Studio Code.

138
00:09:35,959 --> 00:09:39,749
But Visual Studio Code, even
though it's right now, it's quite

139
00:09:39,749 --> 00:09:43,319
popular and many, probably most of
you are using that on every day.

140
00:09:44,199 --> 00:09:48,899
But in 2012, it has one
technical difficulty.

141
00:09:49,399 --> 00:09:51,149
It was running only on Windows.

142
00:09:51,649 --> 00:09:54,589
So it was a huge obstacle to overcome.

143
00:09:55,089 --> 00:09:56,779
But soon it was solved.

144
00:09:57,279 --> 00:10:02,179
Okay, let's leave Microsoft,
and let's move to TypeScript.

145
00:10:02,679 --> 00:10:08,559
And because I started with the
Microsoft, which for me, it's a

146
00:10:08,569 --> 00:10:10,659
company that earns a lot of money.

147
00:10:11,319 --> 00:10:16,569
And I will, I want To stay in the topic
of money because who doesn't love money

148
00:10:17,069 --> 00:10:23,449
and for today examples how Typescript
works with developer experience.

149
00:10:24,229 --> 00:10:29,829
I want to talk about the money that
is provided by scientific grants.

150
00:10:30,329 --> 00:10:35,509
So if you don't know, grants itself
is that the money that is provided

151
00:10:35,529 --> 00:10:41,879
by the government or some institution
or the company to develop some

152
00:10:41,929 --> 00:10:43,639
research, scientific research.

153
00:10:44,139 --> 00:10:50,089
So usually it's like the long time
project that you require, you write

154
00:10:50,329 --> 00:10:54,099
what you wanted to develop, what you
want to discover in your research,

155
00:10:54,099 --> 00:11:03,259
you write some expected results, and
then you proceed with the research.

156
00:11:03,629 --> 00:11:07,979
So usually you need to provide
the document that describes

157
00:11:08,419 --> 00:11:10,269
what your product will be about.

158
00:11:10,819 --> 00:11:15,259
what do you need to buy in case of
the consumables, any materials, any

159
00:11:15,269 --> 00:11:20,829
devices, that will help you to, to
basically make this research and then

160
00:11:20,829 --> 00:11:23,274
write any results that will help you.

161
00:11:23,544 --> 00:11:28,824
you expect to, to be, receiving
or any applications for this

162
00:11:28,874 --> 00:11:31,604
research, if it will be a success.

163
00:11:32,104 --> 00:11:39,274
So this kind of grants grant, contains,
let's say a couple of informations.

164
00:11:39,994 --> 00:11:44,974
and if we want to have a system
that allows to upload this kind

165
00:11:44,974 --> 00:11:47,374
of data, we need to store it.

166
00:11:47,874 --> 00:11:52,024
so the, first of all, we need the
information or the applicant, as you

167
00:11:52,024 --> 00:11:59,144
can see on the right, we have some
name, of the student or the supervisor.

168
00:11:59,784 --> 00:12:04,734
we have some magic number, which
is basically the identifier,

169
00:12:05,114 --> 00:12:06,694
for this specific person.

170
00:12:07,024 --> 00:12:11,714
so we know that he or she, apply
and this is not somebody else from

171
00:12:11,714 --> 00:12:13,504
different university, for example.

172
00:12:14,019 --> 00:12:18,199
We have some new address, maybe
some different information that

173
00:12:18,199 --> 00:12:19,549
is specific for this person.

174
00:12:20,049 --> 00:12:22,109
And the other thing is application number.

175
00:12:22,989 --> 00:12:29,529
so this is something that we'll just
point out the exactly which of the,

176
00:12:29,859 --> 00:12:35,729
application it is, especially the
application number on the contains

177
00:12:35,759 --> 00:12:41,649
information about the Institute, maybe
the funding for which we are asking for,

178
00:12:41,859 --> 00:12:49,259
probably it will contain some year, when
this project is Submitted and so on.

179
00:12:49,989 --> 00:12:53,819
so we also want, it won't be
just, the index from the database.

180
00:12:53,839 --> 00:12:57,769
It has to be something first of
all, a little bit secret, but on

181
00:12:57,769 --> 00:12:59,449
the other hand, quite descriptive.

182
00:12:59,949 --> 00:13:01,609
we'll have some
information of the project.

183
00:13:01,659 --> 00:13:05,769
Of course, we'll have attachments,
which are quite important.

184
00:13:06,479 --> 00:13:11,059
Because it should contain any offers
that we already ask, for the companies

185
00:13:11,059 --> 00:13:16,719
in case of this, devices that we want
to buy or rent, maybe this, materials

186
00:13:16,759 --> 00:13:19,399
that will require for this, research.

187
00:13:19,769 --> 00:13:25,106
We need to have this kind of offers
assigned to the project so they know that

188
00:13:25,106 --> 00:13:31,554
if we are asking, for example, for 100
grants, this is basically the summary of

189
00:13:31,584 --> 00:13:34,524
all the costs that are in the attachment.

190
00:13:35,024 --> 00:13:40,834
and the last part that I wanted to
highlight is the signature of approvals.

191
00:13:40,834 --> 00:13:47,920
because, this kind of project usually
have multiple steps of approval.

192
00:13:48,360 --> 00:13:52,785
in the Europe, And there are
this kind of projects, they are

193
00:13:52,785 --> 00:13:56,255
all, always at least two steps.

194
00:13:56,715 --> 00:14:02,505
The first one is something that is called
formal review, which basically verifies

195
00:14:02,505 --> 00:14:04,885
if the application itself is correct.

196
00:14:05,655 --> 00:14:08,385
all the fields are, filled
correctly, basically.

197
00:14:08,755 --> 00:14:15,725
And if the information that you put
are according to the truth, if you

198
00:14:15,725 --> 00:14:17,645
are applying for the correct project.

199
00:14:18,125 --> 00:14:18,705
And so on.

200
00:14:18,705 --> 00:14:19,085
So on.

201
00:14:19,915 --> 00:14:26,005
And later on, there is, the final review,
which will basically review if your

202
00:14:26,015 --> 00:14:32,675
project are, interesting or needed in case
of the actual situation of the market.

203
00:14:33,290 --> 00:14:38,150
so let's say that you are applying for
the grant, when three years ago, there

204
00:14:38,150 --> 00:14:44,290
was very similar research, done, and you
are basically asking for the money for

205
00:14:44,520 --> 00:14:48,900
very similar, even the same research,
you won't receive this kind of money.

206
00:14:49,450 --> 00:14:54,210
but usually it's on the second
step because it requires somebody

207
00:14:54,210 --> 00:14:58,070
from the industry to verify
if your product is correct.

208
00:14:58,085 --> 00:15:00,965
yeah, so let's start from our
first part, ApplicantData.

209
00:15:01,465 --> 00:15:09,795
We have this kind of basic type that we
will have to, map our applicant data.

210
00:15:10,295 --> 00:15:15,805
So you have some kind of address which
will be used for correspondence or any

211
00:15:15,805 --> 00:15:18,135
other, sending of the letters and so on.

212
00:15:18,136 --> 00:15:22,245
As we have some city, postal
code, country, Let's keep

213
00:15:22,245 --> 00:15:24,385
it simple for right now.

214
00:15:25,365 --> 00:15:30,395
On the other hand, we have this applicant,
which will be our basic, unit of the user.

215
00:15:30,895 --> 00:15:36,025
So we have the first name, last
name, email, phone number, address,

216
00:15:36,385 --> 00:15:42,585
and SSN, which is stands for social
security number, which is the.

217
00:15:43,535 --> 00:15:48,425
Unique identifier for
the people with, the U.

218
00:15:48,425 --> 00:15:48,615
S.

219
00:15:48,615 --> 00:15:49,465
citizenship.

220
00:15:49,965 --> 00:15:55,275
In Poland it's called PESEL, and probably
in other countries it's a similar,

221
00:15:55,365 --> 00:16:00,315
number that is unique for this specific
country and this specific person.

222
00:16:00,815 --> 00:16:05,845
But If for example, I would apply for
the grant in the United States, I don't

223
00:16:05,915 --> 00:16:11,445
have SORA security number I can probably
ask to receive this kind of number but

224
00:16:11,945 --> 00:16:17,435
If I don't have the citizenship, probably
I don't have it, let's say, right now.

225
00:16:18,385 --> 00:16:24,865
So usually in this kind of, in this
kind of applications, we're asked for

226
00:16:24,865 --> 00:16:30,425
a different data that will also allow
us to identify this specific applicant.

227
00:16:30,925 --> 00:16:38,795
So if we don't have social security
number, maybe let's fill up birth date.

228
00:16:39,735 --> 00:16:43,465
So in this case, if we don't
have social security number,

229
00:16:43,635 --> 00:16:44,945
we provide the birth date.

230
00:16:45,265 --> 00:16:49,375
If we have social security number, we
don't need to provide the birth date.

231
00:16:49,825 --> 00:16:54,185
So in this case, let's just put
that both these values are optional.

232
00:16:54,685 --> 00:17:00,665
But this is not the only one who can ask
for a grant because also the companies

233
00:17:00,715 --> 00:17:03,145
can ask for a scientific grants.

234
00:17:03,645 --> 00:17:09,145
So in this case, we won't provide social
security number because we are asking as

235
00:17:09,145 --> 00:17:11,525
a company, not for the specific person.

236
00:17:11,885 --> 00:17:16,105
We won't have the birthdate because
the birthdate of the company

237
00:17:16,605 --> 00:17:18,735
It's not interesting for us.

238
00:17:19,235 --> 00:17:23,235
But what we can ask for is a
company name and their tax ID.

239
00:17:23,735 --> 00:17:29,195
So again, tax ID is something unique
for the company in specific country.

240
00:17:29,655 --> 00:17:34,455
So if you have that, maybe you have
the company name just to fill the form.

241
00:17:35,235 --> 00:17:37,965
Then we have the whole
object of the applicant.

242
00:17:38,465 --> 00:17:42,825
So right now we have four optional
fields, but we require that at

243
00:17:42,825 --> 00:17:47,025
least one field based on the, based
on the type of the application.

244
00:17:47,845 --> 00:17:50,795
we need to, we need that it's filled.

245
00:17:51,645 --> 00:17:53,765
So let's improve that.

246
00:17:54,265 --> 00:17:56,390
so we can start with that.

247
00:17:56,390 --> 00:17:59,590
So we have the private applicant,
which contains all the field

248
00:17:59,640 --> 00:18:01,220
with social security number.

249
00:18:01,720 --> 00:18:03,460
Yeah, that's our basic type.

250
00:18:03,960 --> 00:18:08,890
We can, have the separate, separate
type for private applicant without

251
00:18:08,890 --> 00:18:12,650
social security number, which we
don't have social security number,

252
00:18:12,650 --> 00:18:14,340
but it will have birth date.

253
00:18:14,860 --> 00:18:15,230
Okay.

254
00:18:15,890 --> 00:18:17,770
And the last one, we have
the company applicant.

255
00:18:18,270 --> 00:18:22,340
which will contains, contain the
first name, last name, email,

256
00:18:22,340 --> 00:18:25,490
phone number, address, and the
company name and the tax ID.

257
00:18:26,450 --> 00:18:30,720
And if you want to group that, so
we have applicant will be one of

258
00:18:30,720 --> 00:18:36,550
the three, three types and basically
that will work, but we are repeating

259
00:18:36,610 --> 00:18:38,980
a lot of fields in the types.

260
00:18:39,350 --> 00:18:40,040
Let's improve that.

261
00:18:40,080 --> 00:18:44,390
We don't want to repeat
ourselves dry principle, right?

262
00:18:44,890 --> 00:18:46,630
So yeah, let's improve that.

263
00:18:46,830 --> 00:18:51,690
So we'll create the base applicant
type, which will contains five fields

264
00:18:51,690 --> 00:18:54,030
that we have in all of the fields.

265
00:18:54,530 --> 00:18:58,870
So we have the base, the private
applicant, which will contains base

266
00:18:58,930 --> 00:19:00,870
applicant and the social security number.

267
00:19:01,370 --> 00:19:03,920
Private applicant without social
security number will contain

268
00:19:03,960 --> 00:19:05,850
the same and the birthdate.

269
00:19:06,770 --> 00:19:10,600
And the last one, company applicant
will contain base applicant and

270
00:19:10,600 --> 00:19:12,570
the company name and the tax ID.

271
00:19:13,120 --> 00:19:16,910
yeah, that's basically
what we can achieve.

272
00:19:17,000 --> 00:19:19,630
And we can achieve that
in any other language.

273
00:19:20,240 --> 00:19:21,700
the problem is the solution.

274
00:19:21,990 --> 00:19:23,960
Is that I don't like it.

275
00:19:24,460 --> 00:19:30,890
the biggest problem that I see in this,
in this approach is that we are not secure

276
00:19:31,060 --> 00:19:38,320
from the creating of this, base applicant
type object, because the base applicant

277
00:19:38,340 --> 00:19:44,200
itself is something that is completely
not connected with the business.

278
00:19:44,540 --> 00:19:46,160
So it creates some dummy type.

279
00:19:46,660 --> 00:19:52,400
Because we as a developer, we
don't want to repeat ourselves

280
00:19:52,770 --> 00:19:54,320
because we have a dry principle.

281
00:19:55,290 --> 00:19:59,000
But on the other hand, we are creating
something that's doesn't represent

282
00:19:59,060 --> 00:20:00,710
anything in case of the business.

283
00:20:01,060 --> 00:20:03,860
Like we cannot use base
applicant anywhere.

284
00:20:04,110 --> 00:20:09,100
We'll still need, with social
security number, with birthday, or

285
00:20:09,130 --> 00:20:11,245
with company name and the tax ID.

286
00:20:11,745 --> 00:20:15,405
And apart from that, that this
type base applicant is not

287
00:20:15,455 --> 00:20:17,575
exported outside the file.

288
00:20:18,075 --> 00:20:21,355
This is our, the only security
right now that we won't

289
00:20:21,355 --> 00:20:23,055
create an object of this type.

290
00:20:24,005 --> 00:20:29,835
When you compare that to, for example,
C sharp or Java, In this languages,

291
00:20:29,885 --> 00:20:37,255
we can create interface or abstract
class that we won't still be able

292
00:20:37,255 --> 00:20:40,675
to create the object of this type.

293
00:20:41,010 --> 00:20:45,140
We can create an object which
implements or extends this kind

294
00:20:45,140 --> 00:20:47,720
of interface or abstract class.

295
00:20:48,470 --> 00:20:53,460
So in this case, we said, okay, I know
that this object itself is more complex,

296
00:20:53,750 --> 00:20:58,890
but I want to work only on this couple
of fields with this limited number

297
00:20:58,890 --> 00:21:00,850
of fields, limited number of methods.

298
00:21:01,780 --> 00:21:05,380
And this is what, interfaces
and abstract classes are for.

299
00:21:05,830 --> 00:21:11,160
The typeface itself doesn't allow us to
do So we are creating dummy type, which

300
00:21:11,160 --> 00:21:14,990
are basically just for our convenience.

301
00:21:15,490 --> 00:21:22,450
But the problem right now that we
have some, let's say, base part that

302
00:21:22,520 --> 00:21:27,120
first of all may vary and will affect
private applicant without social

303
00:21:27,120 --> 00:21:30,933
security number and the company
applicant without our knowledge.

304
00:21:30,933 --> 00:21:31,485
Okay.

305
00:21:31,825 --> 00:21:37,445
So let's use something that DevScript
has already in the language.

306
00:21:37,945 --> 00:21:42,185
which will help us solve this
issue with creating a dummy type.

307
00:21:42,685 --> 00:21:44,725
And not repeating ourselves, of course.

308
00:21:45,225 --> 00:21:50,425
So let's start once again for a private
applicant with social security number.

309
00:21:50,995 --> 00:21:52,405
Let's take it as it is.

310
00:21:52,955 --> 00:21:54,595
This is our basic type.

311
00:21:54,915 --> 00:22:00,895
Most of our applications will be
created by private people with

312
00:22:00,895 --> 00:22:05,955
social security number, so we can
say that this is our basic type.

313
00:22:06,455 --> 00:22:09,915
If you want to create a private applicant
without social security number, we

314
00:22:09,915 --> 00:22:12,585
can, for example, use the omit type.

315
00:22:13,515 --> 00:22:18,115
Which basically takes the type
that we provide as a first

316
00:22:18,115 --> 00:22:19,735
argument of this generic type.

317
00:22:20,405 --> 00:22:27,235
And we provide the list of the fields
that we say, okay, skip this field.

318
00:22:27,735 --> 00:22:33,265
And when we have the type that is
declarative like private or pecan

319
00:22:33,305 --> 00:22:34,655
without social security number.

320
00:22:34,795 --> 00:22:35,835
So we just say, okay.

321
00:22:36,220 --> 00:22:37,570
Omit social security number.

322
00:22:37,680 --> 00:22:41,890
It's exactly what we are, we
are, we say that we will have.

323
00:22:42,690 --> 00:22:45,560
And we just add that to
the private birthdate.

324
00:22:45,950 --> 00:22:52,400
So yeah, in the background, we are
actually creating this dummy type, which

325
00:22:52,430 --> 00:22:54,270
won't have this social security number.

326
00:22:54,920 --> 00:22:59,977
But in this case, It's not
access, has access anywhere.

327
00:22:59,977 --> 00:23:06,991
We have to declare that this base
applicant omit private applic, applicants,

328
00:23:06,991 --> 00:23:11,461
social security number to be able to
export that, outside of our function.

329
00:23:11,661 --> 00:23:13,441
This way it's not access, accessible.

330
00:23:13,941 --> 00:23:18,711
In case of the private applicant,
I would recommend us to use PIP.

331
00:23:19,211 --> 00:23:25,221
First of all, because we
are taking specific fields

332
00:23:25,231 --> 00:23:26,421
from the private applicant.

333
00:23:26,921 --> 00:23:32,121
If the private applicant will receive more
fields, I won't expect that the company

334
00:23:32,121 --> 00:23:34,361
applicant will extend on their own.

335
00:23:35,031 --> 00:23:39,421
I want to have in this case, the
full control over what fields

336
00:23:39,501 --> 00:23:44,021
I'm actually putting into company
applicant to have the same type.

337
00:23:44,381 --> 00:23:47,991
The same if it's optional or not.

338
00:23:48,961 --> 00:23:53,861
And so in this case, we just take this
all five fields and let's put them.

339
00:23:54,771 --> 00:24:00,691
So in this case, we create again, the
dummy type with different way around,

340
00:24:01,271 --> 00:24:05,721
but we have a full control over which
fields are actually included in that.

341
00:24:06,221 --> 00:24:10,837
What also, provides us, let's suppose
that the private applicant type

342
00:24:10,837 --> 00:24:16,143
will change slightly that we get
rid of first and then the last name

343
00:24:16,143 --> 00:24:18,796
and change that into the full name.

344
00:24:19,296 --> 00:24:23,576
So in this case, it will affect the
private applicant without social security

345
00:24:23,576 --> 00:24:26,026
number, which also will change its type.

346
00:24:26,106 --> 00:24:29,636
So it won't have full name,
first name and the last name, and

347
00:24:29,656 --> 00:24:31,476
will also only have full name.

348
00:24:32,206 --> 00:24:36,276
But in case of the company
applicant, it will tell us an error.

349
00:24:36,776 --> 00:24:41,706
Because the compiler will say, okay,
there is no first name and last name.

350
00:24:42,206 --> 00:24:43,026
we have only full name.

351
00:24:43,526 --> 00:24:48,616
And of course, this is required,
this requires us our manual log

352
00:24:48,616 --> 00:24:50,656
that we have to update our type.

353
00:24:51,646 --> 00:24:56,396
But if there is situation that we still
want to have for the company applicant,

354
00:24:56,406 --> 00:25:00,096
the first name and the last name
separately, okay, we'll have to do it

355
00:25:00,126 --> 00:25:02,816
manually, but we'll do it either way.

356
00:25:03,316 --> 00:25:05,926
And we have full control,
full knowledge that something

357
00:25:05,936 --> 00:25:07,166
is crushing our application.

358
00:25:07,666 --> 00:25:10,056
That is the advantage of this approach.

359
00:25:10,556 --> 00:25:10,846
Okay.

360
00:25:10,996 --> 00:25:12,386
Let's leave applicant data.

361
00:25:12,816 --> 00:25:14,926
Let's move to application number.

362
00:25:15,426 --> 00:25:20,356
So in our case, let's assume that the
application number is something like that.

363
00:25:20,516 --> 00:25:24,376
So we have some code, some
numbers, slash, and the year.

364
00:25:24,876 --> 00:25:29,506
So first of all, what we can
achieve with the TypeScript?

365
00:25:30,006 --> 00:25:31,016
We can say, okay.

366
00:25:31,016 --> 00:25:31,576
That's.

367
00:25:32,076 --> 00:25:34,556
The application's number
will be just a string.

368
00:25:35,056 --> 00:25:39,976
So we can declare in the type of our whole
application that it will be a string.

369
00:25:40,466 --> 00:25:44,366
Or, we say that okay, we'll
improve that in the future.

370
00:25:44,856 --> 00:25:48,476
So maybe instead of declaring that
as a string, let's say that we

371
00:25:48,506 --> 00:25:52,316
have the type application number,
which right now it is a string.

372
00:25:52,816 --> 00:25:57,766
Maybe at first it doesn't change
anything, but later on if you

373
00:25:57,776 --> 00:26:01,376
change this type, it will also
affect all the types that you want.

374
00:26:01,896 --> 00:26:06,986
And we don't need to search, okay,
where we use string as application

375
00:26:06,986 --> 00:26:12,326
number, because it should already
affect the whole, the whole of our file.

376
00:26:12,326 --> 00:26:18,286
So first of all, we can use
something that we can say that.

377
00:26:18,671 --> 00:26:23,471
There will be like application type
codes that we declare as a list of

378
00:26:23,471 --> 00:26:29,561
the codes And we can declare the years
That will be like this five years.

379
00:26:29,571 --> 00:26:36,511
So the years when this Grant scientific
grant is actually given for the specific

380
00:26:37,031 --> 00:26:44,456
project So if we have something like
that declared We can create a type,

381
00:26:44,646 --> 00:26:50,166
which is TemplarLiteralType, which
will contains of application type,

382
00:26:50,566 --> 00:26:53,376
number, and the application year.

383
00:26:53,926 --> 00:26:54,746
how it looks like.

384
00:26:55,246 --> 00:26:59,676
So if we create this, something
like this literal, Templar,

385
00:26:59,676 --> 00:27:04,656
TemplarLiteralType, it will generate
us all the possible combinations of

386
00:27:04,656 --> 00:27:09,306
our codes, number and slash year.

387
00:27:09,806 --> 00:27:16,866
So in this case, if I, for example, change
that to 2025, it will highlight that this

388
00:27:16,866 --> 00:27:19,996
value that I'm providing is not correct.

389
00:27:20,496 --> 00:27:23,006
in case of the temporary data types.

390
00:27:23,506 --> 00:27:29,056
Again, if I don't put a number,
it will also return an error

391
00:27:29,056 --> 00:27:32,516
that this field is not correct.

392
00:27:33,016 --> 00:27:40,431
So using just this very simple native
mechanism of TypeScript, I can create

393
00:27:40,441 --> 00:27:43,211
already type validator based on that.

394
00:27:43,211 --> 00:27:46,771
I can already set, okay, this is
correct, or this is not correct.

395
00:27:46,991 --> 00:27:53,601
I can verify if this first code after,
somebody puts that manually is correct

396
00:27:53,641 --> 00:27:58,541
with this type of code, because I know
that this type, this application number

397
00:27:58,541 --> 00:27:59,971
will consist of all these fields.

398
00:28:00,386 --> 00:28:09,036
Zinac normally would need to have some
kind of complex regex, just verify that.

399
00:28:09,536 --> 00:28:16,476
TypeScript has regex included in
their language, and that's beautiful.

400
00:28:16,976 --> 00:28:22,156
Let's even improve our, our
application number type validation.

401
00:28:22,651 --> 00:28:27,101
And just play that, play with
it a little bit so we can add

402
00:28:27,381 --> 00:28:29,231
some kind of generic type.

403
00:28:29,731 --> 00:28:33,241
That's, I will just
describe that in a second.

404
00:28:33,551 --> 00:28:35,981
So we have, again, application type codes.

405
00:28:36,011 --> 00:28:40,011
We have year endings, which
generates, the ending.

406
00:28:40,071 --> 00:28:41,331
I have application year.

407
00:28:41,831 --> 00:28:46,121
so we just put something we
don't want to repeat ourselves.

408
00:28:46,811 --> 00:28:51,701
Again, and yeah, we're going to
generate the same code once again.

409
00:28:52,201 --> 00:28:54,401
and how it works basically.

410
00:28:54,901 --> 00:29:00,031
So as you can see, we just provide,
a number, which is this first

411
00:29:00,061 --> 00:29:02,111
argument of our generic type.

412
00:29:02,921 --> 00:29:08,821
We provide that we want to
receive the, array of numbers and

413
00:29:08,821 --> 00:29:11,121
what they are doing basically.

414
00:29:11,621 --> 00:29:18,621
if results of, length of this array
with results, actually extends our.

415
00:29:19,381 --> 00:29:20,051
argument.

416
00:29:20,871 --> 00:29:26,001
So basically that means that
if the results equals our

417
00:29:26,021 --> 00:29:28,301
arguments, return results.

418
00:29:28,311 --> 00:29:34,391
If not, just add additional
result to our, to our array.

419
00:29:34,741 --> 00:29:40,661
So in this case, it just generates numbers
from zero to, to the size of the array.

420
00:29:41,121 --> 00:29:43,251
And yeah, that's how it works.

421
00:29:43,751 --> 00:29:47,481
And as you can see, it's
quite dummy because it can, it

422
00:29:47,491 --> 00:29:49,441
generates us this kind of error.

423
00:29:49,941 --> 00:29:54,411
So in this case, it's better to
use it, until then not higher.

424
00:29:54,911 --> 00:29:55,231
Okay.

425
00:29:55,461 --> 00:29:56,771
Let's move to the attachments.

426
00:29:57,271 --> 00:30:04,001
with the attachments, let's declare that
we'll have three types of attachments.

427
00:30:04,041 --> 00:30:09,701
So again, we'll just use union on
the expenses, income, and the other.

428
00:30:10,661 --> 00:30:11,481
Whatever it is.

429
00:30:12,241 --> 00:30:18,261
And with the attachments, usually we
have two problems in the application.

430
00:30:18,891 --> 00:30:23,211
That the type of the uploading
the, attachments it's

431
00:30:23,241 --> 00:30:25,611
completely different from the.

432
00:30:26,321 --> 00:30:32,231
Type that we receive apartment, because
usually when we upload that, we using

433
00:30:32,231 --> 00:30:37,621
some, multipart request, just upload
the fields and upload the files.

434
00:30:38,161 --> 00:30:43,041
And in case we want to get that,
we receive your, with the file.

435
00:30:43,321 --> 00:30:44,581
so we can download that.

436
00:30:44,581 --> 00:30:49,551
Or if it image, if it is a image,
we just, Render that as an image.

437
00:30:50,271 --> 00:30:55,771
So in our case, we can have attachment
details, payload, which will contains

438
00:30:55,881 --> 00:31:00,391
the file that we'll be able to
upload, using the multiple request.

439
00:31:01,251 --> 00:31:05,141
we'll have the description,
what type of attachment it is.

440
00:31:06,051 --> 00:31:07,071
we'll have the type.

441
00:31:07,181 --> 00:31:09,271
So just this general.

442
00:31:10,236 --> 00:31:13,886
Category of the attachment and maybe
we'll have also the page count which

443
00:31:13,886 --> 00:31:18,286
will be basically the number how
many pages of this Attachment there

444
00:31:18,286 --> 00:31:23,096
is actually is So based on that, we
can verify if all the documents are,

445
00:31:24,006 --> 00:31:29,726
correctly uploaded and when we wanted
to get, the details of the attachment.

446
00:31:29,806 --> 00:31:34,346
So again, we can use the PIC that you
already know, attachment details payload.

447
00:31:34,476 --> 00:31:40,846
We take description type and page count,
and we just add firewall, fire URL.

448
00:31:41,396 --> 00:31:48,276
yeah, based on that, you can handle
both upload and post and get requests

449
00:31:48,306 --> 00:31:50,576
and post and get request data.

450
00:31:50,916 --> 00:31:54,706
Maybe even add some ID in case of
the getting the, this attachment.

451
00:31:55,206 --> 00:31:56,826
But what we can also do.

452
00:31:57,301 --> 00:32:04,201
You can add attachment name, because
usually we'll have, maybe we'll

453
00:32:04,211 --> 00:32:08,621
have some name that attachment
that's also always required, like

454
00:32:09,001 --> 00:32:11,411
CV or some motivation letter.

455
00:32:11,961 --> 00:32:17,201
but any other generic general,
attachments will have probably

456
00:32:17,201 --> 00:32:19,351
this attachment plus number.

457
00:32:19,851 --> 00:32:26,231
So we also have, we want to have
this kind of, assigned for our keys.

458
00:32:26,731 --> 00:32:34,001
And the last part, because we don't want
to create an array of the attachment, but

459
00:32:34,001 --> 00:32:36,891
we can create an object of the attachment.

460
00:32:37,391 --> 00:32:42,131
And in our case we can create an
object of the attachment name, which

461
00:32:42,131 --> 00:32:44,691
will be the key of the attachment.

462
00:32:45,556 --> 00:32:48,496
And attachment details will
just assign the object.

463
00:32:49,106 --> 00:32:51,816
in our case, we'll have
something like that.

464
00:32:51,816 --> 00:32:59,036
So we'll have, okay, so we'll have
just the object of this specific key.

465
00:32:59,366 --> 00:33:04,376
and the attachment details, which just
generates us with the, the attachment.

466
00:33:04,656 --> 00:33:08,096
And based on that, we can, for
example, access the attachment

467
00:33:08,126 --> 00:33:13,876
number two, without iterating over
array or going to the specific.

468
00:33:14,331 --> 00:33:18,371
index of the array, we just ask
for the specific, attachment and we

469
00:33:18,371 --> 00:33:20,331
can say, okay, it's present or not.

470
00:33:20,731 --> 00:33:21,261
And so on.

471
00:33:21,261 --> 00:33:25,861
so yeah, if we group that, that part, so
we have the application, which consists

472
00:33:25,861 --> 00:33:31,621
of the applicant with the applicant
data, we have application date, we have

473
00:33:31,621 --> 00:33:36,651
application number, which we created,
and we have attachments and here I

474
00:33:36,651 --> 00:33:42,711
will use the partial, because once
again, we are not required to upload

475
00:33:43,671 --> 00:33:45,501
always the same number of, attachments.

476
00:33:46,381 --> 00:33:50,861
So we would like to have this
kind of, optional for the keys.

477
00:33:51,151 --> 00:33:55,161
So we just upload only in this
attachments that we actually needed.

478
00:33:55,661 --> 00:34:02,001
And yeah, if we have the
application that has three

479
00:34:02,001 --> 00:34:03,611
actually types of the applicants.

480
00:34:04,111 --> 00:34:08,711
just to remind ourselves, the applicant,
applicant without social security number

481
00:34:09,031 --> 00:34:15,261
and the company applicant, then, and of
course, in other cases, we'll need some

482
00:34:15,301 --> 00:34:18,861
type guards, and how the types that works.

483
00:34:19,021 --> 00:34:24,091
So we can have this kind of
function is object with key, which

484
00:34:24,171 --> 00:34:27,011
basically verifies us if the object.

485
00:34:27,481 --> 00:34:33,401
Is key, if the, the, the argument that
we are providing is actually an object.

486
00:34:33,511 --> 00:34:36,201
We also verify if that is, not nullable.

487
00:34:36,701 --> 00:34:40,071
And yeah, just basically
to, to be sure about that.

488
00:34:40,551 --> 00:34:45,101
So argument that you have provided is the
unknown because we don't know what it is.

489
00:34:46,031 --> 00:34:53,141
And we return that, okay, this is
an object that has some keys and, we

490
00:34:53,141 --> 00:34:55,671
don't know what is the type of the.

491
00:34:56,256 --> 00:34:56,856
of this keys.

492
00:34:57,016 --> 00:34:59,166
So we just return, okay, it's unknown.

493
00:34:59,696 --> 00:35:03,196
so yeah, that is our return type.

494
00:35:03,696 --> 00:35:08,156
So in our case, we just verify if
the applicant that we are providing

495
00:35:08,186 --> 00:35:09,516
is actually a private applicant.

496
00:35:10,416 --> 00:35:14,511
So in our case, We can say,
okay, is a private applicant.

497
00:35:14,521 --> 00:35:18,921
So we verify that if we provide
an applicant, which is unknown, we

498
00:35:18,921 --> 00:35:22,031
can provide an applicant that is
application that will also work.

499
00:35:22,801 --> 00:35:25,521
we say, okay, applicant
is a private applicant.

500
00:35:26,021 --> 00:35:29,311
So in our case, we just
verify if the applicant has.

501
00:35:29,811 --> 00:35:34,261
This object with the keys and
does it has, this property social

502
00:35:34,261 --> 00:35:37,911
security number because it was
unique for our private applicant.

503
00:35:38,711 --> 00:35:42,301
Of course, we can verify multiple
fields, in this type guard.

504
00:35:42,751 --> 00:35:45,761
In our case, social
security number is unique.

505
00:35:45,771 --> 00:35:48,901
And I decided that, okay, the type
that is solved will be sufficient.

506
00:35:48,951 --> 00:35:53,621
If we verify the social security
number, what it gives us, let's

507
00:35:53,621 --> 00:35:55,601
look at a look at the example.

508
00:35:56,051 --> 00:36:00,721
so I make it a little bit simpler
just to fit them on one screen.

509
00:36:01,251 --> 00:36:04,511
so we have a type private
application, which will contains

510
00:36:04,531 --> 00:36:06,251
only the social security number.

511
00:36:06,301 --> 00:36:08,401
So we don't need any other fields.

512
00:36:08,401 --> 00:36:08,691
Okay.

513
00:36:08,961 --> 00:36:13,351
And our applicant will be
private applicant or string.

514
00:36:14,171 --> 00:36:19,261
so yeah, we want to verify that first
of all, it's an object and not a string.

515
00:36:19,451 --> 00:36:22,861
And the first and the second thing
that we wanted to verify if this

516
00:36:22,861 --> 00:36:24,321
is actually social security number.

517
00:36:24,861 --> 00:36:27,371
so yeah, we have the same function.

518
00:36:27,871 --> 00:36:29,231
And what it gives us?

519
00:36:29,941 --> 00:36:34,121
If you have the method that say
printApplicant, it's not very complex,

520
00:36:34,621 --> 00:36:39,081
and we have an argument of this function,
and that is string or privateApplicant.

521
00:36:39,581 --> 00:36:46,561
And we have the if clause, which right now
they know that, okay, it is an applicant.

522
00:36:46,561 --> 00:36:51,231
And, but when we enter on this
method, so inside of this,

523
00:36:52,216 --> 00:36:56,786
scope, the type, you already know
that this is private applicant.

524
00:36:57,286 --> 00:36:59,716
It will say that, okay,
yeah, that's right.

525
00:36:59,766 --> 00:37:00,976
It's a private applicant.

526
00:37:01,826 --> 00:37:03,976
If we, add additional.

527
00:37:04,111 --> 00:37:08,391
line here, and we will say, okay,
applicant, let me just verify that.

528
00:37:08,641 --> 00:37:14,501
Yeah, because it's outside our if
clause, it's actually in the else clause.

529
00:37:14,551 --> 00:37:15,761
It knows right now.

530
00:37:15,761 --> 00:37:16,231
Okay.

531
00:37:16,616 --> 00:37:19,996
It is a string, not a private applicant.

532
00:37:20,846 --> 00:37:24,946
if we just go, beyond that,
okay, I will just remove that.

533
00:37:25,446 --> 00:37:28,331
So again, outside of the, if.

534
00:37:28,961 --> 00:37:32,101
TypeScript doesn't know what
it is, if it's a private

535
00:37:32,161 --> 00:37:33,521
topic on this, of the string.

536
00:37:34,271 --> 00:37:40,131
So again, if we just try to use that,
especially in this complex types, and

537
00:37:40,131 --> 00:37:45,471
then the types we already will say that,
okay, we are not sure what type of method

538
00:37:45,561 --> 00:37:52,231
it is, even though somewhere in the
back, before we execute this function,

539
00:37:52,231 --> 00:37:54,091
we know, okay, this is something else.

540
00:37:54,591 --> 00:37:58,581
the types of itself needs to be certain
and we'll just return those error.

541
00:37:58,731 --> 00:38:02,301
We can fix that before
checking that on the code.

542
00:38:02,801 --> 00:38:03,071
Okay.

543
00:38:03,571 --> 00:38:08,541
so let's look in another helpful,
additional national type.

544
00:38:09,271 --> 00:38:10,506
in case of the hour.

545
00:38:11,351 --> 00:38:16,581
Application will have the fields
that are not changeable at all.

546
00:38:17,081 --> 00:38:18,341
And we want to maintain that.

547
00:38:18,461 --> 00:38:21,011
And to do so we have the read only.

548
00:38:21,881 --> 00:38:29,341
so in, let's say our basic type, so we
have read only and again, we have the

549
00:38:30,031 --> 00:38:31,751
application number if you wanted to.

550
00:38:32,251 --> 00:38:37,241
to change the value, to override that,
TypeScript will tell us we can't do that.

551
00:38:37,241 --> 00:38:46,321
So in our case, We'll have the situation
that we have the whole application

552
00:38:46,351 --> 00:38:53,351
completed and somebody will verify it's
correct and later on just assign, okay,

553
00:38:53,351 --> 00:38:55,311
it's correct, give them money or not.

554
00:38:55,881 --> 00:39:01,021
So we would want our whole
application to be read only.

555
00:39:01,481 --> 00:39:04,421
And only the verification
date, verification status.

556
00:39:04,421 --> 00:39:05,741
And who verified that?

557
00:39:06,241 --> 00:39:09,691
Which are the only fields
that you want to be read?

558
00:39:09,791 --> 00:39:13,031
to be, not read only,
and all of the others.

559
00:39:13,031 --> 00:39:14,501
We wanted to stay at the same.

560
00:39:14,921 --> 00:39:20,081
We want, we don't want anyone to
edit our fields, so in our case,

561
00:39:20,771 --> 00:39:24,551
in our application, we can force
that the argument that we provided,

562
00:39:24,551 --> 00:39:26,186
the methods will be written only.

563
00:39:26,686 --> 00:39:31,466
And only specific fields will be
actually editable inside of this method.

564
00:39:31,966 --> 00:39:37,326
So again, we can make sure that
nobody change, change the fields

565
00:39:37,326 --> 00:39:38,936
that you don't want them to change.

566
00:39:39,436 --> 00:39:46,846
The last thing that I wanted to show you,
is creating a draft because the grant

567
00:39:46,856 --> 00:39:53,826
submissions are usually quite long, to
write that it requires a lot of time.

568
00:39:54,326 --> 00:40:00,076
And even if you start uploading that
into the system, maybe you receive the

569
00:40:00,076 --> 00:40:05,526
information that something is missing and
you have to abandon the process, to gather

570
00:40:05,556 --> 00:40:10,326
the documents, maybe from your university,
maybe it's from somewhere else.

571
00:40:10,326 --> 00:40:16,588
and yeah, you will need to go back
to that after a couple of days.

572
00:40:17,348 --> 00:40:22,318
So in this case, The draft
functionality will be very important

573
00:40:22,628 --> 00:40:24,438
in our case of the application.

574
00:40:24,938 --> 00:40:28,208
So how we can do that with the TypeScript?

575
00:40:28,708 --> 00:40:30,908
so we can create something like that.

576
00:40:31,078 --> 00:40:36,838
So we'll have the applicant, which
will have first name, last name, email,

577
00:40:36,878 --> 00:40:38,978
address, and social security number.

578
00:40:39,478 --> 00:40:43,908
We have the follower application,
which contains applicant, application

579
00:40:43,908 --> 00:40:46,598
date, and some application number.

580
00:40:46,668 --> 00:40:47,728
Let's keep it simple.

581
00:40:48,228 --> 00:40:53,378
and we can create our own type,
generic type that is called Nullable,

582
00:40:53,788 --> 00:40:58,318
which contains null or our, argument.

583
00:40:58,818 --> 00:41:04,118
Later on, we can create a
DeepNullable, which for each.

584
00:41:04,973 --> 00:41:10,523
key in our type, deep nullable
of deep nullable of our, key.

585
00:41:11,293 --> 00:41:16,483
In this case, all of the fields
in our tree will be nullable.

586
00:41:16,903 --> 00:41:21,753
So we can create an object that
will, for example, will be have,

587
00:41:21,973 --> 00:41:25,893
will have, nullable application
date, nullable application number.

588
00:41:26,393 --> 00:41:31,393
Nullable first name, last name, email,
social security number, but in the address

589
00:41:31,393 --> 00:41:33,803
we'll have only field, for example, city.

590
00:41:34,303 --> 00:41:40,663
With these four lines, actually
we create very powerful type that

591
00:41:40,693 --> 00:41:42,703
will allow us to make a magic.

592
00:41:43,003 --> 00:41:47,431
Of course, there are still challenges
how you're going to save that into

593
00:41:47,431 --> 00:41:49,932
the browser or even into the server.

594
00:41:49,932 --> 00:41:52,433
If you have all the fields nullable.

595
00:41:52,733 --> 00:41:57,423
but yeah, from the directory
point of view, four lines and

596
00:41:57,423 --> 00:42:00,153
you have very powerful field.

597
00:42:00,653 --> 00:42:05,233
You can even change that from null to
undefined, and then we don't have to

598
00:42:05,233 --> 00:42:07,323
provide all the nulls, just one field.

599
00:42:07,823 --> 00:42:11,953
Somewhere in the, in the
background that will be filled.

600
00:42:12,453 --> 00:42:15,293
so I have two key takeaways for you.

601
00:42:15,293 --> 00:42:18,583
use advanced types to
create complex types.

602
00:42:19,083 --> 00:42:23,153
Because, there are tools that you
should use, and they are very powerful.

603
00:42:23,723 --> 00:42:27,553
And typeguards allows for
safe and fast typechecks.

604
00:42:28,053 --> 00:42:34,293
Again, If you're, for example, verifying
even the API calls on your local

605
00:42:34,293 --> 00:42:41,713
development, if after verifying the type
that you receive from API, you receive

606
00:42:41,713 --> 00:42:46,663
an error locally, you're still benefiting
because very fast, you received the

607
00:42:46,663 --> 00:42:51,183
information, okay, something changed, some
field is missing, some field changed type.

608
00:42:51,683 --> 00:42:54,693
And you will be able to
update that very fast.

609
00:42:55,223 --> 00:42:55,463
yeah.

610
00:42:55,523 --> 00:42:56,183
Sources.

611
00:42:56,683 --> 00:43:01,933
so first of all is the whole, story
from ScriptSharp to JavaScript.

612
00:43:02,433 --> 00:43:07,953
and the other thing is TypeScript
documentation of TypeScript 5 Minutes,

613
00:43:07,963 --> 00:43:11,293
which contains all the advanced types.

614
00:43:11,793 --> 00:43:13,203
some of them I just highlighted.

615
00:43:13,253 --> 00:43:17,833
I think that there are the most
popular, at least in my code.

616
00:43:18,333 --> 00:43:21,353
but yeah, maybe there is something
else that's, that is there.

617
00:43:21,728 --> 00:43:26,908
And that you feel stuff in that's,
maybe it's useful, it's better to use

618
00:43:26,908 --> 00:43:29,808
something that's already there in the
language rather than write it yourself.

619
00:43:30,308 --> 00:43:30,798
Yeah.

620
00:43:31,298 --> 00:43:31,728
Thank you.

621
00:43:31,788 --> 00:43:32,618
That's all from me.

622
00:43:33,118 --> 00:43:34,328
Do you have any questions?

