1
00:00:00,500 --> 00:00:01,309
Hello everyone.

2
00:00:02,150 --> 00:00:07,340
I'm Chen Kabul from College of
Technology, pan India, and today I'll

3
00:00:07,340 --> 00:00:11,809
be talking about building zero trust,
security infrastructure, and rust.

4
00:00:12,309 --> 00:00:16,779
I will walk you through what zero trust
means and some of the fundamentals of it.

5
00:00:17,279 --> 00:00:19,740
What advantages does
bring to this problem?

6
00:00:20,240 --> 00:00:23,149
We'll also go through some of the
building blocks, just provide to

7
00:00:23,149 --> 00:00:24,679
build a secure infrastructure.

8
00:00:25,179 --> 00:00:29,499
Then we'll look at some implementation
patterns and close with some performance

9
00:00:29,499 --> 00:00:31,719
numbers from real world implementations.

10
00:00:32,220 --> 00:00:36,800
Let's start by looking at zero trust
security fundamentals in today's

11
00:00:36,905 --> 00:00:41,434
threat landscape of sophisticated
threat actors and our advent of ai.

12
00:00:42,065 --> 00:00:45,394
We have to always assume a brief
scenario for any system infrastructure.

13
00:00:45,894 --> 00:00:49,044
This pushes us to lay down some
ground rules for zero trust.

14
00:00:49,544 --> 00:00:53,675
First and foremost, we cannot
trust without verifying

15
00:00:53,675 --> 00:00:54,994
the idea of any component.

16
00:00:55,494 --> 00:00:59,844
Always design access using lease privilege
access, and have a very high standard

17
00:00:59,844 --> 00:01:04,344
from monitoring and validation to detect
what's happening in your ecosystem.

18
00:01:04,844 --> 00:01:08,804
Now with the background of what we
intend to achieve, let's see what Rust

19
00:01:08,804 --> 00:01:11,444
has to offer when it comes to security.

20
00:01:11,944 --> 00:01:16,684
First and foremost, systems built using
Rust gets advantage of rust ownership

21
00:01:16,684 --> 00:01:22,834
model, which prevent memory vanities,
like buffer workflows and use after free.

22
00:01:23,334 --> 00:01:26,514
This is a big trust advantage
for systems built using rust.

23
00:01:27,014 --> 00:01:27,345
Rust.

24
00:01:27,345 --> 00:01:31,095
Also provide predictable performance,
which helps with real time security

25
00:01:31,095 --> 00:01:35,205
decisions using metrics and other
telemetry the ecosystem provides.

26
00:01:35,705 --> 00:01:39,335
Next, let's talk about rust string
type system, which help perform

27
00:01:39,335 --> 00:01:42,335
compile time checks for critical
controls like authentication.

28
00:01:42,835 --> 00:01:46,615
Another advantage of Rust is the
security abstractions provided by

29
00:01:46,615 --> 00:01:51,054
the language for fast and effective
operations when it comes to cryptography,

30
00:01:51,174 --> 00:01:58,074
authentication, and authorizations, which
is critical to build a secure ecosystem.

31
00:01:58,574 --> 00:02:02,504
Rust safety guarantees and
performance characteristics makes

32
00:02:02,504 --> 00:02:06,044
it as ideal choice for a zero
trust architecture implementation.

33
00:02:06,544 --> 00:02:11,974
Now let's dive into some of the components
which will help us build for zero trust.

34
00:02:12,474 --> 00:02:17,034
These rest components are the
building blocks of foundation security

35
00:02:17,244 --> 00:02:21,204
and helps developers and security
engineers achieve their goals.

36
00:02:21,704 --> 00:02:24,284
I have broken these components
into three categories.

37
00:02:24,784 --> 00:02:27,004
First, networking and TLS.

38
00:02:27,504 --> 00:02:33,894
Tokyo Russ, TLS Web PKI, and Quinn
helps developer build for secure channel

39
00:02:33,894 --> 00:02:38,814
implementation with high performance
and memory safety TLS implementations

40
00:02:39,314 --> 00:02:44,414
on the authentication and IT side
Russ Ring and organ two provides the

41
00:02:44,419 --> 00:02:45,899
primitive for strong authentication.

42
00:02:46,399 --> 00:02:51,619
JSON Web Open and or two RS components
help build industry standard

43
00:02:51,949 --> 00:02:53,869
authentication mechanism with ease.

44
00:02:54,369 --> 00:02:58,749
Last, but one of the most important
aspect of security in infrastructure

45
00:02:58,809 --> 00:03:03,159
is default network libraries
and observative capabilities.

46
00:03:04,149 --> 00:03:06,754
Hyper end Tower provides
a robust networking stack.

47
00:03:07,359 --> 00:03:10,779
While tracing and metrics provides
rich performance and diagnostic

48
00:03:10,779 --> 00:03:14,469
data for a solid foundation
for monitoring and detections,

49
00:03:14,969 --> 00:03:17,969
we just talked about how you can
use some of Rust core components

50
00:03:17,969 --> 00:03:19,709
to build a secure software stack.

51
00:03:20,209 --> 00:03:23,899
Now let's talk about a critical
NT of zero trust architecture, and

52
00:03:23,899 --> 00:03:25,684
that is identity aware proxies.

53
00:03:26,184 --> 00:03:30,264
As I mentioned in my opening, one of the
fundamentals of Zero Trust architecture

54
00:03:30,294 --> 00:03:36,264
is verifying the caller and perform
fine, gain authorization decisions, and

55
00:03:36,264 --> 00:03:38,874
also enforce policy based on context.

56
00:03:39,374 --> 00:03:43,184
Rush provides a perfect ecosystem for
search architecture implementation

57
00:03:43,454 --> 00:03:47,134
with components like Tower as
a middleware choice also, rush

58
00:03:47,464 --> 00:03:49,264
trade system is a perfect choice.

59
00:03:49,834 --> 00:03:54,514
Choice for a type safe policy
implementation, which also enables

60
00:03:54,514 --> 00:03:58,924
compile time verification of policy
logic, providing very high security

61
00:03:58,924 --> 00:04:05,484
assurance for policy checks, and best
part is there are no runtime surprises.

62
00:04:05,984 --> 00:04:08,564
We touched on the importance
of observability for a

63
00:04:08,564 --> 00:04:09,449
zero trust architecture.

64
00:04:09,949 --> 00:04:14,809
Rust metrics and tracing libraries
makes metric data gathering a breeze

65
00:04:15,169 --> 00:04:19,399
and comes with a high performance
benefit, which enables almost real

66
00:04:19,459 --> 00:04:23,929
time analysis of metric data for
faster detections without penalizing

67
00:04:23,929 --> 00:04:26,479
the performance of our applications.

68
00:04:26,979 --> 00:04:32,599
Anomaly detection becomes so much better
when you use metrics, data, and rust.

69
00:04:33,099 --> 00:04:36,250
Now let's dive a little deeper
for the secure communication,

70
00:04:36,250 --> 00:04:37,570
implementation and Rust.

71
00:04:38,070 --> 00:04:42,090
As I mentioned earlier, rust, TLS is
a great candidate for memory Safet,

72
00:04:42,090 --> 00:04:47,370
LS implementation, which comes with
high performance and eliminates a

73
00:04:47,370 --> 00:04:52,470
whole suit of ities, which can be
found in other S implementations.

74
00:04:53,220 --> 00:04:54,990
Definitely a big win here.

75
00:04:55,490 --> 00:04:59,155
Web PK ensures that certificate
validation for secure communication

76
00:04:59,155 --> 00:05:04,045
is per RFC standards without a risk
of wrong configurations and possible

77
00:05:04,045 --> 00:05:09,405
authentication, bypass van liberties
and Quinn adds the cherry on top.

78
00:05:09,435 --> 00:05:14,625
If you want to implement quick protocol
for high performance and security, I would

79
00:05:14,625 --> 00:05:16,635
highly increase to have a look at that.

80
00:05:17,135 --> 00:05:22,505
Overall rush library ecosystem offered its
strong typing, compiled time detections

81
00:05:22,505 --> 00:05:28,835
of errors makes it a perfect choice for
implementing error free and robust secure

82
00:05:28,835 --> 00:05:33,965
communication platform and fulfills the
foundation needed for a zero trust system.

83
00:05:34,465 --> 00:05:38,750
Now let's dive into the complex world of
supply chain security, which has caused

84
00:05:38,750 --> 00:05:40,790
some of the biggest breaches of our times.

85
00:05:41,290 --> 00:05:43,900
You must have definitely had of
SolarWinds and how a third party

86
00:05:43,900 --> 00:05:48,560
developer system can compromise
security of overall secure system.

87
00:05:49,060 --> 00:05:53,200
Rust cargo ecosystem ships with
all the tooling needed to maintain

88
00:05:53,200 --> 00:05:57,190
secure dependencies and ensuring
supply chain developes are accounted

89
00:05:57,190 --> 00:05:58,960
for while building the environment.

90
00:05:59,460 --> 00:06:03,390
Definitely an amazing advantage
and make supply chain security

91
00:06:03,390 --> 00:06:05,460
management less complex to implement.

92
00:06:05,960 --> 00:06:09,260
Let's quickly look into some of
the performance characteristic of

93
00:06:09,860 --> 00:06:13,630
rusts implementations, as there
is often a concern that security

94
00:06:13,630 --> 00:06:15,460
comes with a performance price.

95
00:06:15,960 --> 00:06:20,760
As you can see, that rust high
performance on JW validation with

96
00:06:21,000 --> 00:06:23,160
a latency of just 0.3 millisecond.

97
00:06:23,660 --> 00:06:27,870
Ability to make conference secure
connections at a high scale

98
00:06:28,370 --> 00:06:31,960
and the a high availability.

99
00:06:32,460 --> 00:06:37,290
High availability provided by no GC
pause in memory related crashes makes

100
00:06:37,290 --> 00:06:41,070
it a perfect choice for implementing
components for zero test architecture.

101
00:06:41,570 --> 00:06:44,375
Trust proxy is a perfect example
of such an implementation.

102
00:06:44,875 --> 00:06:48,865
I would highly encourage to look at
Cloudflare's Spin Gora for such an

103
00:06:48,865 --> 00:06:53,995
implementation and how CloudFlare has
achieved higher security and performance

104
00:06:53,995 --> 00:06:59,635
at the same time, and providing the best
in class proxy for forest consumers.

105
00:07:00,135 --> 00:07:05,385
Let's talk about some of the key takeaways
from our presentation before we close.

106
00:07:05,885 --> 00:07:09,905
Rest brings lot to the table when it comes
to building security sensitive workloads.

107
00:07:09,934 --> 00:07:11,284
Critical for zero trust.

108
00:07:11,784 --> 00:07:12,775
First compiled.

109
00:07:12,775 --> 00:07:16,705
Time enforcement is a superpower
when it comes to security assurances.

110
00:07:17,205 --> 00:07:20,385
Second, you don't need to
compromise and performance.

111
00:07:20,885 --> 00:07:25,444
And third, the ecosystem continues
to mature when it comes to

112
00:07:25,444 --> 00:07:27,034
security focus, implementation.

113
00:07:27,455 --> 00:07:30,575
And there is lot of open source
contributions in this space.

114
00:07:31,075 --> 00:07:33,745
I will highly encourage all of
you to evaluate your current

115
00:07:33,745 --> 00:07:37,525
stack for bottlenecks related to
authentication performance, secure

116
00:07:37,525 --> 00:07:41,925
communication performance, and also
vulnerability is in those stacks,

117
00:07:42,105 --> 00:07:44,010
and evaluate rust for those needs.

118
00:07:44,960 --> 00:07:46,905
I'm sure you'll not be disappointed.

119
00:07:47,405 --> 00:07:52,055
Thanks for listening my talk, and I
wish you best in your security journey.

