1
00:00:00,500 --> 00:00:01,400
Hello everyone.

2
00:00:01,900 --> 00:00:03,489
Welcome to conference 42.

3
00:00:04,420 --> 00:00:11,355
My name is AU and I am a lead Guidewire
developer at Marque Technology Solutions.

4
00:00:11,705 --> 00:00:13,350
It's an honor to be here.

5
00:00:13,850 --> 00:00:20,470
Building high performance financials
with, I'm going talk about claims

6
00:00:20,470 --> 00:00:23,560
management scale with high performance.

7
00:00:23,830 --> 00:00:31,180
Financial is great for a, it allows
each developing or generating open

8
00:00:31,325 --> 00:00:33,765
A PA documents and clients as well.

9
00:00:34,265 --> 00:00:40,155
Both inbound and outbound
services actually is not a direct

10
00:00:40,155 --> 00:00:45,285
programming language, but involves
the claims management if it comes

11
00:00:45,285 --> 00:00:47,895
to administration and management.

12
00:00:48,535 --> 00:00:48,615
Rush

13
00:00:49,115 --> 00:00:49,505
Financial.

14
00:00:50,005 --> 00:00:51,485
Handling annual.

15
00:00:51,985 --> 00:00:57,145
So the agenda, so what is, how impacts
on financial services when it comes to

16
00:00:57,145 --> 00:01:02,589
the impact on financial services, the
main financial service for imperative?

17
00:01:02,979 --> 00:01:06,880
So understanding the unique challenges
of building mission critical

18
00:01:06,880 --> 00:01:10,229
financial APIs, and while legacy.

19
00:01:10,530 --> 00:01:11,520
Approaches fall shut.

20
00:01:12,030 --> 00:01:17,430
So when it comes to legacy in-house
projects, there are a lot of complexities

21
00:01:17,640 --> 00:01:19,590
when to fit into the digital world.

22
00:01:20,040 --> 00:01:25,420
So to fulfill this one, so Rashti is
introduced high perform microservices

23
00:01:25,575 --> 00:01:28,150
and APIs so that we can achieve.

24
00:01:28,650 --> 00:01:33,469
Key advantages for financial
applications exploring memory safety.

25
00:01:33,859 --> 00:01:38,100
So here when you're creating
the objects and mal the.

26
00:01:38,600 --> 00:01:44,780
Collection so it'll be more safety that
it'll out reving from both directions

27
00:01:45,139 --> 00:01:48,219
and obstruction once everywhere.

28
00:01:48,219 --> 00:01:52,289
We're using the same so that
it'll give obstruction and

29
00:01:52,289 --> 00:01:54,690
fearless con in financial context.

30
00:01:55,109 --> 00:01:58,440
So when it comes, like
earlier, we are having.

31
00:01:58,924 --> 00:02:02,834
Concurrent exceptions with
multi parallel tradings.

32
00:02:02,954 --> 00:02:05,504
So every time it'll get deadlock.

33
00:02:05,804 --> 00:02:11,054
So this, we are going to pay like the
fearless con in financial context, so

34
00:02:11,264 --> 00:02:15,704
you won't get such type of complexities
when it comes to real performance

35
00:02:15,704 --> 00:02:19,784
metrics and case studies with rush
examining concrete outcomes from

36
00:02:19,784 --> 00:02:24,864
rush forward claims management system
crossing three $50 billion annually.

37
00:02:25,364 --> 00:02:25,574
Yeah.

38
00:02:25,694 --> 00:02:29,434
So when it comes to implementation
partners and integration strategies

39
00:02:29,804 --> 00:02:34,634
but practical approaches for building
and developing Rush financial APAs in

40
00:02:34,634 --> 00:02:38,984
production environments when it comes
to the security and compliance and

41
00:02:38,984 --> 00:02:44,099
future directions rush is giving clear
man clear path to address financial

42
00:02:44,099 --> 00:02:46,909
specific security requirements and for.

43
00:02:47,409 --> 00:02:52,059
So it is giving the clear path
so that we'll get the security

44
00:02:52,134 --> 00:02:54,114
as well as the future directions.

45
00:02:54,614 --> 00:02:58,274
Yes, we discussed what is the imperative
in the performance perspective.

46
00:02:58,484 --> 00:03:03,914
So we already discover, we already in the
last page, we have seen that it'll give

47
00:03:03,914 --> 00:03:08,725
the, zero complexity when it comes to the
threat safety and the speed requirement.

48
00:03:09,054 --> 00:03:14,545
So today's world, everyone is follow the
agile methodologies so that these rushed

49
00:03:15,204 --> 00:03:19,495
knowledge, support, like if you see any
product we are getting with the libraries.

50
00:03:19,515 --> 00:03:20,325
It has Yes.

51
00:03:20,325 --> 00:03:20,834
Skeleton.

52
00:03:21,104 --> 00:03:25,434
So we are going to use
that as a customization.

53
00:03:25,514 --> 00:03:29,164
So that like in case of speed
require modern customers expect

54
00:03:29,164 --> 00:03:33,479
instant claim decisions and immediate
fund access while companies.

55
00:03:33,979 --> 00:03:39,109
Operations, so especially in the
claims management to process.

56
00:03:39,609 --> 00:03:40,509
Pending approval.

57
00:03:40,899 --> 00:03:42,789
From there, it'll go awaiting submission.

58
00:03:42,789 --> 00:03:46,399
From there, it'll go for issues,
then it'll go to the clearance.

59
00:03:46,729 --> 00:03:51,184
So the process, it'll take at
least three to 10 business days.

60
00:03:51,544 --> 00:03:56,409
Now this one with rush, the speed
requirements in the sense like

61
00:03:56,409 --> 00:04:00,364
subsecond best ones we're receiving,
of course, like the clearance

62
00:04:00,364 --> 00:04:02,134
and all eight through batches.

63
00:04:02,134 --> 00:04:02,794
It'll happen.

64
00:04:03,139 --> 00:04:07,369
So probably we'll get in a day or shorter.

65
00:04:07,759 --> 00:04:12,169
But when it comes to the security
imperative, trust systems handling

66
00:04:12,499 --> 00:04:15,679
billions in transactions required
bullet through protection against

67
00:04:16,579 --> 00:04:21,079
increasingly sophisticated attacks,
targets, memory vulnerabilities.

68
00:04:21,589 --> 00:04:24,879
So with, especially if you're
taking insurance domain.

69
00:04:25,119 --> 00:04:27,259
So we are reading the security.

70
00:04:27,774 --> 00:04:31,724
Is o for example, if you're doing any
change in the claim or if you're adding

71
00:04:31,724 --> 00:04:37,544
some coverage or modifying something in
the fields of exposure or in the process

72
00:04:37,544 --> 00:04:43,094
of check immediately the change will go
to the is o from the ISO, again, there

73
00:04:43,094 --> 00:04:49,334
are s like Lexi and other services so
that we'll get that if fraudulent claim

74
00:04:50,024 --> 00:04:52,224
response, we we receive that response.

75
00:04:52,724 --> 00:04:54,644
We can say like security.

76
00:04:55,274 --> 00:04:58,934
That means we had security
wise, good performance.

77
00:04:59,499 --> 00:05:06,189
Yeah, so reliability mandates,
so fi financials must 99.99%.

78
00:05:06,459 --> 00:05:13,199
Sometimes we can say hundred percent,
but in real world, up to some 99.

79
00:05:14,144 --> 00:05:18,854
So uptime by crossing millions of
daily transactions with perfect

80
00:05:19,544 --> 00:05:23,654
data across distributed systems
if something is getting failing.

81
00:05:24,014 --> 00:05:26,629
So entire world is faced problems.

82
00:05:26,839 --> 00:05:28,379
We have seen that recently.

83
00:05:28,739 --> 00:05:32,139
And their emergency,
all rights are delayed.

84
00:05:32,469 --> 00:05:36,189
So these type of things in
the financial sector with rush

85
00:05:36,189 --> 00:05:37,839
to, it was never happened.

86
00:05:38,229 --> 00:05:42,684
Scale challenges, modern claim systems
must handle, as I said, like 26

87
00:05:42,684 --> 00:05:44,649
million plus daily results request.

88
00:05:45,059 --> 00:05:48,779
While maintaining the sub hundred
milliseconds response times

89
00:05:48,779 --> 00:05:50,399
across global infrastructure.

90
00:05:51,029 --> 00:05:56,429
So all the legacy systems they
have implemented with core

91
00:05:56,429 --> 00:06:01,129
technologies like Java, net, Python,
they struggle a lot of issues.

92
00:06:01,489 --> 00:06:06,429
And sometimes they're not meeting their
demands without significant oring.

93
00:06:07,134 --> 00:06:11,304
Creating cost inefficiencies and
reliability gaps that directly

94
00:06:11,304 --> 00:06:12,774
impact business outcomes.

95
00:06:12,834 --> 00:06:16,344
Financial institutions need a
fundamentally different approach

96
00:06:16,344 --> 00:06:20,444
to APA development, so why
rushed for financial services?

97
00:06:20,774 --> 00:06:26,004
As I said rush in any combination
performance and safety guarantees that

98
00:06:26,004 --> 00:06:31,229
may makes it exceptionally well suited for
mission critical financial applications.

99
00:06:31,729 --> 00:06:39,839
Eliminate classes of memory error without
performance, preventing workflows and

100
00:06:39,839 --> 00:06:43,639
user after vulnerabilities systems in.

101
00:06:44,139 --> 00:06:48,009
C plus there we have introduced
object oriented program.

102
00:06:48,249 --> 00:06:52,309
That means usually the garbage
collection whenever we're performing

103
00:06:52,309 --> 00:06:56,979
small operation within the method,
when you go to the control there

104
00:06:57,029 --> 00:07:00,029
intentionally it'll create the object.

105
00:07:00,599 --> 00:07:04,049
So it'll fill once, it'll fulfill
that business logic, immediately,

106
00:07:04,049 --> 00:07:06,069
it'll get off from that method.

107
00:07:06,994 --> 00:07:11,254
The, all the variables which are
used inside method is G collected.

108
00:07:11,254 --> 00:07:15,334
It'll get freed the memory, so
that memory will be used upcoming.

109
00:07:15,394 --> 00:07:17,764
But the next statement, execution.

110
00:07:17,944 --> 00:07:19,564
There we are creating the new object.

111
00:07:19,624 --> 00:07:23,524
Those objects will again use and
the same process will follow.

112
00:07:24,429 --> 00:07:25,869
And the zero cost obstruction.

113
00:07:25,869 --> 00:07:30,684
If you see as I said we're having
like in case of claims or policy

114
00:07:30,684 --> 00:07:32,484
or billing or contact manager.

115
00:07:32,994 --> 00:07:37,174
So there is couple of products, like
especially one of the leading product

116
00:07:37,174 --> 00:07:39,304
is Guidewire and certainly we have.

117
00:07:39,804 --> 00:07:40,734
Some other competitors.

118
00:07:41,314 --> 00:07:44,284
But here they're providing
the zero cost abstraction.

119
00:07:44,284 --> 00:07:47,944
That means everything they have
defined, so we need to customize the

120
00:07:47,944 --> 00:07:53,694
code, what they have provided with that
typecast so we won't get more issues.

121
00:07:53,814 --> 00:07:55,139
That's what we're saying zero cost.

122
00:07:55,489 --> 00:07:56,939
Even if you're customizing.

123
00:07:56,939 --> 00:08:01,304
Finally it has to go the so type,
so that time we won't get any

124
00:08:01,304 --> 00:08:03,404
issues like the compatibility.

125
00:08:03,604 --> 00:08:03,994
Issues.

126
00:08:04,664 --> 00:08:08,644
So when it comes to the abstractions,
I can build high level business

127
00:08:08,644 --> 00:08:10,054
logic without performance.

128
00:08:10,174 --> 00:08:15,164
So taking any performance so we can
get good performance abstraction

129
00:08:15,674 --> 00:08:19,874
con, as I said, like there is no
dead in the performance issues and

130
00:08:19,969 --> 00:08:22,009
no hanging out the application.

131
00:08:22,244 --> 00:08:25,444
We subsecond response for
each and every request.

132
00:08:25,764 --> 00:08:29,844
So even if you're 26 million
of request every day.

133
00:08:30,234 --> 00:08:34,154
So without concurrent issues, we can Yeah.

134
00:08:34,454 --> 00:08:39,119
Driven development complex rules
in the system, making invalid

135
00:08:39,119 --> 00:08:41,679
states and representable.

136
00:08:42,179 --> 00:08:43,829
Error before deployment.

137
00:08:44,219 --> 00:08:48,529
So most of the tribe day one
things are handled at the time.

138
00:08:49,449 --> 00:08:56,189
If you're expecting the application kind
of errors, those things, they're making it

139
00:08:56,189 --> 00:08:59,879
as invalid and the forcing has requested.

140
00:08:59,999 --> 00:09:02,399
So to perform the correctly.

141
00:09:02,899 --> 00:09:08,119
Of safety and for whom has led adoption
by major financial institutions

142
00:09:08,359 --> 00:09:10,249
for mission critical a P Systems.

143
00:09:10,749 --> 00:09:14,229
So what is the measurable
impact on performance metrics?

144
00:09:14,769 --> 00:09:19,809
So now if you see that like the crossing
time, it's rejected from the Lexi system.

145
00:09:19,809 --> 00:09:26,259
So the digital world with rushed,
it's almost 85% reduction that time

146
00:09:26,259 --> 00:09:30,849
so that we'll get the performance,
yes Subsecond restaurant everywhere.

147
00:09:31,349 --> 00:09:33,349
Than 26 million gateway.

148
00:09:33,890 --> 00:09:39,239
26 million daily request with
consistent of 90 90 millisecond.

149
00:09:39,630 --> 00:09:44,359
That means across global
operations, so system that means

150
00:09:44,359 --> 00:09:46,295
the performance is giving earlier.

151
00:09:46,295 --> 00:09:46,574
It is.

152
00:09:46,994 --> 00:09:55,614
99.7 to 99 point below 99.74
earlier, now it's more to 1990 9.9.

153
00:09:55,879 --> 00:09:58,989
Sometimes most of the times
achieving the results.

154
00:09:59,349 --> 00:10:02,484
Representing a reduction of 14.9 downtime.

155
00:10:02,984 --> 00:10:04,584
Financial that'll.

156
00:10:05,084 --> 00:10:10,394
And I think there now if we see all the
virtual missions came into the picture

157
00:10:10,454 --> 00:10:15,674
significantly, lawyer, CPU and memory
requirement have 40% infrastructure

158
00:10:15,674 --> 00:10:18,044
cost saving while improving performance.

159
00:10:18,544 --> 00:10:23,544
These metrics comes from aggregated data
across multiple insurance major insurance

160
00:10:23,544 --> 00:10:28,299
carriers and financial institutions
that have implemented rush based claims

161
00:10:28,299 --> 00:10:30,369
crossing system the past three years.

162
00:10:31,014 --> 00:10:36,114
The consistent pattern of improvement
demonstrates that trust for.

163
00:10:36,614 --> 00:10:40,395
Translate directly to business
value in financial context.

164
00:10:40,895 --> 00:10:44,915
So what are the challenges when you,
as you said, like the fraudulent

165
00:10:44,995 --> 00:10:49,625
claims are fraud fraudulent
request we can easily achieve with.

166
00:10:50,125 --> 00:10:54,895
A major insurance carrier needed to
analyze one 40 data points for claim

167
00:10:54,895 --> 00:11:01,675
across 810,000 daily fraud signals
while mening the sub hundred millisecond

168
00:11:01,675 --> 00:11:03,775
response time to enable claim.

169
00:11:04,275 --> 00:11:08,995
So once he created the claim,
so it'll go checks like every.

170
00:11:09,495 --> 00:11:11,954
Checkpoints, there are one 40 checkpoints.

171
00:11:12,135 --> 00:11:17,145
Yeah, all these one 40 checkpoint, it's
crossing within hundred milliseconds.

172
00:11:17,954 --> 00:11:20,969
So what is the rushed solution
implemented as synchronous.

173
00:11:21,069 --> 00:11:24,334
The synchronous rod detection
means, so whenever you are going.

174
00:11:24,745 --> 00:11:25,765
The transaction.

175
00:11:26,095 --> 00:11:31,465
So irrespective of the services, it'll
go and complete that transaction.

176
00:11:31,735 --> 00:11:37,015
Meanwhile, whatever service is called,
it'll get updated as a synchronously.

177
00:11:37,345 --> 00:11:40,885
So rush synchronous waiting
with the Tokyo process, multiple

178
00:11:40,885 --> 00:11:44,910
fraud signals concurrently, which
maintaining strict memory bots.

179
00:11:45,075 --> 00:11:47,375
We should not lead memory leaks.

180
00:11:47,815 --> 00:11:55,235
For that we are that competency copy DC
realization with reduced or passing most

181
00:11:55,235 --> 00:11:57,635
of the things like it's native language.

182
00:11:57,875 --> 00:12:01,485
So we'll get custom memory pool estimated.

183
00:12:01,515 --> 00:12:03,855
What is the results if we're solution?

184
00:12:04,455 --> 00:12:06,860
We're so 99.96.

185
00:12:07,405 --> 00:12:10,985
Fraud checks completed
under 80 milliseconds.

186
00:12:11,165 --> 00:12:13,565
Why we're missing 0.04.

187
00:12:13,865 --> 00:12:19,235
So every day the hackers are coming with
the different techniques and technologies.

188
00:12:19,485 --> 00:12:23,705
It a challenge for the major
carry insurance carriers.

189
00:12:23,975 --> 00:12:29,130
So every time they're coming with
different religious to work on the,

190
00:12:29,320 --> 00:12:32,405
with the hacker ideas and techniques.

191
00:12:32,905 --> 00:12:39,055
The false rate reduction by 31%
through more sophisticated algorithms

192
00:12:39,055 --> 00:12:41,875
enabled by performance every day.

193
00:12:41,935 --> 00:12:45,900
The data analytics, their different
logic to get the more throughput.

194
00:12:46,040 --> 00:12:50,365
So that'll go the performance
give the better performance.

195
00:12:50,515 --> 00:12:50,755
Yeah.

196
00:12:51,305 --> 00:12:55,500
System handles times traffic
spike without degradation.

197
00:12:56,325 --> 00:13:00,165
70% straight throughput crossing
rate for eligible claims.

198
00:13:00,495 --> 00:13:04,635
So the strip rules may mainly
play, will play the major roles

199
00:13:04,935 --> 00:13:06,925
in case of claims applications.

200
00:13:07,425 --> 00:13:12,425
So when it comes to the memory
management, so each and everywhere,

201
00:13:12,485 --> 00:13:14,190
we have the memory related errors.

202
00:13:14,615 --> 00:13:19,265
And unpredictable latency
specs to overcome these.

203
00:13:19,685 --> 00:13:25,355
So we have to follow the techniques,
like we have to clean up the garbage

204
00:13:25,355 --> 00:13:30,200
collections and runtime so that we
can achieve this latency issues.

205
00:13:30,650 --> 00:13:32,830
And when it comes to the safe obstruction.

206
00:13:32,830 --> 00:13:36,050
So always we have to use the
loosely coupling so that we

207
00:13:36,050 --> 00:13:37,940
can get the safe obstruction.

208
00:13:38,365 --> 00:13:44,675
So memory, safety impact on finance
system in traditional collected

209
00:13:44,675 --> 00:13:49,985
language like Java financial systems
experience, unpredictable la latency

210
00:13:49,985 --> 00:13:54,515
spikes during collection cycles, c
plus systems risk memory, corruptions

211
00:13:54,935 --> 00:14:00,125
that can lead to catastrophic failures
that eliminates both problems through

212
00:14:00,695 --> 00:14:05,675
compiled them, enforcement of memory,
correctness without runtime overhead.

213
00:14:06,175 --> 00:14:09,985
So this rushed, all things are
eliminated during the comp time itself.

214
00:14:10,485 --> 00:14:14,495
So the predictable for performance are
shown in the diagram characteristics.

215
00:14:14,975 --> 00:14:22,575
Russia allowed us to eliminate the 19
9.9% latency spike that were causing

216
00:14:22,635 --> 00:14:25,095
transaction time during peak periods.

217
00:14:25,395 --> 00:14:27,015
So when it comes to the bundle.

218
00:14:27,380 --> 00:14:30,740
Commit transaction during sot.

219
00:14:31,240 --> 00:14:36,550
So how we can say the Fearless Conference,
as I said the Golden Systems in the

220
00:14:37,300 --> 00:14:41,370
legacy applications we are having,
sometimes we have to wait for more than

221
00:14:41,370 --> 00:14:43,200
10 minutes to complete the transactions.

222
00:14:43,590 --> 00:14:47,305
So some people, they used to do
multiple times to complete the transac.

223
00:14:48,225 --> 00:14:50,655
And if it is not succeed, they can.

224
00:14:50,685 --> 00:14:52,695
They'll come for the
next day and they'll try.

225
00:14:53,025 --> 00:14:58,735
But when it comes to the rush, so we
have, we're seeing that second response,

226
00:14:58,795 --> 00:15:03,595
like the thousands of concurrent request,
while rendering data consistent across

227
00:15:03,715 --> 00:15:07,915
shared resources, there is approach
force and unacceptable tradeoff.

228
00:15:08,560 --> 00:15:11,920
So what are the problems with
the traditional approaches?

229
00:15:11,920 --> 00:15:17,410
If you go with the course, grands safe,
but creates water next when it comes to

230
00:15:17,410 --> 00:15:23,620
the fine logs, data performance, but risk
deadlocks, lock free algorithms I used.

231
00:15:24,120 --> 00:15:28,800
For means, but extremely how
we are gonna achieve solution.

232
00:15:29,100 --> 00:15:32,910
We're using the type, level
threat safety, so the compiler

233
00:15:32,910 --> 00:15:36,230
prevent data, so compilation.

234
00:15:36,730 --> 00:15:40,040
The one which is bottleneck
in the traditional approaches.

235
00:15:40,490 --> 00:15:43,960
And here we're gonna send, so
whenever it's required, depend.

236
00:15:44,750 --> 00:15:48,380
So always we'll go with so
exclude threat safety guarantees.

237
00:15:48,590 --> 00:15:49,040
Guarantees.

238
00:15:49,100 --> 00:15:50,780
That means concurrent threats.

239
00:15:50,780 --> 00:15:56,235
It won't involve, and we can achieve
expected results within the span of time.

240
00:15:56,735 --> 00:15:59,255
So it's not dependency.

241
00:15:59,255 --> 00:16:01,520
We'll go for the either, I think and wait.

242
00:16:01,895 --> 00:16:02,945
That means it.

243
00:16:03,125 --> 00:16:04,865
No need to wait for that one.

244
00:16:04,895 --> 00:16:08,255
Once we'll get the response,
automatically, it'll get

245
00:16:08,255 --> 00:16:10,205
updated into the system.

246
00:16:10,205 --> 00:16:14,975
So it'll like, through the
through we're going get the high

247
00:16:14,975 --> 00:16:17,675
performance multitasking as well.

248
00:16:18,175 --> 00:16:20,725
Safe communication
between processing stages.

249
00:16:20,995 --> 00:16:25,045
So with these approaches, whatever
traditional approach, bottlenecks

250
00:16:25,045 --> 00:16:28,645
and deadlocks, all these things we
can achieve through trust solutions

251
00:16:29,305 --> 00:16:31,375
in production, financial systems.

252
00:16:31,875 --> 00:16:34,175
Con crossing throughout improvements.

253
00:16:34,845 --> 00:16:35,025
Three.

254
00:16:35,525 --> 00:16:43,135
Ecosystem for financial, a ecosystem for
financial, a ecosystems set of libraries,

255
00:16:43,255 --> 00:16:48,475
frameworks, especially beneficial for
building financial services applications.

256
00:16:48,865 --> 00:16:53,780
So I think as in are seeing the high
performance if we see that the Tokyo

257
00:16:53,780 --> 00:16:57,135
product, great synchronous runtime,
enabling thousands of concurrent.

258
00:16:57,635 --> 00:17:05,135
Connections with the minimal overhead used
by 92% of financial rush application to

259
00:17:05,135 --> 00:17:10,535
handle high throughput, a PA workloads,
and if you're using a P frameworks.

260
00:17:10,535 --> 00:17:14,075
So it'll the cost and also fraud.

261
00:17:14,575 --> 00:17:14,835
We can easily.

262
00:17:15,335 --> 00:17:19,265
Yeah, tested web framework with
comprehensive middleware ecosystems

263
00:17:19,625 --> 00:17:24,275
both offer performance for ex
traditional offering metrics and so

264
00:17:24,275 --> 00:17:28,265
each and every step we have metrics
and monitoring, so when we can

265
00:17:28,265 --> 00:17:32,840
easily trace where the exact, the
performance, the tracing, we can achieve.

266
00:17:33,295 --> 00:17:34,645
Expected performance.

267
00:17:34,885 --> 00:17:39,175
So when it comes to the comprehensive
instrumentation, libraries for production

268
00:17:39,175 --> 00:17:44,005
systems, open telemetry example,
integration enables seamless monitoring,

269
00:17:44,155 --> 00:17:48,235
distributed financial transactions,
in case some database access when it

270
00:17:48,235 --> 00:17:53,245
comes to the database, access each
and every table view you or we are

271
00:17:53,245 --> 00:17:55,585
reading the indexing so that we can get.

272
00:17:56,085 --> 00:18:00,665
Like earlier like the response, we
are getting more than 10 seconds

273
00:18:00,845 --> 00:18:03,305
with this index and queries.

274
00:18:03,515 --> 00:18:07,175
So we are getting the subsecond
response, the serialization.

275
00:18:07,175 --> 00:18:10,590
For security purpose, each and
everything, we serializing.

276
00:18:11,145 --> 00:18:13,515
And sending the over the network.

277
00:18:13,785 --> 00:18:18,385
And in case of that means you could
not able to the one which is shared

278
00:18:18,595 --> 00:18:21,055
with the serialization security.

279
00:18:21,555 --> 00:18:27,635
So we need memory crypto graphic
libraries providing high performance

280
00:18:27,935 --> 00:18:32,045
TLS implementation critical
for security financing data in

281
00:18:32,045 --> 00:18:34,775
transit with the minimal overhead.

282
00:18:35,275 --> 00:18:39,855
Implementation pattern for error handling,
financial error handling in financial

283
00:18:39,855 --> 00:18:42,015
system, unique challenges, error.

284
00:18:42,705 --> 00:18:49,515
Yeah, as we discussed earlier, so these
errors, most of the 99.9% errors, we

285
00:18:49,810 --> 00:18:51,815
are handling it compiled by itself.

286
00:18:52,805 --> 00:18:55,055
So that remaining 1%.

287
00:18:55,455 --> 00:19:00,130
So with the, with ENT programming,
with the rush, we're eliminating it.

288
00:19:00,980 --> 00:19:03,620
So what is the impact
on production systems?

289
00:19:03,770 --> 00:19:09,170
So financial institutions using
rush terror handling patents report.

290
00:19:09,470 --> 00:19:16,220
So 99.92% system availability
under 94% direction.

291
00:19:16,220 --> 00:19:19,750
In unhandled exceptions,
improve error enables.

292
00:19:20,250 --> 00:19:26,450
Minutes enhanced complaints
through comprehensive error added.

293
00:19:26,950 --> 00:19:28,815
So what are the integration strategies?

294
00:19:29,375 --> 00:19:30,615
Adapting, rush incrementally.

295
00:19:31,085 --> 00:19:35,555
Most financial institution can't
rewrite entire system advance.

296
00:19:36,035 --> 00:19:38,705
So we see in the market all the ready.

297
00:19:39,205 --> 00:19:44,995
So we, the system automatically
we can integrate the the hundred

298
00:19:44,995 --> 00:19:49,135
percent reliability software we
can directly, we can integrate

299
00:19:49,375 --> 00:19:51,625
with the as for our requirement.

300
00:19:51,805 --> 00:19:55,375
So these proven integration
patterns enables incredible

301
00:19:55,375 --> 00:19:57,705
adoption and performance.

302
00:19:57,765 --> 00:20:01,285
Critical micro, if you see
the each and every program

303
00:20:01,315 --> 00:20:02,860
we're using the microservices.

304
00:20:03,360 --> 00:20:04,290
Better performance.

305
00:20:04,590 --> 00:20:10,140
Identify impact in existing systems and
replace with the targeted microservices.

306
00:20:11,100 --> 00:20:15,930
Common candidates include fraud detection,
payment crossing, and real time.

307
00:20:16,430 --> 00:20:21,675
This approach delivered 70% crossing
time improvement at a major.

308
00:20:22,175 --> 00:20:23,445
Disrupting core systems.

309
00:20:23,945 --> 00:20:31,035
So the a p gateway, transform, implement,
gateway rate limiting and protocol.

310
00:20:31,535 --> 00:20:37,895
This pattern reduced latency by 60 60%
for global payments while adding minimal.

311
00:20:38,395 --> 00:20:39,205
Existing system.

312
00:20:39,265 --> 00:20:44,845
The gateway became the foundation
for other rush adoption and foreign

313
00:20:44,845 --> 00:20:50,305
function interface exposed functionality
to existing Java application through

314
00:20:50,630 --> 00:20:52,720
foreign function interface bin.

315
00:20:53,350 --> 00:20:57,800
This approach enables replacement
of performance critical components

316
00:20:58,010 --> 00:20:59,080
while rendering compatibility.

317
00:20:59,395 --> 00:21:03,445
With existing systems one bank
through transaction, through three,

318
00:21:03,745 --> 00:21:08,365
3.2 times using this approach,
their Java core banking system.

319
00:21:08,455 --> 00:21:13,665
If you see the loan systems earlier
they started using that systems data

320
00:21:13,665 --> 00:21:18,020
in between if they're changing some
requirement, so entire process, again,

321
00:21:18,135 --> 00:21:19,695
they have to start from the beginning.

322
00:21:20,025 --> 00:21:23,490
So to achieve that one to
work on that problem we have.

323
00:21:23,990 --> 00:21:27,590
When you're in need, we can win
that one and we can complete

324
00:21:28,040 --> 00:21:30,130
within the, it's it model.

325
00:21:30,190 --> 00:21:37,090
So even also it'll follows that model
so that we can achieve expected results

326
00:21:37,660 --> 00:21:42,490
and in that time, and the product
will be in the market, having the.

327
00:21:42,990 --> 00:21:45,210
So it comes to security.

328
00:21:45,710 --> 00:21:50,090
Security advantages that directly
address financial industry requirements.

329
00:21:50,180 --> 00:21:52,580
Those are memory safety guarantees.

330
00:21:52,780 --> 00:21:56,675
So we already seen that memory
safety, like when you're or storing

331
00:21:56,975 --> 00:22:02,405
the data so it always hundred percent
can achieve without any dispatch.

332
00:22:03,155 --> 00:22:04,895
So fall compilation.

333
00:22:04,995 --> 00:22:06,765
Foreign false interface boundaries.

334
00:22:07,035 --> 00:22:12,505
When interfacing with legacy systems
rush provide safe obstructions or unsafe

335
00:22:13,345 --> 00:22:17,665
code containing potential vulnerabilities
to well-defined boundaries.

336
00:22:18,085 --> 00:22:23,035
This pattern has proven crucial,
secure incremental adoption.

337
00:22:23,155 --> 00:22:23,185
I.

338
00:22:23,685 --> 00:22:28,745
And data isolation requirement,
making it easier, multitenant.

339
00:22:29,245 --> 00:22:33,430
So finance, treatment, face unique
security challenges like compliance.

340
00:22:33,480 --> 00:22:40,310
We have different standards like DS d and
multi talent data isolation requirement.

341
00:22:40,310 --> 00:22:46,270
It has all, all these regulations and
sophisticated targeting financial data.

342
00:22:46,770 --> 00:22:51,190
So like the right time right
product when it comes to the

343
00:22:51,190 --> 00:22:56,880
market, only the product having the
business value delivers measurable.

344
00:22:57,165 --> 00:23:02,735
Business impact through a unique
combination of for and safety guarantees,

345
00:23:02,740 --> 00:23:10,535
85% faster processing and 99.991
percentage uptime and 40% infrastructure,

346
00:23:10,775 --> 00:23:15,335
cost reduction and incremental
adoption in practical, so financial

347
00:23:15,335 --> 00:23:18,910
institutions can adopt through gateway.

348
00:23:19,410 --> 00:23:26,300
FFI without risky System S, ecosystem
maturity provides production ready

349
00:23:26,300 --> 00:23:32,350
libraries for all critical financial
API needs from synchronous into secure

350
00:23:32,350 --> 00:23:34,870
database, as I said, the market.

351
00:23:35,200 --> 00:23:41,440
So that skill and the whatever, like 99%
are providing the skeleton as libraries.

352
00:23:41,680 --> 00:23:44,740
So we have just customized
in the financial.

353
00:23:44,925 --> 00:23:45,645
Systems.

354
00:23:45,920 --> 00:23:48,195
Systems, the what are the
next steps in the rush?

355
00:23:48,695 --> 00:23:53,355
So identify high impact performance
bottlenecks in the existing

356
00:23:53,355 --> 00:23:55,665
system as initial rush target.

357
00:23:55,935 --> 00:24:00,755
Start with small bounded micros to
build team expertise so that we can

358
00:24:00,755 --> 00:24:02,885
achieve the performance leverage.

359
00:24:02,885 --> 00:24:05,795
Rushed memory safety
advantages for security.

