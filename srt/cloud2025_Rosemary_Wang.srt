1
00:00:00,150 --> 00:00:03,710
Welcome to the secret to
handling dynamic secrets.

2
00:00:04,239 --> 00:00:06,579
It usually starts with,
a security requirement.

3
00:00:06,609 --> 00:00:10,460
Your security team realizes that you've
been running in cloud for quite some

4
00:00:10,460 --> 00:00:16,039
time, and it's no longer sustainable
to copy paste a bunch of API tokens

5
00:00:16,039 --> 00:00:19,949
and database passwords across different
applications that you've been developing.

6
00:00:19,959 --> 00:00:23,450
So they tell you have to migrate
everything to a secrets manager.

7
00:00:24,150 --> 00:00:28,320
And this seems, mostly easy, I
guess you have to just find every

8
00:00:28,320 --> 00:00:31,470
single instance of a secret and
paste it into a secrets manager.

9
00:00:31,870 --> 00:00:34,080
But it turns out this is a
little bit more complicated

10
00:00:34,080 --> 00:00:35,360
than someone might think, right?

11
00:00:35,710 --> 00:00:38,780
The minute you centralize secrets
in a secrets manager, whether

12
00:00:38,780 --> 00:00:43,099
it be an API token or a database
password, your application now has

13
00:00:43,099 --> 00:00:45,169
to go retrieve it over the network.

14
00:00:45,640 --> 00:00:47,890
And there are a number
of concerns with this.

15
00:00:47,930 --> 00:00:52,695
Whether you're a platform engineer or
developer who is responsible for managing

16
00:00:52,695 --> 00:00:55,695
their own cloud native application
and the infrastructure underneath it.

17
00:00:56,325 --> 00:00:59,955
There are a number of concerns
you might have with an application

18
00:00:59,965 --> 00:01:04,394
reaching out to a secrets manager,
whether that be network connectivity

19
00:01:04,395 --> 00:01:08,344
or just generally the availability
of your password and API token.

20
00:01:09,150 --> 00:01:12,260
And it turns out it gets a little bit
more complicated than that, right?

21
00:01:12,570 --> 00:01:16,530
What happens when you have
to rotate the secret, right?

22
00:01:16,550 --> 00:01:20,330
Imagine you have a security
requirement number 208 or something

23
00:01:20,750 --> 00:01:24,160
that means that you have to
rotate that secret every 30 days.

24
00:01:24,330 --> 00:01:27,570
now you have to coordinate
with your application.

25
00:01:27,570 --> 00:01:32,350
Your application has to reload, reconnect
to the secrets manager, and connect

26
00:01:32,380 --> 00:01:34,520
to the second version of the secret.

27
00:01:34,919 --> 00:01:39,960
Ultimately, after some buffer period of
maybe four or five days, you'll delete

28
00:01:39,989 --> 00:01:43,789
the old version of the secret just to
make sure your application is working.

29
00:01:44,610 --> 00:01:49,535
This works Okay, for maybe one
application, if you're just managing a

30
00:01:49,535 --> 00:01:53,335
single application that's connecting to
the secrets manager, but what happens

31
00:01:53,335 --> 00:01:59,674
when you grow your environment and now
you have multiple applications waiting

32
00:01:59,674 --> 00:02:03,924
to connect to a secrets manager to get
an API token and a database password?

33
00:02:03,985 --> 00:02:07,134
it's a little bit challenging to
figure out which applications need

34
00:02:07,134 --> 00:02:11,315
to retrieve which password, which
applications need to access the API token.

35
00:02:11,605 --> 00:02:16,605
And if you ever have to rotate this
password or this API token again,

36
00:02:16,815 --> 00:02:20,695
you now have to make sure that
every single application that is

37
00:02:20,745 --> 00:02:25,175
potentially using this shared API
token and password have to reload.

38
00:02:25,675 --> 00:02:27,895
Now there are a couple
solutions around this, right?

39
00:02:28,445 --> 00:02:31,705
And the first is, trying
to automate some of this.

40
00:02:31,765 --> 00:02:35,565
I spend a lot of my time automating
and trying to figure out better

41
00:02:35,565 --> 00:02:40,135
workflows for building security into
applications and infrastructure.

42
00:02:40,855 --> 00:02:46,295
And it turns out that there's one really
big secret to doing dynamic secrets.

43
00:02:46,365 --> 00:02:49,795
And when I talk about dynamic secrets,
the ability for an application to

44
00:02:49,795 --> 00:02:53,805
handle a new secret that it has to use.

45
00:02:54,175 --> 00:02:57,934
The secret is actually investing
in some developer enablement.

46
00:02:58,284 --> 00:03:03,135
There is no magical tool, and
unfortunately, no magical workflow.

47
00:03:03,540 --> 00:03:05,690
That will automatically do this for you.

48
00:03:05,950 --> 00:03:10,930
Unfortunately, this requires an
investment into enabling developers,

49
00:03:11,459 --> 00:03:12,940
providing better documentation.

50
00:03:13,340 --> 00:03:16,709
It also means that you have to understand
the patterns that are involved in

51
00:03:16,709 --> 00:03:20,510
order for an application to support
and a constantly rotating secret.

52
00:03:21,010 --> 00:03:24,850
The reality is, in a cloud native
application, you have to be responsible

53
00:03:24,870 --> 00:03:27,160
for handling dynamic configuration.

54
00:03:27,430 --> 00:03:29,990
You expect any dependencies
to change, right?

55
00:03:30,040 --> 00:03:34,370
And why shouldn't we depend, why
shouldn't we make sure that we are able

56
00:03:34,370 --> 00:03:36,050
to depend on an ever changing secret?

57
00:03:36,625 --> 00:03:39,955
The answer is, we need to have a little
bit of a paradigm shift in how we develop

58
00:03:39,955 --> 00:03:41,965
our applications to handle secrets.

59
00:03:42,405 --> 00:03:45,875
Traditionally, we are very used to
having one secret that we never touch

60
00:03:45,904 --> 00:03:47,675
and hopefully will never have to change.

61
00:03:48,105 --> 00:03:52,835
But in a cloud native environment, that's
not possible to expect that, right?

62
00:03:52,835 --> 00:03:56,725
From a security posture perspective,
you want to make sure that you are

63
00:03:56,725 --> 00:04:01,065
rotating your secrets on enough
of a frequency so that you do not

64
00:04:01,065 --> 00:04:05,365
have to worry about someone using
those credentials or an unauthorized

65
00:04:05,735 --> 00:04:07,205
service using those credentials.

66
00:04:07,535 --> 00:04:14,705
So investing in developer enablement is a
big portion why you have to have some kind

67
00:04:14,705 --> 00:04:16,824
of secret and handling dynamic secrets.

68
00:04:17,705 --> 00:04:20,404
As I mentioned before, there are some
categories of secrets though, right?

69
00:04:20,835 --> 00:04:24,474
We traditionally think of a static
secret where we manually copy and

70
00:04:24,474 --> 00:04:27,925
paste this somewhere, probably
into a secrets manager, and then

71
00:04:27,925 --> 00:04:29,955
we manually delete the old secret.

72
00:04:30,544 --> 00:04:32,095
This is all done manually.

73
00:04:32,490 --> 00:04:34,450
And this works perfectly fine.

74
00:04:34,530 --> 00:04:38,030
You treat a secret like a key
and a value, and you inject it

75
00:04:38,039 --> 00:04:39,310
into your application, right?

76
00:04:40,050 --> 00:04:43,890
Now, more and more platforms, especially
in the cloud native environment,

77
00:04:43,900 --> 00:04:45,690
are offering rotated secrets.

78
00:04:46,099 --> 00:04:49,149
This means that automation
retrieves and stores the new secret.

79
00:04:49,515 --> 00:04:52,555
And you manually decide to
delete the old secret, right?

80
00:04:52,555 --> 00:04:56,025
So this is more common if maybe
you're seeing a managed database or

81
00:04:56,025 --> 00:04:59,705
some other managed service that's
offering an API token or a password.

82
00:04:59,715 --> 00:05:02,395
It will help rotate it
for you on your behalf.

83
00:05:02,655 --> 00:05:05,354
You'll just have to make sure
in your application that you're

84
00:05:05,355 --> 00:05:07,435
able to consume the new secret.

85
00:05:08,144 --> 00:05:10,155
Finally, there's the dynamic secret.

86
00:05:10,215 --> 00:05:14,625
The dynamic secret means automation both
generates and revokes the old secret.

87
00:05:15,145 --> 00:05:18,645
I'm going to be showing HashiCorp
Vault, which is a secrets manager.

88
00:05:19,235 --> 00:05:23,815
In as a demonstration of some of these
patterns, but dynamic secrets do exist

89
00:05:23,885 --> 00:05:29,365
quite a bit across large cloud nativist
states in which you've built significant

90
00:05:29,365 --> 00:05:30,754
automation to handle this, right?

91
00:05:30,755 --> 00:05:34,264
So if you have a dynamic secret,
automation will generate the new

92
00:05:34,264 --> 00:05:37,555
secret for you, and it will revoke the
old secret on some kind of cadence.

93
00:05:38,055 --> 00:05:39,315
These are the three categories.

94
00:05:39,965 --> 00:05:42,775
It goes from more manual to,
of course, more automated.

95
00:05:43,065 --> 00:05:47,525
It doesn't mean that every secret is
going to fit into a dynamic secret, right?

96
00:05:47,525 --> 00:05:52,435
You can and you will have secrets,
even in a cloud native environment.

97
00:05:52,850 --> 00:05:53,880
That are static.

98
00:05:53,930 --> 00:05:57,840
And that's because there are some systems
that will always have an API token that

99
00:05:57,840 --> 00:05:59,540
you need to manually and go and generate.

100
00:06:00,310 --> 00:06:03,370
Unfortunately, this is part of
the systems that we work in.

101
00:06:03,370 --> 00:06:07,149
It's part of integrating systems
in a large organization as well.

102
00:06:07,170 --> 00:06:10,839
So you will always have some kind
of static secret, but more and more,

103
00:06:10,840 --> 00:06:15,510
especially as you have, services
that are enabling the rotation of

104
00:06:15,750 --> 00:06:21,000
API tokens using an API, you will
get something like a dynamic secret.

105
00:06:21,500 --> 00:06:24,830
Today, we are going to learn more
about dynamic secrets, but the

106
00:06:24,830 --> 00:06:28,520
patterns that you learn here do
apply to static and rotated secrets.

107
00:06:28,530 --> 00:06:33,620
That's because we are trying to describe
patterns for the most extreme scenario in

108
00:06:33,620 --> 00:06:37,859
which most secrets are rotated frequently
and you expect them to change, right?

109
00:06:37,859 --> 00:06:43,110
So if we're talking about patterns for a
dynamic secret, the same rules will apply

110
00:06:43,140 --> 00:06:48,240
to static and rotated secrets, mostly
because this is about how an application

111
00:06:48,250 --> 00:06:51,210
reacts to a secret dependency change.

112
00:06:51,710 --> 00:06:53,580
So what does it mean to
handle a dynamic secret?

113
00:06:53,580 --> 00:06:55,110
There are three parts to the workflow.

114
00:06:55,600 --> 00:06:57,250
An application must get the secret.

115
00:06:57,570 --> 00:06:59,460
This is actually divided
into two substeps.

116
00:06:59,530 --> 00:07:04,090
The first is authenticating to the secrets
manager and then, using the secret, right?

117
00:07:04,090 --> 00:07:07,020
So once you authenticate to the secrets
manager, you can get the secret and

118
00:07:07,020 --> 00:07:08,450
you can use it in the application.

119
00:07:08,950 --> 00:07:12,360
The second part of the workflow is
actually about changing the secret.

120
00:07:12,460 --> 00:07:15,450
The secrets manager or maybe
yourself will change the secret.

121
00:07:15,600 --> 00:07:17,260
You'll rotate or expire the secret.

122
00:07:17,690 --> 00:07:21,930
In the secrets manager, the application
has no awareness that you've done this

123
00:07:21,970 --> 00:07:25,330
unless you tell the application that you
have actually changed the secret, right?

124
00:07:25,780 --> 00:07:29,400
And telling the application that you've
changed the secret means you either reload

125
00:07:29,410 --> 00:07:33,880
the application or the application detects
the change the secret and reloads code.

126
00:07:34,380 --> 00:07:39,730
This is very important to know,
especially if you have dynamic secrets.

127
00:07:40,270 --> 00:07:46,314
These three parts of this workflow
are required for any kind of workflow.

128
00:07:46,585 --> 00:07:50,635
rotation or any kind of changing secret
that you have in your application.

129
00:07:50,905 --> 00:07:54,075
It's not much different than let's say
if you had dynamic configuration, right?

130
00:07:54,405 --> 00:07:57,615
If you have an application that is
retrieving dynamic configuration

131
00:07:57,645 --> 00:08:01,035
from a configuration server, this
workflow looks pretty similar, right?

132
00:08:01,095 --> 00:08:05,785
Authenticate to a configuration server,
retrieve the configuration properties.

133
00:08:06,110 --> 00:08:09,230
If those configuration properties
change, then you must reload, right?

134
00:08:09,260 --> 00:08:12,880
It's a common enough pattern for any cloud
native application that's built to be

135
00:08:12,880 --> 00:08:17,150
cloud native, but we just typically don't
treat secrets like this because, secrets

136
00:08:17,150 --> 00:08:20,570
don't change as often, or traditionally
we haven't changed them that often.

137
00:08:21,240 --> 00:08:25,540
So the pattern still applies even
if you're doing a static secret

138
00:08:25,550 --> 00:08:27,000
or you're doing a rotated secret.

139
00:08:27,000 --> 00:08:28,400
It doesn't have to be dynamic.

140
00:08:28,900 --> 00:08:33,070
Patterns for dynamic secret can be broken
down into two, two separate patterns.

141
00:08:33,120 --> 00:08:38,630
The first is that the application
is agnostic of the secrets manager.

142
00:08:38,850 --> 00:08:39,370
What does this mean?

143
00:08:39,470 --> 00:08:42,949
the application doesn't request
secrets from the secrets manager.

144
00:08:43,369 --> 00:08:45,830
It doesn't connect to the
secrets manager at all.

145
00:08:46,119 --> 00:08:48,450
Actually, it refers to a separate process.

146
00:08:48,490 --> 00:08:51,890
The separate process authenticates to
the secrets manager and then injects it.

147
00:08:52,090 --> 00:08:52,990
We'll go more into this.

148
00:08:53,435 --> 00:08:54,105
a little bit later.

149
00:08:54,895 --> 00:08:56,875
Then there's the
application aware approach.

150
00:08:57,295 --> 00:09:01,335
The application itself is aware
that there's a secrets manager and

151
00:09:01,335 --> 00:09:05,105
it needs to make an API call to the
secrets manager to get the secret.

152
00:09:05,505 --> 00:09:08,945
So this means that you use some
kind of API or SDK request.

153
00:09:09,750 --> 00:09:11,160
Both patterns are valid.

154
00:09:11,300 --> 00:09:15,480
I do hear a whole number of debates
on whether or not one is better than

155
00:09:15,480 --> 00:09:18,980
the other, and I can certainly tell
you there are benefits as well as

156
00:09:18,980 --> 00:09:22,369
disadvantages to each, and we'll cover
some of that in more detail once we

157
00:09:22,369 --> 00:09:25,569
describe some of the technicalities
and the differences between the two.

158
00:09:26,069 --> 00:09:28,599
So let's start with application agnostic.

159
00:09:29,319 --> 00:09:32,409
As I mentioned before, application
agnostic means that there is

160
00:09:32,409 --> 00:09:36,129
a separate process that is
handling the authentication and

161
00:09:36,129 --> 00:09:37,389
the injection of the secret.

162
00:09:37,689 --> 00:09:41,349
Usually this injection is in the form
of environment variables or files.

163
00:09:41,849 --> 00:09:42,609
You get to choose.

164
00:09:43,269 --> 00:09:47,199
Most applications are more familiar
with environment variables, and so

165
00:09:47,329 --> 00:09:50,529
the application will read the secrets
from the environment variable.

166
00:09:51,499 --> 00:09:54,579
Overall, it's a pretty
straightforward process, right?

167
00:09:54,579 --> 00:09:59,929
You've got a separate controller or
separate process that is going to handle

168
00:10:00,209 --> 00:10:04,029
interfacing with the secrets manager, and
the application doesn't have to change.

169
00:10:04,119 --> 00:10:05,339
Nothing has to happen.

170
00:10:05,719 --> 00:10:09,059
It just continues to read from
environment variables as it wants to.

171
00:10:09,904 --> 00:10:13,484
This works pretty decently for
a number of applications across

172
00:10:13,514 --> 00:10:14,804
many different frameworks.

173
00:10:14,824 --> 00:10:18,404
It works really well for older
applications that you might

174
00:10:18,404 --> 00:10:21,794
replatform into a container,
but you don't necessarily want

175
00:10:21,804 --> 00:10:23,134
to refactor the code, right?

176
00:10:23,859 --> 00:10:30,059
So when the password or the API token
changes, the separate process, handles

177
00:10:30,129 --> 00:10:32,789
the retrieval of the new secret.

178
00:10:32,809 --> 00:10:35,789
The separate process is constantly
monitoring the secrets manager.

179
00:10:36,099 --> 00:10:39,049
It could be on a schedule, or it could
be some kind of event subscription.

180
00:10:39,669 --> 00:10:44,449
And it's going to retrieve the new secret,
re inject it into the environment variable

181
00:10:44,459 --> 00:10:48,249
or file, and then the application picks it
up from the environment variable or file.

182
00:10:48,749 --> 00:10:54,859
Application frameworks like Spring Boot or
NET, they do have some kind of live reload

183
00:10:54,879 --> 00:10:57,859
configuration properties from a file.

184
00:10:58,149 --> 00:11:02,409
So that means that you can reload the
application once it detects a difference

185
00:11:02,419 --> 00:11:05,999
in the configuration properties or file,
which makes it more straightforward.

186
00:11:06,489 --> 00:11:11,099
If you have a programming language
or framework that you're not sure

187
00:11:11,189 --> 00:11:14,849
if it supports live reload, you
may have to write it yourself.

188
00:11:14,879 --> 00:11:17,709
But effectively, you would be
looking for a file difference or

189
00:11:17,709 --> 00:11:20,569
some change the environment property,
and then you would be reloading.

190
00:11:21,069 --> 00:11:23,519
Now, there are other ways that
you can think about doing this.

191
00:11:23,859 --> 00:11:27,299
And it's not just, going to involve
some kind of separate process.

192
00:11:27,749 --> 00:11:32,799
if you are on Kubernetes, for
example, We're going to do this.

193
00:11:33,109 --> 00:11:36,329
if you're on Kubernetes, for
example, you may have a separate

194
00:11:36,329 --> 00:11:39,679
process that actually reloads the
application on your behalf, right?

195
00:11:39,709 --> 00:11:43,189
The application itself doesn't have
to do a live reload, doesn't have

196
00:11:43,189 --> 00:11:44,989
to detect a difference in the file.

197
00:11:45,409 --> 00:11:49,639
Instead, you can have some kind
of separate process reload the

198
00:11:49,689 --> 00:11:51,069
application for you, right?

199
00:11:51,099 --> 00:11:54,509
It could, either kill the process
that the application process ID that

200
00:11:54,509 --> 00:11:58,059
the application is running on, or it
can send a signal to the application.

201
00:11:58,059 --> 00:11:59,399
I need you to refresh something.

202
00:11:59,399 --> 00:12:03,700
a good example of this that I'll mention
is that if you are using the spring

203
00:12:03,700 --> 00:12:07,380
boot actuator, in the spring boot
framework for your development teams,

204
00:12:07,700 --> 00:12:09,440
the actuator has a refresh endpoint.

205
00:12:09,450 --> 00:12:12,080
You can make an API call to refresh.

206
00:12:12,450 --> 00:12:14,220
values in the application, right?

207
00:12:14,580 --> 00:12:17,870
Other frameworks do have some kind of
refresh capability as well that you

208
00:12:17,870 --> 00:12:23,340
can maybe build as an API endpoint
and then expose that for your separate

209
00:12:23,340 --> 00:12:25,470
process to handle the reload for you.

210
00:12:25,959 --> 00:12:29,640
So you don't have to necessarily
support that in the application itself.

211
00:12:29,670 --> 00:12:31,310
You can do that outside the application.

212
00:12:31,810 --> 00:12:34,880
So once it reloads, then it will
get the new secret, and that's

213
00:12:34,980 --> 00:12:36,090
pretty much all it needs to do.

214
00:12:36,730 --> 00:12:39,450
This is a pattern that's
pretty common for Kubernetes.

215
00:12:39,860 --> 00:12:43,770
If you are running on Kubernetes, you
often will find that there's a number

216
00:12:43,799 --> 00:12:45,779
of Kubernetes operators out there.

217
00:12:46,055 --> 00:12:48,845
That will load in external
secrets from something.

218
00:12:48,845 --> 00:12:51,995
it will load in an external
secret from a secrets manager.

219
00:12:51,995 --> 00:12:54,725
It will handle the
authentication on your behalf.

220
00:12:54,965 --> 00:12:58,565
It will retrieve the secrets that
you need, and then it will inject

221
00:12:58,625 --> 00:13:00,755
the secret as a Kubernetes secret.

222
00:13:00,755 --> 00:13:06,275
So the Kubernetes secret can be
added as a file volume or it could,

223
00:13:06,325 --> 00:13:08,755
be added as an environment variable.

224
00:13:08,815 --> 00:13:12,205
In newer versions of Kubernetes, it is
suggested to add them as volume amounts.

225
00:13:12,835 --> 00:13:17,735
but not every application supports,
reading from files and there are some

226
00:13:17,755 --> 00:13:20,685
things that you do have to refactor
on the application side in order

227
00:13:20,685 --> 00:13:23,175
to potentially read from a file.

228
00:13:23,395 --> 00:13:28,595
Most applications standardize, at least
in the past, in the past on environment

229
00:13:28,595 --> 00:13:32,135
variables and expect to do environment
variable injection as a default.

230
00:13:32,525 --> 00:13:35,205
So there's, there are two
choices, but both are supported.

231
00:13:35,205 --> 00:13:38,215
So you can do a Kubernetes
secret as a file, or Kubernetes

232
00:13:38,215 --> 00:13:39,465
secret as environment variable.

233
00:13:40,340 --> 00:13:42,070
I'll show the environment
variable example.

234
00:13:42,810 --> 00:13:46,300
So the important thing is that this
application is a Spring Boot application.

235
00:13:46,550 --> 00:13:50,200
it's not as relevant, but it's
important to recognize that it is a

236
00:13:50,200 --> 00:13:55,660
Java application, and it does expect
to have environment variables like a

237
00:13:55,660 --> 00:14:03,010
database username, a database password,
a static payments processor username,

238
00:14:03,030 --> 00:14:05,480
and a static payments processor password.

239
00:14:06,280 --> 00:14:11,565
All of these in my Kubernetes
manifest for my deployment are

240
00:14:11,565 --> 00:14:14,535
injected by environment variable.

241
00:14:14,535 --> 00:14:18,565
I read the value from a Kubernetes
secret called payments app database

242
00:14:18,565 --> 00:14:21,625
with the key username, with the
password, and everything else.

243
00:14:21,635 --> 00:14:24,665
So there's two separate
secrets that I'm referring to.

244
00:14:24,665 --> 00:14:27,025
One is for the database and
one is for the processor.

245
00:14:27,685 --> 00:14:31,405
And so these are things that maybe
I keep default in my application.

246
00:14:31,865 --> 00:14:34,265
I expect to read them as
environment variables anyway.

247
00:14:34,765 --> 00:14:38,425
And so I don't really have to do any
significant refactor in my application.

248
00:14:38,925 --> 00:14:42,675
One important thing to know is that
the database password here is being

249
00:14:42,675 --> 00:14:47,604
stored in Vault, and being generated by
Vault dynamically, while the processor

250
00:14:47,655 --> 00:14:52,004
password is going to be static, so
it's stored as a key value pair.

251
00:14:52,504 --> 00:14:56,985
I'll show how both get processed
and injected into the Kubernetes

252
00:14:56,995 --> 00:14:58,715
secret, but there will be two.

253
00:14:59,215 --> 00:15:03,225
Important thing to also note is that
again, this is a Spring Boot application.

254
00:15:03,275 --> 00:15:05,345
I'm reading from environment variables.

255
00:15:05,755 --> 00:15:11,065
I could very well render this asset
of application properties as a config

256
00:15:11,084 --> 00:15:14,504
map or something else, but I'm just
injecting them as environment variables.

257
00:15:15,004 --> 00:15:18,254
The next thing that I'm going
to do is I'll just check that

258
00:15:18,254 --> 00:15:19,534
my operator is up and running.

259
00:15:19,854 --> 00:15:22,764
the operator that I'm using today
is the Vault Secrets operator.

260
00:15:22,944 --> 00:15:25,694
The Vault Secrets operator works
with HashiCorp Vault specifically,

261
00:15:25,694 --> 00:15:29,154
although there are many other operators
that you'll find that inject secrets

262
00:15:29,164 --> 00:15:30,794
from other secrets managers as well.

263
00:15:31,234 --> 00:15:33,944
But the operator pretty much does
the function of authenticating

264
00:15:33,954 --> 00:15:35,044
to Vault on my behalf.

265
00:15:35,209 --> 00:15:38,599
which is why I have a custom
resource called vault auth.

266
00:15:38,649 --> 00:15:41,039
It uses a Kubernetes service account.

267
00:15:41,709 --> 00:15:47,409
And then I can define exactly what
secrets I want to retrieve from vault.

268
00:15:47,969 --> 00:15:51,359
This is pretty, standard of
a pattern in terms of custom

269
00:15:51,359 --> 00:15:52,799
resources across Secrets Manager.

270
00:15:52,799 --> 00:15:54,989
So you'll define what
kind of secrets you want.

271
00:15:55,399 --> 00:15:58,189
If it's a static secret,
this is a key and a value.

272
00:15:58,779 --> 00:16:03,939
and this key value, is a password and
username for my payments processor

273
00:16:04,059 --> 00:16:06,019
that I've stored in my Secrets Manager.

274
00:16:06,499 --> 00:16:08,399
So I'm able to retrieve it as I need to.

275
00:16:09,149 --> 00:16:12,539
And I will define my secrets
destination as payments app processor

276
00:16:12,809 --> 00:16:14,409
and refresh after 60 seconds.

277
00:16:14,749 --> 00:16:18,459
This is a pretty frequent refresh,
you might not need 60 seconds.

278
00:16:18,459 --> 00:16:20,899
You could be 30 days, you
could be 15 days, right?

279
00:16:21,309 --> 00:16:25,229
I don't suggest you do 60 seconds unless
you have a secret that always changes.

280
00:16:25,839 --> 00:16:27,789
And finally we have a
rollout restart target.

281
00:16:28,129 --> 00:16:32,419
there are Kubernetes operators
out there that do support

282
00:16:32,429 --> 00:16:34,229
some kind of rollout restart.

283
00:16:34,529 --> 00:16:38,329
They leverage the Kubernetes rollout
capability that you can target

284
00:16:38,369 --> 00:16:42,559
a deployment, a daemon set, or a
stateful set, and it will restart,

285
00:16:42,639 --> 00:16:44,529
the application on your behalf.

286
00:16:44,919 --> 00:16:47,559
This, Mivalt secrets
operator does support that.

287
00:16:47,559 --> 00:16:50,039
So I'm targeting my
payments app deployment.

288
00:16:50,039 --> 00:16:54,319
So anytime the secret changes,
it will roll out and restart

289
00:16:54,469 --> 00:16:55,819
the application for me.

290
00:16:56,319 --> 00:16:59,149
And the dynamic secret is, very similar.

291
00:16:59,149 --> 00:17:02,809
The diff difference is that I am getting
a username and password dynamically

292
00:17:02,929 --> 00:17:04,579
anytime I request it from Vault.

293
00:17:04,909 --> 00:17:07,759
So it's going to be a unique database,
username and password each time.

294
00:17:08,259 --> 00:17:14,799
So I'm going to deploy the custom
resources related to the secrets so that

295
00:17:14,799 --> 00:17:20,119
I can hopefully see that a secret has been
created, with those custom resources, the.

296
00:17:20,389 --> 00:17:22,909
The operator is going to
create two sets of secrets.

297
00:17:22,909 --> 00:17:26,489
One is for a processor and that
has the username and password.

298
00:17:26,989 --> 00:17:28,319
The other is the database.

299
00:17:28,329 --> 00:17:30,059
So we'll check out the processor first.

300
00:17:30,059 --> 00:17:32,199
You'll notice there's a
username and password field.

301
00:17:32,969 --> 00:17:35,299
We also have the database as well.

302
00:17:35,799 --> 00:17:39,289
One thing to know is that if you
need a different format, you don't

303
00:17:39,389 --> 00:17:41,239
want username password like this.

304
00:17:41,239 --> 00:17:42,839
You want them in a file somewhere.

305
00:17:43,139 --> 00:17:45,369
There are some operators that
allow you to have a custom

306
00:17:45,369 --> 00:17:48,979
resource definition that sort of
templatizes the file type you want.

307
00:17:49,639 --> 00:17:53,599
I'll apply the deployment, which we're
going to call payments application.

308
00:17:54,159 --> 00:17:58,969
And it's going to start up with an
initial database username and password.

309
00:17:59,699 --> 00:18:01,249
In the logs, I do print them out.

310
00:18:01,299 --> 00:18:04,719
Do not print your username and
password in plain text in logs, but

311
00:18:04,719 --> 00:18:06,239
I'm doing this for the sake of example.

312
00:18:06,569 --> 00:18:11,019
So when it first starts up,
it's going to have 971, a suffix

313
00:18:11,029 --> 00:18:15,589
of 971 for its username, and
a password prefixed with 084.

314
00:18:16,089 --> 00:18:18,009
And we're going to wait for a little bit.

315
00:18:18,115 --> 00:18:21,895
this will expire after three minutes,
not every database password you'll

316
00:18:21,905 --> 00:18:23,675
want to expire after three minutes.

317
00:18:23,945 --> 00:18:27,225
most of the time you'll want to
set it on a much shorter cadence.

318
00:18:27,575 --> 00:18:29,415
I'm doing this for the sake of example.

319
00:18:29,675 --> 00:18:32,935
so the way that Vault works is
that it has dynamic credentials.

320
00:18:33,015 --> 00:18:35,125
These credentials have what
is called a time to live.

321
00:18:35,485 --> 00:18:38,625
Vault will lease a certain set of
credentials for a certain amount of time.

322
00:18:38,995 --> 00:18:42,025
And then after that certain
amount of time, it will revoke and

323
00:18:42,025 --> 00:18:43,335
expire the credentials for you.

324
00:18:44,090 --> 00:18:47,050
It is something that
you have to monitor for.

325
00:18:47,460 --> 00:18:51,090
You do not get any real awareness
of whether or not the secret

326
00:18:51,090 --> 00:18:54,450
will expire unless you actively
check, how long it's been, how

327
00:18:54,450 --> 00:18:56,060
long that secret has been around.

328
00:18:56,070 --> 00:18:58,490
So the lifetime of the secret
is controlled by Vault.

329
00:18:59,100 --> 00:19:01,580
you can check out the
logs for the operator.

330
00:19:01,580 --> 00:19:04,570
You'll notice that there was a rollout
restart failure when it initially started

331
00:19:04,570 --> 00:19:07,780
up, but there's no indication yet that
it's going to retrieve a new secret.

332
00:19:08,070 --> 00:19:11,730
So we'll just keep waiting
until the secret gets rotated.

333
00:19:12,230 --> 00:19:15,500
It's been about a minute and a
half and so it's your time out.

334
00:19:15,980 --> 00:19:16,900
Just about now.

335
00:19:17,350 --> 00:19:21,380
if you are not familiar with dynamic
credentials and this is the first time

336
00:19:21,380 --> 00:19:26,140
you're working with a lease, I recommend
that you wait for the lease to be two

337
00:19:26,140 --> 00:19:28,390
thirds of the way through its lifetime.

338
00:19:28,840 --> 00:19:31,460
after two thirds of its
lifetime, then rotate.

339
00:19:31,480 --> 00:19:35,110
So it gives you a little bit of time,
to expire the old credentials and

340
00:19:35,110 --> 00:19:37,990
make sure that you've actually your
application works, but you'll notice

341
00:19:38,000 --> 00:19:41,860
that the new app, the application has
restarted and there's a new set of

342
00:19:41,870 --> 00:19:43,690
usernames and passwords for the database.

343
00:19:44,060 --> 00:19:47,050
So this one ends in 099 and
there's a password of Q9S.

344
00:19:47,550 --> 00:19:50,850
So that is how you can do an
application agnostic approach.

345
00:19:51,180 --> 00:19:53,560
there are some benefits to the
application agnostic approach.

346
00:19:53,570 --> 00:19:56,560
Of course, you don't have to
refactor your application, right?

347
00:19:56,600 --> 00:20:01,110
My application could still happily use,
environment variables from Kubernetes

348
00:20:01,110 --> 00:20:03,750
secrets, and it was none the wiser, right?

349
00:20:03,770 --> 00:20:05,840
Everything else was
handled by the operator.

350
00:20:06,050 --> 00:20:10,930
The operator reauthenticated and helped
me roll out and restart pods on my behalf,

351
00:20:10,960 --> 00:20:15,290
and it issued a new username and password
for a database on my behalf as well.

352
00:20:15,590 --> 00:20:16,430
This is pretty nice.

353
00:20:16,450 --> 00:20:20,030
It means I don't have to go looking
for where these database usernames

354
00:20:20,280 --> 00:20:21,710
and passwords are being referenced.

355
00:20:21,730 --> 00:20:25,105
Instead, what I have to do
is just Make sure that it

356
00:20:25,105 --> 00:20:26,375
connects to the secrets manager.

357
00:20:26,705 --> 00:20:29,175
it makes things a lot easier
from a development perspective.

358
00:20:29,825 --> 00:20:34,695
Now, not every development team wants
to do the application agnostic approach.

359
00:20:34,815 --> 00:20:38,485
and there are a couple of reasons for why
they would not necessarily want to do it.

360
00:20:38,865 --> 00:20:41,745
I encounter a number of developer
communities who prefer to

361
00:20:41,745 --> 00:20:43,125
do everything in the code.

362
00:20:43,435 --> 00:20:46,925
And that's because their application
is particularly performance sensitive.

363
00:20:47,240 --> 00:20:49,810
There are some significant
performance requirements.

364
00:20:50,070 --> 00:20:54,330
That means that they do not accept
any latency, even though Kubernetes

365
00:20:54,330 --> 00:20:56,850
rollout restart is a rolling update.

366
00:20:57,315 --> 00:21:00,245
meaning it's not going to roll
everything, roll every pot at once.

367
00:21:00,255 --> 00:21:01,605
It is going to do it gradually.

368
00:21:02,235 --> 00:21:06,405
it is not sufficient from a performance
standpoint for the application.

369
00:21:06,995 --> 00:21:12,035
So some development communities prefer
to build in the connection to the secrets

370
00:21:12,035 --> 00:21:14,054
manager within the application itself.

371
00:21:14,575 --> 00:21:19,075
Other times it's partially because
they might be developing a developer

372
00:21:19,105 --> 00:21:20,625
community that is being supported.

373
00:21:21,155 --> 00:21:24,465
They might be developing a cloud
native application, but it doesn't

374
00:21:24,465 --> 00:21:26,385
necessarily run in containers.

375
00:21:26,705 --> 00:21:30,365
and so the result is that I
have no choice but to interface

376
00:21:30,365 --> 00:21:32,265
directly with a secrets manager.

377
00:21:32,565 --> 00:21:35,765
they don't have an external
automation process or external

378
00:21:35,765 --> 00:21:39,475
process that can handle the
authentication and injection, right?

379
00:21:39,485 --> 00:21:43,085
Instead, the application itself
has to do everything on its own.

380
00:21:43,525 --> 00:21:45,905
So what is the application aware pattern?

381
00:21:46,825 --> 00:21:49,185
The application aware pattern
is a little bit different.

382
00:21:49,645 --> 00:21:54,465
And then the application now has
to be aware that a new secret, it

383
00:21:54,465 --> 00:21:55,895
needs to retrieve a new secret.

384
00:21:56,395 --> 00:21:58,455
This is a bit nuanced, right?

385
00:21:58,995 --> 00:22:02,915
It's not so easy to tell an application
or for an application to understand,

386
00:22:03,255 --> 00:22:07,165
Oh, this, the old credentials are
going to expire, now I need new ones.

387
00:22:07,745 --> 00:22:09,435
it's not quite intuitive, right?

388
00:22:09,925 --> 00:22:11,875
So there are a couple
patterns to understand.

389
00:22:12,055 --> 00:22:15,665
The first is that in your
code, your application needs to

390
00:22:15,665 --> 00:22:17,195
authenticate to a secrets manager.

391
00:22:17,695 --> 00:22:19,705
Then it needs to track expiration.

392
00:22:19,795 --> 00:22:22,885
There are two ways in which
their code could track

393
00:22:22,885 --> 00:22:24,945
expiration for a secret, right?

394
00:22:24,945 --> 00:22:27,085
So imagine you have database
password version one.

395
00:22:27,805 --> 00:22:31,905
you can set a timer for database version
one, database password version one, and

396
00:22:31,905 --> 00:22:33,595
say, okay, I know that it will be done.

397
00:22:33,625 --> 00:22:35,155
It will be gone in three minutes.

398
00:22:35,370 --> 00:22:39,810
So at two minutes, I am going to
get a new set of secrets, right?

399
00:22:40,330 --> 00:22:42,120
or you can subscribe to events.

400
00:22:42,130 --> 00:22:47,800
So this could be a queue that someone
has put together and they're saying, Oh,

401
00:22:47,800 --> 00:22:53,740
I'm going to make sure that I have, some
kind of event that's getting published

402
00:22:54,420 --> 00:22:56,710
that gets sent to my application.

403
00:22:56,720 --> 00:23:01,890
My application will subscribe to that
event and recognize that this new, this

404
00:23:01,890 --> 00:23:04,850
new set of secrets is going to get,
is going to need to be created, right?

405
00:23:05,200 --> 00:23:07,370
because there's some event that's
saying it's going to expire.

406
00:23:08,195 --> 00:23:12,285
So there are a couple important facts
about this that you have to keep in mind.

407
00:23:12,645 --> 00:23:15,955
The first is that you need to
gracefully shut down any connections.

408
00:23:16,315 --> 00:23:20,305
If you're using an API token or
a database username and password

409
00:23:20,315 --> 00:23:23,385
to connect to a database or any
kind of third party service.

410
00:23:23,795 --> 00:23:26,175
You need to gracefully
disconnect everything.

411
00:23:26,505 --> 00:23:30,225
And this is something I have to emphasize
with developers, especially as I work

412
00:23:30,225 --> 00:23:33,835
with them, then even working with platform
teams who have to enable developers,

413
00:23:34,125 --> 00:23:37,825
I'm often talking to them and saying,
are, do you have any kind of graceful

414
00:23:37,835 --> 00:23:41,275
shutdown or some kind of connection
handling so that you can disconnect

415
00:23:41,285 --> 00:23:42,965
everything that's using the old password?

416
00:23:43,315 --> 00:23:44,604
And they're like, I didn't realize that.

417
00:23:44,605 --> 00:23:46,025
I thought I would just shut it all down.

418
00:23:46,075 --> 00:23:48,295
it turns out you do want to
make sure you're gracefully

419
00:23:48,295 --> 00:23:49,585
shutting down those connections.

420
00:23:49,995 --> 00:23:52,935
And then you can inject new
credentials for new connections.

421
00:23:53,315 --> 00:23:57,005
And then if, let's say the secrets
manager goes down, you do have to handle

422
00:23:57,005 --> 00:23:58,805
retries within the application as well.

423
00:23:58,815 --> 00:24:03,545
So there are a number of patterns you have
to consider as you do a code refactor.

424
00:24:04,295 --> 00:24:09,555
So there's a lot more, logic that you have
to include in your application if you're

425
00:24:09,555 --> 00:24:11,425
doing the application aware approach.

426
00:24:11,925 --> 00:24:15,285
Okay, so we'll take a look at what this
looks like, from an ideal perspective.

427
00:24:15,885 --> 00:24:21,224
Spring Boot is very nice because
it offers two, I guess one, one

428
00:24:21,224 --> 00:24:26,474
library that allows you to inject
the credentials from Vault, into your

429
00:24:26,474 --> 00:24:30,384
configuration, and then it does offer
an SDK for you to interface with Vault.

430
00:24:30,694 --> 00:24:31,724
So it's very convenient.

431
00:24:32,164 --> 00:24:36,984
the first, library that you'll probably
work with is the Spring Vault library.

432
00:24:37,739 --> 00:24:43,249
The Spring Vault library is the base
SDK or base API call to Vault itself.

433
00:24:43,539 --> 00:24:45,039
And then there's Spring Cloud Vault.

434
00:24:45,049 --> 00:24:49,159
Spring Cloud Vault uses Spring
Vault and Spring Cloud Vault injects

435
00:24:49,589 --> 00:24:51,579
configuration properties on your behalf.

436
00:24:51,579 --> 00:24:54,969
So it will retrieve information
from Vault and then inject it into

437
00:24:54,969 --> 00:24:56,599
configuration properties for you.

438
00:24:57,049 --> 00:25:01,189
And they're both really fantastic
examples of good patterns for doing

439
00:25:01,199 --> 00:25:05,459
an application aware approach to
connecting to secrets managers.

440
00:25:06,174 --> 00:25:08,074
And so that's why we're using them today.

441
00:25:08,644 --> 00:25:11,554
But you'll need to add these
dependencies into your application.

442
00:25:11,674 --> 00:25:15,614
Now, if you're using something
like Go, NET, any of the other

443
00:25:15,694 --> 00:25:20,104
language frameworks, you may not
find something that exists, right?

444
00:25:20,764 --> 00:25:23,734
Some libraries do handle
retries, some libraries don't.

445
00:25:23,794 --> 00:25:27,184
do your research, double check
which libraries are able to handle

446
00:25:27,184 --> 00:25:31,564
retries on your behalf, which ones
do injection for you on start up.

447
00:25:31,889 --> 00:25:35,419
and make sure that you are verifying
whether or not those behaviors are

448
00:25:35,419 --> 00:25:38,219
something you're going to need to
write or your development team needs to

449
00:25:38,219 --> 00:25:41,289
write in your application or otherwise.

450
00:25:42,059 --> 00:25:45,059
so there's quite a bit of
research that you'll need to

451
00:25:45,059 --> 00:25:46,829
do in order for this to happen.

452
00:25:47,349 --> 00:25:51,399
I'm including the Spring
Cloud Vault, config, library,

453
00:25:51,399 --> 00:25:55,709
which injects configuration
properties, into my application.

454
00:25:56,694 --> 00:26:02,304
And I'm going to be injecting the static
secret as well as a database secret.

455
00:26:02,934 --> 00:26:06,104
In my application properties,
the biggest thing that you have

456
00:26:06,104 --> 00:26:09,664
to define is authentication to
vault, which are lines five and

457
00:26:09,664 --> 00:26:11,574
six, which is the secrets manager.

458
00:26:11,614 --> 00:26:13,494
There are other ways in
which you can define.

459
00:26:13,819 --> 00:26:18,389
Some kind of authentication if you need
to your secrets manager in this case

460
00:26:18,389 --> 00:26:22,079
This is a configuration property that
you'll set for the library itself But

461
00:26:22,089 --> 00:26:25,649
if you're using other libraries for
other secrets managers, you may find

462
00:26:25,649 --> 00:26:29,885
some differences the other thing that
I do is I have to set a configuration

463
00:26:29,895 --> 00:26:32,255
server to point to my secrets manager.

464
00:26:32,515 --> 00:26:35,175
Again, this depends on the
library that you're using.

465
00:26:35,545 --> 00:26:40,415
I'll enable the database secrets that
I'm going to retrieve as well as key

466
00:26:40,415 --> 00:26:41,825
value secrets that I'm going to retrieve.

467
00:26:41,825 --> 00:26:44,185
Again, these are more
specific to Vault itself.

468
00:26:44,515 --> 00:26:47,625
So check your library for your
secrets manager to determine which

469
00:26:47,645 --> 00:26:48,825
attributes you need to enable.

470
00:26:49,505 --> 00:26:52,155
I've already stored the secrets in Vault.

471
00:26:52,655 --> 00:26:54,505
So we'll pull up the secrets.

472
00:26:54,605 --> 00:26:55,455
I'm sorry.

473
00:26:55,455 --> 00:26:56,565
They're not at that secrets.

474
00:26:56,865 --> 00:27:04,365
They're not at that path, but they are
going to be in the secret path that is

475
00:27:04,365 --> 00:27:06,765
going to match the application name.

476
00:27:07,355 --> 00:27:07,915
and I've.

477
00:27:08,060 --> 00:27:13,020
I already stored them as formatted as
spring application properties, right?

478
00:27:13,020 --> 00:27:13,900
So custom.

479
00:27:13,900 --> 00:27:13,900
staticsecret.

480
00:27:13,900 --> 00:27:17,710
username are custom properties
that I'm defining, and they are

481
00:27:17,710 --> 00:27:19,220
in the form of spring properties.

482
00:27:19,250 --> 00:27:21,150
You can choose not to do this.

483
00:27:21,200 --> 00:27:23,600
I'm just doing this for convenience,
especially as I'm using the

484
00:27:23,600 --> 00:27:25,020
Spring Boot application framework.

485
00:27:25,520 --> 00:27:29,380
So once I set all of that up,
I can now, refactor my code.

486
00:27:29,990 --> 00:27:34,280
if you, again, if you have other
frameworks that you're using, they don't

487
00:27:34,300 --> 00:27:38,890
have an SDK like this or they don't have
a library like this for your use, you

488
00:27:38,890 --> 00:27:40,500
will have to build some of this yourself.

489
00:27:40,530 --> 00:27:44,600
You will have to go and authenticate
to Vault or a secrets manager,

490
00:27:44,640 --> 00:27:46,950
retrieve the secret, and inject it.

491
00:27:47,505 --> 00:27:51,895
so once you, once you get that process
done, the second thing you need to

492
00:27:51,895 --> 00:27:53,885
do is, of course, handle a refresh.

493
00:27:54,385 --> 00:27:57,425
and as I mentioned before, a second
part of the workflow is, detecting

494
00:27:57,425 --> 00:27:58,855
when things need to be refreshed.

495
00:27:59,205 --> 00:28:01,905
the first is that if you have a
static secret, you might choose

496
00:28:01,905 --> 00:28:03,465
to do a scheduled refresh.

497
00:28:03,745 --> 00:28:07,485
And a scheduled refresh works perfectly
fine, especially if you have a password

498
00:28:07,485 --> 00:28:09,145
that's not going to change that often.

499
00:28:09,465 --> 00:28:11,765
Now, if you have a password that
you're planning to change every 10

500
00:28:11,765 --> 00:28:16,050
minutes, This might not be ideal, but
for a more simplistic implementation,

501
00:28:16,050 --> 00:28:19,470
you can just schedule delay and
then refresh the application.

502
00:28:19,500 --> 00:28:22,490
In this case, I'm using what
is called a spring, spring

503
00:28:22,490 --> 00:28:24,230
applications context refresh.

504
00:28:24,920 --> 00:28:28,670
And what this will do is refresh
the application context for me.

505
00:28:28,890 --> 00:28:31,440
I do have to tell it what
objects to refresh and.

506
00:28:32,230 --> 00:28:36,970
Exactly what needs to be recreated,
but it will issue what is

507
00:28:36,970 --> 00:28:38,840
called a context refresh for me.

508
00:28:39,580 --> 00:28:44,019
Again, you can change this to do some
kind of event subscription if you want to.

509
00:28:44,280 --> 00:28:47,830
for example, you can detect whether
or not a secret has changed in

510
00:28:47,830 --> 00:28:51,340
the Secrets Manager, publish that
event, and then your application can

511
00:28:51,340 --> 00:28:56,020
subscribe to it, but most secrets
just can handle a scheduled refresh.

512
00:28:56,060 --> 00:29:00,840
They don't need to have a
real time event based refresh.

513
00:29:01,420 --> 00:29:04,410
The other thing that you might want
to consider, especially for dynamic

514
00:29:04,410 --> 00:29:07,895
secrets, if you know that There
is a secret that's going to expire

515
00:29:07,935 --> 00:29:09,175
within a certain period of time.

516
00:29:09,235 --> 00:29:10,125
Let's say three minutes.

517
00:29:10,455 --> 00:29:16,745
you can of course create some kind
of event system for you to find

518
00:29:16,745 --> 00:29:18,625
some kind of lease expired event.

519
00:29:18,955 --> 00:29:24,370
so in this case spring Vault has a
secret lease expired event as a lease

520
00:29:24,370 --> 00:29:26,770
listener that I can, I can subscribe to.

521
00:29:26,960 --> 00:29:30,080
And then if I detect a secret
lease expired event, then I

522
00:29:30,110 --> 00:29:31,530
can refresh the application.

523
00:29:32,320 --> 00:29:33,710
So this is the second way to do it.

524
00:29:33,730 --> 00:29:37,840
Again, if you're using a static secret
or a rotated secret that has some kind

525
00:29:37,840 --> 00:29:41,720
of frequency, like lower frequency
in rotation, you could probably

526
00:29:41,720 --> 00:29:44,570
just do a scheduled task to reload.

527
00:29:44,735 --> 00:29:48,985
The application with that secret,
or if you have a requirement for

528
00:29:48,985 --> 00:29:53,135
a more real time approach, you can
do some kind of event subscription,

529
00:29:53,145 --> 00:29:54,465
and that's what this is showing.

530
00:29:54,965 --> 00:29:57,845
Either way, both patterns do work.

531
00:29:58,205 --> 00:30:00,695
It's just a matter of making sure
that you are able to implement

532
00:30:00,695 --> 00:30:01,785
it properly in your code.

533
00:30:02,285 --> 00:30:06,295
So after you've set up some kind of
refresh mechanism, whether it be on a

534
00:30:06,295 --> 00:30:10,425
schedule or you're subscribed to some
kind of event, the next thing you do

535
00:30:10,505 --> 00:30:13,045
need to do is identify how to reload.

536
00:30:13,455 --> 00:30:14,805
all of your objects, right?

537
00:30:15,215 --> 00:30:20,555
and that's where this is probably the
most important part of the code refactor

538
00:30:20,565 --> 00:30:24,695
that most development teams and platform
teams that I work with tend to forget.

539
00:30:25,215 --> 00:30:28,785
I'm going to enable scheduling,
since I am scheduling a task

540
00:30:28,805 --> 00:30:30,765
to reload a static credential.

541
00:30:31,205 --> 00:30:36,225
the most important part that I would say
developers and platform engineers when

542
00:30:36,225 --> 00:30:38,025
we're talking about dynamic secrets.

543
00:30:38,760 --> 00:30:43,460
The ones that kind of forget is
actually refreshing the credentials

544
00:30:43,540 --> 00:30:45,440
into objects that are using them.

545
00:30:45,850 --> 00:30:49,380
What I mean is that it's not enough
to, for the application to refresh and

546
00:30:49,390 --> 00:30:52,470
reload those usernames and passwords
into some kind of property list.

547
00:30:52,760 --> 00:30:55,990
You need to re inject those properties
back into any objects that use them.

548
00:30:56,480 --> 00:30:58,430
Good example of this is
like data source, right?

549
00:30:58,730 --> 00:31:00,370
in a Java data source.

550
00:31:00,670 --> 00:31:03,770
It needs to connect to the database
and it needs a username and a password.

551
00:31:04,210 --> 00:31:08,540
I have to recreate the entire data source
with the new username and new password.

552
00:31:08,940 --> 00:31:14,340
This is incredibly important because
if I don't, then my application will

553
00:31:14,340 --> 00:31:17,330
continue to use the old username
and old password to continue

554
00:31:17,330 --> 00:31:19,210
connecting to the database since.

555
00:31:19,840 --> 00:31:20,860
It's not been refreshed.

556
00:31:20,860 --> 00:31:22,590
The entire object has not been refreshed.

557
00:31:23,020 --> 00:31:26,900
So I use what is called a Spring,
Spring Boot's refresh scope annotation

558
00:31:27,250 --> 00:31:32,620
to basically let Spring Boot know you
need to refresh this entire object and

559
00:31:32,620 --> 00:31:35,910
you need to make sure that you're using
the latest username and the latest

560
00:31:35,910 --> 00:31:40,980
password from properties and rebuild
the entire data source on my behalf.

561
00:31:41,790 --> 00:31:45,160
The underlying implementation does
a graceful shutdown of connections.

562
00:31:45,560 --> 00:31:47,980
so I don't have to necessarily
implement that myself.

563
00:31:48,380 --> 00:31:52,400
But if, again, you have a framework
that is not Spring Boot, and you have

564
00:31:52,400 --> 00:31:55,570
a framework that you have to implement
this all yourself, you do have to have

565
00:31:55,570 --> 00:32:00,130
some kind of graceful disconnection
capability built into the code base.

566
00:32:00,725 --> 00:32:03,995
and you can do that by abstracting
that into a library, some library

567
00:32:03,995 --> 00:32:05,005
that you've written yourself.

568
00:32:05,325 --> 00:32:10,395
but do keep in mind that it's not just
a combination of detecting the event of

569
00:32:10,405 --> 00:32:12,885
needing to refresh or change the secret.

570
00:32:13,225 --> 00:32:18,745
The secret itself also needs to get re
injected into any, client connection

571
00:32:18,805 --> 00:32:20,825
or data connection that's using it.

572
00:32:21,175 --> 00:32:24,425
So those are two critical, pieces
of the workflow that I often see

573
00:32:24,425 --> 00:32:28,815
are forgotten, especially when we're
talking about, refreshing applications

574
00:32:28,815 --> 00:32:30,925
to account for dynamic secrets.

575
00:32:31,425 --> 00:32:34,175
All right, so I'm going to run
the application, just to show

576
00:32:34,185 --> 00:32:35,455
exactly what this looks like.

577
00:32:36,065 --> 00:32:40,245
unlike the, Kubernetes example
that I showed, this will refresh

578
00:32:40,255 --> 00:32:43,325
within the application, meaning
the application does not restart.

579
00:32:43,355 --> 00:32:46,395
It just simply reloads the, credentials.

580
00:32:46,585 --> 00:32:51,985
So the first database credential
has a username suffix of 8443 and

581
00:32:51,985 --> 00:32:57,595
a password prefix of F A. And I
have an expiration of two minutes

582
00:32:57,605 --> 00:32:58,965
for these database credentials.

583
00:32:59,175 --> 00:33:03,355
So after about two minutes, this
application is going to rebuild the data

584
00:33:03,355 --> 00:33:05,515
source with a new set of credentials.

585
00:33:06,345 --> 00:33:12,070
What's important to recognize about a
number of the, these applications that do

586
00:33:12,070 --> 00:33:14,100
have, are aware of the secrets manager.

587
00:33:14,520 --> 00:33:16,650
You do have to handle any retries.

588
00:33:16,750 --> 00:33:21,370
if let's say the secrets manager
is not on, not online, and you

589
00:33:21,370 --> 00:33:22,560
can't connect to it, right?

590
00:33:22,750 --> 00:33:26,064
You have to make sure that you can
cache the secrets, existing secrets.

591
00:33:26,315 --> 00:33:30,355
If the secrets manager is offline, it's
not going to rotate the secret for you,

592
00:33:30,365 --> 00:33:32,085
so things are fine for the most part.

593
00:33:32,435 --> 00:33:35,525
the biggest problem is actually whether
or not the application itself can cache

594
00:33:35,525 --> 00:33:38,585
these secrets, especially if you're doing
some kind of scheduled refresh, right?

595
00:33:39,105 --> 00:33:41,035
you don't want to override
the previous secret.

596
00:33:41,300 --> 00:33:45,350
Ideally, you want to keep the old
secret cached until you can reconnect

597
00:33:45,350 --> 00:33:46,590
back to the secrets manager.

598
00:33:47,300 --> 00:33:53,830
The other important thing to know is that
if you are doing this within a framework

599
00:33:53,860 --> 00:33:58,920
that doesn't handle graceful shutdown, you
will have to handle the graceful shutdown.

600
00:33:59,485 --> 00:34:02,925
Make sure that you're clear on what
that sequence looks like and make

601
00:34:02,925 --> 00:34:05,795
sure you're clear on what handling
you want in your application.

602
00:34:06,225 --> 00:34:07,995
it's not necessarily
just databases, right?

603
00:34:08,515 --> 00:34:11,115
So we've now got the database
credentials refreshed.

604
00:34:11,125 --> 00:34:14,805
I'm going to create, make an
API call to the application.

605
00:34:15,195 --> 00:34:19,195
in the case of Spring, you have
to make an API call, in order for

606
00:34:19,205 --> 00:34:21,365
it to reconnect to the database.

607
00:34:21,685 --> 00:34:24,825
So it rebuilt the secret with
a new set of secrets, right?

608
00:34:25,120 --> 00:34:28,600
Different, suffix you'll notice for
the username and different password.

609
00:34:29,080 --> 00:34:32,400
it's got a new username and password
and now it's restarting a Hikari

610
00:34:32,400 --> 00:34:34,690
pool or a database connection pool.

611
00:34:35,210 --> 00:34:40,010
and so all of these are quite
important steps in the process.

612
00:34:40,370 --> 00:34:42,710
Especially if you have
application aware approach.

613
00:34:43,555 --> 00:34:43,715
All right.

614
00:34:43,735 --> 00:34:47,115
So I didn't mention before there
are benefits and disadvantages to

615
00:34:47,115 --> 00:34:49,275
each with application agnostic.

616
00:34:49,285 --> 00:34:52,465
You're able to support many
languages and frameworks and you're

617
00:34:52,465 --> 00:34:54,085
maximizing platform automation.

618
00:34:54,475 --> 00:34:58,075
So I see this pattern quite a
lot in the kubernetes ecosystem.

619
00:34:58,415 --> 00:35:03,045
most of the time when you have
heterogeneous programming language

620
00:35:03,045 --> 00:35:07,225
types, different types of containers
running in a kubernetes cluster.

621
00:35:07,475 --> 00:35:08,199
most languages.

622
00:35:08,860 --> 00:35:13,080
Codebases don't really want the
work of refactoring, their code

623
00:35:13,090 --> 00:35:15,150
in order to support a live reload.

624
00:35:15,600 --> 00:35:19,560
and for the most part, the availability
of the application will depend on

625
00:35:19,560 --> 00:35:20,930
the number of instances you have.

626
00:35:21,220 --> 00:35:25,870
Most of the time you're running multiple
replicas of the application in Kubernetes

627
00:35:25,870 --> 00:35:27,480
or some kind of cloud native environment.

628
00:35:27,750 --> 00:35:32,870
So a rollout, that has like a rolling
update capability is not going to disrupt

629
00:35:32,870 --> 00:35:34,460
the application significantly, right?

630
00:35:34,960 --> 00:35:38,800
So the good news about application
agnostic approach is that you can

631
00:35:38,800 --> 00:35:40,380
maximize your platform automation.

632
00:35:40,390 --> 00:35:42,920
This makes it a little bit
easier for it to be maintained

633
00:35:42,930 --> 00:35:44,640
by a platform engineering team.

634
00:35:45,340 --> 00:35:50,680
However, there are reasons that I've
seen for people to do application aware.

635
00:35:51,560 --> 00:35:55,835
There are organizations that I've
worked with who Standardized on very

636
00:35:55,835 --> 00:35:57,045
few languages and frameworks, right?

637
00:35:57,045 --> 00:36:00,025
They're all committed to spring boot
or they're all committed to dot net,

638
00:36:00,585 --> 00:36:06,525
and they would rather invest in code
libraries or their own libraries to

639
00:36:06,525 --> 00:36:12,985
handle all the code because they prefer
to control the performance as well as

640
00:36:12,995 --> 00:36:14,785
the behavior of their applications.

641
00:36:15,240 --> 00:36:17,870
In response to changes to
dynamic secrets, right?

642
00:36:18,370 --> 00:36:21,820
And so the availability will
depend on the code base.

643
00:36:22,250 --> 00:36:25,670
You're only as good as the
code that you've written from

644
00:36:25,730 --> 00:36:27,180
a performance standpoint.

645
00:36:27,180 --> 00:36:29,320
So there's a lot of testing involved.

646
00:36:29,320 --> 00:36:32,300
There are a lot of patterns going
back and forth and trying to evaluate.

647
00:36:32,355 --> 00:36:36,205
A lot of stress testing involved
when there's a third party or a new

648
00:36:36,215 --> 00:36:37,695
library that's being introduced.

649
00:36:38,165 --> 00:36:41,635
but if there are a few languages, only
a few languages that are approved,

650
00:36:42,075 --> 00:36:45,965
and most applications are being
developed in a single language, then I

651
00:36:45,965 --> 00:36:49,765
do see organizations who go with this
application aware approach, and they

652
00:36:49,765 --> 00:36:51,535
would rather refactor the application.

653
00:36:52,405 --> 00:36:55,565
The, downside is that it
doesn't maximize code refactor.

654
00:36:55,575 --> 00:36:57,245
So you do have to take some time.

655
00:36:57,540 --> 00:37:03,870
So refactor your code base to
handle and reinject the secrets.

656
00:37:03,940 --> 00:37:06,330
And this is something
that is not going to be.

657
00:37:06,950 --> 00:37:12,110
Let's say, abstracted away by a
platform team building like us the

658
00:37:12,110 --> 00:37:16,430
equivalent of, let's say, like Spring
Cloud Vault for their chosen framework.

659
00:37:16,900 --> 00:37:19,560
it is something that has to be
done within the application itself.

660
00:37:19,910 --> 00:37:23,240
And I think that's the challenge
that I typically encounter with

661
00:37:23,240 --> 00:37:26,709
development communities and
organizations who are trying to do this.

662
00:37:27,150 --> 00:37:30,040
they're saying, Oh, I, I know I
need to reload this object with a

663
00:37:30,040 --> 00:37:34,030
new username and password, but I've
done it in a nonstandard way and

664
00:37:34,030 --> 00:37:35,560
we've had this code for four years.

665
00:37:35,560 --> 00:37:36,870
It's not like I'm going to change it.

666
00:37:36,880 --> 00:37:42,510
So there are some nuances there and
that most of the time platform teams

667
00:37:42,510 --> 00:37:43,960
are trying to navigate and understand.

668
00:37:44,120 --> 00:37:48,150
it does minimize platform automation,
so there is a good benefit in some

669
00:37:48,150 --> 00:37:52,650
ways to this in that if your platform
is particularly resource constrained,

670
00:37:53,320 --> 00:37:59,320
you don't want to be, adding more
separate processes to your cluster

671
00:37:59,350 --> 00:38:02,915
to your container orchestrator or
something, this application aware

672
00:38:02,915 --> 00:38:06,355
approach is a way to alleviate some
of the burden and put it into code,

673
00:38:06,785 --> 00:38:08,805
but there's two approaches to it.

674
00:38:08,895 --> 00:38:12,005
The cloud native approach, of course,
is to think about doing this from an

675
00:38:12,015 --> 00:38:16,525
application agnostic perspective, meaning
that the application itself should not

676
00:38:16,535 --> 00:38:21,335
have any significant or understanding
of the interface to the secrets manager.

677
00:38:21,835 --> 00:38:25,545
But there are reasons for folks who do
want to do application aware, even if

678
00:38:25,545 --> 00:38:27,605
they do have a cloud native application.

679
00:38:28,105 --> 00:38:32,855
Before you choose either application
agnostic or application aware, though,

680
00:38:33,395 --> 00:38:36,305
if you're a platform engineer or
you're a development team that's the

681
00:38:36,305 --> 00:38:40,325
center of excellence for things, or a
developer community who's, trying to

682
00:38:40,325 --> 00:38:45,205
standardize and trying to figure out
what's best, Do assess your applications.

683
00:38:45,535 --> 00:38:47,705
I think this is the biggest
mistake that I've seen.

684
00:38:48,465 --> 00:38:51,525
Most folks don't really know
what applications are running.

685
00:38:52,155 --> 00:38:55,375
Document what your run times are,
where are the applications running,

686
00:38:55,565 --> 00:38:58,565
how they're running, are they in
containers, are they not in containers.

687
00:38:59,415 --> 00:39:06,365
There are a lot of systems that don't
have containerized applications and it's

688
00:39:06,365 --> 00:39:11,165
a mix of the two, ideally in cloud native,
of course, we take we tend to, we tend

689
00:39:11,165 --> 00:39:14,525
to think of cloud native as containers
only, but that's not always the case.

690
00:39:14,525 --> 00:39:18,305
you is possible on occasion to have
an application that follows some

691
00:39:18,305 --> 00:39:21,235
cloud need of principles, but not
necessarily running in a container.

692
00:39:21,865 --> 00:39:24,115
And so do assess the runtime.

693
00:39:24,210 --> 00:39:27,450
Do assess the frameworks
that you are using.

694
00:39:27,520 --> 00:39:30,930
And if you're using spring boot, then
you have a lot of libraries available

695
00:39:30,930 --> 00:39:35,140
to you that handle injection as well
as authentication to secrets managers.

696
00:39:35,400 --> 00:39:39,260
There are many of them, and there are
very, they are very convenient to use,

697
00:39:39,290 --> 00:39:42,980
but make sure you understand their
behaviors if you have, other frameworks

698
00:39:43,760 --> 00:39:48,130
that don't necessarily support a
retry, doesn't support any kind of

699
00:39:48,140 --> 00:39:49,720
interfacing with your secrets manager.

700
00:39:50,590 --> 00:39:53,270
You may have to write some
additional code on your own.

701
00:39:53,270 --> 00:39:55,500
So you do have to assess
what frameworks exist.

702
00:39:56,150 --> 00:39:57,760
And then availability requirements.

703
00:39:58,330 --> 00:40:04,370
Some applications do not, do not perform
well, with an application aware approach.

704
00:40:04,600 --> 00:40:07,760
they are, and they perform better
with an application agnostic approach.

705
00:40:08,170 --> 00:40:10,730
So they are horizontally scalable.

706
00:40:10,790 --> 00:40:14,290
They are able to be reloaded and
rolled out with a rolling update.

707
00:40:14,740 --> 00:40:16,784
Oops.

708
00:40:17,265 --> 00:40:20,235
With a rolling update,
while others do not, right?

709
00:40:20,235 --> 00:40:24,315
So it's dependent on your availability
requirements for your application.

710
00:40:24,815 --> 00:40:25,905
And then finally, secrets.

711
00:40:25,915 --> 00:40:27,805
Secrets, there are many types.

712
00:40:28,115 --> 00:40:32,825
So you know, we talked about database and
API credentials, but secrets injected into

713
00:40:32,825 --> 00:40:34,755
applications can range from certificates.

714
00:40:35,385 --> 00:40:40,035
to some other kind of identification
that allows access, right?

715
00:40:40,095 --> 00:40:43,445
if you have, let's say, AWS and
you're on a cloud service provider,

716
00:40:43,705 --> 00:40:48,225
they may have their own unique,
authentication and instance information,

717
00:40:48,245 --> 00:40:50,985
metadata information and things
like that for you to authenticate.

718
00:40:51,775 --> 00:40:55,335
And you also want to document the
rotation frequency of secrets that

719
00:40:55,335 --> 00:40:56,675
are being used by your application.

720
00:40:57,175 --> 00:41:02,255
I would say most of the time, I don't
get a solid answer on what the rotation

721
00:41:02,255 --> 00:41:04,895
frequency of application secrets are.

722
00:41:04,955 --> 00:41:07,975
Most of the time I get, an
explanation of, we only rotate

723
00:41:07,975 --> 00:41:10,224
it on demand, which is never.

724
00:41:10,225 --> 00:41:13,605
We've kept this secret around for
three years and we've never touched it.

725
00:41:14,155 --> 00:41:15,605
and that's perfectly fine.

726
00:41:15,905 --> 00:41:19,545
It's just good to document, which
secrets you may expect to rotate

727
00:41:19,545 --> 00:41:21,175
more frequently and which types.

728
00:41:21,530 --> 00:41:25,580
Database credentials, for example, you
may expect to be, asked to rotate them

729
00:41:25,580 --> 00:41:27,620
every 30 days from a security perspective.

730
00:41:27,980 --> 00:41:30,810
certificates, you could have
a lifetime of 10 years, but

731
00:41:30,810 --> 00:41:32,870
certificates themselves also expire.

732
00:41:33,250 --> 00:41:36,490
and certificates, may have a rotation
frequency of 5 years or a year,

733
00:41:36,520 --> 00:41:38,350
depending on the certificates.

734
00:41:38,395 --> 00:41:42,325
documenting how these secrets are working
within the application is very important.

735
00:41:42,505 --> 00:41:46,595
Doing this discovery phase will help
alleviate a lot of the questions and

736
00:41:46,645 --> 00:41:49,995
inform whether or not you should be
thinking about an application agnostic

737
00:41:49,995 --> 00:41:54,975
approach or an application aware approach,
when you think about having, dynamic

738
00:41:54,975 --> 00:41:58,575
secrets or any kind of interfacing
with secrets in your application.

739
00:41:59,075 --> 00:42:00,385
And finally, developer enablement.

740
00:42:00,415 --> 00:42:02,145
After all, I said that
was the main secret.

741
00:42:03,145 --> 00:42:09,245
all of the patterns that I taught here in
this session, you can take back, right?

742
00:42:09,285 --> 00:42:11,275
Take back and build
documentation around them.

743
00:42:11,285 --> 00:42:13,895
These are the most common
patterns that I've seen.

744
00:42:14,305 --> 00:42:18,555
For developers to inject secrets
into their application and handle

745
00:42:18,565 --> 00:42:23,645
more dynamic or dynamic secrets that
are changing more frequently, right?

746
00:42:23,925 --> 00:42:27,145
so document these common patterns,
organize the workflows and

747
00:42:27,145 --> 00:42:30,025
articulate and communicate them
to your development communities,

748
00:42:30,385 --> 00:42:31,905
learn them for yourself as well.

749
00:42:32,170 --> 00:42:33,740
and provide lots of code examples.

750
00:42:33,790 --> 00:42:38,480
Most developer communities within an
organization or who are trying to build

751
00:42:38,480 --> 00:42:42,570
their cloud native application, they
do want a lot of code examples, right?

752
00:42:43,380 --> 00:42:46,860
Office hours are pretty critical,
and I would say do one or two live

753
00:42:46,860 --> 00:42:48,800
refactors with certain development teams.

754
00:42:49,290 --> 00:42:50,660
This has been really helpful.

755
00:42:50,945 --> 00:42:55,905
in my experience, because you get a sense
of what the development team patterns are,

756
00:42:56,225 --> 00:43:00,295
and you also get to identify any pitfalls
that you might not have thought about.

757
00:43:00,355 --> 00:43:03,605
a good example of this, as I was working
with a develop, a development team,

758
00:43:04,055 --> 00:43:10,925
and they had some specific patterns in
Spring Boot, and they didn't use beans.

759
00:43:10,925 --> 00:43:14,745
They didn't use the annotation
for Bean, which meant that refresh

760
00:43:14,745 --> 00:43:16,145
didn't quite work right for them.

761
00:43:16,205 --> 00:43:18,495
it was good to understand
what they were looking for.

762
00:43:18,555 --> 00:43:22,625
other teams that I had worked with,
they are using, let's say, GraalVM or

763
00:43:22,625 --> 00:43:27,485
Native Image, and they couldn't use
Reflection, Java Reflection, right?

764
00:43:27,575 --> 00:43:33,225
we had to write some code from scratch,
to help, detect whether or not those

765
00:43:33,525 --> 00:43:37,935
credentials were changed and then refresh,
refresh these objects by local proxy.

766
00:43:37,985 --> 00:43:41,795
like I said, this sounds maybe complicated
or if you're not familiar with Spring.

767
00:43:41,950 --> 00:43:43,000
doesn't make any sense.

768
00:43:43,000 --> 00:43:46,550
But the reality is there are
only patterns that you're going

769
00:43:46,550 --> 00:43:48,540
to find during live refactor.

770
00:43:48,910 --> 00:43:52,570
and it's good to learn those new patterns,
identify what the development communities

771
00:43:52,580 --> 00:43:54,090
are using, what they're not using.

772
00:43:54,530 --> 00:43:57,780
and it's helpful to build videos
around certain patterns, as well.

773
00:43:57,790 --> 00:44:01,390
I think a lot of the, platform teams
that I've worked with, they're like, Oh,

774
00:44:01,390 --> 00:44:03,280
can we just make a video out of this?

775
00:44:03,280 --> 00:44:06,080
Like we'll just cut and,
cut away some of the pieces.

776
00:44:06,350 --> 00:44:09,630
But the most important thing for us
is we just want to make sure that we

777
00:44:09,670 --> 00:44:12,760
distribute this to our developer community
so they can see this live refactor.

778
00:44:13,615 --> 00:44:17,105
And finally, from a development
perspective, you may have to build

779
00:44:17,175 --> 00:44:21,375
new interfaces in order to support
this paradigm of dynamic secrets.

780
00:44:21,795 --> 00:44:26,395
sometimes you don't have frameworks
that support a retry, a proper retry.

781
00:44:26,755 --> 00:44:29,715
Other times You know, there are new
frameworks out there that are coming out.

782
00:44:30,185 --> 00:44:35,245
and then you can't, you just don't have
the ability at that point to support

783
00:44:35,525 --> 00:44:37,365
retrieval from secrets managers, right?

784
00:44:37,375 --> 00:44:39,995
So you have to write your
own API and SDK for it.

785
00:44:40,645 --> 00:44:45,085
so build the interfaces if you need it
and certainly assess any exceptions.

786
00:44:45,705 --> 00:44:49,795
there are a number of communities
that I've worked with who went

787
00:44:49,795 --> 00:44:53,405
down the application aware path,
only to find that it doesn't

788
00:44:53,405 --> 00:44:54,855
really work for their application.

789
00:44:54,895 --> 00:44:57,615
maybe a small portion, like 20
percent of their applications.

790
00:44:58,005 --> 00:45:00,265
And so they'll end up doing
the application agnostic

791
00:45:00,265 --> 00:45:01,325
approach for that 20%.

792
00:45:01,775 --> 00:45:04,965
This happens for, maybe not
necessarily cloud native

793
00:45:04,965 --> 00:45:09,250
applications, but applications
that Cloud Native, the Cloud Native

794
00:45:09,280 --> 00:45:11,250
environment runs or accesses, right?

795
00:45:11,260 --> 00:45:15,690
These are services that are not Cloud
Native themselves, but are heavily

796
00:45:15,690 --> 00:45:18,270
dependent on by a Cloud Native service.

797
00:45:18,330 --> 00:45:23,020
these could be date, older databases,
or they could also be, older APIs.

798
00:45:23,990 --> 00:45:26,800
So do assess any exceptions
that you do have.

799
00:45:26,810 --> 00:45:30,610
You will have a combination of
not application aware, but also

800
00:45:30,610 --> 00:45:32,530
application agnostic approaches, right?

801
00:45:32,530 --> 00:45:35,200
Because not every framework
will support it and not every

802
00:45:35,200 --> 00:45:38,620
application will be able to interface
directly with the secrets manager.

803
00:45:38,630 --> 00:45:43,130
And similarly, in the application
agnostic approach, you might not find the

804
00:45:43,130 --> 00:45:45,970
capability exists in your runtime, right?

805
00:45:46,820 --> 00:45:49,420
Depending on the container
orchestrator you're using or just

806
00:45:49,430 --> 00:45:50,890
workload orchestration in general.

807
00:45:51,390 --> 00:45:54,610
Finally, that's the end of The Secret.

808
00:45:54,900 --> 00:45:55,560
it's a lot.

809
00:45:55,560 --> 00:45:57,270
It's a pretty big secret, actually.

810
00:45:57,610 --> 00:46:00,050
but I'm trying not to keep
it a secret any longer.

811
00:46:00,050 --> 00:46:02,890
So if you do have any questions,
you're welcome to reach out to me.

812
00:46:03,210 --> 00:46:06,020
All this material is
available on my webpage.

813
00:46:06,640 --> 00:46:10,790
So feel free to review it and distribute
it to your own development communities.

814
00:46:10,810 --> 00:46:14,930
If you're a developer who wants to handle
dynamic sequencing your application,

815
00:46:14,940 --> 00:46:18,330
hopefully you have a sense of the
patterns that you need to implement.

816
00:46:18,580 --> 00:46:22,170
If you're a security team or a
platform engineering team that needs

817
00:46:22,170 --> 00:46:27,015
to identify and assess and educate
your development community on how to

818
00:46:27,015 --> 00:46:29,005
use a centralized secrets manager.

819
00:46:29,345 --> 00:46:32,615
hopefully this provides some valuable
information on how to improve the

820
00:46:32,655 --> 00:46:35,375
overall adoption of your secrets
manager and make it a little

821
00:46:35,375 --> 00:46:37,215
bit easier for your developers.

822
00:46:37,465 --> 00:46:37,855
Thank you.

