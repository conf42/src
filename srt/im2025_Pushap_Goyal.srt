1
00:00:00,500 --> 00:00:01,159
Hi everyone.

2
00:00:01,819 --> 00:00:02,780
My name is Push.

3
00:00:03,050 --> 00:00:06,590
Today I will be presenting
accelerating IR response with

4
00:00:06,590 --> 00:00:08,120
distributed draft Technology.

5
00:00:08,620 --> 00:00:09,460
Okay, let's begin.

6
00:00:10,180 --> 00:00:12,760
So could disclaimer before
we go further and talk.

7
00:00:12,760 --> 00:00:16,870
So content presented here is based on my
personal experience and publicly available

8
00:00:16,870 --> 00:00:21,310
information, it has not been officially
approved and endorse by any organization.

9
00:00:21,810 --> 00:00:24,990
Let's discuss the limitations
of the traditional I systems.

10
00:00:25,560 --> 00:00:30,450
So I categorize the problem enough for
subcategories, the data fragmentation,

11
00:00:30,450 --> 00:00:34,320
time, synchronization issues, relationship
lightness, and manual correlation

12
00:00:34,320 --> 00:00:36,690
overload, so data fragmentation.

13
00:00:37,140 --> 00:00:41,129
So in today's world, we have a
lot of systems producing data.

14
00:00:41,129 --> 00:00:46,260
It's very hard to connect the data across
those disconnected system, which hinders

15
00:00:46,260 --> 00:00:48,150
a timely aggregation and correlation.

16
00:00:48,930 --> 00:00:50,640
The next is time synchronization.

17
00:00:50,910 --> 00:00:54,420
So all the systems generate
events according to times

18
00:00:54,510 --> 00:00:55,740
which is relevant to them.

19
00:00:55,800 --> 00:01:00,900
So we don't get accurate forensic time
when we want to reconstruct everything.

20
00:01:01,400 --> 00:01:04,580
Relationship planning has traditional
model failed to capture the complex

21
00:01:04,580 --> 00:01:06,350
relationship between various entities.

22
00:01:06,850 --> 00:01:08,530
The last one is manual correlation.

23
00:01:08,530 --> 00:01:15,250
I've seen lot of SRE engineers looking at
dashboards, which is very time process to.

24
00:01:15,750 --> 00:01:16,350
That happened.

25
00:01:16,620 --> 00:01:21,280
The, so these inherent limitations
result in fundamental problems in the

26
00:01:21,280 --> 00:01:24,790
security systems, which are leading
extended detection system, reservation

27
00:01:24,790 --> 00:01:28,030
time, and incomplete investigation,
and increased operational cost.

28
00:01:28,840 --> 00:01:30,520
We trying to address these issues.

29
00:01:31,020 --> 00:01:33,930
So now graph technology
for incident response.

30
00:01:34,620 --> 00:01:41,910
So graph can transform the all the
entities in a relationship model, which

31
00:01:41,970 --> 00:01:43,920
can help us to debug the issue better.

32
00:01:44,460 --> 00:01:49,050
So it can categorize the issue
among nodes, edges, and properties.

33
00:01:49,050 --> 00:01:50,430
So nodes are the users.

34
00:01:50,430 --> 00:01:55,050
Machine IP addresses, processes,
edges can be like relationship access

35
00:01:55,770 --> 00:01:59,910
created, communicated with properties
can be contextual information like

36
00:02:00,000 --> 00:02:02,220
timestamps, severity, and classifications.

37
00:02:02,985 --> 00:02:07,635
So the structure enable us relationship
based investigation, which follows

38
00:02:07,635 --> 00:02:11,175
the natural progression of security
incident across the system boundaries.

39
00:02:11,675 --> 00:02:16,175
So in graph database, we can build
this unified sematic layer across

40
00:02:16,235 --> 00:02:19,835
all silo data sources enabling
the comprehensive analysis.

41
00:02:20,015 --> 00:02:20,915
For example, we can.

42
00:02:21,415 --> 00:02:25,075
Put all the data from network
application endpoint, cloud

43
00:02:25,345 --> 00:02:30,265
identity indexes in one big giant
dashboard and we can query across.

44
00:02:30,765 --> 00:02:34,815
So now whatever problems we've discussed,
spanner graph is a natural fit for that.

45
00:02:35,175 --> 00:02:38,565
There are a lot of SaaS application
available in the market, but with span

46
00:02:38,565 --> 00:02:41,345
graph, we just use graph for your.

47
00:02:41,845 --> 00:02:45,565
Day to day OTP workload and
also for analysis, workload,

48
00:02:45,565 --> 00:02:47,005
and build a huge graph.

49
00:02:47,485 --> 00:02:52,405
So SPAN graph is a globally distributed
graph, extending spans capability

50
00:02:52,405 --> 00:02:56,005
for precise, reliable analysis
of massive distributed dataset.

51
00:02:56,905 --> 00:03:01,075
So for incident response, paragraph
offers global consistency.

52
00:03:01,165 --> 00:03:05,095
All it ensures like all the data
is consistent and immediately

53
00:03:05,155 --> 00:03:06,745
available across all regions.

54
00:03:07,225 --> 00:03:07,375
The.

55
00:03:07,875 --> 00:03:10,965
It enables a precise globally
synchronized timelines.

56
00:03:10,965 --> 00:03:13,005
Eliminate the timestamp discrepancies.

57
00:03:13,395 --> 00:03:17,715
For accurate forensic P construction
relationship model, we can bring

58
00:03:17,715 --> 00:03:22,605
the massive graph by edges and
connect those edges across multiple

59
00:03:22,605 --> 00:03:25,335
nodes, scalability and reliability.

60
00:03:25,425 --> 00:03:28,965
So Spanner inherently has horizontal
scalability for petabytes of

61
00:03:29,000 --> 00:03:31,920
data with automatic charging and
replication for high availability.

62
00:03:32,420 --> 00:03:35,930
By combining these attributes,
paragraph, transform the fragmented

63
00:03:35,930 --> 00:03:41,160
data into cohesive, globally
consistent relationship based database,

64
00:03:41,160 --> 00:03:44,520
which can accelerate investigation
and strengthen security portion.

65
00:03:45,020 --> 00:03:48,230
We already discussed two specific
things, which are already interesting.

66
00:03:48,230 --> 00:03:50,545
First is two, time Mother
is a relationship model.

67
00:03:51,045 --> 00:03:55,575
True is a very fundamental
construct in this span, a PA, which

68
00:03:55,575 --> 00:04:00,795
provides solution to as problems,
like we get globally consistent

69
00:04:00,855 --> 00:04:03,305
timestamps across different system.

70
00:04:04,190 --> 00:04:08,410
We get bounded uncertainty,
so we have a maximum skew.

71
00:04:09,080 --> 00:04:12,950
That can happen between various
even cordial consistency.

72
00:04:13,130 --> 00:04:16,220
It guarantees that events are ordered
across all regions, preventing

73
00:04:16,220 --> 00:04:17,720
a true sequence of actions,

74
00:04:18,220 --> 00:04:19,330
a relationship model.

75
00:04:19,870 --> 00:04:24,250
So as you've discussed earlier, with
a relationship model can be defined

76
00:04:24,250 --> 00:04:26,110
by your nodes, edges, and properties.

77
00:04:26,530 --> 00:04:32,140
So what this get us, so this
can help us to identify a few

78
00:04:32,140 --> 00:04:34,600
of the early things in the.

79
00:04:35,100 --> 00:04:39,485
To the incident responders, which we
usually look for first, it'll identify

80
00:04:39,635 --> 00:04:43,415
the blast radius by traversing the
connection from the breach point of the

81
00:04:43,415 --> 00:04:47,995
affected asset so it can do the later
moment patterns across traverse system,

82
00:04:47,995 --> 00:04:49,975
revealing the attackers path in detail.

83
00:04:50,665 --> 00:04:54,645
We can also hidden discover
hidden relationships across

84
00:04:54,645 --> 00:04:56,805
unrelated events, connecting the.

85
00:04:57,330 --> 00:04:59,280
The dots which traditional tools miss.

86
00:04:59,730 --> 00:05:03,360
We can build a comprehensive
attack timelines with perfect

87
00:05:03,360 --> 00:05:07,215
sequencing, and thanks to the
temporal, consistent, and co mapping.

88
00:05:07,695 --> 00:05:11,685
So the holistic view empowers the
incident responders to move beyond

89
00:05:11,685 --> 00:05:16,365
fragmented, alert driven system, and
leading to fast record incident response

90
00:05:16,365 --> 00:05:17,895
and minimizing the business impact.

91
00:05:18,395 --> 00:05:21,425
I will briefly touch on the query
capabilities that SPAN Graph

92
00:05:21,425 --> 00:05:26,255
has, so we can do path analysis,
find all the possible connections

93
00:05:26,255 --> 00:05:27,635
between compromised assets.

94
00:05:27,635 --> 00:05:28,895
We can do pattern matching.

95
00:05:29,675 --> 00:05:34,895
We can do take centrally available
measures like critical assets

96
00:05:34,895 --> 00:05:36,695
and identify the choke points.

97
00:05:37,175 --> 00:05:40,745
We can do the community detection,
like group of related events

98
00:05:40,925 --> 00:05:42,755
to identify the campaign scope.

99
00:05:43,385 --> 00:05:48,955
So these kind of scenarios can be easily
covered by span graph capabilities.

100
00:05:49,455 --> 00:05:52,605
A very brief slide on the
implementation if someone wants to

101
00:05:52,605 --> 00:05:54,255
onboard, like what they need to do.

102
00:05:54,755 --> 00:06:00,665
So I categorize that in four or five,
I would say five different categories.

103
00:06:00,665 --> 00:06:02,075
So the first one is collection.

104
00:06:02,075 --> 00:06:04,295
We need to collect the
data from all the sources.

105
00:06:04,355 --> 00:06:06,005
Then we need to normalize those.

106
00:06:06,740 --> 00:06:07,880
And find.

107
00:06:08,120 --> 00:06:10,670
After that, we need to fit
that in those graph model.

108
00:06:11,240 --> 00:06:15,320
And once we fit that in graph models,
panel storage is a natural fit for that.

109
00:06:15,620 --> 00:06:20,260
And after that we can just investigate
by using those panel query model three

110
00:06:20,260 --> 00:06:23,440
technical challenges, which I have listed.

111
00:06:23,590 --> 00:06:25,870
If someone wants to
design the application.

112
00:06:25,870 --> 00:06:27,610
So the first one is schema design.

113
00:06:28,165 --> 00:06:33,625
So we need to see how we can balance
between various entities and relations

114
00:06:34,125 --> 00:06:36,135
for getting the good performance.

115
00:06:36,375 --> 00:06:38,085
The second is ingestion timeline.

116
00:06:38,085 --> 00:06:42,345
So we need to see whether we are doing
the real time or the batch processing, how

117
00:06:42,345 --> 00:06:47,355
we are handling out the quarter events,
how we are enriching the data across.

118
00:06:47,855 --> 00:06:51,815
So this, we need to ensure
like all the queries are

119
00:06:51,815 --> 00:06:53,585
responding within the threshold.

120
00:06:53,675 --> 00:06:58,925
For that we might need some of the
tune enables in query either better

121
00:06:58,985 --> 00:07:04,415
planning or some caching, or we need
to balance out the response timing

122
00:07:04,415 --> 00:07:06,695
with the data that we're fetching.

123
00:07:07,195 --> 00:07:11,095
Key takeaways, spanner transforms higher.

124
00:07:11,725 --> 00:07:16,075
By providing few the capabilities
which are unique to the system.

125
00:07:16,075 --> 00:07:19,375
The first one is it provides a
unified time synchronized view

126
00:07:19,375 --> 00:07:24,295
across all security events so we
can trace the attack progression

127
00:07:24,295 --> 00:07:26,185
through complex multi relations.

128
00:07:26,685 --> 00:07:29,715
It provide the precise time
coordination that eliminates the

129
00:07:29,715 --> 00:07:34,785
timestamp discrepancies, so it helps
us to build a relationship model that

130
00:07:34,785 --> 00:07:36,735
reveals the full scope of compromise.

131
00:07:36,765 --> 00:07:39,915
By implementing this approach,
organization can achieve faster.

132
00:07:40,415 --> 00:07:40,895
Thank you.

