1
00:00:00,500 --> 00:00:01,069
Hey everyone.

2
00:00:01,549 --> 00:00:02,780
My name is Rodney Genta.

3
00:00:03,440 --> 00:00:07,879
I'm a senior software engineer with
over 15 years of experience, and

4
00:00:07,879 --> 00:00:11,150
I'm excited to have the opportunity
to speak at this conference.

5
00:00:11,150 --> 00:00:13,820
And I want to thank you all
for joining today's session.

6
00:00:14,320 --> 00:00:18,610
The topic we are going to explore today
is Microservices Business Monolith, a

7
00:00:18,610 --> 00:00:20,890
platform engineering decision framework.

8
00:00:21,390 --> 00:00:25,440
As platform engineers, we face an
architectural crossroad in almost

9
00:00:25,440 --> 00:00:27,360
every large scale crowd project.

10
00:00:27,930 --> 00:00:31,830
Should we stick with the simplicity of
a monolith or embrace the flexibility

11
00:00:31,830 --> 00:00:33,750
and scalability of microservices?

12
00:00:34,680 --> 00:00:38,970
The choice is not just technical as
it affects the development velocity,

13
00:00:39,060 --> 00:00:43,680
team productivity cost, and how
systems evolve over the long term.

14
00:00:44,180 --> 00:00:47,870
My goal today is to walk you through
the structured decision framework,

15
00:00:48,410 --> 00:00:52,910
one that takes into account platform
maturity, team structure, and

16
00:00:52,910 --> 00:00:56,779
infrastructure capabilities, so
you can align the architecture with

17
00:00:56,779 --> 00:00:58,669
business outcomes rather than hype.

18
00:00:59,169 --> 00:01:03,370
So cloud computing has completely
changed the way we build applications.

19
00:01:03,820 --> 00:01:07,690
It has unlocked scalability,
global reach, and agility.

20
00:01:08,500 --> 00:01:11,889
But with this evolution comes
a crucial decision point.

21
00:01:12,550 --> 00:01:16,750
Do we build as a monolith or do we
break things down into microservices?

22
00:01:17,560 --> 00:01:20,440
And this decision impacts four big areas.

23
00:01:21,085 --> 00:01:25,285
One is the speed of development and
team productivity, the operational

24
00:01:25,285 --> 00:01:29,965
complexity and maintenance burden that
we take on the cost structures and how

25
00:01:29,965 --> 00:01:34,555
efficiently we use resources and the
long-term adaptability of our systems.

26
00:01:35,125 --> 00:01:38,575
In other words, the decision we
make at this architectural fork

27
00:01:38,664 --> 00:01:44,664
sets the tone for how sustainable,
flexible, and maybe cost efficient our

28
00:01:44,664 --> 00:01:46,825
platform will be for years to come.

29
00:01:47,325 --> 00:01:50,115
So let's take a look
at microservices first.

30
00:01:50,605 --> 00:01:54,325
Microservices, they just break
applications into small and

31
00:01:54,325 --> 00:01:59,155
independent services that talk to
each other through APIs, and each

32
00:01:59,155 --> 00:02:03,445
of the server is independently
deployable, scalable, and manageable.

33
00:02:04,265 --> 00:02:06,065
But what does it mean in practice?

34
00:02:06,185 --> 00:02:09,815
So independent scaling means that
the each service scales on its own.

35
00:02:10,295 --> 00:02:13,715
Which means the granular resource
control and auto-scaling can be

36
00:02:13,715 --> 00:02:16,115
configured based on load variations.

37
00:02:16,925 --> 00:02:20,765
And studies show 30 to 40% cost
savings through efficient scale

38
00:02:21,265 --> 00:02:22,885
and the deployment flexibility.

39
00:02:23,095 --> 00:02:28,465
The frequency increases dramatically if
five to 10 times higher, a deployment

40
00:02:28,465 --> 00:02:31,405
downtime is reduced by as much as 90%.

41
00:02:32,245 --> 00:02:36,085
Microservices work hand in hand
with continuous integration and

42
00:02:36,085 --> 00:02:37,705
continuous deployment pipelines.

43
00:02:38,590 --> 00:02:40,570
And the failures are mostly contained.

44
00:02:41,080 --> 00:02:44,710
A problem in one service does
not cascade across the system.

45
00:02:45,580 --> 00:02:50,440
This distributed fall tolerance
is what enables 99% availability.

46
00:02:50,940 --> 00:02:52,050
Technology, diversity, right?

47
00:02:52,350 --> 00:02:54,570
Each service can use the
most suitable tech stack.

48
00:02:55,140 --> 00:02:59,700
This allows incremental adoption
of new technologies and supports

49
00:02:59,700 --> 00:03:00,990
polyglot programming approaches.

50
00:03:01,490 --> 00:03:04,880
This also allows for a certain
level of autonomy in the teams.

51
00:03:05,570 --> 00:03:09,290
So microservices are about
resilience, speed, and flexibility.

52
00:03:09,740 --> 00:03:12,890
They are backbone of the
cloud native innovation.

53
00:03:13,390 --> 00:03:15,850
But microservices is not a silver bullet.

54
00:03:16,360 --> 00:03:18,250
They come with their
own challenges, right?

55
00:03:18,250 --> 00:03:20,440
First is interservice communication.

56
00:03:20,890 --> 00:03:25,270
Every service call introduces
network latency, anywhere from 10 to

57
00:03:25,270 --> 00:03:26,830
hundreds of milliseconds per call.

58
00:03:27,370 --> 00:03:29,380
You also need service discovery.

59
00:03:29,740 --> 00:03:35,080
A good API, versioning and mechanisms
like circuit breakers and retry logic.

60
00:03:35,890 --> 00:03:38,140
Second, data consistency management.

61
00:03:38,890 --> 00:03:43,320
In distributed systems, transactions
become far more complex.

62
00:03:43,800 --> 00:03:45,750
Eventual consistency models.

63
00:03:45,750 --> 00:03:47,340
They need careful design.

64
00:03:47,840 --> 00:03:52,580
Synchronizing data across services can
be difficult, and patterns like saga are

65
00:03:52,580 --> 00:03:54,830
often required for complex workflows.

66
00:03:55,460 --> 00:04:00,440
Third is the operational overhead
Microservices demand, sophisticated

67
00:04:00,440 --> 00:04:04,605
monitoring, logging, distributed
tracing, and observability.

68
00:04:05,105 --> 00:04:08,945
There are simply more moving parts,
more infrastructure to manage.

69
00:04:09,605 --> 00:04:12,725
So this also increases the cognitive
load for development teams.

70
00:04:13,225 --> 00:04:18,505
So while microservices unlock cloud
native innovation, they also require

71
00:04:18,534 --> 00:04:22,735
a higher level of maturity, both
organizationally and technically.

72
00:04:23,515 --> 00:04:27,980
And as someone famous once said, with
great power comes great responsibility.

73
00:04:28,480 --> 00:04:31,719
So now let's look at microservices
in the context of DevOps.

74
00:04:31,719 --> 00:04:32,380
Integration.

75
00:04:33,130 --> 00:04:35,500
Microservices don't operate in isolation.

76
00:04:35,770 --> 00:04:38,530
They depend on a strong
platform foundation.

77
00:04:39,190 --> 00:04:43,760
First, being the orchestration
of containers tools like

78
00:04:43,825 --> 00:04:45,229
Kubernetes are essential.

79
00:04:45,859 --> 00:04:50,780
They provide service me mesh integration,
automated rollouts and rollbacks,

80
00:04:50,780 --> 00:04:52,580
and self-healing capabilities.

81
00:04:53,465 --> 00:04:57,965
And without this operating microservices
at scale quickly becomes unmanageable.

82
00:04:58,465 --> 00:05:00,114
Second is the CICD pipeline.

83
00:05:00,114 --> 00:05:06,324
Sophistication with independent service
pipelines build times are reduced by 60

84
00:05:06,324 --> 00:05:12,264
to 80%, and teams can deploy in parallel
use feature flags to control releases, and

85
00:05:12,264 --> 00:05:14,244
even run automated cross service testing.

86
00:05:14,744 --> 00:05:19,155
And third is the observability
infrastructure with dozens

87
00:05:19,155 --> 00:05:20,744
or even hundreds of services.

88
00:05:20,744 --> 00:05:24,734
We need distributed tracing,
centralized logging, and service

89
00:05:24,734 --> 00:05:29,114
level metrics to understand system
behavior and troubleshoot effectively.

90
00:05:29,614 --> 00:05:32,704
So microservices and DevOps,
they go hand in hand.

91
00:05:33,275 --> 00:05:36,184
Without this integration,
the promised benefits of

92
00:05:36,184 --> 00:05:38,284
microservices cannot be realized.

93
00:05:38,784 --> 00:05:41,274
Now let's talk a little bit about
the monolithic architecture.

94
00:05:41,774 --> 00:05:46,934
So the monolith is a single unified
code base, and despite what we often

95
00:05:46,934 --> 00:05:53,024
hear, monolith offers some advantages,
which is that they make development more

96
00:05:53,084 --> 00:05:55,844
efficient, especially for smaller teams.

97
00:05:56,324 --> 00:06:00,594
Onboarding is quicker, debugging is
more straightforward, and testing is

98
00:06:00,594 --> 00:06:02,544
simplified in a unified environment.

99
00:06:03,189 --> 00:06:06,789
So ramp up time for new developers
is usually reduced by up to 50%.

100
00:06:07,289 --> 00:06:11,190
They have performance advantages in
the sense that like the in-process

101
00:06:11,190 --> 00:06:14,130
method calls are a hundred
times faster than network calls.

102
00:06:14,640 --> 00:06:20,280
The database connection pooling improves
efficiency by about 40 to 60%, and

103
00:06:20,280 --> 00:06:25,380
because there is no network protocol
overhead, you get much better raw speed.

104
00:06:25,880 --> 00:06:29,780
So monoliths deliver simplicity,
cohesion, and speed when

105
00:06:29,780 --> 00:06:31,340
applied in the right context.

106
00:06:31,840 --> 00:06:34,630
So when does monolith excel?

107
00:06:35,130 --> 00:06:37,380
There are a few scenarios
where monoliths shine.

108
00:06:37,800 --> 00:06:40,290
One is the early stage applications.

109
00:06:40,710 --> 00:06:45,080
When we are building MVPs or prototypes,
the time to market is the priority.

110
00:06:45,965 --> 00:06:50,075
So teams are small, often fewer
than 20 developers and domain

111
00:06:50,075 --> 00:06:51,545
boundaries are still unclear.

112
00:06:52,085 --> 00:06:55,895
So here a monolith will
accelerate delivery when there

113
00:06:55,895 --> 00:06:57,305
are predictable workloads.

114
00:06:57,515 --> 00:07:01,685
If you have a stable user base with
known growth patterns or internal

115
00:07:01,685 --> 00:07:05,855
tools with limited concurrency,
a monolith is easier to manage.

116
00:07:06,355 --> 00:07:08,365
Strong consistency requirements.

117
00:07:08,545 --> 00:07:12,265
I think financial transactions or
business processes with complex data

118
00:07:12,265 --> 00:07:16,984
dependencies real-time consistency
and simplified transaction rollback

119
00:07:16,984 --> 00:07:19,025
are much easier in a monolith.

120
00:07:19,525 --> 00:07:23,965
In all of these scenarios, monolith
gives us speed, cost, efficiency,

121
00:07:24,025 --> 00:07:26,275
and reduced operational overhead.

122
00:07:26,775 --> 00:07:29,295
But monoliths do have some limitations.

123
00:07:29,865 --> 00:07:34,844
As applications grow larger, monolith
become harder to manage resource over

124
00:07:34,844 --> 00:07:39,735
provisioning, it can lead to costs that
are two to three times higher Development.

125
00:07:39,735 --> 00:07:44,795
Speech slows down by 20 to 30% each year
in a large complex code base, and this is

126
00:07:44,795 --> 00:07:49,055
where the balance tips and microservices
begin to offer clear advantages.

127
00:07:49,555 --> 00:07:52,225
So now we get to the
million dollar question.

128
00:07:52,355 --> 00:07:55,415
At least the question worth
hundreds of thousands of dollars.

129
00:07:55,745 --> 00:07:56,555
How do we decide?

130
00:07:57,055 --> 00:08:00,055
The first step is to assess
organizational readiness.

131
00:08:00,805 --> 00:08:02,130
Team maturity is critical.

132
00:08:03,085 --> 00:08:07,525
Monolith fits small teams under
20 developers with basic CICD

133
00:08:07,585 --> 00:08:09,475
and limited cloud experience.

134
00:08:09,865 --> 00:08:13,735
Whereas microservice requires larger
teams, often with over 50 developers,

135
00:08:14,155 --> 00:08:18,625
with advanced automation and
distributed systems expertise and the

136
00:08:18,625 --> 00:08:21,145
cultural indicators, they also matter.

137
00:08:21,715 --> 00:08:24,235
Is ownership centralized or distributed?

138
00:08:24,745 --> 00:08:26,005
How is the communication?

139
00:08:26,005 --> 00:08:28,135
Is that synchronous or asynchronous?

140
00:08:28,635 --> 00:08:31,605
Is the organization
conservative or experimental?

141
00:08:31,995 --> 00:08:33,704
And does it have a
strong learning culture?

142
00:08:34,205 --> 00:08:39,215
So teams with distributed ownership,
comfortable with asynchronous

143
00:08:39,215 --> 00:08:43,085
communication, experimental and
learning mindset would be more

144
00:08:43,085 --> 00:08:45,275
adept to incorporate microservices.

145
00:08:45,275 --> 00:08:49,615
So the bottom line here is that even
before technology look at the people

146
00:08:49,615 --> 00:08:54,175
and culture, architecture must align
with the organizational maturity.

147
00:08:54,675 --> 00:08:58,005
Next we need to evaluate
our technical requirements.

148
00:08:58,645 --> 00:09:01,555
Look at the application complexity,
what are the number of business

149
00:09:01,555 --> 00:09:06,625
domains, integration points and
consistency requirements, and then

150
00:09:06,625 --> 00:09:08,385
look at scalability projections.

151
00:09:08,385 --> 00:09:10,364
How quickly will the user base grow?

152
00:09:11,084 --> 00:09:14,819
How variable are traffic patterns and what
geographic distribution will be needed?

153
00:09:15,319 --> 00:09:18,649
Because at this stage, it's critical
for the organization to be realistic,

154
00:09:19,459 --> 00:09:24,709
overly optimistic forecasts or
assumptions drawn from limited data.

155
00:09:25,099 --> 00:09:28,129
It can mislead the teams
and result in wasted effort.

156
00:09:28,629 --> 00:09:32,229
And you also need to consider cloud
platform capabilities, which is the

157
00:09:32,229 --> 00:09:37,389
container orchestration, service
measures, serverless integration, managed

158
00:09:37,389 --> 00:09:40,269
database, and cost optimization features.

159
00:09:40,769 --> 00:09:45,479
So a decision between monolith
and microservice is just not

160
00:09:45,479 --> 00:09:47,249
about software architecture.

161
00:09:47,819 --> 00:09:50,459
It's also about the maturity
of your cloud platform.

162
00:09:50,959 --> 00:09:55,309
If the platform is not ready to support
microservices at scale, then the

163
00:09:55,309 --> 00:09:58,399
architecture will struggle no matter
how well designed it looks on paper.

164
00:09:58,899 --> 00:10:02,964
So with these steps, you'll be able
to assess whether microservices are

165
00:10:02,964 --> 00:10:06,504
a right fit for your organization
or if sticking with a monolithic

166
00:10:06,504 --> 00:10:07,644
approach makes more sense.

167
00:10:08,144 --> 00:10:12,704
So one thing we need to
keep in mind though is that

168
00:10:12,854 --> 00:10:15,044
architecture is evolutionary.

169
00:10:15,704 --> 00:10:17,234
It doesn't have to be a leap.

170
00:10:17,634 --> 00:10:18,144
It can be a journey.

171
00:10:18,644 --> 00:10:22,844
And a typical roadmap that I would
recommend to teams to consider would look

172
00:10:22,904 --> 00:10:27,094
something like this, which is to start
with the modular monolith or assist the

173
00:10:27,094 --> 00:10:32,974
current system, and then use domain-driven
design to identify logical service

174
00:10:32,974 --> 00:10:38,974
boundaries, incrementally extract services
using patterns like strangler, fig, or

175
00:10:39,184 --> 00:10:41,224
optimized modules within the monolith.

176
00:10:42,035 --> 00:10:45,395
And then build operational
capabilities, observability

177
00:10:45,454 --> 00:10:47,374
automation, and CICD in parallel.

178
00:10:47,874 --> 00:10:53,394
On an average, a full migration to
microservices takes 18 to 24 months.

179
00:10:54,084 --> 00:10:58,494
Optimizing a monolith with future
flexibility can take six to 12 months.

180
00:10:58,854 --> 00:11:01,050
Both are valid, but it
depends on the context.

181
00:11:01,550 --> 00:11:04,459
Let's let me share a real
world example where we use

182
00:11:04,459 --> 00:11:05,869
this decision framework, right?

183
00:11:06,589 --> 00:11:11,340
In our domain, we had a monolithic
routing application that

184
00:11:11,340 --> 00:11:12,840
was slowing everything down.

185
00:11:13,540 --> 00:11:18,155
Scaling was difficult, deployments were
bottleneck, and along with the technical

186
00:11:18,155 --> 00:11:23,225
lead, the team's maturity and culture
were ready to adopt microservices.

187
00:11:23,725 --> 00:11:29,275
The solution was to decouple the routing
function into modular microservices.

188
00:11:29,775 --> 00:11:34,815
We created reusable libraries, symphony
plugins, and a DR template, which

189
00:11:34,815 --> 00:11:40,035
we used to record our architectural
decisions, and we implemented service

190
00:11:40,035 --> 00:11:43,965
auto wiring and internal utilities,
which was used to streamline development.

191
00:11:44,465 --> 00:11:46,055
And the results were powerful.

192
00:11:46,265 --> 00:11:48,935
The deployments became three times faster.

193
00:11:49,325 --> 00:11:54,305
Code to production speed improved
21 times, uptime increased by 8.5%.

194
00:11:54,785 --> 00:11:59,375
The meantime to recovery was cut in
half, and the system scaled to handle

195
00:11:59,495 --> 00:12:01,595
tens of millions of contacts per month.

196
00:12:02,095 --> 00:12:06,025
And this transformation wasn't just
technical, it improved AC developer

197
00:12:06,025 --> 00:12:09,565
efficiency, maintainability, and
the overall business outcome.

198
00:12:10,065 --> 00:12:13,955
And what made this possible, right?

199
00:12:14,855 --> 00:12:15,635
Three things.

200
00:12:15,815 --> 00:12:20,675
One is architecture and planning, breaking
requirements into like clear technical

201
00:12:20,675 --> 00:12:25,205
tickets, designing decouple structures,
and then documenting those decisions and

202
00:12:25,205 --> 00:12:29,195
the implementation itself, where building
share utilities like feature toggles,

203
00:12:29,195 --> 00:12:34,415
cache and logging, and then fixing deep
framework issues and leading through

204
00:12:34,415 --> 00:12:38,315
code reviews, resolving blockers for
the team, and then knowledge sharing.

205
00:12:38,815 --> 00:12:41,815
So architecture is ne
never just technology.

206
00:12:41,865 --> 00:12:42,855
It's part people.

207
00:12:43,695 --> 00:12:45,975
Processes and leadership working together.

208
00:12:46,785 --> 00:12:51,015
So realizing this and facilitating this
is what an experienced professional

209
00:12:51,015 --> 00:12:52,635
is expected to bring to the table.

210
00:12:53,135 --> 00:12:57,725
Now having spoken about two sides
of the coin, I would be remiss if I

211
00:12:57,755 --> 00:12:59,735
don't elaborate on the current state.

212
00:13:00,725 --> 00:13:04,505
The truth is the conversation
is moving just beyond monolith

213
00:13:04,505 --> 00:13:05,495
business microservices.

214
00:13:06,110 --> 00:13:08,990
S because there are advancements
that teams and organizations

215
00:13:08,990 --> 00:13:11,900
should be considering while
addressing the business needs.

216
00:13:12,860 --> 00:13:16,910
And this is not an exhaustive list,
but I would highlight these to anyone

217
00:13:16,910 --> 00:13:21,470
considering their roadmap, which is
like the serverless or function as

218
00:13:21,470 --> 00:13:23,390
a service combines benefits of both.

219
00:13:24,140 --> 00:13:26,685
It is even driven with minimal
overhead and automatic scaling.

220
00:13:27,185 --> 00:13:30,545
Modular monolith maintain
a single deployment, but it

221
00:13:30,545 --> 00:13:31,925
enforces clear boundaries.

222
00:13:32,495 --> 00:13:36,125
So this reduces complexity while
keeping migration options open.

223
00:13:36,625 --> 00:13:41,275
And just like AI is penetrating every
other aspect, AI driven architectures

224
00:13:41,275 --> 00:13:45,055
are also emerging where it uses
machine learning to predict, scaling,

225
00:13:45,355 --> 00:13:48,655
recommend service decomposition
and intelligently route traffic.

226
00:13:49,155 --> 00:13:52,500
The bottom line is that the
future of architecture, it is not.

227
00:13:53,145 --> 00:13:53,715
Binary.

228
00:13:54,115 --> 00:13:56,605
It's nuanced and it's evolving.

229
00:13:57,105 --> 00:13:59,925
To conclude, let me leave
you with four takeaways.

230
00:14:00,645 --> 00:14:03,825
First is that architecture
is evolutionary.

231
00:14:04,515 --> 00:14:09,555
Start simple and then evolve as a
system and organization demanded.

232
00:14:10,455 --> 00:14:13,395
Second context matters more than trends.

233
00:14:13,965 --> 00:14:19,155
So Joe, don't just copy Netflix or Amazon
or any other company that has made it big.

234
00:14:19,905 --> 00:14:23,655
Make decisions based on your own
needs and or your own reality.

235
00:14:24,645 --> 00:14:27,345
And third is that hybrid
approaches often win.

236
00:14:28,215 --> 00:14:32,355
Combining elements of monolith,
microservices, and serverless

237
00:14:32,355 --> 00:14:33,765
can deliver the best outcomes.

238
00:14:34,455 --> 00:14:39,405
And finally, and probably the
most important business value

239
00:14:39,435 --> 00:14:43,250
drives architecture, the most
elegant technical design.

240
00:14:43,280 --> 00:14:45,980
It's meaningless if it does
not serve business goals.

241
00:14:46,480 --> 00:14:50,230
Thank you once again for joining
this session and allowing

242
00:14:50,230 --> 00:14:51,250
me to share my thoughts.

