1
00:00:00,500 --> 00:00:01,190
Hello everyone.

2
00:00:01,470 --> 00:00:04,770
Thank you for joining me
at Con 42, DOOPS 2025.

3
00:00:04,770 --> 00:00:08,200
Today we'll discuss about and
open source static analysis tool.

4
00:00:08,700 --> 00:00:12,745
My name is, I'm an SRE for more
than 20 years, more than 20 years of

5
00:00:12,745 --> 00:00:17,035
experience, and I have reliability,
infrastructure and platform engineering.

6
00:00:17,535 --> 00:00:19,755
I'm another analyst speaker
and I'm currently working as

7
00:00:19,755 --> 00:00:20,865
a principal engineer language.

8
00:00:21,365 --> 00:00:22,425
So what is sast?

9
00:00:23,310 --> 00:00:27,940
So it is static application security
testing, also known as static analysis.

10
00:00:28,600 --> 00:00:31,810
What it does is discover
vulnerabilities in your source code

11
00:00:31,870 --> 00:00:33,040
before it's research production.

12
00:00:33,540 --> 00:00:37,125
SaaS can scan an application before
the code is coupled or built.

13
00:00:37,625 --> 00:00:40,775
It's also non white box testing
because the tool has access

14
00:00:40,775 --> 00:00:42,275
to that or little source code.

15
00:00:42,775 --> 00:00:44,510
So what is that done of using sast?

16
00:00:45,010 --> 00:00:49,300
See manual security review of
every code change is impossible.

17
00:00:49,690 --> 00:00:52,810
Nobody's gonna scale at the
volume your code is generated.

18
00:00:53,500 --> 00:00:53,860
Alright?

19
00:00:54,280 --> 00:01:01,060
So shifting security left is the only way,
and since Saasta has access to your source

20
00:01:01,840 --> 00:01:05,979
code, it can do a hundred percent code
coverage for all security vulnerabilities.

21
00:01:06,699 --> 00:01:10,539
You can also scale across large
code base and can for every change

22
00:01:10,660 --> 00:01:11,175
you recommend that you make.

23
00:01:11,675 --> 00:01:14,515
So it can also identify certain
wellknown vulnerabilities, like

24
00:01:14,515 --> 00:01:18,774
SQ injection, secret key exposure,
buffer workflows and things like that.

25
00:01:19,225 --> 00:01:20,365
But it is not limited to that.

26
00:01:20,414 --> 00:01:24,149
There are like, large number of
vulnerabilities and so it can bubble.

27
00:01:24,649 --> 00:01:30,205
So the initial SaaS tools, otherwise
known as first generation SaaS tools.

28
00:01:30,885 --> 00:01:33,235
Had its phone issues they were clumsy.

29
00:01:33,835 --> 00:01:38,725
Their scans took covers, and the
setup was very complex and the result

30
00:01:38,995 --> 00:01:40,315
in itself was not very testable.

31
00:01:41,305 --> 00:01:44,185
And many developers because of
this, had security atic fatigue

32
00:01:44,185 --> 00:01:46,765
and felt that, the tool is tools.

33
00:01:46,765 --> 00:01:49,245
SA scan of tools are useless right now.

34
00:01:49,745 --> 00:01:54,915
The difference here is that, in second
generation SaaS tools, it also has issues.

35
00:01:54,975 --> 00:01:58,215
It also brought in some improvements,
but some of the issues still are

36
00:01:58,265 --> 00:02:00,315
higher number of, false positives.

37
00:02:00,815 --> 00:02:05,285
It is also difficult for SaaS to
detect advanced security issues like

38
00:02:05,585 --> 00:02:10,025
authentication, access control, and
authorization and things like that.

39
00:02:10,475 --> 00:02:14,880
It cannot dated weak cryptography or
any other kind of security issues.

40
00:02:15,380 --> 00:02:19,520
It also cannot find out issues
with the configurations because

41
00:02:19,520 --> 00:02:21,170
it only looks at the source code.

42
00:02:21,670 --> 00:02:23,440
So how does SaaS work?

43
00:02:23,940 --> 00:02:26,830
So the source code is broken
down into tokens keywords,

44
00:02:26,830 --> 00:02:28,660
identifiers, operators, and whatnot.

45
00:02:28,930 --> 00:02:30,390
It's in the, programming language.

46
00:02:31,080 --> 00:02:35,580
Then this tokens are analyzed according
to the grammar rules of the language to

47
00:02:35,580 --> 00:02:38,440
create a hierarchical set of know code.

48
00:02:39,310 --> 00:02:41,230
Typically, this is abstracts industry.

49
00:02:42,145 --> 00:02:44,410
And this still determines
how the program execute.

50
00:02:44,550 --> 00:02:48,565
And, in the case of, control for
analysis it determines like, how the

51
00:02:48,565 --> 00:02:52,735
control from of the program falls
from one part of the code to another.

52
00:02:53,515 --> 00:02:58,705
And then there is data for analysis,
which tracks how data is manipulated

53
00:02:59,155 --> 00:03:00,650
and, traveling through the code.

54
00:03:01,150 --> 00:03:06,080
And once the code structure on the floors
are identified the pre different rules

55
00:03:06,080 --> 00:03:08,520
or pattern are applied to this structure.

56
00:03:09,180 --> 00:03:13,590
And then it can detect common coding,
reverse inside of practices or

57
00:03:13,690 --> 00:03:15,850
indicators of potential vulnerabilities.

58
00:03:16,240 --> 00:03:17,625
And that is the way SaaS operates.

59
00:03:18,125 --> 00:03:21,080
Now we talked about ASTs
briefly in the previous slide.

60
00:03:21,080 --> 00:03:25,590
So what is an A SD asds Abstracts
Industry, which is a three shared

61
00:03:25,590 --> 00:03:29,760
representation of your code
that captures its tructure and

62
00:03:29,760 --> 00:03:31,410
not its raw text or formatting.

63
00:03:31,910 --> 00:03:34,545
You can think of it like you know
how we compiler operator that

64
00:03:34,635 --> 00:03:36,255
understands your code internally?

65
00:03:36,755 --> 00:03:38,110
Now, why is it put abstract?

66
00:03:38,110 --> 00:03:41,055
It is because it ignores details
that doesn't matter for the

67
00:03:41,205 --> 00:03:42,775
meaning or the purpose of the code.

68
00:03:43,070 --> 00:03:46,610
No comments, no white tion
no exact formatting or

69
00:03:46,610 --> 00:03:48,080
beautification, things like that.

70
00:03:48,680 --> 00:03:52,840
As you can see on the exam at the
bottom, all of these essentially,

71
00:03:52,980 --> 00:03:58,185
if you look at from a pure text or
pattern perspective, these four.

72
00:03:58,935 --> 00:04:03,045
Print head over statements are
totally different, but when an as

73
00:04:03,045 --> 00:04:07,430
is generated out of these 2, 3, 4,
sorry, four statements, they are, go

74
00:04:07,490 --> 00:04:09,980
do that is the beauty of using ASCs.

75
00:04:10,310 --> 00:04:14,210
It gives you a deterministic
program aware structure.

76
00:04:14,710 --> 00:04:17,730
Now let's look at, a simple
example of how a Python program

77
00:04:17,830 --> 00:04:19,290
is converted into an A SC.

78
00:04:20,250 --> 00:04:26,520
So Python provides an a ST library,
which takes a source code as an input,

79
00:04:26,610 --> 00:04:31,535
and then returns an A ST. And as you
can see at the bottom output, the A ST

80
00:04:31,535 --> 00:04:33,695
proves a relay structure for the code.

81
00:04:34,195 --> 00:04:36,925
So to make the concept a little
bit more clear, let us look at the

82
00:04:36,925 --> 00:04:38,455
graphical ation of the ceiling.

83
00:04:39,415 --> 00:04:41,635
As you can see, the core
only has one expression.

84
00:04:42,340 --> 00:04:45,970
And the function name and the
arguments as will test tokens and

85
00:04:45,975 --> 00:04:48,155
are the same note within the two.

86
00:04:48,655 --> 00:04:52,510
So let's look at a slightly different
example to clear the concept here.

87
00:04:52,620 --> 00:04:56,250
So here we are using a variable
assignment and then printing the

88
00:04:56,250 --> 00:04:59,820
variable rather than directly
using a scaler or string to print.

89
00:05:00,780 --> 00:05:03,845
This has two soft, one for the same,
and then another for the functional

90
00:05:03,885 --> 00:05:08,100
n. If you have a large number of lines
of code, you can see how this will,

91
00:05:08,100 --> 00:05:10,200
expand into a huge three already.

92
00:05:10,700 --> 00:05:11,930
So let's talk about similar now.

93
00:05:12,800 --> 00:05:16,870
So Send RA basically is
a tool and a platform.

94
00:05:17,080 --> 00:05:18,520
It's available at, similar about Dev.

95
00:05:19,310 --> 00:05:23,210
The core of the is an open source.

96
00:05:24,180 --> 00:05:30,075
Engine for Vulner, the evaluation, and
that is called C or Community Edition.

97
00:05:30,825 --> 00:05:34,875
Now, if so, it also has a central
pro and commercial SaaS platform,

98
00:05:35,295 --> 00:05:39,195
which adds additional features,
reporting central ruling, et cetera.

99
00:05:39,695 --> 00:05:42,005
So what is the name mean?

100
00:05:42,335 --> 00:05:42,695
Sam.

101
00:05:42,780 --> 00:05:43,924
Sam essentially is.

102
00:05:44,424 --> 00:05:45,174
Semantic.

103
00:05:45,569 --> 00:05:49,764
Grap semantic essentially means
that se grip as a tool understands

104
00:05:49,854 --> 00:05:55,159
your programming language, semantic,
and then uses grap or not Israeli

105
00:05:55,159 --> 00:06:00,689
graph, but grap means patterns graph
like patterns that you can use to

106
00:06:00,689 --> 00:06:03,649
apply on the your code basically.

107
00:06:04,149 --> 00:06:09,145
So the commercial platform also while
we are covering C here, the commercial

108
00:06:09,465 --> 00:06:13,719
platform in itself, not just the sas,
it can also software com analysis,

109
00:06:13,900 --> 00:06:15,369
supply chain, security, et cetera.

110
00:06:15,869 --> 00:06:17,880
So how does SIM work exactly?

111
00:06:18,380 --> 00:06:20,960
So BR doesn't need compelled artifacts.

112
00:06:21,350 --> 00:06:22,880
It works directly on the source.

113
00:06:23,380 --> 00:06:27,119
So it'll answer the,
according to an EST, and then.

114
00:06:27,710 --> 00:06:31,099
There are rules which are patterns
that match against this a ST to

115
00:06:31,099 --> 00:06:33,349
detect in code or buggy code shape.

116
00:06:33,849 --> 00:06:37,299
The thing with sum up is that, it
is not just code, but the rules

117
00:06:37,299 --> 00:06:41,469
are also converted into ASTs so
that the matching becomes much

118
00:06:41,469 --> 00:06:42,284
more return mistaken and easy.

119
00:06:42,784 --> 00:06:47,684
So this rules essentially are yamal
structured documents that can be the

120
00:06:47,684 --> 00:06:49,484
stored locally or centrally in a registry.

121
00:06:50,039 --> 00:06:52,864
And you can also add your own rules
and run them against your code

122
00:06:52,864 --> 00:06:56,789
locally and the output of the, scan
or the assembly of scan of your.

123
00:06:57,564 --> 00:07:02,299
It can either be a simple text for,
that you will see in CLI or you can

124
00:07:02,299 --> 00:07:07,664
audit them or a security specific
form called, which helps you in

125
00:07:07,664 --> 00:07:11,564
integrating this with CI systems or
other security tools for reporting.

126
00:07:12,064 --> 00:07:16,145
So the core of graph is the
patterns or the rules, right?

127
00:07:16,864 --> 00:07:19,659
So the sum patterns looks
pretty much like a real code.

128
00:07:20,159 --> 00:07:23,304
You write a snippet with the
placeholders for the parts that you

129
00:07:23,304 --> 00:07:25,374
want to, vary or apply specific rules.

130
00:07:25,374 --> 00:07:27,474
Things kind like that, right?

131
00:07:27,714 --> 00:07:31,015
So let's say, for example, you know you
want to match a Python function, call

132
00:07:31,020 --> 00:07:32,309
that directly with the library code.

133
00:07:33,114 --> 00:07:34,249
You can just, put request order.

134
00:07:34,929 --> 00:07:35,329
I said no.

135
00:07:35,894 --> 00:07:39,904
Pure statement, but let us say you
won't use within request order, get your

136
00:07:39,904 --> 00:07:44,494
passing a URL and you want parameters
that URL and do some checks on that URL.

137
00:07:45,094 --> 00:07:49,970
Then you can make it's, you can create
some, or there is something called meta

138
00:07:49,970 --> 00:07:54,194
variables within some grid, which is
essentially parameterizing and variable,

139
00:07:54,244 --> 00:07:55,954
creating variable out of that pattern.

140
00:07:56,374 --> 00:07:58,804
And then you can apply
rules on that variable.

141
00:07:59,304 --> 00:07:59,634
No.

142
00:08:00,134 --> 00:08:03,524
In addition to that, a single
rule has multiple things.

143
00:08:03,614 --> 00:08:07,704
It also has metadata like messages,
severity, language, et cetera.

144
00:08:08,544 --> 00:08:12,899
And the good thing about the pattern
rules is that since this patterns are

145
00:08:12,899 --> 00:08:18,499
code alike, developers can really review
direct without needing to a complex DSL.

146
00:08:18,999 --> 00:08:21,744
So what is the structure
of a specific rule?

147
00:08:21,794 --> 00:08:26,674
The first thing is a unique rule Id it
could be it just has to be a stream.

148
00:08:26,774 --> 00:08:27,854
Could be in any format.

149
00:08:27,904 --> 00:08:30,934
What you're seeing here is, something
that is structured like a company

150
00:08:31,424 --> 00:08:35,250
then type of vulnerable di but
in reality it could be anything.

151
00:08:35,750 --> 00:08:38,424
So the pattern is what define
your actual match criteria.

152
00:08:38,924 --> 00:08:42,220
The code snippets that, you
have to scan and message.

153
00:08:42,220 --> 00:08:45,365
Message is what, a developer will find
when you scan against a vulnerability

154
00:08:45,385 --> 00:08:46,405
and it takes a vulnerability.

155
00:08:46,510 --> 00:08:51,634
The message is sent as an output and there
is a variable that pins a rule to one or

156
00:08:51,634 --> 00:08:56,080
more specific languages, which makes it
easier to filter out words from a large

157
00:08:56,080 --> 00:08:57,520
number of words for multiple languages.

158
00:08:58,020 --> 00:09:04,040
And metadata for message know, or a
rule can store, CV links, documentation,

159
00:09:04,100 --> 00:09:07,000
internal if you're writing a local
rule, things like that, right?

160
00:09:07,420 --> 00:09:12,255
So this overall structure allows you
to build an internal router that can

161
00:09:12,255 --> 00:09:15,285
affect your organization's coding,
standards, security practices,

162
00:09:15,615 --> 00:09:17,505
and also educate your developers.

163
00:09:17,970 --> 00:09:21,660
By using the metadata effectively into
reporting into specific sacred code

164
00:09:21,660 --> 00:09:23,730
deadlines, documentations, et cetera.

165
00:09:24,230 --> 00:09:29,400
Alright, so let's look at Hello
program in some so our code here

166
00:09:29,400 --> 00:09:31,650
in question is a simple print.

167
00:09:31,650 --> 00:09:31,950
Hello.

168
00:09:31,950 --> 00:09:36,650
That's a simple python, one
manner, and the rule is essentially

169
00:09:36,650 --> 00:09:38,540
going to match it exactly.

170
00:09:39,100 --> 00:09:39,710
Footprint.

171
00:09:39,710 --> 00:09:39,990
Hello?

172
00:09:40,350 --> 00:09:41,855
'cause we are looking
for the pattern print.

173
00:09:41,855 --> 00:09:42,245
Hello.

174
00:09:42,485 --> 00:09:45,030
In any program, any Python program.

175
00:09:45,535 --> 00:09:48,715
And here we will get an excitement
because the rule and the content

176
00:09:48,715 --> 00:09:50,790
of the program remains same.

177
00:09:51,290 --> 00:09:57,045
We'll just run that now rule using
some group CLI against the court.

178
00:09:57,905 --> 00:10:01,440
Now what you're seeing here is CLI
and all this the no verification

179
00:10:01,440 --> 00:10:03,660
output, but it found one issue.

180
00:10:04,515 --> 00:10:08,235
If you see here, it outputs what is
the file on which state form the issue.

181
00:10:08,800 --> 00:10:10,140
It outputs the rule.

182
00:10:10,640 --> 00:10:14,640
It also does a output, your message.

183
00:10:15,270 --> 00:10:16,440
What was the exact error about?

184
00:10:16,440 --> 00:10:19,980
So this is where like your met
message is what comes into picture

185
00:10:20,130 --> 00:10:22,590
and gives that a context, right?

186
00:10:23,220 --> 00:10:27,300
And it also finally, it also outputs
line number of the program and

187
00:10:27,300 --> 00:10:28,895
the program impact that it itself.

188
00:10:29,395 --> 00:10:32,625
All right, now that we are on
our, hello program, let's move on.

189
00:10:33,125 --> 00:10:34,205
So we talked about patterns, right?

190
00:10:34,205 --> 00:10:37,280
Pattern is the core of
your rules, similar rules.

191
00:10:37,780 --> 00:10:41,360
So there are different ways to
indicate and define your patterns.

192
00:10:41,900 --> 00:10:45,235
So if you just give pattern
in the know Yael file, it is

193
00:10:45,235 --> 00:10:46,700
a single pattern that it is.

194
00:10:47,200 --> 00:10:50,785
You can have multiple patterns by
stacking the mass in a using pattern.

195
00:10:50,785 --> 00:10:54,165
Either you could have a list of patterns
and any of them could be matching.

196
00:10:54,665 --> 00:10:57,110
Then you can have patterns, which
essentially says like you can have

197
00:10:57,310 --> 00:11:00,485
multiple patterns, but all of them
are considered, it is like an ant.

198
00:11:01,145 --> 00:11:06,045
And then there's pattern which allows
you to match against, again, it is

199
00:11:06,045 --> 00:11:09,760
like pattern, a single pattern, but
the it match against the profile.

200
00:11:10,190 --> 00:11:11,380
Pure text, right?

201
00:11:12,175 --> 00:11:14,605
And then there are
nestable pattern operators.

202
00:11:14,695 --> 00:11:17,965
So let's say you define a top
level 11 called pattern or pattern

203
00:11:17,965 --> 00:11:20,095
angle, which is stand or core.

204
00:11:20,395 --> 00:11:24,745
And then you can have one or more
of this sub pattern operators, which

205
00:11:24,745 --> 00:11:28,315
could be pattern inside, which says
it'll look inside, know the code

206
00:11:28,855 --> 00:11:30,355
or pattern note, it's an negation.

207
00:11:30,895 --> 00:11:34,595
Pattern, not insert if this code
is not inside the particular block

208
00:11:35,145 --> 00:11:38,065
or, it doesn't match the specific
projects, things like that.

209
00:11:38,585 --> 00:11:41,435
Then of course there is meta variables
that we already, talked about.

210
00:11:41,555 --> 00:11:44,465
Meta variable is essentially, I think,
but placeholder for some part of your

211
00:11:44,465 --> 00:11:49,055
code, which you want to process later in
the pattern matching right now, for that

212
00:11:49,055 --> 00:11:51,845
matter variable, let's say, you have,
you are as I mentioned earlier, right?

213
00:11:52,350 --> 00:11:55,290
Python request is basically for URL.

214
00:11:55,650 --> 00:11:58,315
So let's say you are passing a UR
and you want to variable that ur,

215
00:11:58,500 --> 00:12:01,200
you can use meta variable, and then
in the next line you can probably

216
00:12:01,200 --> 00:12:03,960
use select meta variable pattern to
look for a pattern within that URL.

217
00:12:04,780 --> 00:12:07,655
You can do a comparison, you can
run, reject anything that you

218
00:12:07,655 --> 00:12:09,335
want for more fine grain control.

219
00:12:09,835 --> 00:12:14,700
So these are a few examples of patterns,
as I said pattern essentially is you

220
00:12:14,700 --> 00:12:16,080
could have a bunch of patterns in there.

221
00:12:16,080 --> 00:12:19,590
The first pattern, if you see patterns,
defense, you can have all more patterns.

222
00:12:19,590 --> 00:12:21,810
So you can list additional
patterns in here.

223
00:12:22,170 --> 00:12:25,500
And as you can see, this is a multi-line
pattern, not a single line pattern.

224
00:12:26,200 --> 00:12:28,745
Pattern two, also multiline
pattern, but it's negation of

225
00:12:28,745 --> 00:12:30,635
pattern, which says patterns now.

226
00:12:31,175 --> 00:12:34,015
And the third one is basically
patterns, either which means

227
00:12:34,065 --> 00:12:38,455
this is actually a pattern for SQ
injection finding SQ injection.

228
00:12:38,455 --> 00:12:39,535
And there are three patterns.

229
00:12:39,985 --> 00:12:43,440
If any of them matches the rule
will say no rule will alert that

230
00:12:43,440 --> 00:12:45,030
is, there's an SQ injection.

231
00:12:45,530 --> 00:12:49,750
So structural matches versus
structural process in are basically

232
00:12:49,850 --> 00:12:52,610
a rule that matches snapshot
of a code shape in one place.

233
00:12:53,420 --> 00:12:54,740
Then there is data for rules.

234
00:12:54,810 --> 00:12:58,285
Consider how your data moves from, one
place to another within your program.

235
00:12:58,735 --> 00:13:01,495
And then there is change analysis,
which tracks untrusted input

236
00:13:01,495 --> 00:13:02,965
flowing through your dangerous APIs.

237
00:13:03,465 --> 00:13:07,585
The community edition essentially
only looks at rule-based engine

238
00:13:07,585 --> 00:13:09,855
and a simplifi single file code.

239
00:13:10,525 --> 00:13:13,375
Pro engine on the other hand,
gives you advanced in file

240
00:13:13,495 --> 00:13:15,595
scanning 10 support, et cetera.

241
00:13:16,095 --> 00:13:16,605
No, several.

242
00:13:16,765 --> 00:13:19,915
I'm talking about some community
rules registries, essentially

243
00:13:20,295 --> 00:13:23,845
3000 plus open source rules
available in in central place.

244
00:13:24,295 --> 00:13:27,805
So if you are just starting off,
you can just start by running your

245
00:13:27,805 --> 00:13:31,665
code against central registry with
all the, de default rules that is

246
00:13:31,670 --> 00:13:32,625
want to build with the community.

247
00:13:33,125 --> 00:13:36,785
So most of the rules covers like
industry best practice, like our top 10

248
00:13:36,785 --> 00:13:39,835
common cws and flavor specific issues.

249
00:13:40,615 --> 00:13:40,945
Alright?

250
00:13:41,485 --> 00:13:47,515
And some groups is of for a CLI
and the confi equal to auto option

251
00:13:47,725 --> 00:13:54,015
allows you to just talk to not
central registry and pick whatever is

252
00:13:54,015 --> 00:13:55,400
applicable or relevant to your code.

253
00:13:55,725 --> 00:13:58,245
You don't have to do anything
specifically, it will just

254
00:13:58,245 --> 00:14:01,475
automatically determine what is the
log language, and based on that,

255
00:14:01,475 --> 00:14:05,655
you'll go to the registry and pull
the local language and the framework

256
00:14:05,655 --> 00:14:07,495
specific rules from the registry.

257
00:14:07,995 --> 00:14:11,135
Now, we can always for and
tweak some of these rules,

258
00:14:11,245 --> 00:14:13,220
make it your own COVID locally.

259
00:14:13,760 --> 00:14:17,435
And this helps you in building
like, rules from accession.

260
00:14:17,435 --> 00:14:19,365
You don't have to, start
off from the scratch.

261
00:14:19,365 --> 00:14:23,505
Rather, you can start from the open
source rules, then make it your own.

262
00:14:23,925 --> 00:14:26,630
Collaborate locally,
keep the, rules locally.

263
00:14:26,630 --> 00:14:29,060
And as your code and your
organization needs role.

264
00:14:29,560 --> 00:14:35,580
Now if you're install, it's of course it's
CRA and options like, Docker, depending

265
00:14:35,580 --> 00:14:37,590
on where you want, install this CRA.

266
00:14:38,090 --> 00:14:40,730
And as I mentioned, like auto
rule configuration is the easiest

267
00:14:40,730 --> 00:14:41,930
one way to, get started off.

268
00:14:41,990 --> 00:14:45,875
But of course know you can point your
configuration local or to, multiple,

269
00:14:45,975 --> 00:14:49,855
locations and it'll accumulate
rules from all these locations

270
00:14:49,875 --> 00:14:51,095
and run it against your court.

271
00:14:51,595 --> 00:14:54,865
So result of course, is the by default,
you'll see it from the console as you

272
00:14:54,865 --> 00:14:59,605
saw earlier, but we can also convert them
into just format or salary format so that,

273
00:14:59,605 --> 00:15:03,205
it can be negative with dashboards, code
scanning, or any other security tool.

274
00:15:03,704 --> 00:15:07,584
So now let's look at where we can
integrate now to set up, and get the

275
00:15:07,584 --> 00:15:10,424
comfort with the, where we can integrate.

276
00:15:10,735 --> 00:15:12,535
Similar right in the NSTC.

277
00:15:13,074 --> 00:15:17,935
So the earliest you can integrate
any tooling in the T Cs in the id.

278
00:15:17,985 --> 00:15:22,725
And software is actually getting developed
similar, has plugins for most popular IDs.

279
00:15:23,445 --> 00:15:28,525
And this means that you are shifting it
to the no atmos left the security right,

280
00:15:29,090 --> 00:15:33,725
and you can, cash in patterns before they
even committed into the local problem.

281
00:15:34,324 --> 00:15:34,534
Alright.

282
00:15:35,254 --> 00:15:38,294
And developers can immediately get,
hints and fixed patterns they might

283
00:15:38,654 --> 00:15:40,124
otherwise repeat somewhere else.

284
00:15:40,614 --> 00:15:45,914
And this also makes it easier, change
similar stance from a gatekeeper

285
00:15:45,914 --> 00:15:49,994
or an entry point to a teaching
tool that continuously educates

286
00:15:50,294 --> 00:15:52,044
developers about security issues.

287
00:15:52,544 --> 00:15:52,934
Nope.

288
00:15:53,519 --> 00:15:57,199
The next option is, of course, we
are moving towards the, right now, we

289
00:15:57,199 --> 00:15:59,779
were extra alert with the ID plugins.

290
00:15:59,839 --> 00:16:01,669
Now we are looking at pre-com rules.

291
00:16:02,269 --> 00:16:06,969
So pre-commit rules also creates a
natural, low friction checkpoint.

292
00:16:06,969 --> 00:16:07,569
It's a checkpoint.

293
00:16:07,569 --> 00:16:11,439
It has a bit of friction, but it is still
low friction because when you make the

294
00:16:11,439 --> 00:16:16,349
commit itself, you can use to scan the
changes that you know you have committed.

295
00:16:16,559 --> 00:16:20,249
And that makes it easy to like,
integrate into your precum books

296
00:16:20,249 --> 00:16:24,189
because only the changes are looking
into, and the when find something

297
00:16:24,189 --> 00:16:28,689
critical, it can block the commit with
a or more like clear messages, right?

298
00:16:28,689 --> 00:16:31,904
And that helps in catching,
before this is committed

299
00:16:32,404 --> 00:16:33,184
no CHCD.

300
00:16:33,724 --> 00:16:37,019
And that is you can have
just pre, you can have.

301
00:16:38,009 --> 00:16:40,229
Automatic scans for every
committed code, right?

302
00:16:40,229 --> 00:16:47,034
And again, on all these steps, the rules
might change you, in the id the developer

303
00:16:47,034 --> 00:16:52,024
might have, personal specific, more
specific rules that he he or she catches

304
00:16:52,714 --> 00:16:56,004
in the pre, probably there's the team,
the rapport owners are maintaining a set

305
00:16:56,004 --> 00:17:00,219
of rules that they only know about or
spec very specific to their code base.

306
00:17:01,194 --> 00:17:06,804
And CSCD, where like you can
implement community roles, organize

307
00:17:06,804 --> 00:17:10,104
specific rules that run your
infrastructure or the implements.

308
00:17:10,644 --> 00:17:15,749
So that is how you know the
the scanning progresses, right?

309
00:17:16,249 --> 00:17:21,409
So when you are adopting it initially, you
should start with some soft fields, right?

310
00:17:21,679 --> 00:17:26,069
Rather than first just give a warning, put
a warning in, unless it's a very critical

311
00:17:26,170 --> 00:17:30,760
security issue, just put a warning in the
logs in CI and you don't move on with it.

312
00:17:31,240 --> 00:17:34,595
Also use the salary for just based output.

313
00:17:34,655 --> 00:17:38,625
Put it into, GitHub or some other
reporting tool that supports format.

314
00:17:39,125 --> 00:17:44,250
Now if this is an example of data actions,
file, if you want to integrate graph into

315
00:17:44,250 --> 00:17:49,429
your ca or process ca process, actually
this is a sample that you can use.

316
00:17:49,929 --> 00:17:52,299
Now, you can also use
graph in, quarter pr.

317
00:17:52,799 --> 00:17:56,604
What it could do is it can
make security review a part

318
00:17:56,604 --> 00:17:58,840
of your review culture, right?

319
00:17:59,169 --> 00:18:01,629
And instead of reverse manually
looking at common patterns

320
00:18:01,679 --> 00:18:02,850
rules can automatically do that.

321
00:18:02,850 --> 00:18:06,654
And also comment on the PR and over
period of time, teams can find,

322
00:18:06,654 --> 00:18:07,844
okay, what, what are the issues?

323
00:18:08,114 --> 00:18:12,344
Then add more rules in the, rule base and
the tribal knowledge get translated from

324
00:18:12,644 --> 00:18:14,484
people's mind into, some rules, right?

325
00:18:14,984 --> 00:18:16,274
So noise, right?

326
00:18:16,274 --> 00:18:20,164
So of course, as I mentioned earlier
sas, the biggest problem for SAS

327
00:18:20,164 --> 00:18:22,564
is or the noises we can call it.

328
00:18:23,064 --> 00:18:28,689
So to avoid that from early on and
not to avoid hindering of adoption

329
00:18:28,689 --> 00:18:32,499
because once ERs find that, and
it's even too much noise, they don't

330
00:18:32,499 --> 00:18:34,600
look at the tool for their right.

331
00:18:34,959 --> 00:18:35,455
So to avoid that.

332
00:18:36,050 --> 00:18:40,210
Start with the non baseline scan and
focus on some of the new issues similar.

333
00:18:40,270 --> 00:18:44,334
Gives you options like, exclude
during runtime or send up as a

334
00:18:44,334 --> 00:18:47,310
file within the report so that you
can ignore certain pattern or in

335
00:18:47,310 --> 00:18:49,110
certain parts of the code base.

336
00:18:49,889 --> 00:18:50,219
Alright?

337
00:18:50,879 --> 00:18:54,600
And slowly iterate on the rules,
and the patterns and combinations

338
00:18:54,600 --> 00:18:56,149
to reduce, force positives.

339
00:18:56,649 --> 00:19:00,010
Realistically on a daily floor, a
developer can implement the feature

340
00:19:00,760 --> 00:19:06,730
warnings in the id, fix them and
then know get come passes, which

341
00:19:06,730 --> 00:19:08,175
manage everything is well and good.

342
00:19:08,800 --> 00:19:12,879
And then same know in CH stage,
some block manager check for all

343
00:19:12,879 --> 00:19:18,129
they know, full change it and come
on any issues, reviews can happen.

344
00:19:18,129 --> 00:19:20,680
And during the remote, engineers
can review suggestions.

345
00:19:20,680 --> 00:19:23,760
They can add additional violations
to the rules, things like

346
00:19:23,760 --> 00:19:24,720
that over a period of time.

347
00:19:25,459 --> 00:19:29,610
There will be fewer issues that is
getting through your, code because your,

348
00:19:29,670 --> 00:19:34,350
all your baseline thing, security stuff,
taking care of what, flying by system, it

349
00:19:34,350 --> 00:19:36,750
gives like a much faster, feedback loop.

350
00:19:36,930 --> 00:19:40,410
So that's quite useful in terms
of, shifting your security left.

351
00:19:40,910 --> 00:19:42,520
So when you're adopting assembly.

352
00:19:42,620 --> 00:19:44,270
Don't turn on every rule reports.

353
00:19:44,320 --> 00:19:47,530
It adds you phatic and for the right.

354
00:19:47,740 --> 00:19:48,400
So start smart.

355
00:19:48,940 --> 00:19:51,730
A few reports, limited rule set.

356
00:19:52,100 --> 00:19:53,780
Focus on the developer's experience first.

357
00:19:54,325 --> 00:19:57,005
'cause they need to get used
to running some rules locally.

358
00:19:57,620 --> 00:19:59,265
And then only you should,
no more rules, more.

359
00:19:59,765 --> 00:20:04,195
And even there is, success stories,
this particular application so on.

360
00:20:04,195 --> 00:20:08,390
So which, start adopting some, right?

361
00:20:09,350 --> 00:20:14,865
And you can of course work with security
engineers side by side, fine tune the, and

362
00:20:14,965 --> 00:20:18,035
also you can document local conventions.

363
00:20:18,815 --> 00:20:21,955
Local rules and, and additional rules
do things like that so that you know

364
00:20:21,955 --> 00:20:23,515
you have much better security also.

365
00:20:24,015 --> 00:20:27,430
And let's look at a very quick demo
and see a few rules and know code.

366
00:20:27,930 --> 00:20:31,460
So as you can see here we are
looking at three type of rules here.

367
00:20:31,460 --> 00:20:34,345
And so you are already seen
our, hello and program.

368
00:20:34,345 --> 00:20:38,525
So other than that, we have three more
now set of rules that programs here.

369
00:20:39,005 --> 00:20:41,135
So let's start with the first
one, which is sq e rejection.

370
00:20:41,635 --> 00:20:43,225
So let's just look at the file first.

371
00:20:43,725 --> 00:20:48,635
So as you can see this is the rule
for sq e rejection, and what you're

372
00:20:48,635 --> 00:20:50,495
seeing here is three patterns.

373
00:20:50,930 --> 00:20:54,350
It's an either pattern, any of this
pattern matches, it's an SQ induction.

374
00:20:54,710 --> 00:20:58,170
So if you see here if you remember
on Python, there are cursors that

375
00:20:58,170 --> 00:21:00,120
you can use to execute SQ queries.

376
00:21:00,660 --> 00:21:02,670
And the first argument is, of
course, you know the query.

377
00:21:03,330 --> 00:21:07,705
So now this pattern essentially
says any pattern plus you are

378
00:21:07,795 --> 00:21:11,700
conga, connating a variable,
then that is an integral pattern.

379
00:21:12,480 --> 00:21:17,125
Second one, user and upstream,
and then use variable within that.

380
00:21:17,125 --> 00:21:18,020
That's also an integral pattern.

381
00:21:18,520 --> 00:21:21,160
But you could also use the
percentages for replacing variables

382
00:21:21,280 --> 00:21:23,470
within the query that's there.

383
00:21:23,470 --> 00:21:28,360
Also, if you're using a variable
and a text together, then that is

384
00:21:28,450 --> 00:21:30,320
again another, chance of injection.

385
00:21:30,950 --> 00:21:34,520
And of course you can add metadata about
you, what kind of vulnerability this is,

386
00:21:34,910 --> 00:21:39,680
what kind of categories is what technology
or language supports, languages.

387
00:21:39,770 --> 00:21:40,040
You here.

388
00:21:40,760 --> 00:21:41,955
Technology is more like metadata.

389
00:21:42,800 --> 00:21:43,160
All right.

390
00:21:43,160 --> 00:21:47,170
And as you can see, the ID here
is again, something unique and

391
00:21:47,230 --> 00:21:50,070
you can pick interest, know
what this ID should be, right?

392
00:21:51,040 --> 00:21:52,390
And again, severity error.

393
00:21:52,390 --> 00:21:56,835
You have a very post message that this is
an injection and how you should, fix that.

394
00:21:57,335 --> 00:21:59,110
Let's look at the sample program.

395
00:21:59,610 --> 00:22:00,780
Sample program is quite simple.

396
00:22:01,050 --> 00:22:02,800
It has around two functions.

397
00:22:03,510 --> 00:22:05,525
And, both of the Mexicos one as pure code.

398
00:22:06,245 --> 00:22:08,345
As you can see in the first
one, there's a pattern where the

399
00:22:08,345 --> 00:22:10,315
variable is conga, they variable.

400
00:22:11,125 --> 00:22:12,595
And the second one it use an upstream.

401
00:22:12,595 --> 00:22:15,260
But again it replaces, it
inserts a variable here.

402
00:22:15,260 --> 00:22:16,790
So both are in circuit patterns.

403
00:22:17,600 --> 00:22:20,100
Let run this, pattern against
the file and see what happens.

404
00:22:20,600 --> 00:22:20,870
Cool.

405
00:22:20,930 --> 00:22:24,140
So as we expected, it formed two issues.

406
00:22:24,380 --> 00:22:25,880
As you can see, the file will scanned.

407
00:22:25,880 --> 00:22:26,510
Is this one?

408
00:22:26,930 --> 00:22:31,320
The rule ID is this one, and
as you can see, there is.

409
00:22:31,820 --> 00:22:35,360
Two no issues that you know
it or it rather tells you like

410
00:22:35,480 --> 00:22:36,800
this is possible skill ejection.

411
00:22:36,830 --> 00:22:41,110
And these are the two patterns out of
the three C, three patterns we give.

412
00:22:41,530 --> 00:22:43,260
Two of them were detected.

413
00:22:43,265 --> 00:22:43,315
Here.

414
00:22:43,815 --> 00:22:44,265
There's more.

415
00:22:44,265 --> 00:22:47,575
And look at, the next type of
program, which is input validation.

416
00:22:48,025 --> 00:22:50,920
So just say in your organization,
you want to implement a standard.

417
00:22:51,715 --> 00:22:54,580
Function, which will do, or
validate all sort of input.

418
00:22:54,580 --> 00:22:57,855
Right now we have doing the function,
it can be improved as a library and

419
00:22:57,855 --> 00:23:01,875
function in your code, but we need to
check whether the reps are actually

420
00:23:01,875 --> 00:23:07,770
using it during a program right now to
do that, we again, define again, there's

421
00:23:07,770 --> 00:23:11,790
an ID and another whole things, and
then you have a pattern which differ.

422
00:23:11,880 --> 00:23:13,080
It's a multi-line function.

423
00:23:13,580 --> 00:23:15,320
Which defense a function.

424
00:23:15,650 --> 00:23:17,930
Then there's an argument
passed to the body, right?

425
00:23:17,930 --> 00:23:21,160
So that is a, and this
is the next one, right?

426
00:23:21,880 --> 00:23:26,230
Where if you see what is the difference
here, both are same function definition,

427
00:23:26,590 --> 00:23:30,310
but in the first one it just, it
could be another, could be anything.

428
00:23:30,760 --> 00:23:34,815
But in the second one, there is
actually a function called validated.

429
00:23:34,995 --> 00:23:38,980
And this is the right way to do it,
because validated input is a function

430
00:23:38,980 --> 00:23:40,630
that you give to your organization.

431
00:23:41,035 --> 00:23:43,825
So that everybody in the company
uses this validate input.

432
00:23:44,325 --> 00:23:45,165
Now let's look at the quote.

433
00:23:45,665 --> 00:23:46,805
So there are two functions here.

434
00:23:47,525 --> 00:23:50,645
The first function, just,
process, the input as it is.

435
00:23:51,185 --> 00:23:54,535
And the second one actually
validates input first and

436
00:23:54,535 --> 00:23:57,015
then only process that I know.

437
00:23:57,015 --> 00:23:58,665
Data again, run this group.

438
00:23:59,165 --> 00:24:02,765
Again, we found one issue because
the second one, actually not

439
00:24:02,765 --> 00:24:05,975
second part of the code actually
used the well data input function.

440
00:24:05,975 --> 00:24:06,965
The first one didn't.

441
00:24:07,385 --> 00:24:08,135
So that was code.

442
00:24:08,135 --> 00:24:11,885
And as you can see, this is a
multiline pattern and it found on

443
00:24:11,885 --> 00:24:12,935
all the lines that matches the.

444
00:24:13,435 --> 00:24:16,315
Now let's look at the third
and the final pattern.

445
00:24:16,405 --> 00:24:20,775
This is quite common nowadays that
people commit their AWS credentials,

446
00:24:20,775 --> 00:24:24,455
which includes access key and a private
secret key into the code, right?

447
00:24:24,955 --> 00:24:26,695
So let's look at the rule first.

448
00:24:27,195 --> 00:24:30,800
It's a little lengthier and
reduces specific, pattern Then.

449
00:24:30,830 --> 00:24:32,420
So if you see the pattern here, right?

450
00:24:33,245 --> 00:24:36,605
Essentially most of the time if you
are using access security, it'll be

451
00:24:36,605 --> 00:24:37,895
in a variable assignment formatted.

452
00:24:37,895 --> 00:24:40,085
And that is exactly what it's
a simple variable assignment.

453
00:24:40,475 --> 00:24:42,845
Whereas know there's a,
then there's a value.

454
00:24:43,055 --> 00:24:47,525
Right now here we are making
use of ware 'cause we defend

455
00:24:47,555 --> 00:24:49,055
the dollar a dollar value.

456
00:24:49,055 --> 00:24:53,165
Right now you can apply pattern, any
of these things, no meta variables.

457
00:24:53,345 --> 00:24:54,635
So here we are seen meta variables.

458
00:24:55,520 --> 00:24:56,300
Within the pattern.

459
00:24:56,900 --> 00:25:00,500
And what it says is the
meta variable to be used, no

460
00:25:00,540 --> 00:25:02,455
evaluated it, value, lower value.

461
00:25:02,550 --> 00:25:04,050
And that rejects is this one.

462
00:25:04,530 --> 00:25:07,730
So this is a common pattern
for, this one, what you say.

463
00:25:08,360 --> 00:25:11,900
This is a common pattern for access
keys, not secret keys for access keys.

464
00:25:12,290 --> 00:25:12,650
Alright?

465
00:25:12,950 --> 00:25:16,330
So it is going to have first a
specified, bunch of defined patterns.

466
00:25:16,765 --> 00:25:19,010
But there'll be four characters
and then there will be additional

467
00:25:19,010 --> 00:25:22,340
section characters altogether,
making it a 20 character Id.

468
00:25:22,840 --> 00:25:25,035
Now you look at the second one,
we are looking at The Secret.

469
00:25:25,125 --> 00:25:27,535
I know a w Secret right now in here.

470
00:25:28,035 --> 00:25:31,775
It is pretty much like a Basic 60 for
Know The Secret is pretty much now

471
00:25:31,775 --> 00:25:34,845
looking like a base 64 recorded online.

472
00:25:35,245 --> 00:25:39,200
You have, alpha characters
plus slash plus and them.

473
00:25:39,950 --> 00:25:40,310
Equal to.

474
00:25:41,090 --> 00:25:44,220
And the total size of
the key is 40 characters.

475
00:25:44,720 --> 00:25:47,900
And let us look at the
program that used it.

476
00:25:48,410 --> 00:25:49,640
It is a quite simple program.

477
00:25:50,060 --> 00:25:50,870
There are two factors.

478
00:25:50,870 --> 00:25:53,510
One of them just, have demy credit here.

479
00:25:54,500 --> 00:26:00,755
Whereas this function here has a
code AWS access key and secret key.

480
00:26:01,255 --> 00:26:02,155
Embedded in the code.

481
00:26:03,055 --> 00:26:07,185
Alright, so let's see what happens when
you run some grid against this rule.

482
00:26:07,685 --> 00:26:07,865
Cool.

483
00:26:08,255 --> 00:26:09,845
We did two code findings.

484
00:26:09,875 --> 00:26:14,640
The first one is finding the
secret, sorry, access key Id

485
00:26:15,060 --> 00:26:16,920
and second er, secret key id.

486
00:26:17,420 --> 00:26:19,250
That brings us to the end of our demo.

487
00:26:19,880 --> 00:26:25,010
I hope you got an idea about how, what
similar is, how similar can be used,

488
00:26:25,190 --> 00:26:32,075
and I would argue to not start using
or any other SaaS tool in your SU.

489
00:26:32,575 --> 00:26:33,045
Thank you.

