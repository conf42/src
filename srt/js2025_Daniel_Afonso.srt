1
00:00:00,330 --> 00:00:02,040
Hello, welcome for you two.

2
00:00:02,040 --> 00:00:04,800
It's a huge pleasure to
be here, to talk to you.

3
00:00:04,800 --> 00:00:08,730
So before we start, I would like to
invite you to think about something.

4
00:00:08,970 --> 00:00:10,500
I would like to invite you to think on.

5
00:00:10,860 --> 00:00:12,330
Why do we test?

6
00:00:12,900 --> 00:00:16,950
And it can be because it brings you
the reliability that you like can be

7
00:00:16,950 --> 00:00:18,860
because you want to make sure that.

8
00:00:19,360 --> 00:00:23,209
Your code is doing exactly what
the project manager and what

9
00:00:23,209 --> 00:00:24,709
the product expects it to do.

10
00:00:25,070 --> 00:00:29,479
It can be because your boss told you that
you have to you might not even be testing.

11
00:00:29,930 --> 00:00:35,540
So I would like to invite you to reflect
on this during this talk because hopefully

12
00:00:35,540 --> 00:00:39,970
by the end you have a visibility of what's
been happening in the past few years.

13
00:00:39,970 --> 00:00:40,810
Where are we going?

14
00:00:41,170 --> 00:00:45,220
And maybe this might, this
question, this answer might change.

15
00:00:45,720 --> 00:00:51,339
So I'd like to think as well on if has
any of these issues ever happened to you?

16
00:00:51,729 --> 00:00:55,029
If you ever had to deal with flaky
tests, with complex tests, with issues

17
00:00:55,029 --> 00:00:59,914
with mocking, issues with tests that are
hard to maintain, having testing tools

18
00:00:59,914 --> 00:01:04,024
that are hearts slow tests, having too
much boiler plate, lack of type script

19
00:01:04,024 --> 00:01:06,274
support, or AKA via SAM support there.

20
00:01:06,274 --> 00:01:10,804
All things that we have struggled with
historically when dealing with testing.

21
00:01:11,569 --> 00:01:13,969
And this leads us to our pain points.

22
00:01:13,969 --> 00:01:17,179
So when I decided to start doing this
talk, I decided to look at the state

23
00:01:17,179 --> 00:01:21,529
of JS survey, which actually is already
open right now for the next year.

24
00:01:21,529 --> 00:01:24,679
So please go ahead and if
you have time, feel it.

25
00:01:24,709 --> 00:01:27,889
It's very helpful for people
like me who are doing content for

26
00:01:27,889 --> 00:01:30,769
you, but it's also pretty helpful
for open source maintainers.

27
00:01:30,769 --> 00:01:34,259
It's open for the grateful for the
community, and anyone who has to make

28
00:01:34,259 --> 00:01:35,759
decisions around the JavaScript date.

29
00:01:35,859 --> 00:01:36,339
World.

30
00:01:36,639 --> 00:01:38,979
So if you have some time,
please fill out that survey.

31
00:01:39,479 --> 00:01:40,569
So back to the talk.

32
00:01:40,649 --> 00:01:42,689
I started thinking,
okay, where is our pain?

33
00:01:42,689 --> 00:01:45,359
Because I had all these points in the
previous slide, there are things that

34
00:01:45,359 --> 00:01:48,959
I've struggled with, so I looked into the
state of JS survey and it told us that,

35
00:01:48,959 --> 00:01:50,909
okay, mocking is the number one pain.

36
00:01:51,449 --> 00:01:57,359
Then we went into configuration
performance, JS ESM, and common js,

37
00:01:57,419 --> 00:01:59,579
excessive complexity, flakiness.

38
00:01:59,909 --> 00:02:04,709
That's 0.8, which is shows empty is
browser testing issues, end-to-end

39
00:02:04,709 --> 00:02:08,789
testing, lack of documentation, TypeScript
support, unit testing, debugging.

40
00:02:09,289 --> 00:02:13,789
And it seems like the testing world
is, we're going on with a lot of pain,

41
00:02:14,779 --> 00:02:17,959
but how happy are we with what we have?

42
00:02:17,959 --> 00:02:19,459
Where does these with us?

43
00:02:20,059 --> 00:02:24,019
It's a 2.5 out of four, which is not Whoa.

44
00:02:24,019 --> 00:02:24,559
Of testing.

45
00:02:24,559 --> 00:02:27,459
It's yeah, okay, let's write another test.

46
00:02:28,420 --> 00:02:32,920
So with these pain points and with this
data, I decided it was time that I did

47
00:02:32,920 --> 00:02:35,679
the 2025 state of JavaScript testing.

48
00:02:36,339 --> 00:02:38,409
So that's where the stock is going.

49
00:02:38,409 --> 00:02:40,570
But before, let me just introduce myself.

50
00:02:40,929 --> 00:02:43,959
My name is Anon and I'm a
developer advocate at PagerDuty.

51
00:02:44,079 --> 00:02:46,059
I'm part of the solid JSTX team.

52
00:02:46,149 --> 00:02:49,480
I'm an instructor at Egg io and
I'm the author of a book called

53
00:02:49,749 --> 00:02:51,519
State Management with React Query.

54
00:02:51,549 --> 00:02:55,229
You can find me pretty much
anywhere online at Daniel g CFOs or.

55
00:02:55,859 --> 00:02:59,779
On page three comments aside from this,
I maintain a newsletter called this Month

56
00:02:59,779 --> 00:03:04,639
in Solid, where pretty much every month
or so I can, I go over what's happened

57
00:03:04,689 --> 00:03:09,489
in the past month and the solid land
so that people can be updated to it.

58
00:03:09,969 --> 00:03:12,699
So if you kinda charact that we have
here under the right, basically it'll

59
00:03:12,699 --> 00:03:14,409
take you through all of my links.

60
00:03:14,909 --> 00:03:19,079
When I started this talk, aside from the
pain points, I was taking a bit on our

61
00:03:19,199 --> 00:03:23,759
company's testing and I have this data
that tell me that 60% of the company,

62
00:03:23,819 --> 00:03:28,859
62% of the companies are using Jest,
storybook, V Test, playwright Cyrus,

63
00:03:28,859 --> 00:03:35,954
testing, library Mock moca moca, sorry,
puppeteer, selenium Box Service Worker, no

64
00:03:35,954 --> 00:03:42,809
Test Runner, web Rev io Test Cafe, and 13%
are not even testing at all as it seems.

65
00:03:43,309 --> 00:03:46,609
But this gave me
information about the tools.

66
00:03:46,609 --> 00:03:50,269
It didn't give information on how
the tools are using are being used.

67
00:03:50,539 --> 00:03:54,619
So I DMed a couple of friends of mine
and I tried to get some data outta

68
00:03:54,619 --> 00:03:59,329
them and the question that I asked
them is, Hey, could you tell me how

69
00:03:59,329 --> 00:04:01,189
are you writing tests in your company?

70
00:04:01,669 --> 00:04:06,169
And eight of my friends got back to me,
so let's review these cases, shall we?

71
00:04:06,574 --> 00:04:10,444
For the case one, they're using, they're
writing BD, D tests with playwright.

72
00:04:10,534 --> 00:04:12,184
So we have driven development.

73
00:04:12,184 --> 00:04:14,884
They're using covering
Gerkin to write these tests.

74
00:04:15,394 --> 00:04:17,554
They're using jets and React
testing library for unit and

75
00:04:17,554 --> 00:04:20,704
integration, and they're using
storybook as a component catalog.

76
00:04:21,204 --> 00:04:21,834
For the case.

77
00:04:21,834 --> 00:04:25,254
Two, they're using Jes and React
testing library for unit integration

78
00:04:25,254 --> 00:04:28,064
and Cyprus to end-to-end case three.

79
00:04:28,124 --> 00:04:31,334
They're using Karma and Jasmine
for integration slash component

80
00:04:31,334 --> 00:04:33,164
testing and jest and react testing.

81
00:04:33,164 --> 00:04:37,244
Library for unit playwright for
visual regression playwright for

82
00:04:37,244 --> 00:04:41,024
end-to-end and storybook as a
component catalog for the case.

83
00:04:41,024 --> 00:04:41,444
Four.

84
00:04:41,504 --> 00:04:44,504
They're using Jes and enzyme
for integration and we driver

85
00:04:44,504 --> 00:04:46,484
io plus Cucumber for end-to-end.

86
00:04:46,984 --> 00:04:47,194
Okay.

87
00:04:47,194 --> 00:04:51,154
We start seeing some patterns here,
mainly around the unit and integration.

88
00:04:51,644 --> 00:04:53,209
Let's see what the next cases bring.

89
00:04:54,194 --> 00:04:58,574
For the case five, they're using J and
React operator for unit integration.

90
00:04:58,664 --> 00:04:59,804
Clear right for end to end.

91
00:04:59,894 --> 00:05:02,624
And this is the first person that
mentioned mock service worker.

92
00:05:02,924 --> 00:05:06,764
So for those who are not familiar with
mock service worker or MSS W for short,

93
00:05:07,094 --> 00:05:12,374
it's basically an API mocking tool that
allows you to define your API schemas

94
00:05:12,434 --> 00:05:18,494
and ways and handlers that will respond
whenever a request is sent to these.

95
00:05:19,394 --> 00:05:22,064
Request and basically, so it
intercept a request and returns

96
00:05:22,064 --> 00:05:24,244
your mock data for the K six.

97
00:05:24,484 --> 00:05:27,754
They're using just and
React for unit integration.

98
00:05:27,814 --> 00:05:30,904
And K seven was the one that I
think that surprised me the most.

99
00:05:30,904 --> 00:05:34,234
I don't know if it's because it's
a more recent company, but first,

100
00:05:34,294 --> 00:05:37,234
this is the first person that
actually considers static analysis

101
00:05:37,234 --> 00:05:40,449
as part of their testing tool kit.

102
00:05:40,589 --> 00:05:42,869
So if you're looking at a testing trophy.

103
00:05:43,194 --> 00:05:46,764
Static analysis sits at the bottom
and this person remembers of that

104
00:05:46,884 --> 00:05:48,264
and I was very happy around that.

105
00:05:48,264 --> 00:05:49,764
So they're using TypeScript and Yes, link.

106
00:05:50,454 --> 00:05:53,364
And this is also the first person
that mentioned V test instead of

107
00:05:53,364 --> 00:05:57,129
just using V test and React testing
library for unit slash integration.

108
00:05:57,629 --> 00:06:01,049
For end to end for the final
case, Cypress, for end-to-end

109
00:06:01,349 --> 00:06:04,769
an enzyme slash react testing
library for unit integration.

110
00:06:05,189 --> 00:06:08,849
And the way that this company
is working is the whole tests

111
00:06:08,849 --> 00:06:09,899
are all written in enzyme.

112
00:06:09,959 --> 00:06:11,939
The new tests are written
in a React testing library.

113
00:06:11,939 --> 00:06:15,179
And if for some reason you need to
touch a whole test, you migrated

114
00:06:15,179 --> 00:06:16,289
for the React testing library.

115
00:06:16,289 --> 00:06:19,349
And that's the way that they can
ensure that the migration happens

116
00:06:19,349 --> 00:06:22,309
successfully and without any hiccups.

117
00:06:22,429 --> 00:06:24,949
And they're also using
mock service worker, which.

118
00:06:25,179 --> 00:06:26,469
Once again made me very happy.

119
00:06:26,969 --> 00:06:31,169
So this is the testing trophy I
was telling you about where we

120
00:06:31,169 --> 00:06:35,159
have study analysis at the bottom,
we go to the unit one unit tests,

121
00:06:35,159 --> 00:06:37,229
integration tests, and then to end.

122
00:06:37,889 --> 00:06:42,929
And I think we should go over each
one of these points when we are

123
00:06:43,199 --> 00:06:48,099
considering what's the state of 2025
testing in the JavaScript when, so let's

124
00:06:48,099 --> 00:06:50,259
start with the static analysis part.

125
00:06:50,759 --> 00:06:56,419
I think to the surprise of no one
TypeScript and the are winning and

126
00:06:56,989 --> 00:06:58,639
I don't see them going anywhere.

127
00:06:58,939 --> 00:07:02,149
Especially now with TypeScript being
rewritten in Go, it's becoming more,

128
00:07:02,329 --> 00:07:03,889
it's becoming faster, more performant.

129
00:07:04,429 --> 00:07:05,959
It's a de facto in the industry.

130
00:07:05,959 --> 00:07:09,379
And personally, I won't want
to change and I don't see a lot

131
00:07:09,379 --> 00:07:10,579
of people wanting to do that.

132
00:07:10,819 --> 00:07:14,689
However I would've recommended that you
keep an eye out for tools like Biome

133
00:07:14,689 --> 00:07:20,059
and OX Wind, which are actually being
used already by some projects and.

134
00:07:20,944 --> 00:07:24,574
In some scenarios specifically, like when
you're talking about X wind, it says that

135
00:07:24,604 --> 00:07:31,684
it outperforms outperforms the rest in 15
to 20% in short to medium sized projects.

136
00:07:31,714 --> 00:07:37,384
So that seems a good thing to, to look
into or at least keeping your radar.

137
00:07:37,884 --> 00:07:40,194
So now let's talk about the
unit and integration testing.

138
00:07:40,434 --> 00:07:42,864
And I think for us to.

139
00:07:43,359 --> 00:07:44,259
Talk about unit.

140
00:07:44,259 --> 00:07:47,949
We need to talk about integration
because there have been deeply

141
00:07:47,949 --> 00:07:50,439
tied in the JS land for the last.

142
00:07:50,939 --> 00:07:52,679
10 years or so, let's say it that way.

143
00:07:53,339 --> 00:07:55,979
And I think it's good that
we go with an history lesson.

144
00:07:56,479 --> 00:08:00,199
10 years ago we were writing tests using
this thing called Karma and Jasmine.

145
00:08:00,619 --> 00:08:04,429
And these tests were what we
used to call component testing.

146
00:08:04,969 --> 00:08:08,329
And the reason why they call it component
testing was because we were running this

147
00:08:08,329 --> 00:08:13,439
tests in a browser environment, but we had
some issues with this and with this, first

148
00:08:13,439 --> 00:08:15,989
one was these tests tended to be flaky.

149
00:08:16,289 --> 00:08:17,759
They were slow.

150
00:08:18,269 --> 00:08:22,259
We had issues running them in CICD,
so pipeline, using them in a pipeline

151
00:08:22,259 --> 00:08:25,739
was painful and it was unreliable.

152
00:08:26,039 --> 00:08:27,599
So we needed to have a transition.

153
00:08:27,599 --> 00:08:30,329
We needed something better.

154
00:08:30,829 --> 00:08:33,169
I don't know if you transitioned for
something better, but we transitioned

155
00:08:33,169 --> 00:08:38,679
to something that worked because then we
moved out of component testing and into.

156
00:08:39,179 --> 00:08:42,979
Jes and which is a Jes
dom based testing tool.

157
00:08:43,490 --> 00:08:47,060
And basically what now we are doing
is instead of running our tests into

158
00:08:47,060 --> 00:08:48,680
a browser, we're running them in node.

159
00:08:48,890 --> 00:08:53,510
So what the Jes dom does, it probably
fills some browser APIs or some the

160
00:08:53,510 --> 00:08:57,319
most browser APIs so that basically
your tests can run in an load based

161
00:08:57,380 --> 00:08:58,670
environment without you having to.

162
00:08:59,170 --> 00:09:02,709
To worry about what we had before, and
this meant that these tests were faster.

163
00:09:02,889 --> 00:09:07,120
They were not as flaky and they could run
in CICD because it was all based in node

164
00:09:07,959 --> 00:09:10,870
and this was where we were until 2018.

165
00:09:11,709 --> 00:09:16,900
And in 2018 the testing library came
out and with the testing library came.

166
00:09:16,900 --> 00:09:17,920
Its main philosophy.

167
00:09:18,010 --> 00:09:20,770
The more your tests resemble the
way your software is used, the more

168
00:09:20,770 --> 00:09:23,319
confidence they can give you and.

169
00:09:23,819 --> 00:09:27,749
This meant that now we were writing
our tests from a user-centric approach.

170
00:09:27,749 --> 00:09:30,180
There were no longer
implementation details.

171
00:09:30,180 --> 00:09:31,619
Focus on our tests now.

172
00:09:31,619 --> 00:09:33,655
We were writing our tests
as if we were the user.

173
00:09:34,619 --> 00:09:37,919
But this caused a bit on what I
like to call the backend fallacy

174
00:09:37,919 --> 00:09:39,089
and the categorization pain.

175
00:09:39,599 --> 00:09:44,039
What I mean with the backend fallacy
is when I learn my tests and I learn

176
00:09:44,039 --> 00:09:46,889
how to test, I was a backend developer
and I learned it from a backend

177
00:09:46,889 --> 00:09:50,129
developer perspective, which meant,
okay, when we're testing a unit,

178
00:09:50,159 --> 00:09:52,949
we're making sure that we're going
to that unit, implementation details.

179
00:09:53,310 --> 00:09:56,969
When we're testing an integration, we're
testing integration between several units.

180
00:09:57,149 --> 00:10:02,300
But now that implementation details
bit didn't exist anymore and.

181
00:10:02,900 --> 00:10:06,500
Then we led into where we are with
the categorization pain because

182
00:10:06,600 --> 00:10:10,620
some people, what a unity is
not what a unity is for others.

183
00:10:10,980 --> 00:10:14,130
And this LED will led to different
companies and different organizations

184
00:10:14,130 --> 00:10:17,400
have different definitions
of what testing is for them.

185
00:10:18,390 --> 00:10:20,220
I've worked in a couple
of companies in the past.

186
00:10:20,850 --> 00:10:22,430
Six seven years.

187
00:10:22,760 --> 00:10:25,579
I've met a lot of people that work in
different companies in the past few

188
00:10:25,579 --> 00:10:29,629
years, and I can assure you that most of
them have different testing definitions.

189
00:10:29,930 --> 00:10:35,119
So we are in this categorization pain,
which for the good or for the bad.

190
00:10:35,619 --> 00:10:39,449
It helped us in a sense because, now we
migrated to using the testing library

191
00:10:39,539 --> 00:10:42,979
and we can say that's where testing
started to become fun, fun for a lot

192
00:10:42,979 --> 00:10:45,739
of people, and made it even better.

193
00:10:46,249 --> 00:10:48,559
So what's our next transition then?

194
00:10:49,059 --> 00:10:51,459
It's all about test runners
and ware integration.

195
00:10:51,639 --> 00:10:55,659
I don't know about you, but if you ever
had to configure JS to run with Webpac,

196
00:10:55,749 --> 00:10:58,119
you know it's a configuration help.

197
00:10:58,619 --> 00:10:59,759
It's painful.

198
00:10:59,759 --> 00:11:02,989
I spent hours and hours going
over that web pack file,

199
00:11:03,049 --> 00:11:05,629
and I gotta be honest, just.

200
00:11:06,154 --> 00:11:07,624
It's stuck in time.

201
00:11:08,084 --> 00:11:11,794
What I mean by being stuck in time
TypeScript support is experimental.

202
00:11:12,124 --> 00:11:15,994
ESM support is experimental
and we're 2025.

203
00:11:16,294 --> 00:11:19,954
We have things like storybook 10
that is going ESM only already.

204
00:11:20,414 --> 00:11:24,574
And they're reporting that it they
have 50% decrease in package size.

205
00:11:24,724 --> 00:11:27,394
And in the meantime we have
tools like Jes, where DSM support

206
00:11:27,394 --> 00:11:29,334
is still experimental and.

207
00:11:29,834 --> 00:11:34,334
That's like mind opening
or mind blowing in a sense.

208
00:11:34,784 --> 00:11:38,564
But it's not just that we needed a test
runner that is aware of its environment

209
00:11:38,564 --> 00:11:40,334
and it works together with a bundler.

210
00:11:40,574 --> 00:11:44,084
So in a sense, we want to build our tests
in the same way that we are building

211
00:11:44,084 --> 00:11:47,324
our application, which is something
that we were not doing until this time.

212
00:11:47,824 --> 00:11:53,764
So that's when V test showed up and
V, so basically V test and work was

213
00:11:53,764 --> 00:11:55,474
working together with V and basically.

214
00:11:56,224 --> 00:11:59,134
We're using the same tool that
we're using to bundle and run

215
00:11:59,134 --> 00:12:00,994
our code to run our tests.

216
00:12:01,234 --> 00:12:03,124
And we even need this another transition.

217
00:12:03,124 --> 00:12:05,794
So instead of using just pure gto,
we were using this thing called

218
00:12:05,824 --> 00:12:10,394
epione, which for performance
reasons got rid of certain APIs.

219
00:12:10,734 --> 00:12:13,344
And it's basically a
faster version of j Om.

220
00:12:13,844 --> 00:12:18,074
But when we're talking about J Om, then
it takes us to the beginning of this year.

221
00:12:18,574 --> 00:12:23,374
And that when we started talking final,
finally talking about the JS Om issue art,

222
00:12:23,674 --> 00:12:27,304
the creator of a mock service worker wrote
this amazing blog post called Why I Want

223
00:12:27,304 --> 00:12:30,334
to use Js Om for today's Attention Span.

224
00:12:30,334 --> 00:12:32,704
I know it might be a bit
too long, it's 10 minutes.

225
00:12:33,034 --> 00:12:36,364
But I made sure to make it
shorter so that everyone can get

226
00:12:36,364 --> 00:12:38,344
grasp the fundamentals and why.

227
00:12:38,909 --> 00:12:39,899
We have issues with the js om.

228
00:12:40,859 --> 00:12:42,929
So the first part is js.

229
00:12:42,929 --> 00:12:48,419
Om runs a node and fuss browser APIs,
so you don't have an actual browser.

230
00:12:48,479 --> 00:12:51,449
It's executing browser wide
code without having one.

231
00:12:51,969 --> 00:12:54,789
Artize This code there that I
really which is, which says Js om

232
00:12:54,789 --> 00:12:58,679
runs in node js pretends to be a
browser, but ends up being neither.

233
00:12:59,179 --> 00:13:01,339
So what's the suggestion here?

234
00:13:01,339 --> 00:13:02,569
What should we do?

235
00:13:03,169 --> 00:13:04,879
Art closes up the.

236
00:13:05,829 --> 00:13:11,469
Closes up or has this around mid halfway
to the end of the blog post that says, the

237
00:13:11,469 --> 00:13:15,189
closer your test environment resembles the
actual environment where your code runs,

238
00:13:15,519 --> 00:13:17,259
the more value your test will bring you.

239
00:13:17,649 --> 00:13:20,739
And if you're familiar with the
testing library, you might be

240
00:13:20,739 --> 00:13:23,799
familiar with this quote because it
sounds a lot quite the same thing.

241
00:13:24,669 --> 00:13:26,409
So what is art telling us?

242
00:13:26,909 --> 00:13:30,839
It's telling us it's about time that we go
back to the browser and it's recommending

243
00:13:30,839 --> 00:13:32,609
that we use V test browser mode.

244
00:13:33,119 --> 00:13:37,469
So what V test browser mode does,
it's basically what I just tell you.

245
00:13:37,529 --> 00:13:41,099
It allows you to run your
tests in a browser environment.

246
00:13:41,189 --> 00:13:43,859
You don't test to run them in node.

247
00:13:43,859 --> 00:13:47,369
Again, you're going back to the
browser because our technology

248
00:13:47,369 --> 00:13:48,959
finally allows us to do this.

249
00:13:49,499 --> 00:13:52,079
And I know you might be
thinking, oh, it's gonna take a

250
00:13:52,079 --> 00:13:53,519
lot of refactoring to do that.

251
00:13:54,479 --> 00:13:55,079
Not really.

252
00:13:55,349 --> 00:13:59,189
All you have to do is basically
swapping out to imports, because now

253
00:13:59,219 --> 00:14:03,839
we migrated from the testing library
into actually the V test browser slash

254
00:14:03,839 --> 00:14:09,179
framework of choice and making sure
that we, our tests now are synchronous.

255
00:14:09,279 --> 00:14:13,089
And I, while was doing this migration
as well myself, I noticed five

256
00:14:13,089 --> 00:14:14,374
points that I wanted to have here.

257
00:14:15,109 --> 00:14:19,069
These are from a React developer's
perspective, but here's what I noticed.

258
00:14:19,159 --> 00:14:23,599
The first one, I got rid of everything
that was query by and find by, because

259
00:14:23,599 --> 00:14:25,879
everything now is a get by query.

260
00:14:26,659 --> 00:14:32,549
Second point, got rid of all the wait four
from Reacts library because now v test

261
00:14:32,579 --> 00:14:37,259
browser mode will have automatic retries
out of the box, which is super powerful.

262
00:14:37,259 --> 00:14:38,099
You don't have to.

263
00:14:39,074 --> 00:14:39,914
Wrap it with anything.

264
00:14:39,914 --> 00:14:43,844
All we have to do is say a wait
and it'll retry during until

265
00:14:43,844 --> 00:14:48,034
time out time change mock service
worker to run into worker mode.

266
00:14:48,064 --> 00:14:51,724
So instead of intercepting stuff
in node based environment, we'll

267
00:14:51,724 --> 00:14:54,934
use the service worker that it runs
in browser to actually intercept

268
00:14:54,934 --> 00:14:57,124
requests and return those mock data.

269
00:14:57,875 --> 00:15:02,584
Point four, turn test synchronous and
0.5, get rid of unnecessary mocks because

270
00:15:02,614 --> 00:15:04,685
now we have access to the proper browser.

271
00:15:04,685 --> 00:15:05,135
API.

272
00:15:05,435 --> 00:15:09,905
So this meant I got rid of stuff like
mocks on the loca storage because I can

273
00:15:09,905 --> 00:15:11,854
actually use the proper loca storage.

274
00:15:11,854 --> 00:15:15,474
Now I don't have to mock stuff that
I. Didn't have access to before

275
00:15:15,534 --> 00:15:16,944
and that made me really happy.

276
00:15:16,994 --> 00:15:21,404
I love deleting code and I love, and
this migration was super, super smooth.

277
00:15:22,034 --> 00:15:25,364
I know you're thinking now
about of what, about time,

278
00:15:25,484 --> 00:15:27,854
what, how slow these tests are.

279
00:15:28,394 --> 00:15:31,124
It was not that a significant increase.

280
00:15:31,124 --> 00:15:32,219
It was like two to three seconds.

281
00:15:33,129 --> 00:15:37,179
And to be honest, I'm okay with
two to three seconds slower tests

282
00:15:37,209 --> 00:15:40,599
if they're actually running in the
environment where the code is running.

283
00:15:40,809 --> 00:15:43,630
It gives me confidence
that it's going to work.

284
00:15:44,130 --> 00:15:48,680
So when I was preparing this talk and
I was doing it for the first time,

285
00:15:48,710 --> 00:15:52,730
I thought, oh, I wish I could, aside
from this post from art and this

286
00:15:52,730 --> 00:15:54,310
thing that I'm doing here, I had some.

287
00:15:54,810 --> 00:15:59,575
Something that would help me convince
you to use the testing library the

288
00:15:59,575 --> 00:16:02,365
testing library if you test browser
mode and migrating to these things.

289
00:16:02,785 --> 00:16:05,680
And the author of the testing
library itself wrote this post.

290
00:16:06,430 --> 00:16:08,830
Exactly on that same day,
which made me very happy.

291
00:16:09,100 --> 00:16:11,560
And here it says, never been
so happy to see people on

292
00:16:11,560 --> 00:16:12,910
installing the testing library.

293
00:16:13,570 --> 00:16:17,410
Honestly, it's incredibly validating that
the testing library has been successful

294
00:16:17,930 --> 00:16:22,100
been so successful that it's been adopted
and rewritten natively by playwright.

295
00:16:22,190 --> 00:16:24,380
And we test my work here is done.

296
00:16:25,340 --> 00:16:27,845
So that's our next transition.

297
00:16:28,345 --> 00:16:32,215
Our next transition and where I think and
hope that people will move into the next

298
00:16:32,215 --> 00:16:35,815
two, three years is basically just v test.

299
00:16:36,175 --> 00:16:41,125
The testing library is there as represent
representation because the fundamentals

300
00:16:41,125 --> 00:16:44,125
of are is still going to be important
and we're still gonna have to use them.

301
00:16:44,125 --> 00:16:48,085
But basically how we have, and all
we're going to need is V test and

302
00:16:48,085 --> 00:16:50,685
v. And I'm pretty happy with that.

303
00:16:51,185 --> 00:16:53,525
So yeah, the feature is
in component testing.

304
00:16:53,675 --> 00:16:57,845
Let's go back to the browser and
let's see where this is going.

305
00:16:58,325 --> 00:17:02,095
I feel like in the web land, and
especially in the JavaScript land, we're

306
00:17:02,095 --> 00:17:07,935
finding ways of constantly picking up old
concepts and stuff that was not working

307
00:17:07,935 --> 00:17:10,905
in the past and bringing them back and.

308
00:17:11,405 --> 00:17:14,585
I'm happy with it because the
technology now allows us to do this.

309
00:17:14,865 --> 00:17:17,415
I have an example when we're
talking about frameworks itself.

310
00:17:17,565 --> 00:17:23,025
Until 20 20, 20 21, everyone was so
happy having single page applications.

311
00:17:23,025 --> 00:17:25,865
But then someone started asking
the question, our bundles

312
00:17:25,865 --> 00:17:27,770
seemed to be a bit packed.

313
00:17:27,860 --> 00:17:30,800
The stuff that we're shipping
to the browser seems packed.

314
00:17:30,800 --> 00:17:33,230
Is there a way that we can start
doing server side rendering again?

315
00:17:33,740 --> 00:17:36,830
And that's what we did because the
technology then allowed us to do

316
00:17:36,830 --> 00:17:40,370
server-side rendering in a better
way that we were doing back in

317
00:17:40,370 --> 00:17:43,740
the old times before going away
and on single page applications.

318
00:17:43,980 --> 00:17:46,440
So the same thing happened
with server components.

319
00:17:46,440 --> 00:17:48,360
The same thing is happening
with component testing.

320
00:17:48,600 --> 00:17:51,245
We are back and I hope to see how it.

321
00:17:52,125 --> 00:17:52,755
This is growing.

322
00:17:53,255 --> 00:17:56,555
So the next point, we're talking
about end-to-end testing, and I

323
00:17:56,555 --> 00:17:59,765
think the surprise of no one who
write has been winning the adoption.

324
00:17:59,945 --> 00:18:03,545
And it's not just because it's
cross, cross browser, cross

325
00:18:03,545 --> 00:18:05,105
platform, cross language.

326
00:18:05,375 --> 00:18:10,925
It has stuff like cogen and tracing out
of the box and as things like parallelism,

327
00:18:10,925 --> 00:18:14,075
which was paid in Cypress until a
couple of versions ago, I'm not sure

328
00:18:14,075 --> 00:18:16,835
if it still is out of the box for free.

329
00:18:17,285 --> 00:18:20,465
And it's not just that the community
work that playwright has been doing.

330
00:18:20,965 --> 00:18:24,295
A hundred percent shows why
they're winning this adoption.

331
00:18:24,835 --> 00:18:28,575
And if you're picking something
up, I would go with playwright.

332
00:18:29,075 --> 00:18:31,565
But one thing that I was noticed
when I was doing the research

333
00:18:31,565 --> 00:18:36,185
for this talk is that end-to-end
solutions are becoming more than just

334
00:18:36,365 --> 00:18:40,745
end-to-end testing because all of
them have versions of visual testing.

335
00:18:40,805 --> 00:18:43,645
All of them have versions of
component testing, even though it's

336
00:18:43,645 --> 00:18:45,235
on play is currently experimental.

337
00:18:45,940 --> 00:18:48,970
All of them have versions of
API testing and all of them have

338
00:18:48,970 --> 00:18:51,010
versions of accessibility testing.

339
00:18:51,820 --> 00:18:53,350
And it's not just them.

340
00:18:53,560 --> 00:18:57,860
Things like tools like storybook
that many of us considered just

341
00:18:57,860 --> 00:19:02,450
for our design systems also allow
you to run all of these tests.

342
00:19:03,200 --> 00:19:06,709
So it's very interesting to see
how these solutions are trying to

343
00:19:06,709 --> 00:19:12,199
cover the market for all these other
type of tests and what is going to.

344
00:19:12,699 --> 00:19:18,849
Survive on the non tool, solution part.

345
00:19:19,209 --> 00:19:23,019
So are we going to migrate even our
component tests into this and not, and

346
00:19:23,019 --> 00:19:25,269
only write unit tests on the other side?

347
00:19:25,599 --> 00:19:29,199
I'm very curious to see what's going to
happen there, because one thing I noticed

348
00:19:29,229 --> 00:19:33,639
during the server component storyline of
all of this is that many people didn't

349
00:19:33,639 --> 00:19:37,359
know how to write integration tests for
them, and then basically they just ended

350
00:19:37,359 --> 00:19:38,949
up doing end to end for everything.

351
00:19:39,579 --> 00:19:41,079
So I'm curious.

352
00:19:41,949 --> 00:19:45,790
But I'm optimistic that this is
going to be the new testing trophy.

353
00:19:45,879 --> 00:19:48,010
This is going to be where we are shifting.

354
00:19:48,459 --> 00:19:53,270
So static analysis on the bottom
unit, test a bit above it.

355
00:19:53,360 --> 00:19:57,979
And then we have component and end-to-end
testing and going over all of this.

356
00:19:58,010 --> 00:20:02,899
We have visual and accessibility
testing, so I'm excited to see

357
00:20:03,139 --> 00:20:04,249
where we're going to end up.

358
00:20:04,429 --> 00:20:06,560
And this kind of covers the.

359
00:20:07,060 --> 00:20:11,620
Static analysis, unit slash integration
and end-to-end section of testing.

360
00:20:12,189 --> 00:20:18,810
Now, one of the biggest pains that we
people talked about was mocking, and I

361
00:20:18,810 --> 00:20:20,250
want to talk about mock service worker.

362
00:20:20,639 --> 00:20:23,850
A bit more because to be honest,
it has become the industry

363
00:20:23,850 --> 00:20:25,769
standard and I'm very happy for it.

364
00:20:25,829 --> 00:20:29,139
If you want to get a bit more
information about MSW, its

365
00:20:29,139 --> 00:20:30,610
documentation is pretty great.

366
00:20:30,969 --> 00:20:33,879
If you want to know what I,
why, I love Mock Service Worker,

367
00:20:34,209 --> 00:20:35,229
you can search on YouTube.

368
00:20:35,229 --> 00:20:38,979
I have this talk called, all You
Need is a contract, which basically

369
00:20:38,979 --> 00:20:44,559
gives you a 30 to 40 minute
explanation on why I love MSW, but.

370
00:20:44,919 --> 00:20:48,399
In a short sense, it supports
rest, GraphQL and web socket.

371
00:20:49,089 --> 00:20:52,819
It works for the browser for
Node and for React native and.

372
00:20:53,319 --> 00:20:54,639
The community of it.

373
00:20:54,639 --> 00:20:56,589
It's been working a lot.

374
00:20:56,589 --> 00:21:00,069
So it has things like SW Auto Mock,
which basically is a COI tool that

375
00:21:00,069 --> 00:21:04,179
generates random mock data from
open API DEF definitions for Ms. W.

376
00:21:04,599 --> 00:21:08,379
You have playwright MSW, which is a
package that provides a better developer

377
00:21:08,379 --> 00:21:13,449
experience when you're mocking APIs using
playwright, and it's working on some art.

378
00:21:13,659 --> 00:21:16,059
It's working on something called
Cross process interception.

379
00:21:16,559 --> 00:21:20,489
Which basically allows you developers
to control network requests across

380
00:21:20,489 --> 00:21:22,049
different process boundaries.

381
00:21:22,409 --> 00:21:27,569
And this is useful when we're talking
about stuff like server and client site.

382
00:21:27,629 --> 00:21:29,969
So it allows you to mock data
on the server and ask you

383
00:21:30,419 --> 00:21:32,069
to mock data on the client.

384
00:21:32,519 --> 00:21:36,119
It's very exciting and I wouldn't
pick any other solution when we're

385
00:21:36,264 --> 00:21:40,259
talking about network mocking
and it just makes it so easy.

386
00:21:40,759 --> 00:21:42,949
So yeah, that's my suggestion.

387
00:21:42,949 --> 00:21:43,834
When we were talking about mocking.

388
00:21:44,629 --> 00:21:49,999
Now we're in 2025, so obviously
we need to talk about ai.

389
00:21:50,929 --> 00:21:53,689
And when we're talking about ai,
obviously the first part we talk

390
00:21:53,689 --> 00:21:57,594
about is copilots and Quad and all
of our Paraprogramming buddies.

391
00:21:58,094 --> 00:21:59,384
You have two thoughts here.

392
00:21:59,504 --> 00:22:03,554
The first one is they'll obviously speed
you up, but you make need to make sure

393
00:22:03,554 --> 00:22:07,484
that you check its sources, especially
when you're playing around with things

394
00:22:07,484 --> 00:22:12,704
that might haven't been around for a
long time, like component testing or the

395
00:22:12,704 --> 00:22:14,414
test browser mode and all those things.

396
00:22:14,414 --> 00:22:18,794
Make sure that the test that it's
writing, it's actually giving

397
00:22:18,794 --> 00:22:19,874
you the things that you need.

398
00:22:20,384 --> 00:22:24,044
Because this leads to the second
point, which is we shouldn't use AI to.

399
00:22:24,544 --> 00:22:28,444
Delegate our thought process and
our knowledge gap, our knowledge,

400
00:22:28,474 --> 00:22:31,114
because then we're going to end
up with a knowledge gap if we have

401
00:22:31,174 --> 00:22:33,094
AI generating everything for us.

402
00:22:33,214 --> 00:22:35,434
Next time, we're gonna have
to refactor these things.

403
00:22:35,934 --> 00:22:37,074
We won't have the knowledge.

404
00:22:37,134 --> 00:22:38,544
We'll just be delegated everything.

405
00:22:38,544 --> 00:22:43,344
So don't use AI as an excuse
to not learn your stuff.

406
00:22:43,374 --> 00:22:46,344
Make sure that you actually
learn them and then you work

407
00:22:46,344 --> 00:22:48,749
together with AI to speed you up.

408
00:22:49,249 --> 00:22:52,489
Next MCP model, context, protocol.

409
00:22:52,579 --> 00:22:54,079
It's everywhere.

410
00:22:54,229 --> 00:22:56,299
Everyone is going in, all in on MCP.

411
00:22:56,509 --> 00:23:00,559
You have stuff like playwright,
which is pretty, pretty good.

412
00:23:00,589 --> 00:23:02,689
You can just tell them,
Hey, open this website.

413
00:23:03,109 --> 00:23:07,429
Navigate around it, use certain actions,
and then leverage the tools that you

414
00:23:07,429 --> 00:23:12,619
used to do these things to generate me a
playwright test, and it'll do you that.

415
00:23:13,549 --> 00:23:17,599
It's insanely good, and it's not just
playwright that build an MCP server

416
00:23:17,899 --> 00:23:23,899
meet scene js, which is a testing
attesting tool created by ance, which

417
00:23:23,899 --> 00:23:26,239
we're talking in a bit as an MCP server.

418
00:23:26,689 --> 00:23:29,539
ES went as an MCP server.

419
00:23:29,839 --> 00:23:34,644
So everyone has been going on MCP
and the hype doesn't seem, seems

420
00:23:34,644 --> 00:23:36,054
to be getting better and better.

421
00:23:36,054 --> 00:23:38,964
So let's see how it keeps progressing.

422
00:23:38,964 --> 00:23:41,064
But now you have these tools.

423
00:23:41,829 --> 00:23:45,149
Your hands reach to use and leverage.

424
00:23:45,649 --> 00:23:48,739
So one question that a lot of
people ask me when we start talking

425
00:23:48,739 --> 00:23:53,719
about AI in testing is, how far
are we from self-healing tests?

426
00:23:54,409 --> 00:23:58,669
There was this blog post last year on
the ministry of Testing that was pretty,

427
00:23:58,669 --> 00:24:02,654
pretty good and at this example of how
this company was already using some AI

428
00:24:02,654 --> 00:24:06,494
models and some stuff to have a level of.

429
00:24:07,019 --> 00:24:07,860
Self-healing.

430
00:24:08,360 --> 00:24:11,270
This was in 2024 now in or in 2025.

431
00:24:11,270 --> 00:24:16,610
So I believe that this model might be
bit outdated because now we have things

432
00:24:16,610 --> 00:24:21,680
like auto playwright side prompt and
mid scene that allow you to basically

433
00:24:21,680 --> 00:24:27,650
just use natural language to write your
tests and 'cause we're using natural

434
00:24:27,650 --> 00:24:30,055
language to write our tests obviously.

435
00:24:30,965 --> 00:24:33,575
These tests are going to be a bit slow
because you still have to go to the

436
00:24:33,580 --> 00:24:40,774
LLM or the VLM and do the thing that
you have to do, but if for some reason

437
00:24:40,774 --> 00:24:44,649
the logout button changes positions,
it's this test is still gonna pass.

438
00:24:45,260 --> 00:24:49,990
It'll recover because it will figure
out, okay, on the previous version,

439
00:24:49,990 --> 00:24:52,870
the wout button was here, but on this
new version, the Wout button is here.

440
00:24:52,870 --> 00:24:53,620
It's still there.

441
00:24:53,770 --> 00:24:56,500
So your test will find a way
to recover and still pass.

442
00:24:56,770 --> 00:25:01,450
So this is be the closest thing
that we have to self-healing.

443
00:25:01,480 --> 00:25:06,370
It's not fully self-healing because
you're still depending on the LLM or the

444
00:25:06,370 --> 00:25:08,850
VLM to do these things, but it's close.

445
00:25:09,239 --> 00:25:11,669
I'm not sure when we're gonna reach it.

446
00:25:12,090 --> 00:25:15,239
I'll leave that to future
Daniel, to present in a state

447
00:25:15,239 --> 00:25:17,789
of testing in 2027 or 2026.

448
00:25:17,850 --> 00:25:19,409
2028. We'll see.

449
00:25:20,009 --> 00:25:22,049
But I'm very interested
to see how this grows.

450
00:25:22,379 --> 00:25:24,899
And I was talking about LMS
and VMs because there's a

451
00:25:24,899 --> 00:25:25,685
difference when you are using.

452
00:25:26,429 --> 00:25:29,639
Each one of these models,
which are testing suite.

453
00:25:30,029 --> 00:25:34,649
So when integrate mid cinema to
integrate with GPT-4 four oh Gemini UI

454
00:25:35,340 --> 00:25:40,820
tars and UI tars is basically a point
where the model can make a difference

455
00:25:40,820 --> 00:25:42,500
because for you are not familiar.

456
00:25:42,500 --> 00:25:47,029
UI Tars BY is an open source
multi-model agent that's built upon.

457
00:25:47,414 --> 00:25:48,824
Vision language model.

458
00:25:48,824 --> 00:25:52,544
So it's a VLM that integrates
advanced reasoning and enabled

459
00:25:52,544 --> 00:25:53,924
my reinforcement learning.

460
00:25:54,494 --> 00:25:59,564
So when using EY Tars, you can use
target driven style prompts, like log

461
00:25:59,564 --> 00:26:01,904
in with username, fu, and password bar.

462
00:26:02,474 --> 00:26:05,804
Whilst using stuff like GPT, you
have to be more descrip descriptive.

463
00:26:05,984 --> 00:26:08,384
So it allows you to
basically in one prompt.

464
00:26:08,639 --> 00:26:12,449
Say what it needs to do and what the
VLM will do is take a screenshot of

465
00:26:12,449 --> 00:26:16,679
the page and then reason You can see
a thinking reason in the background

466
00:26:16,709 --> 00:26:19,830
until it figures out, okay, for a
week logging in, I need to find a

467
00:26:19,830 --> 00:26:23,610
username, I need to find a password,
and then I need to find a login button.

468
00:26:23,699 --> 00:26:27,299
And it will do that whilst when
using GPT you have to be more

469
00:26:27,299 --> 00:26:30,419
descriptive because basically what it
does, it takes a, it doesn't take a

470
00:26:30,419 --> 00:26:31,949
screenshot of the page, it gets you.

471
00:26:32,470 --> 00:26:35,860
Your representation of the dome,
how it works and passes it via the

472
00:26:35,905 --> 00:26:37,810
LLM because it's all text based.

473
00:26:38,350 --> 00:26:43,419
One thing that we noted though is
that GPT is better at generating

474
00:26:43,419 --> 00:26:48,220
assertions compared to a visual
language model, but visual angle

475
00:26:48,639 --> 00:26:52,210
language model like QI avatar, these
things are pretty, pretty good.

476
00:26:52,450 --> 00:26:53,745
They play doom better than I do.

477
00:26:54,245 --> 00:26:56,705
Yeah, that's a whole other discussion.

478
00:26:57,205 --> 00:27:02,084
So yeah, we started this talk looking
at the tools that we had and me

479
00:27:02,084 --> 00:27:05,864
asking a couple friends how they
were being used in the organization.

480
00:27:06,014 --> 00:27:11,494
And hopefully by now you'll have a
different overview of how they're

481
00:27:11,494 --> 00:27:14,134
being used and why we are using it.

482
00:27:14,764 --> 00:27:19,104
And I hope that your discussion
on why do we test in your.

483
00:27:19,494 --> 00:27:23,804
Prompt at the beginning might
change a bit during this talk.

484
00:27:23,954 --> 00:27:28,514
If not, let me recap everything
that we went to and hopefully by the

485
00:27:28,514 --> 00:27:30,374
end I'll be able to convince you.

486
00:27:31,214 --> 00:27:34,214
So the first point that I would like
to make is that everyone will keep

487
00:27:34,214 --> 00:27:35,414
doing their own things and everything.

488
00:27:35,414 --> 00:27:36,644
Different ways to test.

489
00:27:36,944 --> 00:27:38,774
That's the truth.

490
00:27:38,954 --> 00:27:39,884
It's like opinions.

491
00:27:39,884 --> 00:27:40,934
Everyone has their own.

492
00:27:41,024 --> 00:27:42,704
And the same thing happens with tests.

493
00:27:42,734 --> 00:27:44,114
Everyone will like to write tests.

494
00:27:44,114 --> 00:27:47,644
The way that they do, however, tools
like TypeScript and Slink are the

495
00:27:47,644 --> 00:27:49,954
best way to do static analysis.

496
00:27:50,254 --> 00:27:52,564
V test has brought the
shift in test runners.

497
00:27:52,564 --> 00:27:55,324
We were one expecting component.

498
00:27:55,324 --> 00:27:58,504
Testing is back, and it's
shifting us back to the browser.

499
00:27:59,434 --> 00:28:02,224
MSW is a de facto solution
for network mocking.

500
00:28:02,254 --> 00:28:05,734
Mocking, and end-to-end solutions
are pushing into a testing tool

501
00:28:05,734 --> 00:28:10,294
suite by having, giving you things
like API, accessibility, visual

502
00:28:10,294 --> 00:28:11,824
component, and end-to-end testing.

503
00:28:12,664 --> 00:28:13,744
And we're talking about ai.

504
00:28:14,049 --> 00:28:16,929
It won't fix your knowledge gap,
but it'll make you more productive.

505
00:28:17,319 --> 00:28:21,309
And AI testing might lead to
self-healing, but at the cost of speed.

506
00:28:21,849 --> 00:28:26,129
And finally, we should stop
considering tests second class

507
00:28:26,129 --> 00:28:30,059
citizens because they are as important
as you code that you're right.

508
00:28:30,329 --> 00:28:34,709
Heck, they're even more important because
they are the things that tell you that

509
00:28:34,739 --> 00:28:38,409
the business logic that you wrote is
actually doing what you expect it to do.

510
00:28:39,294 --> 00:28:42,114
It's the things that when stakeholders
come up to you and tell you,

511
00:28:42,114 --> 00:28:43,464
prove me that this is working.

512
00:28:43,824 --> 00:28:47,034
It's the point where you can point
the place where you can point at.

513
00:28:47,094 --> 00:28:50,034
It's the things that's gonna help you
make sure that there's not gonna be

514
00:28:50,034 --> 00:28:52,524
incidents, that your stuff is gonna
break in the middle of the night.

515
00:28:53,424 --> 00:28:57,594
So the next time that you're thinking,
oh, I ate testing, I don't have

516
00:28:57,594 --> 00:29:00,194
time to do this, think about this.

517
00:29:00,584 --> 00:29:03,764
'cause they are the ones that
actually give you the confidence.

518
00:29:03,824 --> 00:29:05,429
Confidence in way to
sleep better at night.

519
00:29:05,929 --> 00:29:07,249
So yeah, everyone mi that.

520
00:29:08,059 --> 00:29:10,159
Thank you so much for having me.

521
00:29:10,549 --> 00:29:12,889
This was a huge pleasure to be here.

522
00:29:13,009 --> 00:29:15,559
And yeah, you will, if you want to
connect with me, you can scan this

523
00:29:15,559 --> 00:29:18,499
care code or find me pretty much
anywhere at Daniel Jesse phones.

524
00:29:18,799 --> 00:29:21,349
This was the 2025 state
of JavaScript testing.

525
00:29:21,919 --> 00:29:22,579
Thank you everyone.

526
00:29:22,639 --> 00:29:23,359
I'll see you around.

527
00:29:23,839 --> 00:29:24,229
Bye.

