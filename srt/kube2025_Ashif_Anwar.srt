1
00:00:00,500 --> 00:00:02,929
Hello everyone, and thank
you for joining me today.

2
00:00:03,380 --> 00:00:07,609
My name is Asif Anwar and I serve as a
principal engineer at Walter Stewart.

3
00:00:08,180 --> 00:00:12,020
My background, I hold a master's
degree in information technology

4
00:00:12,230 --> 00:00:15,530
with a specialization in software
engineering from Illinois

5
00:00:15,530 --> 00:00:17,180
Institute of Technology, Chicago.

6
00:00:17,750 --> 00:00:22,160
Over the course of my career, I have
gained extensive experience as a

7
00:00:22,160 --> 00:00:26,389
software engineer with a focus on
building cloud native applications

8
00:00:26,720 --> 00:00:28,729
and architecting event driven systems.

9
00:00:29,150 --> 00:00:32,990
I'm passionate about designing
scalable, resilient solutions that

10
00:00:32,990 --> 00:00:37,100
leverage modern cloud technologies,
and I look forward to sharing some

11
00:00:37,100 --> 00:00:38,540
of these insights with you today.

12
00:00:39,040 --> 00:00:44,169
I'm excited to share how we can
scale Kubernetes native system

13
00:00:44,260 --> 00:00:46,480
using even driven patterns on Azure.

14
00:00:46,779 --> 00:00:48,970
You might be wondering why this matters.

15
00:00:49,825 --> 00:00:52,495
Our world is moving faster than ever.

16
00:00:52,825 --> 00:00:57,835
Customer expects instant response
system must scale on demand and

17
00:00:57,835 --> 00:00:59,725
downtime is no longer an option.

18
00:01:00,265 --> 00:01:04,495
Today we will explore how combining
Kubernetes with event driven

19
00:01:04,555 --> 00:01:07,015
architecture help us meet these demands.

20
00:01:07,705 --> 00:01:12,145
We'll examine our real world case study,
how we built a fraud detection system

21
00:01:12,205 --> 00:01:14,634
that responds in unjust under two seconds.

22
00:01:15,310 --> 00:01:18,639
By the end of this session, you
will understand not only the

23
00:01:18,639 --> 00:01:22,660
underlying principles, but how to
apply them in your own environment.

24
00:01:23,160 --> 00:01:27,119
Let's start with the imperative of
cloud native and event driven systems.

25
00:01:27,809 --> 00:01:33,140
In today's landscape, agility,
fault tolerance aren't

26
00:01:33,140 --> 00:01:34,580
just nice to have features.

27
00:01:34,940 --> 00:01:36,679
They are pretty much non-negotiable.

28
00:01:37,115 --> 00:01:41,795
Customer expects a seamless
experience, real time responsiveness,

29
00:01:41,914 --> 00:01:45,274
and they won't tolerate any
outages of service performance.

30
00:01:46,024 --> 00:01:50,464
Unfortunately, traditional monolithic
architecture make it hard to keep it up.

31
00:01:51,035 --> 00:01:51,755
They are rigid.

32
00:01:52,175 --> 00:01:57,785
Scaling is course grade and any change
or failure risk taking down the whole

33
00:01:57,789 --> 00:02:02,735
systems here is what, why Kubernetes
steps in to address these pain points.

34
00:02:03,259 --> 00:02:08,300
By orchestrating containers, Kubernetes
provides a self-healing, automatic

35
00:02:08,300 --> 00:02:10,310
scaling and service abstraction.

36
00:02:10,729 --> 00:02:15,110
This means we can deploy microservices
independently, recover from

37
00:02:15,110 --> 00:02:20,169
failure automatically, and scale
individual services based on demand.

38
00:02:20,829 --> 00:02:22,989
But Kubernetes isn't just a silver bullet.

39
00:02:23,259 --> 00:02:27,699
It's primarily an infrastructure
and an orchestration layer to

40
00:02:27,729 --> 00:02:31,389
achieve the real time agility
that modern applications require.

41
00:02:31,825 --> 00:02:34,164
We need to embrace event driven patterns.

42
00:02:34,795 --> 00:02:38,804
In essence, Kubernetes gives
us the foundation, but events

43
00:02:39,105 --> 00:02:41,054
makes the foundation come alive.

44
00:02:41,554 --> 00:02:44,554
Why focus on event driven architecture?

45
00:02:45,484 --> 00:02:49,054
Because it changes how
services communicate and scale

46
00:02:49,474 --> 00:02:51,064
in an event driven model.

47
00:02:51,364 --> 00:02:53,075
Services are loosely coupled.

48
00:02:53,314 --> 00:02:55,730
They communicate all
synchronously through events.

49
00:02:56,230 --> 00:02:59,230
Imagine sending a letter
versus making a phone call.

50
00:02:59,560 --> 00:03:04,150
You dispatch the letter and move on with
your day instead of waiting on the line.

51
00:03:04,810 --> 00:03:09,700
This decoupling reduces dependencies
and make systems easier to maintain.

52
00:03:10,200 --> 00:03:15,719
Even driven architecture also enables
scalability, workload expand and contract

53
00:03:15,719 --> 00:03:17,850
naturally with the flow of events.

54
00:03:18,179 --> 00:03:22,350
If your traffic spikes during
a scale or a news event.

55
00:03:22,799 --> 00:03:26,399
Your system scales up to meet
the demand and then scales back

56
00:03:26,399 --> 00:03:27,839
down when the rush is over.

57
00:03:28,289 --> 00:03:33,509
Resiliency is another benefit
by isolating components.

58
00:03:33,899 --> 00:03:36,749
Even driven architecture
prevents cascading failures.

59
00:03:37,169 --> 00:03:41,759
If one service goes down, the rest
of the system keeps it running, and

60
00:03:41,759 --> 00:03:47,024
perhaps most importantly, event driven
system enable real time interactions.

61
00:03:47,715 --> 00:03:49,515
Services response to events.

62
00:03:49,515 --> 00:03:52,665
The moment they occur, there
is no polling or waiting.

63
00:03:53,234 --> 00:03:57,345
In an event driven mindset events
are its first class citizens.

64
00:03:58,304 --> 00:04:03,075
Instead of building a web of
synchronous API calls, we build a

65
00:04:03,075 --> 00:04:07,300
network of listeners that respond
when something meaningful happens.

66
00:04:07,800 --> 00:04:12,839
To implement event driven architecture
effectively, we need the right tools.

67
00:04:13,334 --> 00:04:17,564
Microsoft Azure provides a
comprehensive event driven toolkit.

68
00:04:18,434 --> 00:04:20,469
The first piece is event rate.

69
00:04:20,979 --> 00:04:27,374
It's a hyperscale event routing service
that filters routes and deliver events to

70
00:04:27,374 --> 00:04:30,164
subscriber with near real time latency.

71
00:04:31,034 --> 00:04:35,564
Then there is a service bus message
broker that offers enterprise grade

72
00:04:35,564 --> 00:04:41,164
durability and first, first out ordering
if an even grid is the nervous system.

73
00:04:41,750 --> 00:04:45,469
Service bus is the circulatory
system that reliably transport

74
00:04:45,469 --> 00:04:46,909
message across the body.

75
00:04:47,409 --> 00:04:51,699
The third component is Azure
function, which gives us serverless

76
00:04:51,699 --> 00:04:56,919
compute to handle events on demand
function, scale automatically and

77
00:04:56,919 --> 00:04:59,229
charge only for what you consume.

78
00:04:59,950 --> 00:05:03,789
Finally, Azure Kubernetes
Services, which is a KS.

79
00:05:04,284 --> 00:05:09,744
Ties everything together by orchestrating
containers and integrating natively

80
00:05:09,744 --> 00:05:11,244
with this messaging services.

81
00:05:11,874 --> 00:05:16,224
What is remarkable is that these
services work seamlessly together.

82
00:05:16,614 --> 00:05:21,264
There is no need to stitch together
disparate open source com components.

83
00:05:21,775 --> 00:05:25,614
Azure provides an integrated
ecosystem that speeds sub

84
00:05:25,614 --> 00:05:27,954
development and increase reliability.

85
00:05:28,454 --> 00:05:31,289
Let's dig a bit deeper into event rate.

86
00:05:31,789 --> 00:05:36,669
At its core, even Grid is a highly
scalable published subscribed

87
00:05:36,669 --> 00:05:38,260
service, which is a pub sub model.

88
00:05:38,919 --> 00:05:42,909
It supports massive fanout
delivering events to many

89
00:05:42,909 --> 00:05:45,489
subscriber with real time latency.

90
00:05:45,989 --> 00:05:50,429
Advanced filtering lets you route events
based on attributes such as subject

91
00:05:50,609 --> 00:05:55,919
type or even custom metadata Built
in retype policies and dead lettering

92
00:05:55,919 --> 00:05:58,169
handle transient failure automatically.

93
00:05:58,995 --> 00:06:03,075
You can think of event data as a central
nervous system of your architecture.

94
00:06:03,735 --> 00:06:07,395
It routes millions of events
per second across your services

95
00:06:08,235 --> 00:06:12,765
performance skills to handle millions
of events with Subsecond delivery.

96
00:06:13,455 --> 00:06:18,135
This makes it ideal for scenarios
like IOT Telemetry where thousands of

97
00:06:18,135 --> 00:06:23,025
sensors produced data simultaneously,
or from micro based architecture

98
00:06:23,025 --> 00:06:26,115
where many components need to
interact with the same event.

99
00:06:26,615 --> 00:06:28,355
Now let's look at service bus.

100
00:06:28,865 --> 00:06:33,605
When even grid excels at high
volume broadcast service bus focus

101
00:06:33,605 --> 00:06:35,375
on reliable message delivery.

102
00:06:36,305 --> 00:06:41,045
It provides you with cues and topics
with guaranteed persistence, so message

103
00:06:41,045 --> 00:06:43,474
aren't lost even if a consumer is offline.

104
00:06:44,075 --> 00:06:48,784
Service bus supports sessions to
preserve fast first out order, which

105
00:06:48,784 --> 00:06:53,525
is essential when your business logic
depends on processing events in sequence.

106
00:06:54,025 --> 00:06:56,125
Error handling is another key feature.

107
00:06:56,635 --> 00:07:01,284
Dead letter queues captures message
that can't be delivered, allowing you

108
00:07:01,284 --> 00:07:03,685
to analyze and reprocess them later.

109
00:07:04,164 --> 00:07:07,705
This is critical in industries
where audit trails and message

110
00:07:07,705 --> 00:07:09,385
durability are mandatory.

111
00:07:09,985 --> 00:07:13,945
For example, consider a very
high value financial transaction.

112
00:07:14,635 --> 00:07:18,985
If a message is lost or processed out
of order, the consequence would be.

113
00:07:19,485 --> 00:07:23,415
Service bus is the one which
ensures that this never happens.

114
00:07:23,915 --> 00:07:29,105
So how do we execute code
when these events arrive?

115
00:07:29,945 --> 00:07:32,345
This is where Azure functions come in.

116
00:07:33,155 --> 00:07:36,605
Functions are serverless
units of execution.

117
00:07:37,205 --> 00:07:39,455
They react to a variety of triggers.

118
00:07:40,025 --> 00:07:45,335
Event grid service bus, rest
based HTTP block storage and more.

119
00:07:45,815 --> 00:07:49,715
They automatically scale from
zero to thousandths of concurrent

120
00:07:49,715 --> 00:07:54,815
execution, and you only pay for
the resource you consume functions.

121
00:07:54,815 --> 00:07:58,115
They really shine at lightweight
transformations and orchestration.

122
00:07:58,595 --> 00:08:03,990
You can enrich and even filter, transform
it, publish it to another service.

123
00:08:04,730 --> 00:08:09,380
They are perfect for rusty workloads
or glue logic that connects

124
00:08:09,380 --> 00:08:11,240
different parts of your architecture.

125
00:08:11,870 --> 00:08:17,360
In other words, functions are reactive
glue that holds your pipeline together.

126
00:08:17,860 --> 00:08:20,620
Now let's look at some of the
architectural patterns with

127
00:08:20,680 --> 00:08:22,000
event driven architecture.

128
00:08:22,510 --> 00:08:24,100
It is not just about tools.

129
00:08:24,430 --> 00:08:26,560
It is about using the right patterns.

130
00:08:27,060 --> 00:08:30,750
Azure supports several reusable
architecture pattern that help

131
00:08:30,750 --> 00:08:32,460
manage complexity at scale.

132
00:08:32,960 --> 00:08:33,980
This is my favorite.

133
00:08:34,220 --> 00:08:37,789
The first is CQRS, which
stands for Command Quality

134
00:08:37,789 --> 00:08:39,260
Responsibility Segregation.

135
00:08:40,130 --> 00:08:44,990
With CQRS, you can separate read and
write operations into different models.

136
00:08:45,560 --> 00:08:50,360
For example, in an e-commerce
site you write such as placing

137
00:08:50,360 --> 00:08:54,710
orders, updating an inventory can
be fast and eventually consistent.

138
00:08:55,250 --> 00:08:59,060
Separating them optimizes
performance and scalability.

139
00:08:59,840 --> 00:09:02,510
The second pattern is event sourcing.

140
00:09:03,110 --> 00:09:08,000
Instead of storing the latest state
of an object, you store the sequence

141
00:09:08,000 --> 00:09:09,890
of events that led to that state.

142
00:09:10,340 --> 00:09:14,390
This approach provides a complete
audit trail and allow you to

143
00:09:14,390 --> 00:09:16,400
reconstruct any past state.

144
00:09:17,360 --> 00:09:21,650
Then there is a pattern saga,
basically coordinates complex business

145
00:09:21,650 --> 00:09:23,390
transactions across multiple services.

146
00:09:23,890 --> 00:09:29,170
Imagine booking a trip or you need to book
your flight, you need to book hotel, and

147
00:09:29,170 --> 00:09:31,750
you need to rent a car, a saga pattern.

148
00:09:31,750 --> 00:09:36,730
Ensure that if any of these step fails,
the previous steps are compensated.

149
00:09:37,360 --> 00:09:39,730
Let's say for an example,
your flight is canceled.

150
00:09:40,230 --> 00:09:43,825
Finally balance between
choreography and orchestration.

151
00:09:44,440 --> 00:09:49,330
In a choreographic system, services
reacts to events independently, which

152
00:09:49,330 --> 00:09:52,630
promotes autonomy in orchestrated systems.

153
00:09:52,780 --> 00:09:56,230
A central controls tells
service what to do.

154
00:09:56,770 --> 00:10:01,315
Finding the right balance improves
coordination without creating a bottleneck

155
00:10:01,815 --> 00:10:05,535
to see how these patterns come
together, let's examine a real

156
00:10:05,535 --> 00:10:07,005
time fraud detection case.

157
00:10:07,505 --> 00:10:12,575
Fraudulent transactions cost financial
institution billions of dollars every year

158
00:10:12,905 --> 00:10:15,515
in direct losses and regulated penalties.

159
00:10:16,265 --> 00:10:21,425
Legacy fraud detection systems often
took minutes or even hours to identify

160
00:10:21,425 --> 00:10:26,915
suspicious activity, far too slow when
criminals can exploit weakness in seconds.

161
00:10:27,635 --> 00:10:33,095
The goal was ambitious, reduce
detection time to under two seconds

162
00:10:33,155 --> 00:10:35,345
while achieving 95% accu accuracy.

163
00:10:35,845 --> 00:10:40,795
Meeting this goal would not
only protect customers, but also

164
00:10:40,795 --> 00:10:45,565
transform fraud detection from a
reactive process to a proactive one.

165
00:10:46,065 --> 00:10:49,275
Here is how we built the system in Azure.

166
00:10:49,725 --> 00:10:54,795
First, every transaction generated
in our payment services running

167
00:10:54,795 --> 00:10:56,715
on Azure Kubernetes services.

168
00:10:57,405 --> 00:10:58,155
It's an event.

169
00:10:58,515 --> 00:11:02,625
The event goes into an event grid,
which immediately routes it to a

170
00:11:02,625 --> 00:11:05,085
service bus for reliable ordering.

171
00:11:05,085 --> 00:11:05,655
Processing.

172
00:11:06,315 --> 00:11:11,295
A dedicated Azure function wakes up
and enrich the data with customer

173
00:11:11,295 --> 00:11:13,755
history and contextual information.

174
00:11:14,295 --> 00:11:17,895
The enriched event is then passed
to a machine learning model

175
00:11:18,435 --> 00:11:21,585
running in GPU, packed a KS pods.

176
00:11:22,395 --> 00:11:27,165
The model evaluates the transaction and
returns a fraud score within milliseconds.

177
00:11:27,675 --> 00:11:33,285
The final Azure function interprets
the score and makes a real time

178
00:11:33,285 --> 00:11:38,595
decision, approve the transaction,
reject the transaction, or flag the

179
00:11:38,595 --> 00:11:43,515
transaction for review, delivering
a response in under two seconds.

180
00:11:44,295 --> 00:11:48,645
What makes this architecture
elegant is how each Azure

181
00:11:49,095 --> 00:11:50,865
service plays a distinct role.

182
00:11:51,585 --> 00:11:54,915
Event grid dispatches event instantly.

183
00:11:55,485 --> 00:12:00,825
Service bus guarantees the order
of transactions, functions handle

184
00:12:00,825 --> 00:12:02,445
enrichment and orchestration.

185
00:12:03,165 --> 00:12:08,175
Azure Kubernetes Services a KS
runs the resource intensive machine

186
00:12:08,175 --> 00:12:12,945
learning provider models, thus
providing the compute together.

187
00:12:12,945 --> 00:12:16,860
They form a pipeline that
captures every transaction.

188
00:12:17,505 --> 00:12:22,395
And reaches it, evaluates it,
and responds at all cloud scale.

189
00:12:22,895 --> 00:12:26,855
During implementation, we
had to plan for the worst.

190
00:12:27,695 --> 00:12:30,665
Think of it as a Black Friday
when transaction volumes

191
00:12:30,665 --> 00:12:32,135
spike down dramatically.

192
00:12:33,005 --> 00:12:37,445
Even grid, it can handle millions of
events per second, so it doesn't become

193
00:12:37,445 --> 00:12:39,455
a bottleneck during those peak hours.

194
00:12:39,995 --> 00:12:43,925
Service bus provides automatic
retries and dead lettering queues,

195
00:12:43,955 --> 00:12:48,095
ensuring that zero messages are lost
even if something has gone wrong.

196
00:12:48,695 --> 00:12:54,215
Azure function scale instantaneously from
zero to thousand of concurrent executions.

197
00:12:54,755 --> 00:13:01,265
Meanwhile, the machine learning model
run on GPU backed Kubernetes part that

198
00:13:01,265 --> 00:13:03,335
scale horizontally to meet demand.

199
00:13:04,085 --> 00:13:04,775
What was the result?

200
00:13:05,275 --> 00:13:07,120
Through elastic scalability.

201
00:13:07,620 --> 00:13:14,400
During peak shopping periods such as Black
Friday or any other weekend festival, the

202
00:13:14,400 --> 00:13:19,950
system processed millions of simultaneous
transactions without any downtime and

203
00:13:19,950 --> 00:13:22,080
maintained sub two second response time.

204
00:13:22,710 --> 00:13:27,510
This is the power of even driven patterns
when it combined with Kubernetes.

205
00:13:28,010 --> 00:13:29,480
So what did we achieve?

206
00:13:29,885 --> 00:13:34,475
We reduced the average response time
from minutes to under two seconds,

207
00:13:34,775 --> 00:13:38,375
which means suspicious transactions
are flagged almost immediately.

208
00:13:38,855 --> 00:13:44,495
We also call cut false positive by
15%, improving the customer experience.

209
00:13:45,155 --> 00:13:48,935
The system achieved a hundred
percent uptime during peak periods,

210
00:13:49,355 --> 00:13:53,705
meaning no outages or degraded
performance beyond this metrics.

211
00:13:54,695 --> 00:13:59,345
It also gained full observability
with correlation ID that trace

212
00:13:59,405 --> 00:14:03,995
each event through the system,
reduced operational overhead through

213
00:14:04,085 --> 00:14:08,855
automation, improved compliance by
maintaining comprehensive auditors.

214
00:14:09,545 --> 00:14:14,855
All of these benefits translated directly
into cost setting, increased customer

215
00:14:14,885 --> 00:14:17,885
trust and competitive edge in the market.

216
00:14:18,385 --> 00:14:21,625
So what did we learn from
building this system?

217
00:14:22,045 --> 00:14:26,845
We learned some important lesson that
apply to any event driven architecture.

218
00:14:27,625 --> 00:14:31,465
First design item, potent flows.

219
00:14:32,455 --> 00:14:37,645
Your handler should produce the same
result, even if they are processed

220
00:14:37,645 --> 00:14:39,235
the same event more than once.

221
00:14:39,895 --> 00:14:41,330
This prevent duplicate charges.

222
00:14:42,150 --> 00:14:44,290
Ensure consistency using retries.

223
00:14:45,085 --> 00:14:47,575
Second plan for schema evolution.

224
00:14:48,025 --> 00:14:53,095
Use semantic versioning for
your events so consumers can

225
00:14:53,095 --> 00:14:55,495
handle both old and new version.

226
00:14:56,035 --> 00:14:59,395
Third, always include correlation IDs.

227
00:15:00,205 --> 00:15:03,595
They are essential for
debugging and tracing events

228
00:15:03,595 --> 00:15:05,005
through distributed systems.

229
00:15:05,845 --> 00:15:12,350
Finally, implementable strong security
pipeline, leveraging managed identities

230
00:15:12,475 --> 00:15:15,115
and role based access controls from the.

231
00:15:15,730 --> 00:15:20,650
Azure Ensure service communicates
securely without hardcore credentials.

232
00:15:21,190 --> 00:15:23,950
These elections aren't
specific to finance.

233
00:15:24,370 --> 00:15:30,310
They apply across any industry that
requires scalable, reliable event

234
00:15:30,310 --> 00:15:33,780
processing systems, even driven patterns.

235
00:15:33,960 --> 00:15:39,125
They unjust limited to fraud
detection or even finance industries.

236
00:15:39,860 --> 00:15:45,170
In healthcare event driven telemetry
monitors patient vitals in real time.

237
00:15:45,800 --> 00:15:51,800
Systems can achieve 99% of time and
trigger instant alerts when readings

238
00:15:51,800 --> 00:15:57,560
deactivate from safe range in retail or
synchronous inventory synchronization

239
00:15:57,950 --> 00:16:04,130
across multiple stores, reduce lag
by 85%, and prevents talk outs during

240
00:16:04,130 --> 00:16:07,700
sales in insurance, automated claims.

241
00:16:08,510 --> 00:16:12,830
Adjudication combines document
processing with fraud detection

242
00:16:12,920 --> 00:16:14,270
to speed up reimbursement.

243
00:16:15,020 --> 00:16:19,340
These examples demonstrate the
versatility of event driven

244
00:16:19,340 --> 00:16:22,460
architecture across drivers industries.

245
00:16:22,960 --> 00:16:27,870
Now, as we near to end of our journey,
let me summarize the key messages.

246
00:16:28,650 --> 00:16:33,810
Event driven patterns combined with
Kubernetes deliver scalable, resilient,

247
00:16:33,900 --> 00:16:36,510
and efficient systems at enterprise scale.

248
00:16:37,260 --> 00:16:43,590
Microsoft Azure provides a comprehensive
toolkit, event grade service bus, Azure

249
00:16:43,680 --> 00:16:49,380
function, and Azure Kubernetes services,
which is KKS, that lets you build event

250
00:16:49,380 --> 00:16:52,020
driven systems without the glue code.

251
00:16:52,520 --> 00:16:58,220
Fraud detection case study shows real
world value sub two second latency,

252
00:16:58,460 --> 00:17:03,380
zero zone downtime, and improved
accuracy and success in healthcare,

253
00:17:03,440 --> 00:17:09,020
retail, and insurance prove the broad
applicability of these patterns.

254
00:17:09,950 --> 00:17:14,930
Importantly, even driven architecture
isn't just a theoretical, it is

255
00:17:14,930 --> 00:17:19,685
battle tested in production, handling
millions of transactions every day.

256
00:17:20,480 --> 00:17:21,860
So what's next?

257
00:17:22,460 --> 00:17:27,560
If you have a legacy system, consider
modernizing them with event driven design.

258
00:17:28,130 --> 00:17:32,630
If you're building a new microservices,
start with events and choose services

259
00:17:32,630 --> 00:17:36,890
like event grid, service bus and
serverless compute, like Azure function.

260
00:17:37,490 --> 00:17:40,790
The sooner you adopt these
patterns, the faster you will

261
00:17:40,790 --> 00:17:42,265
reap the benefits of real time.

262
00:17:42,765 --> 00:17:44,835
Thank you for your time and attention.

263
00:17:44,985 --> 00:17:49,335
I hope you have a clear understanding
of how Kubernetes and event driven

264
00:17:49,335 --> 00:17:52,095
architecture can transform your systems.

265
00:17:52,545 --> 00:17:56,535
I'm happy to answer any question
or discuss how these concepts

266
00:17:56,805 --> 00:17:58,365
apply to your organization.

267
00:17:58,725 --> 00:18:00,165
Thank you so much for your time today.

