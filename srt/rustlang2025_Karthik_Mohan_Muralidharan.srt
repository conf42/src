1
00:00:00,500 --> 00:00:01,280
Hello everyone.

2
00:00:01,369 --> 00:00:02,929
My name is Karthik Mohan.

3
00:00:03,429 --> 00:00:04,629
You can call me Karthik.

4
00:00:05,410 --> 00:00:09,789
I'm a software engineer with eight
years of experience specializing in

5
00:00:09,849 --> 00:00:13,369
building and integrating complex systems.

6
00:00:13,909 --> 00:00:16,504
My work is focused on
the Salesforce platform.

7
00:00:17,074 --> 00:00:21,364
And cloud data solutions like
Google BigQuery with an expertise in

8
00:00:21,364 --> 00:00:26,634
crafting everything from the intuitive
user interface down to the robust

9
00:00:26,634 --> 00:00:28,705
backend architecture that powers it.

10
00:00:29,205 --> 00:00:32,985
Today I want to talk about a
fundamental shift happening in

11
00:00:32,985 --> 00:00:35,205
how we build enterprise systems.

12
00:00:36,000 --> 00:00:40,110
We are moving away from a world where
everything happens in the cloud towards

13
00:00:40,110 --> 00:00:43,650
a more balanced and hybrid approach.

14
00:00:44,150 --> 00:00:47,690
My goal for this session is to
explore how we can effectively

15
00:00:47,690 --> 00:00:52,880
bridge the growing divide between
edge computing and the cloud.

16
00:00:53,380 --> 00:00:56,230
We'll look at two powerful
orchestration methods.

17
00:00:56,905 --> 00:01:03,745
Patterns that will solve real world
problems and show how rust programming

18
00:01:03,745 --> 00:01:08,485
language provides the perfect foundation
for these modern realtime systems.

19
00:01:09,475 --> 00:01:13,615
By the end, I hope you'll have a clear,
practical roadmap for implementing

20
00:01:13,615 --> 00:01:15,535
these ideas in your own organizations.

21
00:01:16,035 --> 00:01:19,345
Okay, here's a quick look at our
journey for the next few minutes.

22
00:01:20,050 --> 00:01:25,090
First we'll set the stage by digging into
the specific problems with traditional

23
00:01:25,600 --> 00:01:29,620
cloud only architectures, especially
when it comes to real time applications.

24
00:01:30,120 --> 00:01:34,530
Next, we'll dive into the core of
the presentation to transformative

25
00:01:34,840 --> 00:01:36,160
orchestration patterns.

26
00:01:36,670 --> 00:01:37,390
Those are.

27
00:01:37,890 --> 00:01:42,660
The edge inference, cloud remediation
pattern, and the cloud insight,

28
00:01:42,750 --> 00:01:44,310
edge reconfiguration pattern.

29
00:01:44,810 --> 00:01:46,670
Then we'll talk about the why.

30
00:01:47,180 --> 00:01:50,300
Why is rust such a game
changer for edge computing?

31
00:01:50,800 --> 00:01:55,030
We'll touch on its key features
like memory safety and what

32
00:01:55,570 --> 00:01:58,900
fearless concurrency actually
means for us as developers.

33
00:01:59,400 --> 00:02:02,350
Of course every project
has its own huddles.

34
00:02:02,960 --> 00:02:07,330
We'll honestly discuss the big
implementation challenges like managing

35
00:02:07,330 --> 00:02:12,400
distributed state and security, and
the solutions we found to be effective.

36
00:02:12,900 --> 00:02:14,610
Now let's start with the core problem.

37
00:02:15,210 --> 00:02:19,630
As we deploy more and more IOT
devices in our factories our stores

38
00:02:19,630 --> 00:02:23,470
or cities, we are pushing up against
the natural limits of what a purely

39
00:02:23,530 --> 00:02:25,480
cloud-centric model can handle.

40
00:02:25,720 --> 00:02:29,340
This creates some challenges,
the three major challenges.

41
00:02:29,840 --> 00:02:32,045
The first one is latency, right?

42
00:02:32,045 --> 00:02:39,605
So for many real time applications like a
robot or a medical monitoring device, the

43
00:02:39,605 --> 00:02:45,219
roundtrip time to a distance cloud server
is simply too long, even though it might

44
00:02:45,219 --> 00:02:47,799
be just a hundred to 200 milliseconds.

45
00:02:48,279 --> 00:02:53,140
That is also too long to wait
for a decision when we need a

46
00:02:53,140 --> 00:02:57,609
decision to be made in, let's
say, less than 20 milliseconds.

47
00:02:58,019 --> 00:03:03,669
The second problem is, the bandwidth
the sheer volume of data from thousands

48
00:03:03,669 --> 00:03:05,519
of sensors can be overwhelming.

49
00:03:06,239 --> 00:03:09,329
Trying to stream everything to
the cloud 24 by seven creates a

50
00:03:09,329 --> 00:03:13,169
massive network congestion and
can lead to astronomical costs.

51
00:03:13,669 --> 00:03:15,699
Finally, there's one more challenge.

52
00:03:15,699 --> 00:03:16,839
That's the availability.

53
00:03:17,579 --> 00:03:22,319
If your critical operations are entirely
dependent on a stable internet connection

54
00:03:22,839 --> 00:03:24,554
you are creating a huge point of failure.

55
00:03:25,519 --> 00:03:28,579
Your edge systems needs to
keep functioning even when the

56
00:03:28,579 --> 00:03:30,049
cloud connectivity is lost.

57
00:03:30,549 --> 00:03:35,269
So these challenges make it clear that
the future isn't about choosing an

58
00:03:35,269 --> 00:03:37,279
edge system or a cloud architecture.

59
00:03:37,429 --> 00:03:40,159
It's about making them work
together intelligently.

60
00:03:40,659 --> 00:03:45,204
Okay, now let's talk
about our first solution.

61
00:03:45,704 --> 00:03:49,815
This is a pattern called edge
inference Cloud remediation.

62
00:03:50,694 --> 00:03:54,384
This pattern fundamentally flips
the traditional data processing

63
00:03:54,384 --> 00:03:56,664
model, and here's how it works.

64
00:03:57,174 --> 00:04:01,424
Instead of sending the raw data to the
cloud we perform the initial analysis

65
00:04:01,424 --> 00:04:03,014
right where the data is created.

66
00:04:03,434 --> 00:04:04,124
On the edge.

67
00:04:04,634 --> 00:04:08,374
We deploy like lightweight,
efficient machine learning models

68
00:04:08,374 --> 00:04:09,964
onto the edge devices themselves.

69
00:04:10,464 --> 00:04:15,084
These models can make immediate
realtime decisions only the results

70
00:04:15,134 --> 00:04:19,244
the important insights or anomalies
or exceptions are sent to the cloud.

71
00:04:19,744 --> 00:04:25,324
The cloud can then perform more
sophisticated analysis and decide if a

72
00:04:25,404 --> 00:04:27,804
larger remediation action is required.

73
00:04:28,354 --> 00:04:32,085
Let's say dispatching a technician
or triggering a workflow right?

74
00:04:32,979 --> 00:04:36,940
The benefits of this is instantaneous.

75
00:04:36,969 --> 00:04:40,900
Like you dramatically reduce the
latency for critical decisions.

76
00:04:41,629 --> 00:04:46,249
The bandwidth needs are reduced
and a more reliable system is

77
00:04:46,254 --> 00:04:51,859
built without crippling the without
being crippled by network outages.

78
00:04:52,359 --> 00:04:56,880
This type of pattern is ideal for
industries such as manufacturing,

79
00:04:57,179 --> 00:05:01,989
predictive maintenance, and
essentially any scenario where local

80
00:05:02,229 --> 00:05:05,559
realtime responsiveness is necessary.

81
00:05:06,059 --> 00:05:09,029
Okay, now let's go to the next one.

82
00:05:09,719 --> 00:05:11,789
Now the second, pattern.

83
00:05:12,259 --> 00:05:15,109
This pattern solves a completely
different kind of problem.

84
00:05:15,609 --> 00:05:19,519
If the first pattern was
about local autonomy.

85
00:05:20,299 --> 00:05:22,829
This one it's called Cloud Insight.

86
00:05:22,859 --> 00:05:24,269
Edge reconfiguration.

87
00:05:24,929 --> 00:05:29,079
It's all about creating a system
wide continuous learning loop.

88
00:05:29,579 --> 00:05:30,719
So here's the flow.

89
00:05:30,859 --> 00:05:35,129
The cloud analytics platform aggregates
the data from your, entire fleet

90
00:05:35,129 --> 00:05:41,349
of edge devices that gives, so this
gives like a bird's eye view that

91
00:05:41,349 --> 00:05:43,929
no single device possesses right.

92
00:05:44,719 --> 00:05:50,619
From there machine learning models
generates like needed insights and it also

93
00:05:50,619 --> 00:05:56,589
identifies like optimization opportunities
that are only visible and all the

94
00:05:56,589 --> 00:05:58,329
data is present or visible at scale.

95
00:05:58,829 --> 00:06:04,109
These insights are then translated
into specific policy generations

96
00:06:04,179 --> 00:06:08,709
new rules or configurations that
are tailored for the individual

97
00:06:08,709 --> 00:06:10,689
devices or the group of devices.

98
00:06:10,929 --> 00:06:15,549
Finally, in the edge configuration
step, these new policies are pushed

99
00:06:15,549 --> 00:06:18,949
down to the devices which update
their local operations on the flight.

100
00:06:19,449 --> 00:06:24,229
Examples of this can be anything from
adjusting a price in a retail store to

101
00:06:24,229 --> 00:06:26,709
chaining the timing of a traffic light.

102
00:06:27,399 --> 00:06:30,749
It's a powerful feedback loop
when centralized intelligence

103
00:06:30,749 --> 00:06:32,999
drives distributed execution.

104
00:06:33,499 --> 00:06:35,474
Okay let's go to the next slide.

105
00:06:35,974 --> 00:06:36,304
Okay.

106
00:06:36,364 --> 00:06:38,134
Now let's talk about rust.

107
00:06:38,634 --> 00:06:44,974
So Rust is the technology that makes
these demanding patterns possible.

108
00:06:45,474 --> 00:06:50,614
Now, this choice of language
is also a strategic one because

109
00:06:51,004 --> 00:06:52,774
there are many advantages of rust.

110
00:06:53,144 --> 00:06:56,774
For example, rust provides
memory safety without the

111
00:06:56,804 --> 00:06:58,364
overhead of a garbage collector.

112
00:06:58,864 --> 00:07:02,374
This is like the holy grail
for embedded and IT systems.

113
00:07:02,614 --> 00:07:07,444
It eliminates entire classes of
bugs and security vulnerabilities at

114
00:07:07,444 --> 00:07:12,914
compiling without the unpredictable
performances Pauses that garbage

115
00:07:12,914 --> 00:07:14,774
collect collection can introduce.

116
00:07:15,274 --> 00:07:19,659
Second is fearless concurrency
edge devices are always

117
00:07:19,659 --> 00:07:20,229
juggling multiple tasks.

118
00:07:20,729 --> 00:07:26,349
So rusts compiler guarantees that you
don't have any data races which are

119
00:07:26,439 --> 00:07:28,839
notoriously difficult bugs to track down.

120
00:07:29,339 --> 00:07:34,399
This allows us to write highly
parallel code with confidence.

121
00:07:34,899 --> 00:07:37,579
Third rusts absolutely fantastic.

122
00:07:37,579 --> 00:07:41,039
Cross platform compilation
lets us write our logic.

123
00:07:41,429 --> 00:07:48,389
Once and deployed across the diverse
hardware landscape of the edge from

124
00:07:48,389 --> 00:07:54,269
the tiny a RM based sensors to the
powerful X 86 industrial computers.

125
00:07:54,769 --> 00:08:03,329
Finally, rust has what is called zero
cost abstractions, which is like a fancy

126
00:08:03,329 --> 00:08:07,919
way of saying you can write high level
expressive code without sacrificing the.

127
00:08:08,594 --> 00:08:13,984
Bare metal performance which you'll expect
from language like let's say C. Okay.

128
00:08:14,854 --> 00:08:18,644
Let's go to the next slide
and here are some numbers.

129
00:08:18,734 --> 00:08:21,014
So this is not just theory.

130
00:08:21,064 --> 00:08:23,164
There are some numbers
that we can see here.

131
00:08:23,284 --> 00:08:26,734
Rust usually uses 50 to 80% less.

132
00:08:27,409 --> 00:08:29,809
Memory than their counterparts.

133
00:08:30,379 --> 00:08:35,539
When the counterparts are returned
in managed languages on a RM devices,

134
00:08:35,899 --> 00:08:40,269
we see two to three times better
performance per what, which is critical

135
00:08:40,269 --> 00:08:42,109
for power constrained environments.

136
00:08:42,609 --> 00:08:45,399
And it's also consistently

137
00:08:45,899 --> 00:08:47,879
having an interference.

138
00:08:48,224 --> 00:08:52,064
Jitter of sub millisecond, right?

139
00:08:52,874 --> 00:08:58,644
This means our performance is predictable
and reliable, which is exactly what

140
00:08:58,644 --> 00:09:01,404
you need in real time applications.

141
00:09:01,904 --> 00:09:03,044
So yeah.

142
00:09:03,464 --> 00:09:07,964
Now that we've seen the patterns and
what's the best language to use, let's

143
00:09:07,964 --> 00:09:10,034
see, some implementation challenges.

144
00:09:10,934 --> 00:09:17,614
Okay, now the first major challenge is
managing state across a distributed system

145
00:09:17,674 --> 00:09:20,134
with unreliable network connections.

146
00:09:20,584 --> 00:09:23,794
How do you ensure that the
data on the Edge device and the

147
00:09:23,794 --> 00:09:25,324
data in the cloud stay in sync?

148
00:09:25,824 --> 00:09:28,584
The best solution would be
a hybrid consistency model.

149
00:09:29,084 --> 00:09:33,184
Because we shouldn't use like a
one size fits all approach, right?

150
00:09:33,634 --> 00:09:36,524
For critical data like
financial transactions.

151
00:09:36,524 --> 00:09:43,164
We can enforce high immediate consistency,
but for a less critical analytics

152
00:09:43,164 --> 00:09:47,904
data, we can relax the constraints
and use eventual consistency and to

153
00:09:47,904 --> 00:09:50,184
resolve conflicts when they do occur.

154
00:09:50,574 --> 00:09:56,284
We use, special data structures called
CDTs that can automatically and gracefully

155
00:09:56,284 --> 00:09:58,774
merge different versions of the data.

156
00:09:59,274 --> 00:10:01,374
Let's go to the next slide.

157
00:10:01,874 --> 00:10:02,204
Okay.

158
00:10:02,714 --> 00:10:09,694
So the next big challenge is security
edge devices often operate in a

159
00:10:09,784 --> 00:10:16,144
physically insecure environment, we have
to assume that they are v vulnerable.

160
00:10:16,644 --> 00:10:20,394
It's better if the architecture
is built on a zero trust model.

161
00:10:20,734 --> 00:10:24,814
So which means every single request
is authenticated and authorized

162
00:10:25,024 --> 00:10:26,704
regardless of where it comes from.

163
00:10:27,204 --> 00:10:31,694
The rusts compile time security
needs to be leveraged to eliminate

164
00:10:31,754 --> 00:10:35,564
entire classes of vulnerabilities
before they ever reach production.

165
00:10:36,064 --> 00:10:36,664
Then.

166
00:10:37,129 --> 00:10:42,624
Fine grained capability based
security model needs to be used to

167
00:10:42,684 --> 00:10:47,184
ensure devices only have permission
to do exactly what they need to do.

168
00:10:47,684 --> 00:10:53,584
Finally we need to implement like a app
machine learning based threat detection.

169
00:10:54,084 --> 00:10:55,044
Let's go to the next slide.

170
00:10:55,544 --> 00:11:02,054
And now our final challenge is squeezing
out every last drop of performance.

171
00:11:02,554 --> 00:11:04,474
And we can do this in three ways.

172
00:11:04,714 --> 00:11:09,594
Like first we need to use advanced
caching which might include the

173
00:11:09,744 --> 00:11:14,874
predictive prefetching that anticipates
like what data will be needed next.

174
00:11:15,364 --> 00:11:19,274
So this alone would reduce
the cloud query significantly.

175
00:11:19,774 --> 00:11:24,024
Second, we need to use selective
data compression, right?

176
00:11:24,024 --> 00:11:28,554
So by using content aware algorithms
instead of generic compression,

177
00:11:28,584 --> 00:11:33,729
we can cut our bandwidth usage
with minimal CPU overhead, right?

178
00:11:34,229 --> 00:11:39,199
And finally, for performance
critical hotspots, we need to write

179
00:11:39,259 --> 00:11:41,044
workload specific optimizations.

180
00:11:41,544 --> 00:11:48,104
Using low level SIMD instructions,
which can in some cases increase

181
00:11:48,104 --> 00:11:51,644
the data processing throughput
by more than three times.

182
00:11:52,574 --> 00:11:52,874
Okay,

183
00:11:53,374 --> 00:11:54,899
let's go to the next slide now.

184
00:11:55,139 --> 00:11:57,449
How can we get started on this?

185
00:11:57,549 --> 00:12:00,949
This can be divided into let's
say four practical guidelines.

186
00:12:01,429 --> 00:12:04,309
First, we need to start
with the business metric.

187
00:12:05,089 --> 00:12:07,839
We shouldn't lead with
the technology first.

188
00:12:07,839 --> 00:12:14,119
We need to identify the business KPI,
that we want to improve and work backward

189
00:12:14,119 --> 00:12:15,619
to design the right architecture.

190
00:12:16,119 --> 00:12:19,599
Second, we need to design
for degraded operation.

191
00:12:20,099 --> 00:12:23,339
We always need to assume
that our network will fail.

192
00:12:23,839 --> 00:12:28,069
Then we need to build our edge
applications to function autonomously

193
00:12:28,129 --> 00:12:29,839
and then recover gracefully.

194
00:12:30,339 --> 00:12:35,349
And the next implementation guideline
is we need to measure everything.

195
00:12:35,849 --> 00:12:39,169
We we cannot optimize what
we cannot measure, right?

196
00:12:39,169 --> 00:12:43,669
We need to implement comprehensive
telemetry from day one to

197
00:12:43,669 --> 00:12:45,349
understand our system's behavior.

198
00:12:45,849 --> 00:12:46,029
Okay?

199
00:12:46,689 --> 00:12:53,034
And the fourth guideline would be
we need to use containerization.

200
00:12:53,769 --> 00:12:54,009
Okay?

201
00:12:54,429 --> 00:12:58,009
So deploying our edge
workloads in containers.

202
00:12:58,954 --> 00:13:03,634
We'll give you consistency,
reproducibility, and make your update

203
00:13:03,754 --> 00:13:06,094
process much safer and reliable.

204
00:13:06,594 --> 00:13:10,134
So the rust code snippet that you
can see here shows a few of these

205
00:13:10,134 --> 00:13:13,989
principle in action using parallel
processing and efficient buffer

206
00:13:13,989 --> 00:13:16,269
handling to process the sensor data.

207
00:13:16,769 --> 00:13:17,069
Okay.

208
00:13:17,609 --> 00:13:17,879
Yeah.

209
00:13:18,179 --> 00:13:23,249
So let's go to the next
slide, the final one.

210
00:13:23,789 --> 00:13:24,089
Okay.

211
00:13:24,089 --> 00:13:27,559
As we wrap up, I want to leave
you with three main takeaways

212
00:13:27,559 --> 00:13:28,399
from our discussion today.

213
00:13:28,899 --> 00:13:35,269
First, these transformative patterns will
give you a blueprint a proven blueprint

214
00:13:35,269 --> 00:13:40,129
actually for designing responsive and
intelligent architectures that processes

215
00:13:40,129 --> 00:13:42,649
data in the most optimal location.

216
00:13:43,149 --> 00:13:48,564
Second the first provides the
ideal foundation for these systems,

217
00:13:48,834 --> 00:13:53,154
offering the safety, concurrency, and
performance needed for mission critical.

218
00:13:53,929 --> 00:13:55,129
Edge deployments.

219
00:13:55,629 --> 00:13:58,999
And finally this all leads
to real business impact.

220
00:13:59,499 --> 00:14:02,769
By thoughtfully combining the
immediacy of edge computing.

221
00:14:02,769 --> 00:14:06,629
With the power of the cloud
we can create systems that

222
00:14:06,629 --> 00:14:08,489
deliver truly measurable value.

223
00:14:08,989 --> 00:14:13,734
The goal here is to build intelligent,
resilient systems that bridge

224
00:14:13,974 --> 00:14:16,464
the physical and digital worlds.

225
00:14:16,674 --> 00:14:16,704
Okay.

226
00:14:17,204 --> 00:14:19,804
That wraps up our presentation.

227
00:14:20,374 --> 00:14:25,384
Thank you all so much for your time
and thank you for giving me this

228
00:14:25,384 --> 00:14:27,844
opportunity to speak at this conference.

229
00:14:28,234 --> 00:14:28,924
Have a nice day.

230
00:14:28,924 --> 00:14:29,674
Bye-bye.

