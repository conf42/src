1
00:00:00,360 --> 00:00:01,110
Hi everyone.

2
00:00:01,110 --> 00:00:02,310
Welcome to my talk.

3
00:00:02,370 --> 00:00:05,370
My name is Ryan and I'm a
DevOps engineer at Land Straw.

4
00:00:05,790 --> 00:00:08,910
Today we're going to look at
how to implement a blue green

5
00:00:08,910 --> 00:00:11,100
deployment strategy on AWS.

6
00:00:11,370 --> 00:00:15,450
So what benefit it brings, also,
what trade offs it comes with, and

7
00:00:15,450 --> 00:00:19,200
we focus on how lum that edge can
power bluegreen deployments and

8
00:00:19,200 --> 00:00:22,860
how this approach must adapt when
caching becomes part of the equation.

9
00:00:23,924 --> 00:00:26,235
So before we begin, let me
first introduce Lens Straw,

10
00:00:26,265 --> 00:00:27,974
which is the company I work for.

11
00:00:28,275 --> 00:00:31,064
So Lens Straw is a consulting
firm specialized in managing

12
00:00:31,064 --> 00:00:32,474
the entire cloud stack.

13
00:00:32,835 --> 00:00:34,935
So we build and secure cloud environments.

14
00:00:35,144 --> 00:00:40,275
We organize and operate data platforms
and we develop API driven or AI power

15
00:00:40,275 --> 00:00:44,385
solutions to help our clients, um,
address their challenges efficiently.

16
00:00:44,985 --> 00:00:48,974
So we primarily work in the luxury
banking and insurance sectors.

17
00:00:49,260 --> 00:00:54,000
And we're a team of 80 people across whole
Europe, with our headquarters in Paris.

18
00:00:55,500 --> 00:00:59,070
And also we are growing pretty
quickly and all, uh, and we are

19
00:00:59,070 --> 00:01:00,390
always looking for new clients.

20
00:01:00,390 --> 00:01:02,430
So if you're interested,
feel free to reach out.

21
00:01:03,540 --> 00:01:07,890
Um, this stock is actually inspired by
the work done for one of our clients,

22
00:01:08,190 --> 00:01:11,820
but it'll go a bit beyond, uh, this
single project because my goal is

23
00:01:11,820 --> 00:01:16,140
that most of you, uh, walk away with
something applicable to your own context.

24
00:01:17,745 --> 00:01:18,585
So let's begin.

25
00:01:19,485 --> 00:01:22,605
And it's always better to
understand why we are doing things.

26
00:01:22,905 --> 00:01:25,695
So, uh, let's start with
this simple question, why,

27
00:01:27,795 --> 00:01:29,295
and here is the starting point.

28
00:01:29,715 --> 00:01:34,005
So this is a pretty classic LWS
architecture to deliver a web application.

29
00:01:34,425 --> 00:01:35,835
Nothing, uh, fancy.

30
00:01:36,045 --> 00:01:39,705
Well, of course this diagram is
a very simplified view of the

31
00:01:39,705 --> 00:01:43,664
reality, but the idea is that
platform serves all satisfies.

32
00:01:44,025 --> 00:01:49,395
So HT M-L-C-S-S, JavaScript from
an, uh, an S3 bucket and for

33
00:01:49,395 --> 00:01:51,705
the backend platform forwards.

34
00:01:51,705 --> 00:01:57,134
API calls to an application load balancer,
which, uh, itself distributes traffic

35
00:01:57,164 --> 00:01:59,414
across an ECS cluster running on, forget.

36
00:02:00,285 --> 00:02:03,615
So the compute is serverless,
scalable and fully managed.

37
00:02:04,964 --> 00:02:09,734
And even if, uh, even if this looks
good, we were experiencing a high number

38
00:02:09,734 --> 00:02:12,015
of incidents during production release.

39
00:02:12,465 --> 00:02:16,575
So the rollbacks were, uh, slow
and complex, so really painful, and

40
00:02:16,575 --> 00:02:20,805
this caused a lot of operational
stress to the team and sometimes

41
00:02:20,865 --> 00:02:22,935
even downtime during deployments.

42
00:02:23,265 --> 00:02:26,834
So we, yeah, we definitely
needed a safer, a more controlled

43
00:02:26,834 --> 00:02:28,215
way to deploy our application.

44
00:02:30,390 --> 00:02:34,710
And this brings us to the next part, to
the next part, blue green deployments.

45
00:02:35,160 --> 00:02:41,520
So, um, blue green deployments is a real
strategy where we maintain two identical,

46
00:02:41,579 --> 00:02:43,320
uh, production ready environments.

47
00:02:43,650 --> 00:02:46,620
So, but one is live here,
that's the blue environment.

48
00:02:46,800 --> 00:02:51,030
And the other, the green environments will
host the new version that is deployed.

49
00:02:51,630 --> 00:02:52,740
So the idea is simple.

50
00:02:53,010 --> 00:02:54,655
We prepare the new release in green.

51
00:02:55,365 --> 00:02:58,905
We run all of our tests, we validate
that everything behaves currently.

52
00:02:59,204 --> 00:03:03,615
And when confident, we switch traffic
from blue to green instantly and

53
00:03:03,615 --> 00:03:05,655
without impacting the users at all.

54
00:03:06,615 --> 00:03:10,065
And if anything goes wrong, we
can just flip back traffic to blue

55
00:03:10,245 --> 00:03:12,195
without, uh, without any issue.

56
00:03:13,394 --> 00:03:15,555
So how does that help help us?

57
00:03:15,555 --> 00:03:19,605
In our case, first, we could test
the new version in the real world

58
00:03:19,605 --> 00:03:21,165
conditions before switching traffic.

59
00:03:22,200 --> 00:03:27,119
Um, and also rollbacks became fast and
low risk, essentially with one action.

60
00:03:27,750 --> 00:03:31,980
So at the end, releases become
safer and more, uh, predictable.

61
00:03:32,220 --> 00:03:35,519
And importantly, we achieve zero
down time during deployments.

62
00:03:36,420 --> 00:03:38,519
Well, of course it's not perfect.

63
00:03:38,790 --> 00:03:40,709
Uh, there are a few
pitfalls to be aware of.

64
00:03:41,280 --> 00:03:45,005
The, the first one being that you're
temporarily running two environments.

65
00:03:45,675 --> 00:03:47,805
Which means, of course, higher costs.

66
00:03:48,315 --> 00:03:52,395
And you also need to think
very, um, carefully about states

67
00:03:52,395 --> 00:03:53,925
and database synchronization.

68
00:03:54,255 --> 00:03:58,095
Um, especially for applications
that often have, um, schema changes.

69
00:03:59,025 --> 00:04:02,505
Um, in our cases, uh, in our case,
we didn't manage any database.

70
00:04:02,805 --> 00:04:06,735
We only had a few illustration instances,
so we didn't have to worry about that.

71
00:04:07,095 --> 00:04:10,730
But this can, yeah, this can become
very tricky, uh, in some cases.

72
00:04:12,090 --> 00:04:15,750
And also finally, it adds
some configuration complexity

73
00:04:15,750 --> 00:04:19,350
depending on how your routing
is set up in your architecture.

74
00:04:22,320 --> 00:04:26,370
Okay, now we are going to look at
civil possible configurations for

75
00:04:26,370 --> 00:04:30,090
implementing blue green deployments
based on the architecture we, we just

76
00:04:30,090 --> 00:04:32,640
saw, um, not all of these approaches.

77
00:04:33,075 --> 00:04:37,065
Made totally, totally sense in our
specific situation, but at Seal

78
00:04:37,065 --> 00:04:41,744
Walk, uh, through them because, uh,
depending on your own environments,

79
00:04:41,804 --> 00:04:44,385
some of these options might
be the, the right fit for you.

80
00:04:46,905 --> 00:04:51,075
The first option to implement
bluegreen is simply to use Route 53.

81
00:04:51,465 --> 00:04:53,354
This is usually the most
straightforward approach.

82
00:04:54,104 --> 00:04:57,284
So, uh, you point your domain
to the blue environment, and

83
00:04:57,284 --> 00:04:58,784
when you are done, you're ready.

84
00:04:58,995 --> 00:05:02,025
You update the DNS record to
points, to the green environment.

85
00:05:02,534 --> 00:05:04,664
Um, you can also use weighted routine.

86
00:05:04,995 --> 00:05:10,455
Uh, this is a feature of route, uh, 53,
where you gradually shift, uh, uh, defined

87
00:05:10,455 --> 00:05:12,974
percentage of traffic from blue to green.

88
00:05:13,424 --> 00:05:17,924
Um, but in practice, DNS caching,
um, makes this difficult to

89
00:05:17,924 --> 00:05:19,335
control with, uh, with precision.

90
00:05:20,685 --> 00:05:24,795
So the main benefits of this method
are, uh, that it's very simple

91
00:05:24,974 --> 00:05:26,715
and that it's, uh, universal.

92
00:05:26,805 --> 00:05:31,935
So it works, um, no matter which
architecture you have, uh, whether you

93
00:05:31,935 --> 00:05:36,344
are serving static files, APIs, if you
have a, a microservice architecture,

94
00:05:36,375 --> 00:05:38,534
everything works, uh, with that setup.

95
00:05:40,005 --> 00:05:41,775
But it has a few drawbacks.

96
00:05:42,075 --> 00:05:45,105
Um, first it's dependent on DNS caching.

97
00:05:45,780 --> 00:05:50,430
Uh, so the traffic switch is never
instant and you can't fully predict

98
00:05:50,430 --> 00:05:54,630
how long clients will hold, uh,
will hold on to hold records.

99
00:05:55,140 --> 00:05:59,100
And you also get very poor control
over individual request because

100
00:05:59,100 --> 00:06:03,120
you count route, uh, for example,
using cookies or headers, uh, logic.

101
00:06:04,170 --> 00:06:04,530
And yes.

102
00:06:04,530 --> 00:06:08,970
Finally, uh, this setup requires to
duplicate the entire infrastructure to, so

103
00:06:08,970 --> 00:06:11,730
this is something also to to have in mind.

104
00:06:13,424 --> 00:06:18,825
Okay, the next option is to
handle Bluegreen routing directly

105
00:06:18,825 --> 00:06:20,895
at the edge using Lambda Edge.

106
00:06:21,224 --> 00:06:25,245
So, um, just so everything, uh,
so everyone is at the same page.

107
00:06:25,484 --> 00:06:29,205
Lambda Edge is a platform feature
that lets you run lightweight

108
00:06:29,205 --> 00:06:31,815
functions inside AWS Edge location.

109
00:06:32,205 --> 00:06:36,705
So before the request even reaches
your, uh, your backend, your origin.

110
00:06:38,190 --> 00:06:41,400
This gives you the ability to
inspect the incoming request.

111
00:06:41,670 --> 00:06:44,370
So for example, you can inspect
cookies, headers, uh, path.

112
00:06:46,140 --> 00:06:49,560
Basically anything, anything
that the request, um, contains,

113
00:06:50,100 --> 00:06:55,350
and then you can, um, modify the
request, um, fields dynamically.

114
00:06:55,890 --> 00:06:59,400
So the routing in that case
works by modifying the request

115
00:06:59,400 --> 00:07:01,530
before it hits the, the origin.

116
00:07:01,980 --> 00:07:06,960
For example, uh, the Lambda function can
change the origin domain to point to the

117
00:07:06,960 --> 00:07:09,120
blue, to the blue or the green backend.

118
00:07:09,479 --> 00:07:14,520
Or it can modify the S3 path
prefix to serve a different

119
00:07:14,520 --> 00:07:15,630
version of the front end.

120
00:07:16,469 --> 00:07:20,430
So for the user's perspective,
everything is transparent, but we

121
00:07:20,430 --> 00:07:24,659
decide behind the scenes, uh, the
scenes, which version they actually get.

122
00:07:25,950 --> 00:07:28,260
This gives, uh, two big benefits.

123
00:07:28,530 --> 00:07:32,385
First one, it's a very dynamic
and highly flexible routing

124
00:07:32,534 --> 00:07:34,380
because we can choose the version.

125
00:07:34,440 --> 00:07:34,890
Uh.

126
00:07:35,370 --> 00:07:39,360
Um, per user, per cookie,
or per uh, request.

127
00:07:39,690 --> 00:07:43,980
And it has a very low latency since
all of the logic runs directly at the

128
00:07:43,980 --> 00:07:46,200
age close to, to the, to the user.

129
00:07:47,670 --> 00:07:49,830
Of course, uh, there are some drawbacks.

130
00:07:50,130 --> 00:07:52,050
This approach introduce more complexity.

131
00:07:52,560 --> 00:07:56,310
Because you now need to manage
routine logic inside platform's,

132
00:07:56,340 --> 00:08:00,150
request lifecycle, and handle
cash interactions carefully.

133
00:08:00,360 --> 00:08:01,380
We'll come to that later.

134
00:08:01,920 --> 00:08:07,320
Um, and updating along that edge
functions has a propagation delay since

135
00:08:07,320 --> 00:08:11,730
the new code needs to be deployed to
every AWS Edge location worldwide.

136
00:08:12,420 --> 00:08:15,030
Um, so yeah, we also mentioned that later.

137
00:08:17,700 --> 00:08:20,730
Okay, before we look at the
solution, we actually implemented.

138
00:08:21,104 --> 00:08:26,174
I want to quickly mention three other
AWS options for blue green deployments.

139
00:08:26,505 --> 00:08:28,034
They are all valid approaches.

140
00:08:28,395 --> 00:08:32,204
Um, they didn't really make sense
in our specific context, but yeah,

141
00:08:32,235 --> 00:08:33,314
they might be useful for you.

142
00:08:33,314 --> 00:08:37,694
So, so here, there are, um, so
the first one is API gateway.

143
00:08:38,505 --> 00:08:42,645
It offers a very flexible routine
and you can switch versions using

144
00:08:42,645 --> 00:08:45,345
headers, cookies, or stage variables.

145
00:08:46,245 --> 00:08:49,395
So it's a very great solution
for APIs and microservices.

146
00:08:49,709 --> 00:08:53,490
But it doesn't work for S3, the static
front ends, so that's why it didn't

147
00:08:53,490 --> 00:08:57,240
fit, uh, our a, our architecture
and we didn't have this service

148
00:08:57,240 --> 00:08:59,339
already, uh, configured in our case.

149
00:09:00,839 --> 00:09:05,430
The next option is a LB, so application
load balancer waiting routing, uh,

150
00:09:05,459 --> 00:09:10,230
you can set up two target group
blue and green and assign weights

151
00:09:10,319 --> 00:09:11,939
to shift the traffic between them.

152
00:09:11,939 --> 00:09:12,030
It's.

153
00:09:13,065 --> 00:09:15,585
Very fast, and the
rollback is also very fast.

154
00:09:15,795 --> 00:09:20,715
But, um, even if it works well for API
and microservices, it doesn't support

155
00:09:20,775 --> 00:09:26,985
static, static, um, S3 content and
compared to API gateway, it doesn't offer

156
00:09:27,015 --> 00:09:31,245
the, all the advanced routing logic,
for example, with a cookie based rules.

157
00:09:32,849 --> 00:09:34,920
And finally we have CodeDeploy.

158
00:09:35,250 --> 00:09:40,199
This one gives you, uh, a fully automated
blue-green workflow with health checks,

159
00:09:40,500 --> 00:09:44,579
uh, with lifecycle routes and automatic
world back if something goes wrong.

160
00:09:44,880 --> 00:09:50,040
So it's a really great tool, but it has,
um, yeah, it also introduced significant

161
00:09:50,339 --> 00:09:54,900
set up overhead, um, especially if
you don't have it already configured.

162
00:09:58,935 --> 00:10:02,954
Okay, so now we're going to see
how our implementation of bluegreen

163
00:10:02,954 --> 00:10:05,415
deployment, uh, works with Lambda.

164
00:10:08,115 --> 00:10:13,275
Um, so the idea is that we implemented
the Bluegreen routing, the Bluegreen, yes.

165
00:10:13,275 --> 00:10:16,964
Rooting directly at the edge
using the cookie based approach.

166
00:10:17,324 --> 00:10:18,765
So let me explain how it works.

167
00:10:19,334 --> 00:10:20,655
Um, so first, yeah.

168
00:10:20,685 --> 00:10:25,334
As you can see, each environment blue
and green has its own application load

169
00:10:25,334 --> 00:10:28,035
balancer with its own ECS cluster.

170
00:10:28,334 --> 00:10:32,954
And for the front end part we have, uh,
different prefixes on the same S3 buckets.

171
00:10:33,584 --> 00:10:37,215
So the idea is that we will use
lambda at H to modify the request

172
00:10:37,215 --> 00:10:41,265
fields so that it points to the
correct origin or the correct S3, uh,

173
00:10:41,295 --> 00:10:43,215
prefix, depending on the cookie value.

174
00:10:44,775 --> 00:10:49,035
So based on this cookie, the function
decides whether the user should see

175
00:10:49,035 --> 00:10:50,685
the blue version or the green version.

176
00:10:51,074 --> 00:10:55,875
The cookie can, um, store something
meaningful, uh, but difficult to guess.

177
00:10:55,875 --> 00:10:59,864
For example, the commit ash of
the, the application release.

178
00:11:02,535 --> 00:11:02,775
Okay.

179
00:11:02,775 --> 00:11:08,145
So cookies were a great tool in our case
because it lets us, uh, take decisions

180
00:11:08,324 --> 00:11:10,545
per user to preserve their experience.

181
00:11:11,040 --> 00:11:15,720
Because on a user is assigned the
version, uh, we want them to stay on

182
00:11:15,720 --> 00:11:20,580
that version so that they don't bounce
between releases while navigating the app.

183
00:11:20,970 --> 00:11:24,330
And that's especially true if
there are breaking chains, breaking

184
00:11:24,330 --> 00:11:25,950
changes between uh, two version.

185
00:11:27,780 --> 00:11:32,880
We also added, um, a new component,
which is a developer override cookie.

186
00:11:33,300 --> 00:11:35,970
So this cookie has
priority over everything.

187
00:11:36,344 --> 00:11:40,785
And it allows developers or QA
to force a specific version,

188
00:11:40,875 --> 00:11:42,285
uh, directly in their browser.

189
00:11:42,555 --> 00:11:46,574
So this prevents them from being switched
automatically, even if they refresh

190
00:11:46,574 --> 00:11:48,765
the page or anything else they can do.

191
00:11:49,064 --> 00:11:52,545
Uh, this is crucial for testing and
the begging, uh, for, for the use case.

192
00:11:53,834 --> 00:11:55,665
Okay, so here's the routing logic.

193
00:11:56,204 --> 00:12:00,854
If a version cookie is already present,
we keep the user on that version.

194
00:12:01,125 --> 00:12:03,104
So this preserves the, the context.

195
00:12:03,464 --> 00:12:03,824
Uh.

196
00:12:04,425 --> 00:12:08,415
Of the user and is ensure that there
is a smooth experience for the, for

197
00:12:08,415 --> 00:12:13,245
the user if no cookie is present,
or if the app is being reloaded,

198
00:12:13,485 --> 00:12:15,225
for example, on a full refresh.

199
00:12:15,285 --> 00:12:18,525
Um, that requests the
new HTML uh, content.

200
00:12:18,855 --> 00:12:22,755
We assign the user to the currently
active release and we set the cookie

201
00:12:22,755 --> 00:12:24,855
at that moment for future requests.

202
00:12:25,695 --> 00:12:31,725
And this lets us move users only
when it's, um, only when it's needed.

203
00:12:34,500 --> 00:12:34,920
Okay.

204
00:12:35,280 --> 00:12:39,840
Um, and the last step, if the
developer cookie is present,

205
00:12:40,199 --> 00:12:42,000
it's, uh, always, it always wins.

206
00:12:42,120 --> 00:12:45,960
So the user is explicitly pins
to that version regardless of

207
00:12:45,960 --> 00:12:47,490
reloads or global switches.

208
00:12:49,230 --> 00:12:52,710
The combination gives us a
control, flexible and user

209
00:12:52,710 --> 00:12:53,910
friendly blue green system.

210
00:12:54,405 --> 00:12:58,455
While still letting developers, uh,
target specific versions instantly.

211
00:12:59,535 --> 00:13:01,095
Um, but there's still an issue.

212
00:13:01,905 --> 00:13:09,105
Uh, it's that when, um, we want to,
uh, to update the, the active version

213
00:13:09,105 --> 00:13:13,755
in the Lambda Edge code, there's a
propagation delay, uh, which means

214
00:13:13,755 --> 00:13:18,105
that updating the alarm that code,
uh, is slow and lacks predictability.

215
00:13:18,510 --> 00:13:23,130
So we find, um, a way to improve
the, this, this implementation.

216
00:13:23,340 --> 00:13:25,650
And that's what I'm going to,
to explain in the next slide.

217
00:13:28,829 --> 00:13:32,430
So for the second iteration of
the, the project, the idea was

218
00:13:32,430 --> 00:13:36,390
to avoid redeploying the lambda
edge every time a value changes.

219
00:13:36,750 --> 00:13:40,800
So to achieve this, we externalize
all dynamic configuration into

220
00:13:40,800 --> 00:13:44,939
the SSM parameter store, and this
allows us to store the active

221
00:13:44,939 --> 00:13:46,260
version outside of the code.

222
00:13:46,995 --> 00:13:52,005
So, uh, the LAMB data only has to
retrieve the, this configuration

223
00:13:52,005 --> 00:13:58,365
when needed and to prevent, um, a
network request on every invocation.

224
00:13:58,725 --> 00:14:03,225
We cache the release information
in memory, uh, for short duration.

225
00:14:03,555 --> 00:14:07,605
And this preserve the performance
benefits of running at the edge while,

226
00:14:07,665 --> 00:14:11,235
uh, still allowing configuration
updates without redeployment.

227
00:14:15,375 --> 00:14:15,735
Okay.

228
00:14:15,735 --> 00:14:18,645
There's something we didn't talk
about for the moment, and that's

229
00:14:18,645 --> 00:14:22,755
one of cloud, uh, one of, uh,
cloud phone's key capabilities.

230
00:14:23,115 --> 00:14:26,175
It's the ability to cache
contents at edge locations.

231
00:14:26,715 --> 00:14:31,005
Um, and that's, uh, yeah, we will see
how it implies some adjustments to

232
00:14:31,005 --> 00:14:32,685
the implement, the implementation.

233
00:14:32,685 --> 00:14:32,949
We just.

234
00:14:36,570 --> 00:14:40,650
Okay, so before diving into the
adjustments, there is one essential

235
00:14:40,650 --> 00:14:45,870
concepts we need to clarify, and that's
how CloudFront processes request and

236
00:14:45,870 --> 00:14:48,120
more importantly, how caching happens.

237
00:14:48,660 --> 00:14:52,380
So CloudFront has four possible
interception points for Lambda age.

238
00:14:52,625 --> 00:14:56,340
Uh, the first one, the viewer
request, which happens just

239
00:14:56,340 --> 00:14:58,920
after the user makes the request.

240
00:14:59,445 --> 00:15:01,575
Then the, um, the origin request.

241
00:15:01,875 --> 00:15:06,225
That's, uh, when platform decides
it needs to contact the origin.

242
00:15:06,525 --> 00:15:11,505
Then there's the origin response when
the origin sends data back to platform,

243
00:15:11,985 --> 00:15:13,725
and there is the viewer response.

244
00:15:13,875 --> 00:15:19,245
So just before the response goes back
to the user, the key here, uh, is to

245
00:15:19,245 --> 00:15:23,655
understand that the cache sits between
the viewer side and the origin side.

246
00:15:24,015 --> 00:15:27,915
This means that CloudFront will
only reach the origin request phase.

247
00:15:28,335 --> 00:15:32,925
If the requested object is not already
cached at the edge location, if the

248
00:15:32,925 --> 00:15:35,265
content is cached, the content is cached.

249
00:15:35,415 --> 00:15:39,705
The origin request and origin response
phases never happened, and that's why

250
00:15:39,705 --> 00:15:45,195
we need to, um, really carefully decide
which logic runs in your request and which

251
00:15:45,195 --> 00:15:51,195
lodging Logic runs in origin request to
ensure that, uh, Bluegreen works correctly

252
00:15:51,195 --> 00:15:55,335
with static assets because they only,
this only concerns, uh, the static assets.

253
00:15:55,680 --> 00:16:02,670
So the S3 origin in our case, and that's
the final workflow we implemented.

254
00:16:03,030 --> 00:16:07,800
So on the reviewer request side, if a
developer preview cookie is present,

255
00:16:07,980 --> 00:16:13,200
we inject a unique identifier into the
request so that it bypasses cash object.

256
00:16:13,439 --> 00:16:17,160
So this guarantees that developers,
as I I mentioned previously, always

257
00:16:17,160 --> 00:16:21,870
see the most UpToDate information
and content for the testing purposes.

258
00:16:23,265 --> 00:16:28,185
Then if the cache isn't hit, uh, a
release, the origin request phase

259
00:16:28,185 --> 00:16:33,015
starts and the Lambda at edge, uh, is
triggered, uh, with the following logic.

260
00:16:33,015 --> 00:16:38,475
So if a release cookie is already set
and the app is not loading, we route

261
00:16:38,505 --> 00:16:42,615
the request to the correct blue or green
prefix, depending on the active version.

262
00:16:43,035 --> 00:16:46,935
Otherwise, we retrieve, uh, the
currently active release from

263
00:16:46,935 --> 00:16:48,705
SSM and we roots accordingly.

264
00:16:50,189 --> 00:16:54,780
Then on the origin response, so before
the response is sent back to CloudFront,

265
00:16:55,170 --> 00:17:01,350
um, if the app is loading, we, uh, choose
that moment to assign the release cookie.

266
00:17:01,650 --> 00:17:02,640
And this inserts that.

267
00:17:02,640 --> 00:17:05,399
Cons this, uh, yes, this
ensures consistent routine

268
00:17:05,399 --> 00:17:06,930
for, uh, the following request.

269
00:17:07,020 --> 00:17:12,720
The subsequent request, and this is
also why we perform a cash invalidation

270
00:17:12,720 --> 00:17:14,024
whenever the active release changes.

271
00:17:15,075 --> 00:17:19,724
Um, because the next request
without a release cookie or the

272
00:17:19,724 --> 00:17:25,694
next week request to, um, reload the
application will not be a cash sheet.

273
00:17:26,264 --> 00:17:30,764
And instead, CloudFront will trigger
the origin request, Lambda, where we

274
00:17:30,764 --> 00:17:36,105
decide the, the version to serve and
the origin response Lambda, where

275
00:17:36,105 --> 00:17:37,935
we assigned the version cookie.

276
00:17:38,475 --> 00:17:42,915
And on this cookie set, the following
request will consistently hit.

277
00:17:43,290 --> 00:17:46,770
The cache entry that corresponds
to the assigned version.

278
00:17:47,070 --> 00:17:50,880
So the invalidation inserts,
that version assignments always

279
00:17:50,880 --> 00:17:53,130
happens correctly at the moment.

280
00:17:53,220 --> 00:17:56,340
A user, uh, first loads or
reloads the application.

281
00:17:57,570 --> 00:18:01,590
And this combination inserts that
caching works with our blue green

282
00:18:01,650 --> 00:18:03,690
strategy rather than against it.

283
00:18:06,210 --> 00:18:08,340
So to, uh, to wrap things up.

284
00:18:08,879 --> 00:18:11,340
Here's what we were able to achieve first.

285
00:18:11,340 --> 00:18:15,600
We now have low latency, cookie
based routing that lets us, uh,

286
00:18:15,629 --> 00:18:18,960
switch traffic between blue and
green, instantly and safely.

287
00:18:19,679 --> 00:18:24,360
Um, promoting a new version or
rolling back takes less than a minute

288
00:18:24,540 --> 00:18:29,225
with no prop delay or fully, and
with a fully predictable behavior.

289
00:18:29,845 --> 00:18:33,810
And we also implemented cash Azure
Static Frontend management, which

290
00:18:33,810 --> 00:18:37,649
means that version, uh, changes
or image it and consistent.

291
00:18:39,000 --> 00:18:41,970
And most importantly, we have
a zero production incident.

292
00:18:42,179 --> 00:18:46,830
We had zero production incident during
releases since adopting this strategy.

293
00:18:47,699 --> 00:18:50,939
Okay, now there are of course a
few additional consideration that

294
00:18:50,939 --> 00:18:55,740
we didn't cover today, uh, but are
still very relevant, especially

295
00:18:55,740 --> 00:18:57,000
when scaling this approach.

296
00:18:57,330 --> 00:19:01,740
For example, uh, we don't talk about,
uh, coordinating blue green states

297
00:19:01,980 --> 00:19:06,090
across multiple components, uh,
across multiple backend services,

298
00:19:06,090 --> 00:19:07,530
databases, and microservice.

299
00:19:07,919 --> 00:19:11,250
This can become very complex,
especially when shared states

300
00:19:11,489 --> 00:19:13,169
or schema changes are involved.

301
00:19:14,580 --> 00:19:20,129
Um, there's also the idea of progressive,
uh, validation where only a subset of

302
00:19:20,129 --> 00:19:22,139
user are assigned to the new version.

303
00:19:22,139 --> 00:19:27,899
Before switching everyone over, uh, this
gives you, um, an additional layer of

304
00:19:27,899 --> 00:19:30,300
safety for large or risky deployments.

305
00:19:30,659 --> 00:19:33,750
And finally, integration
with CICD pipelines.

306
00:19:34,110 --> 00:19:38,550
Um, so that's how we would do to fully
automate the promotion, the roll back, and

307
00:19:38,550 --> 00:19:42,810
the validation steps, making the entire
release, uh, yeah, the entire release

308
00:19:42,810 --> 00:19:45,419
process, more reliable and reputable.

309
00:19:48,060 --> 00:19:49,470
So, thank you for your time.

310
00:19:49,679 --> 00:19:52,980
I hope this talk gave you some
useful insights and ideas.

311
00:19:52,980 --> 00:19:55,080
Also, you can apply in your own context.

312
00:19:55,440 --> 00:19:58,889
If you'd like to continue the
conversation, collaborate with RA

313
00:19:58,889 --> 00:20:02,730
or join the team, please feel free
to reach out using the links here.

314
00:20:03,090 --> 00:20:06,540
Or you can also contact me
directly by email or LinkedIn.

315
00:20:07,139 --> 00:20:09,240
Uh, thanks again and have a great day.

