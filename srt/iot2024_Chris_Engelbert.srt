1
00:00:00,280 --> 00:00:00,750
All right.

2
00:00:00,790 --> 00:00:02,010
Nice that you're all here.

3
00:00:02,050 --> 00:00:03,010
very appreciated.

4
00:00:03,020 --> 00:00:04,369
Oh, let's dive right in.

5
00:00:04,489 --> 00:00:08,540
One thing I learned, giving this
presentation a few times in the past is

6
00:00:08,550 --> 00:00:14,140
that the title slide is very often very
much misunderstood, or, at least say,

7
00:00:14,189 --> 00:00:18,530
it helps people or giving people a laugh
because a lot of people actually read

8
00:00:18,530 --> 00:00:21,539
it as Duke Postgres don't do Kubernetes.

9
00:00:21,649 --> 00:00:22,949
which is not how it meant.

10
00:00:22,969 --> 00:00:24,529
it's actually a good read.

11
00:00:24,619 --> 00:00:25,929
but I think it's the wrong way.

12
00:00:26,229 --> 00:00:30,399
because from my perspective,
Postgres really loves Kubernetes.

13
00:00:30,549 --> 00:00:33,269
And the other way around,
Kubernetes really loves Postgres.

14
00:00:33,270 --> 00:00:37,559
I expect that there is quite a few people
in the audience already that use Postgres.

15
00:00:37,879 --> 00:00:41,459
there is a good chunk of people
that I guess uses Kubernetes.

16
00:00:41,499 --> 00:00:44,669
And there is probably still a
sizable amount of people that

17
00:00:44,699 --> 00:00:46,529
already use Postgres on Kubernetes.

18
00:00:47,024 --> 00:00:50,684
If you don't, I hope that by the
end of the presentation, I actually

19
00:00:50,684 --> 00:00:54,204
got you to the point where ah, that
sounds like a really good idea.

20
00:00:54,214 --> 00:00:55,954
I should totally do that.

21
00:00:56,054 --> 00:00:57,504
So a few words about me.

22
00:00:57,524 --> 00:00:58,444
Just say I'm Chris.

23
00:00:58,494 --> 00:01:00,314
I'm a developer advocate at Simplyblock.

24
00:01:00,644 --> 00:01:02,544
been with a few companies in the past.

25
00:01:02,764 --> 00:01:04,634
some might be more known than others.

26
00:01:04,964 --> 00:01:07,684
Some people might have heard
about this weird little

27
00:01:07,684 --> 00:01:09,274
gaming company called Ubisoft.

28
00:01:09,324 --> 00:01:13,144
If you heard about those, Probably in
the context of copy protection, but,

29
00:01:13,184 --> 00:01:15,004
that was not what I worked on at least.

30
00:01:15,234 --> 00:01:17,544
but afterwards it's very
much all about data.

31
00:01:17,824 --> 00:01:19,164
Hazelcast was an in memory data grid.

32
00:01:19,394 --> 00:01:24,504
meaning that everything was about the
actual, data in memory that you could,

33
00:01:24,564 --> 00:01:29,264
analyze, that you could share state
between different instances stateless.

34
00:01:29,564 --> 00:01:30,474
Stuff like that, right?

35
00:01:30,484 --> 00:01:33,424
it was all about data and Stata
was all about observability.

36
00:01:33,454 --> 00:01:35,214
So it's still all about data, right?

37
00:01:35,254 --> 00:01:36,704
it's metrics.

38
00:01:37,019 --> 00:01:39,489
it's, traces it spans.

39
00:01:39,709 --> 00:01:43,359
It's all about the combination
of different services and how

40
00:01:43,359 --> 00:01:45,869
they work together in the whole
infrastructure, stuff like that.

41
00:01:45,869 --> 00:01:46,769
it's all about data.

42
00:01:46,939 --> 00:01:48,639
Clever bit, was my own startup.

43
00:01:48,659 --> 00:01:52,879
We actually made hot end software for
animal husbandry, measuring like CO2

44
00:01:52,899 --> 00:01:57,749
ammonia levels, trying to correlate them
with like medication and in general,

45
00:01:57,749 --> 00:02:01,139
trying to prevent medication from giving.

46
00:02:01,409 --> 00:02:06,389
from being given to the animals, to make
better meat quality, in general, get

47
00:02:06,419 --> 00:02:10,339
the animals a healthier life for, at
least for the time they actually live.

48
00:02:10,389 --> 00:02:11,829
we all know how that ends, right?

49
00:02:12,069 --> 00:02:16,049
but at least making their lives as good
as possible while they're around, and

50
00:02:16,049 --> 00:02:19,559
timescale, is a time series database at.

51
00:02:20,554 --> 00:02:24,765
Or on top of Postgres, and as you can see
in the picture, that is from last year.

52
00:02:24,825 --> 00:02:26,785
I really like that,
that conference picture.

53
00:02:26,835 --> 00:02:31,125
At a timescale, I love to, to explain
people why I think Postgres is the

54
00:02:31,125 --> 00:02:34,245
ultimate database for time serious data.

55
00:02:34,295 --> 00:02:37,275
And now I'm at SimpliBlock, and
SimpliBlock is also all about data.

56
00:02:37,285 --> 00:02:41,405
It's all about data storage, how you can,
expand storage, how you can scale storage.

57
00:02:41,455 --> 00:02:46,095
so there, there's a little bit of a red
thread through my life, even at Ubisoft, a

58
00:02:46,095 --> 00:02:52,535
lot of stuff in, in, in games these days,
is it about data is about interaction,

59
00:02:52,565 --> 00:02:54,855
how players interact with your games.

60
00:02:55,165 --> 00:02:56,815
so there's like this general thing.

61
00:02:56,915 --> 00:03:00,905
if you want to drop me a message, if
you have questions, you see my socials.

62
00:03:01,210 --> 00:03:02,680
the presentation will be shared.

63
00:03:02,730 --> 00:03:06,030
just feel free to, to drop
me a line and ask a question.

64
00:03:06,050 --> 00:03:09,950
What I learned over the last couple
of years is that you want to start.

65
00:03:10,390 --> 00:03:13,860
presentation with a game, making
it interactive, making it fun.

66
00:03:13,860 --> 00:03:17,869
So for the ones that don't know what
family thought is, it's basically a,

67
00:03:17,870 --> 00:03:23,850
a game show where, two families fight
against each other, trying to guess.

68
00:03:24,140 --> 00:03:28,220
Like the first answers that
popped into people's minds.

69
00:03:28,230 --> 00:03:34,140
So the idea is we asked a hundred people,
what is your first thought when it

70
00:03:34,140 --> 00:03:39,400
comes to X, Y, Z for today, I thought it
makes sense to have, like, why shouldn't

71
00:03:39,410 --> 00:03:40,590
you run a database in Kubernetes?

72
00:03:40,970 --> 00:03:45,110
And because it's hard to do this life
right now, I actually went ahead.

73
00:03:45,240 --> 00:03:48,490
I was nice enough to fix,
to figure that out for you.

74
00:03:48,490 --> 00:03:50,390
So I went to Twitter.

75
00:03:50,950 --> 00:03:53,880
And ask like, why shouldn't you
run a database on Kubernetes?

76
00:03:54,270 --> 00:03:54,860
What do you think?

77
00:03:54,870 --> 00:03:55,650
I please help me.

78
00:03:55,650 --> 00:03:56,290
I need your help.

79
00:03:56,560 --> 00:04:00,890
when you do this things on Twitter,
sorry, X, you have to remember one thing

80
00:04:00,900 --> 00:04:07,380
when you ask, a controversial question
on Twitter, X, I have to get used to

81
00:04:07,380 --> 00:04:10,530
that on X, always ask for a friend.

82
00:04:10,620 --> 00:04:12,270
It's important asking for a friend.

83
00:04:12,430 --> 00:04:13,320
it's not about you.

84
00:04:13,410 --> 00:04:15,100
Obviously you would never do this.

85
00:04:15,120 --> 00:04:17,610
so asking for a friend is like
the most important thing for those

86
00:04:17,610 --> 00:04:19,220
kinds of stuff, there were answers.

87
00:04:19,590 --> 00:04:24,010
and the answers were like, Kubernetes
wasn't designed in with databases in mind.

88
00:04:24,420 --> 00:04:26,820
Which is very much true.

89
00:04:27,060 --> 00:04:30,550
Like when Kubernetes was
designed initially, what is it?

90
00:04:30,570 --> 00:04:34,580
10, 10 years ago, We had the
Kubernetes, yeah, so 10 years

91
00:04:34,580 --> 00:04:38,900
ago, Kubernetes was designed for
stateless systems and stateless only,

92
00:04:39,340 --> 00:04:41,810
but about five or six years ago.

93
00:04:42,190 --> 00:04:44,610
I don't want to pinpoint
to the exact point in time.

94
00:04:45,020 --> 00:04:46,220
Kubernetes has changed.

95
00:04:46,385 --> 00:04:50,165
People started to figure out, okay,
stateless systems are nice, but they're

96
00:04:50,165 --> 00:04:51,665
not easy to do be designed, right?

97
00:04:51,665 --> 00:04:56,465
So they started to integrate
elements for stateful services,

98
00:04:56,465 --> 00:04:57,505
what they call it, right?

99
00:04:57,515 --> 00:05:03,470
So stateful service in general,
true databases weren't Well, thought

100
00:05:03,470 --> 00:05:07,210
about at, I guess at that point, at
least, maybe not like first thought.

101
00:05:07,490 --> 00:05:08,920
but that changed quite a bit.

102
00:05:08,950 --> 00:05:12,840
So if you're stuck in the past, yes,
Kubernetes wasn't designed for databases.

103
00:05:12,840 --> 00:05:15,220
These days, that's not
actually very much true.

104
00:05:16,190 --> 00:05:16,520
then.

105
00:05:17,230 --> 00:05:19,960
Never run stateful
workloads on Kubernetes.

106
00:05:20,170 --> 00:05:21,350
Okay, that's a harsh one.

107
00:05:21,610 --> 00:05:26,420
as I said, stuck, if you're stuck in the
past, that's true, but stateful workloads

108
00:05:26,440 --> 00:05:28,490
aren't always just like database.

109
00:05:28,510 --> 00:05:32,280
It might be the first thing people think
about and that pops into their minds.

110
00:05:32,610 --> 00:05:34,820
But in general, there's a
lot of stateful services.

111
00:05:34,870 --> 00:05:39,770
It's really hard actually to write
a fully stateless service because

112
00:05:39,800 --> 00:05:46,330
oftentimes You have like at least a
minimal, state that might be ephemeral.

113
00:05:46,330 --> 00:05:49,650
So it doesn't really matter if it
gets lost, but you want to keep

114
00:05:49,660 --> 00:05:51,710
it because it makes stuff easier.

115
00:05:51,720 --> 00:05:52,660
It makes stuff faster.

116
00:05:52,670 --> 00:05:55,950
so stateless services are
actually very hard to do.

117
00:05:56,450 --> 00:05:58,590
persistent data will kill
you because it's too slow.

118
00:05:58,650 --> 00:05:59,570
that's a good one.

119
00:05:59,700 --> 00:06:04,310
and, you might be true about that, but
I think that very much depends on you.

120
00:06:04,515 --> 00:06:08,145
Where you go in the sense
of how do I store my data?

121
00:06:08,205 --> 00:06:11,205
this is up to you find
a good data solution.

122
00:06:11,205 --> 00:06:13,765
I might be biased and say,
simply block is a good one.

123
00:06:14,035 --> 00:06:17,105
but I think this very much depends on you.

124
00:06:17,125 --> 00:06:19,655
And there's a lot of options
these days for Kubernetes.

125
00:06:19,905 --> 00:06:23,935
even simple stuff like NFS or
local hard disk, like local

126
00:06:23,935 --> 00:06:25,520
persistent storage, it's all there.

127
00:06:25,690 --> 00:06:30,270
Wouldn't say do this or we'll get back to
that later, but there's a lot of options.

128
00:06:30,280 --> 00:06:32,310
So I think that is not true.

129
00:06:32,330 --> 00:06:37,550
if you, if you say, okay, I want to plug
in a USB stick and I store my database

130
00:06:37,570 --> 00:06:40,830
on this USB stick via persistent volume.

131
00:06:41,380 --> 00:06:42,200
Be my guest.

132
00:06:42,430 --> 00:06:43,750
Don't expect it to be fast.

133
00:06:43,800 --> 00:06:45,040
nobody understands Kubernetes.

134
00:06:45,060 --> 00:06:47,950
And that is a really interesting one.

135
00:06:47,980 --> 00:06:53,190
I had to, hard, really, love to,
really hard when I saw that, that, that

136
00:06:53,250 --> 00:06:55,460
specific answer, because, Yes and no.

137
00:06:55,510 --> 00:06:56,630
there is some truth to it.

138
00:06:56,700 --> 00:06:59,510
I'm pretty sure nobody understands
Kubernetes, including the

139
00:06:59,540 --> 00:07:01,720
Kubernetes developers, including me.

140
00:07:01,940 --> 00:07:05,730
there is still a lot of things in
Kubernetes that I've never used.

141
00:07:06,390 --> 00:07:07,970
And I probably never will.

142
00:07:08,150 --> 00:07:11,630
I think it's a little bit like getting
used to programming languages, right?

143
00:07:11,640 --> 00:07:14,620
You can say you're a proficient in
a programming language, but does

144
00:07:14,620 --> 00:07:18,310
that mean you know every little bit
about those programming languages?

145
00:07:18,320 --> 00:07:19,010
No, you don't.

146
00:07:19,330 --> 00:07:23,680
But if you feel like you're not
understanding Kubernetes at all, please

147
00:07:23,680 --> 00:07:25,300
don't run a database on Kubernetes.

148
00:07:25,450 --> 00:07:27,130
Don't run an application on Kubernetes.

149
00:07:27,160 --> 00:07:29,050
Please don't run Kubernetes at all.

150
00:07:29,050 --> 00:07:33,430
if you feel like you're not understanding
anything about it, just don't use it.

151
00:07:33,760 --> 00:07:35,380
there is no need in your case.

152
00:07:35,380 --> 00:07:36,010
Most probable.

153
00:07:36,370 --> 00:07:37,960
The next one is what is your benefit?

154
00:07:38,010 --> 00:07:40,950
databases don't need to scale
or especially outer scale.

155
00:07:41,340 --> 00:07:43,590
And that one kind of confused me.

156
00:07:43,680 --> 00:07:48,310
it feels This is a person that necess
didn't necessarily run a database,

157
00:07:48,700 --> 00:07:50,855
of a size of a meaningful size.

158
00:07:51,185 --> 00:07:53,585
many databases probably
don't need to outscale.

159
00:07:53,745 --> 00:07:58,505
but especially, things were like
you, you store user behavior,

160
00:07:58,535 --> 00:08:02,815
click click flows, any kind of
iot data, all that kinda stuff.

161
00:08:02,815 --> 00:08:06,055
Databases need to outscale and out
scaling can be a lot of things.

162
00:08:06,055 --> 00:08:09,325
It could be database, it could
be compute, it could be storage.

163
00:08:09,800 --> 00:08:10,810
There's a lot of stuff.

164
00:08:11,270 --> 00:08:13,720
then databases and applications
should be separated.

165
00:08:13,720 --> 00:08:15,710
And I'm very much on par with that.

166
00:08:15,810 --> 00:08:19,400
I totally agree your database
and your applications normally

167
00:08:19,400 --> 00:08:21,120
shouldn't run on the same notes.

168
00:08:21,310 --> 00:08:24,970
and we'll see a little bit of
a solution for that later on.

169
00:08:25,190 --> 00:08:25,900
so yes.

170
00:08:26,320 --> 00:08:29,780
fully agree is not an
argument against Kubernetes.

171
00:08:30,360 --> 00:08:34,360
and the last one is actually something I
very much agree with, not another layer of

172
00:08:34,370 --> 00:08:38,680
indirection and abstraction, abstractions
and indirections can be complicated.

173
00:08:39,080 --> 00:08:42,640
they don't have to be, they're
a blessing, they're made.

174
00:08:43,255 --> 00:08:48,435
They're made in heaven as long as stuff
happens and works, because they take

175
00:08:48,435 --> 00:08:55,885
away complexity, but they can be, a beast
from hell if stuff goes down the cell or

176
00:08:55,935 --> 00:09:00,725
goes down the drain, and now you have to
figure out where stuff is actually broken.

177
00:09:00,885 --> 00:09:05,785
That is really a problem, and Kubernetes
doesn't make things easier using, all

178
00:09:05,785 --> 00:09:09,495
those like extensions for Kubernetes,
like service mesh and all that kind of

179
00:09:09,495 --> 00:09:14,485
stuff, all the things that make your
life easier, actually make it harder.

180
00:09:14,515 --> 00:09:18,015
The second you have an issue and you
try to figure out what is happening.

181
00:09:18,455 --> 00:09:24,395
So the question, I saw those answers and
I was like, ah, oh, how do, where do.

182
00:09:25,305 --> 00:09:26,855
Do I get from here, right?

183
00:09:26,875 --> 00:09:29,965
Like, how do I make this work
out for the presentation?

184
00:09:29,975 --> 00:09:32,695
I wanted to tell you about why
you actually should do that.

185
00:09:32,715 --> 00:09:33,855
and why it's a great idea.

186
00:09:33,905 --> 00:09:35,625
do I have to burn in hell now?

187
00:09:35,655 --> 00:09:36,695
this is complicated.

188
00:09:36,745 --> 00:09:38,565
What am I doing?

189
00:09:38,645 --> 00:09:40,425
I want to go to the happy place.

190
00:09:40,435 --> 00:09:43,165
So let's, how do we, how can we do this?

191
00:09:43,615 --> 00:09:46,655
So my first initial
thought, Hey, let's cheat.

192
00:09:47,265 --> 00:09:48,725
Cheating is good.

193
00:09:48,875 --> 00:09:51,845
I work for Ubisoft, so I know
what I'm talking about, right?

194
00:09:51,895 --> 00:09:53,045
I'm a big gamer.

195
00:09:53,305 --> 00:09:55,345
I know exactly what I'm talking about.

196
00:09:55,695 --> 00:10:01,025
So that is something, that a
lot of the older folks in the

197
00:10:01,025 --> 00:10:02,495
audience might actually know.

198
00:10:02,685 --> 00:10:04,375
it's the so called Konami code.

199
00:10:04,375 --> 00:10:09,215
It's probably the most known or
most well known, cheat of all times.

200
00:10:09,295 --> 00:10:11,905
for the younger generation,
just look it up on Wikipedia.

201
00:10:11,965 --> 00:10:14,675
Konami, like the gaming
company Konami code.

202
00:10:14,675 --> 00:10:15,775
it was a great pleasure.

203
00:10:16,095 --> 00:10:20,725
So now that we cheated, we can
actually go to the real topic, right?

204
00:10:20,725 --> 00:10:22,565
So where do I get from here?

205
00:10:22,605 --> 00:10:25,255
Why do we want to run
Postgres on Kubernetes?

206
00:10:25,705 --> 00:10:26,235
And I think.

207
00:10:26,700 --> 00:10:28,850
There is a good set of reasons.

208
00:10:28,920 --> 00:10:33,670
And first of all, I'm a big
hater of cloud vendor lock in.

209
00:10:33,700 --> 00:10:36,460
I think it's a really big problem.

210
00:10:36,750 --> 00:10:40,220
cloud vendors, especially
hyperscalers love to offer you all

211
00:10:40,220 --> 00:10:44,280
kinds of services, and make them
easy to integrate to lure you in.

212
00:10:44,470 --> 00:10:45,450
But the problem is.

213
00:10:45,810 --> 00:10:50,240
Those services might be nice
and might be good for the first,

214
00:10:50,490 --> 00:10:53,770
iteration, maybe the first couple
of iterations, but at some point.

215
00:10:54,165 --> 00:10:57,805
You're hitting the upper
limit of what is possible.

216
00:10:57,805 --> 00:10:59,735
Those services are meant
for the mainstream.

217
00:10:59,835 --> 00:11:03,775
They only work because they
can be used by a lot of people.

218
00:11:03,905 --> 00:11:07,485
And a lot of people means that
the second you have something

219
00:11:07,485 --> 00:11:09,585
special, there is a problem, right?

220
00:11:09,585 --> 00:11:10,465
There, they don't.

221
00:11:10,970 --> 00:11:14,340
They don't care for you anymore because
you're not part of the mainstream.

222
00:11:14,750 --> 00:11:19,760
and specifically for databases like RDS
and stuff that can come in very fast.

223
00:11:19,800 --> 00:11:22,870
If you use custom extensions
or special extensions.

224
00:11:23,100 --> 00:11:23,730
sure.

225
00:11:23,955 --> 00:11:27,485
like the standard extensions are all
available, like post GIS and stuff.

226
00:11:28,285 --> 00:11:32,995
The second you come to something like,
for example, timescale, you might have

227
00:11:33,005 --> 00:11:37,185
an old version, you might only have an
Apache license version, which doesn't have

228
00:11:37,185 --> 00:11:39,295
all the features, stuff like that, right?

229
00:11:39,315 --> 00:11:44,105
You might actually have quite the issue
really fast, even though you feel like.

230
00:11:44,685 --> 00:11:48,195
You're, you haven't outgrown
the size of something like RDS.

231
00:11:48,695 --> 00:11:50,725
faster time to market, decreasing costs.

232
00:11:50,725 --> 00:11:52,565
I think that goes and automation.

233
00:11:52,615 --> 00:11:55,065
I think that goes all
well, hand in hand, right?

234
00:11:55,065 --> 00:11:58,385
If I have everything automated, if
I have everything easily deployable,

235
00:11:59,265 --> 00:12:04,035
It's super easy to, get to Mac market
fast, do a couple of iterations, see

236
00:12:04,035 --> 00:12:06,055
if stuff works that decreases cost.

237
00:12:06,055 --> 00:12:09,235
I might actually save, one or two people.

238
00:12:09,465 --> 00:12:10,955
that is where automation comes in.

239
00:12:10,955 --> 00:12:16,865
I tell Kubernetes, Hey, or like whatever
I need, a new, postgres cluster, it spins

240
00:12:16,865 --> 00:12:21,135
it up and make sure that everything is
around, that can be a single DevOps person

241
00:12:21,155 --> 00:12:23,695
instead of a team of, database engineers.

242
00:12:23,695 --> 00:12:24,555
I'm sorry.

243
00:12:24,555 --> 00:12:27,575
I know that I'm bashing on
database engineers here.

244
00:12:27,915 --> 00:12:29,425
but don't get me wrong.

245
00:12:29,435 --> 00:12:30,805
You still have a job.

246
00:12:30,865 --> 00:12:32,505
It's just not the boring stuff.

247
00:12:32,535 --> 00:12:34,815
Now you can actually look
into the cool things, right?

248
00:12:35,075 --> 00:12:37,075
a unified deployment architecture.

249
00:12:37,075 --> 00:12:39,675
I think I'm a big lover
of that kind of stuff.

250
00:12:39,825 --> 00:12:43,145
I think, unified, architecture
makes things easy to understand.

251
00:12:43,395 --> 00:12:47,725
we have the databases deployed the
same way as we have deployed our

252
00:12:47,725 --> 00:12:49,115
application, all that kind of stuff.

253
00:12:49,125 --> 00:12:51,655
That's why people love
Terraform so much, right?

254
00:12:51,865 --> 00:12:56,095
Because Terraform gave you
like a single tool to actually

255
00:12:56,095 --> 00:12:57,405
do all this kind of stuff.

256
00:12:57,505 --> 00:13:00,745
Somebody has to write the recipes,
but it doesn't have to be you.

257
00:13:01,010 --> 00:13:03,720
and last but not least, I'm
a big fan of read replicas.

258
00:13:03,740 --> 00:13:08,970
If you have a use case where this like
small performance or a small lack of,

259
00:13:09,010 --> 00:13:13,820
data, through, physical replication is
not much of an issue and that is probably

260
00:13:13,820 --> 00:13:18,040
true for a lot of IOT use cases, like my
own startup, like Cleverbit, we actually

261
00:13:18,040 --> 00:13:23,491
have that we used read replicas quite
a lot, we, we got values or, metrics.

262
00:13:23,852 --> 00:13:28,102
like every 10 seconds, but we averaged
them on a minute scale anyway.

263
00:13:28,102 --> 00:13:32,692
So it didn't really matter if there's one
or two messages being lost or not lost,

264
00:13:32,712 --> 00:13:35,192
but not arrive on a read replica yet.

265
00:13:35,192 --> 00:13:40,322
So what we did is we literally just
spread the query load to all nodes,

266
00:13:40,382 --> 00:13:44,972
writes always went to the primary, but we
had read replicas for query, scale out.

267
00:13:45,572 --> 00:13:45,972
okay.

268
00:13:46,212 --> 00:13:48,012
now that we know why we want to do this.

269
00:13:48,977 --> 00:13:50,187
What do I get from here?

270
00:13:50,197 --> 00:13:53,167
let's get a few things out of
a way, which aren't necessarily

271
00:13:53,167 --> 00:13:54,967
like superior Postgres specific.

272
00:13:55,087 --> 00:13:58,277
from my perspective, the most
important thing, and I can't

273
00:13:58,527 --> 00:14:04,137
stress this enough, enable TLS,
enable data encryption at rest.

274
00:14:04,587 --> 00:14:06,667
You want to make sure
your data is encrypted.

275
00:14:06,747 --> 00:14:11,167
It doesn't matter if you're like a
10 people company and you feel like

276
00:14:11,167 --> 00:14:13,087
everyone can have access to the database.

277
00:14:13,237 --> 00:14:14,607
That is not the point.

278
00:14:14,887 --> 00:14:18,337
The point is make sure that
somebody from the outside.

279
00:14:18,887 --> 00:14:24,417
Can not get to your data, like at
all, like no way possible there's

280
00:14:24,417 --> 00:14:27,147
nothing worse than a data breach.

281
00:14:27,207 --> 00:14:32,127
And luckily to this day, I can
say I've not been at a company at

282
00:14:32,127 --> 00:14:36,737
least, while there was a data breach
of, of any kind, which I think is.

283
00:14:37,182 --> 00:14:37,632
Good.

284
00:14:37,682 --> 00:14:40,282
I know this is not true for other
people, and I know how I can't

285
00:14:40,282 --> 00:14:41,812
imagine how embarrassed that is.

286
00:14:42,152 --> 00:14:45,632
the problem with a software update
that basically killed all Windows

287
00:14:45,632 --> 00:14:47,342
systems just a few weeks ago, right?

288
00:14:47,612 --> 00:14:51,062
if you're on Kubernetes, use Secret,
Kubernetes Secrets used to be certificate

289
00:14:51,062 --> 00:14:53,192
manager, ertman or cert manager.

290
00:14:53,462 --> 00:14:57,162
use, the integration from
cloud providers, for credential

291
00:14:57,162 --> 00:14:58,482
management, all that kinda stuff.

292
00:14:58,827 --> 00:15:03,877
Just make sure you have security
locked down as much as possible, yay,

293
00:15:03,917 --> 00:15:05,377
we, we actually got security, right?

294
00:15:05,387 --> 00:15:09,867
Yoo hoo, okay, the other thing, think
about backups are important, and

295
00:15:09,867 --> 00:15:13,867
when I talk about backups, I don't
just mean a stupid PG dump, don't

296
00:15:13,867 --> 00:15:15,726
do this, from my perspective, okay?

297
00:15:15,807 --> 00:15:18,607
PgDump is not designed
as a backup solution.

298
00:15:18,897 --> 00:15:22,897
PgBaseBackup is okay, but please
don't try to roll your own solution.

299
00:15:23,057 --> 00:15:27,967
when we talk about backups in Postgres,
we specifically, or in most databases,

300
00:15:27,977 --> 00:15:31,937
we specifically mean continuous backup,
meaning the, that the actual writer

301
00:15:31,937 --> 00:15:34,817
headlock needs to be stored, same as.

302
00:15:35,057 --> 00:15:38,157
a database snapshot and there
is great tools for that.

303
00:15:38,167 --> 00:15:39,587
We're in the Postgres ecosystem.

304
00:15:39,587 --> 00:15:42,967
Everything has 10 plus one tools,
because with Postgres distribution

305
00:15:42,967 --> 00:15:44,097
doesn't give you those things.

306
00:15:44,107 --> 00:15:47,107
So everyone started to build their own.

307
00:15:47,217 --> 00:15:50,276
I actually have amazing
experience with PG backrest.

308
00:15:50,277 --> 00:15:52,847
it is the tool that we used, quite a lot.

309
00:15:52,897 --> 00:15:54,867
it's from my perspective, rock solid.

310
00:15:55,097 --> 00:15:59,407
I know a lot of people actually using
barman and that just works as well.

311
00:15:59,557 --> 00:16:01,857
there's PG horde and
there's so many other tools.

312
00:16:02,192 --> 00:16:06,552
my recommendation would be either go
with Barman or PgBackrest, and just use

313
00:16:06,552 --> 00:16:11,092
those tools are, industry proven, rock
solid, they are proven, they just work.

314
00:16:11,442 --> 00:16:15,792
from my perspective, that is the way
to go, and store your data somewhere

315
00:16:15,792 --> 00:16:21,392
that is not, Your own notes don't
store them somewhere in a notes, right?

316
00:16:21,462 --> 00:16:26,582
don't set up a min IO on Kubernetes
and say, Oh, I have an S3 API.

317
00:16:26,582 --> 00:16:28,152
So I can just store my backups there.

318
00:16:28,242 --> 00:16:29,552
that's not how a backup works.

319
00:16:29,742 --> 00:16:33,932
Store it to object storage,
like S3 or, cloud, cloud store

320
00:16:33,942 --> 00:16:35,962
or, blob storage or whatever.

321
00:16:36,182 --> 00:16:37,712
Just make sure they're not on your notes.

322
00:16:37,962 --> 00:16:39,982
and the other thing is test your backups.

323
00:16:40,237 --> 00:16:40,517
please.

324
00:16:40,517 --> 00:16:41,577
I can't stress this enough.

325
00:16:41,867 --> 00:16:42,787
test your backups.

326
00:16:43,287 --> 00:16:49,737
and backup testing doesn't mean like
once a year or once in a while tested

327
00:16:49,737 --> 00:16:54,767
regular, like once a month, once a week,
once every day, with my own startup, we

328
00:16:54,767 --> 00:16:56,657
actually went for like once every week.

329
00:16:57,307 --> 00:17:00,887
and the way we did it, I think
Kubernetes made this very simple for us.

330
00:17:00,937 --> 00:17:03,207
We had a Kubernetes backup, Kubernetes.

331
00:17:03,377 --> 00:17:07,027
Cluster and the cluster was basically,
one primary to read replica.

332
00:17:07,037 --> 00:17:10,337
So what we did is we just scaled
the cluster up and said, Hey,

333
00:17:10,737 --> 00:17:13,667
we need a third, read replica,
basically a four note cluster.

334
00:17:13,987 --> 00:17:15,537
it restored it from a backup.

335
00:17:15,877 --> 00:17:17,797
the notes try to join the cluster.

336
00:17:17,837 --> 00:17:21,407
So it had to set up physical
replication streamed in the remaining

337
00:17:21,407 --> 00:17:24,417
stuff that was not in the backup
and eventually joined the cluster.

338
00:17:24,767 --> 00:17:28,227
The second, it joined fully,
had the cluster fully joined and

339
00:17:28,227 --> 00:17:30,857
was able to service requests.

340
00:17:30,857 --> 00:17:33,037
We knew that our backup
strategy actually worked.

341
00:17:33,287 --> 00:17:37,487
we scaled it down again, and
Kubernetes just deleted the old

342
00:17:37,617 --> 00:17:39,557
node, whatever that was, basically.

343
00:17:39,697 --> 00:17:43,827
So we had a little bit of a rolling,
a restart, a system as well, which

344
00:17:43,827 --> 00:17:46,847
tested a few other things like
cluster health and stuff like that.

345
00:17:46,897 --> 00:17:50,877
so I think Kubernetes makes those things
like very easy and very nice to use.

346
00:17:51,722 --> 00:17:56,882
The other thing that kind of surprised me
initially when I started using Postgres

347
00:17:56,902 --> 00:18:01,052
or setting up Postgres on Kubernetes is
that the actual Postgres configuration

348
00:18:01,052 --> 00:18:03,092
isn't much influenced at all.

349
00:18:03,282 --> 00:18:06,132
you still want to configure like
your shared buffers, workman,

350
00:18:06,132 --> 00:18:07,432
blah, blah, blah, right?

351
00:18:07,492 --> 00:18:10,842
All of these standard parameters,
you're actually changing normally.

352
00:18:11,222 --> 00:18:16,312
but that doesn't mean that they, Are
influenced by how you set up Kubernetes

353
00:18:16,442 --> 00:18:18,612
or how you set up Postgres on Kubernetes.

354
00:18:18,802 --> 00:18:21,582
You need to remember that you have
a container and your container

355
00:18:21,582 --> 00:18:23,622
has like certain size limits.

356
00:18:23,632 --> 00:18:26,892
So you want to make sure that
you're actually, configuring based

357
00:18:26,892 --> 00:18:28,362
on that, but that's about it.

358
00:18:29,362 --> 00:18:34,322
The other thing is if you have no
idea about those parameters, they're

359
00:18:34,332 --> 00:18:36,542
very much, those are the easy ones.

360
00:18:36,572 --> 00:18:40,462
There is like way more advanced
ones worker sizes or worker

361
00:18:40,462 --> 00:18:41,632
numbers and stuff like that.

362
00:18:41,992 --> 00:18:45,532
if you don't feel like you have a good
idea what they mean and how they affect

363
00:18:45,532 --> 00:18:49,077
your Postgres installation, Try to get
his consultant to help you set it up.

364
00:18:49,327 --> 00:18:51,337
don't just play around with it yourself.

365
00:18:51,387 --> 00:18:54,447
I know it sounds stupid to get
a consultant for those things.

366
00:18:54,687 --> 00:18:58,097
but believe me, that
is money well invested.

367
00:18:58,187 --> 00:19:02,217
you, you get to, to a good
point, like much faster, with

368
00:19:02,387 --> 00:19:06,306
much less problems, you not over
configuration, configure Postgres.

369
00:19:06,307 --> 00:19:08,397
The worst problem is that if.

370
00:19:08,757 --> 00:19:13,447
Everything seems to work out and you get
like super fast response times and stuff.

371
00:19:13,717 --> 00:19:17,337
but when you actually put load
on the system, you have it over

372
00:19:17,337 --> 00:19:20,607
configured, you run out of memory,
stuff like that is not nice.

373
00:19:20,617 --> 00:19:23,357
So make sure you have
somebody who understands that.

374
00:19:23,787 --> 00:19:24,647
and the other thing is.

375
00:19:24,737 --> 00:19:26,117
Postgres loves used pages.

376
00:19:26,477 --> 00:19:30,467
so wherever you run Postgres, make
sure you have future pages enabled in

377
00:19:30,467 --> 00:19:32,027
your kernel settings, blah, blah, blah.

378
00:19:32,217 --> 00:19:34,757
With Kubernetes, there is like
a little bit of an issue and

379
00:19:34,757 --> 00:19:36,597
we'll get back to that later on.

380
00:19:36,637 --> 00:19:38,787
Just remember, huge pages are great.

381
00:19:39,357 --> 00:19:42,227
and because we're in the Postgres
ecosystem, much more knowledgeable

382
00:19:42,227 --> 00:19:46,357
people than me actually wrote about
that before, or even recorded a video.

383
00:19:46,427 --> 00:19:48,377
make sure that you
actually listen to them.

384
00:19:48,427 --> 00:19:52,606
they give you a lot of information
about how to, how post, Postgres

385
00:19:52,606 --> 00:19:56,436
should be configured for performance,
how you set up the, huge pages

386
00:19:56,436 --> 00:19:57,666
in Postgres and stuff like that.

387
00:19:57,716 --> 00:20:02,856
the slides are shared, as I said before,
so just follow the links afterwards

388
00:20:02,906 --> 00:20:04,156
and, you're in for a good read.

389
00:20:04,236 --> 00:20:08,516
Then you have, Postgres extensions
and that is where it becomes

390
00:20:08,576 --> 00:20:11,236
a little bit more complicated.

391
00:20:11,526 --> 00:20:16,136
You remember, when I set that, on
hyperscaler setups, you, extensions

392
00:20:16,146 --> 00:20:20,216
might already be an issue if you
have something like timescale.

393
00:20:20,336 --> 00:20:25,846
PG vector is very Common these days
to, to be seen on those setups, but

394
00:20:25,866 --> 00:20:29,586
in the first couple of months, PG
vector was still an issue, right?

395
00:20:29,586 --> 00:20:33,756
So if the second you use
extensions, you might be out

396
00:20:33,756 --> 00:20:35,546
of the scope of hosted setups.

397
00:20:35,916 --> 00:20:40,556
the problem is you might not be
out of a scope in the sense of

398
00:20:40,576 --> 00:20:42,086
when it comes to Kubernetes, right?

399
00:20:42,086 --> 00:20:44,196
So the standard image for Postgres.

400
00:20:44,891 --> 00:20:47,511
does not contain a lot of, extensions.

401
00:20:47,671 --> 00:20:51,831
And to my surprise off the, I think the
standard image doesn't even, support

402
00:20:51,831 --> 00:20:53,991
post JS, which I find very confusing.

403
00:20:54,091 --> 00:20:55,731
but, it is what it is.

404
00:20:55,841 --> 00:20:59,261
that means the second you need
extensions, you actually need to build.

405
00:20:59,611 --> 00:21:05,051
Your own layers, like image layers, Docker
image layers on top of the standard image.

406
00:21:05,301 --> 00:21:08,911
I would always start from the like
standard Postgres, like the official

407
00:21:08,911 --> 00:21:12,991
Postgres image, and then just keep
adding and installing the extensions.

408
00:21:13,491 --> 00:21:16,551
the alternative is that there is
some magic and we'll get to that

409
00:21:16,761 --> 00:21:22,341
in, later on in the presentation,
magic that I really um, the.

410
00:21:23,031 --> 00:21:29,171
Other thing that I find very important, is
to keep an eye on, on, on your versions.

411
00:21:29,261 --> 00:21:33,831
we all know that Postgres versions
can be complicated, especially when

412
00:21:33,831 --> 00:21:38,321
you do major upgrades, and you have to
run something like pgMigrate, but that

413
00:21:38,321 --> 00:21:41,126
is always an issue because you have.

414
00:21:41,366 --> 00:21:44,556
To have both Postgres versions,
the version you're running on

415
00:21:44,556 --> 00:21:48,606
right now and the version you're
wanting to go to PG 15 and PG 17.

416
00:21:49,086 --> 00:21:52,426
that is true when the data file
format actually changed and

417
00:21:52,446 --> 00:21:53,666
you have to run a migration.

418
00:21:53,896 --> 00:21:55,146
for those kinds of things, various.

419
00:21:55,401 --> 00:21:58,801
Two things to consider, as I
said, first of all, you need both

420
00:21:58,801 --> 00:22:00,621
versions of Postgres in your image.

421
00:22:00,911 --> 00:22:03,441
And secondly, you need to
double the storage because

422
00:22:03,451 --> 00:22:05,411
that is not an in place update.

423
00:22:05,631 --> 00:22:07,291
It's actually a copy operation.

424
00:22:07,301 --> 00:22:12,041
So it copies the database in the
new format to a different location.

425
00:22:12,361 --> 00:22:14,971
keep that in mind because for
a while we'll actually double

426
00:22:15,021 --> 00:22:16,241
your storage requirements.

427
00:22:16,691 --> 00:22:18,841
and for Kubernetes versions,
it's the same thing.

428
00:22:19,191 --> 00:22:19,511
it's.

429
00:22:19,721 --> 00:22:24,181
It can be complicated if you use
like a hosted managed Kubernetes,

430
00:22:24,551 --> 00:22:27,121
like AKS or EKS or whatever.

431
00:22:27,541 --> 00:22:30,331
they often only support like
the last three or four versions.

432
00:22:30,361 --> 00:22:34,301
And I think, Kubernetes provides a
new version like every three months.

433
00:22:34,351 --> 00:22:36,111
After a year, you're out of support.

434
00:22:36,521 --> 00:22:41,041
AWS just recently started to provide
extended Kubernetes support, which I

435
00:22:41,061 --> 00:22:42,901
think goes up to five or six versions.

436
00:22:43,341 --> 00:22:47,021
the second you switch from
Kubernetes to extended Kubernetes,

437
00:22:47,031 --> 00:22:48,571
you're paying 10 times the price.

438
00:22:48,581 --> 00:22:52,251
So invest that money slightly better
into somebody can actually help you

439
00:22:52,321 --> 00:22:53,691
with the migration of Kubernetes.

440
00:22:53,951 --> 00:22:56,391
So that means at least
once a year or something.

441
00:22:56,981 --> 00:23:00,101
Around that timeframe you're
in for a Kubernetes upgrade.

442
00:23:00,261 --> 00:23:01,251
keep that in mind.

443
00:23:01,281 --> 00:23:06,361
if you run your own hosted
Kubernetes, you can get around that.

444
00:23:06,731 --> 00:23:08,001
I would not recommend that.

445
00:23:08,001 --> 00:23:10,871
There's a lot of cool stuff that
comes in new Kubernetes versions,

446
00:23:11,061 --> 00:23:13,231
especially related to storage.

447
00:23:13,231 --> 00:23:14,416
So I would.

448
00:23:14,586 --> 00:23:17,746
Try to keep them up and
running as, much as possible.

449
00:23:17,866 --> 00:23:18,246
All right.

450
00:23:18,306 --> 00:23:21,996
So now that we have all of that out
of the way, and there were already

451
00:23:22,016 --> 00:23:24,206
some hints, what is really different?

452
00:23:24,256 --> 00:23:28,696
where do we have to put our thoughts
when running Postgres and Kubernetes?

453
00:23:28,696 --> 00:23:31,786
And the first and most
important one is storage, right?

454
00:23:31,836 --> 00:23:35,356
we heard that people think storage
will kill you because it's too slow.

455
00:23:35,786 --> 00:23:38,436
in Kubernetes, you have the
idea of persistent volumes.

456
00:23:38,621 --> 00:23:43,381
and persistent volume is basically
your virtual storage entity, your unit,

457
00:23:43,391 --> 00:23:45,531
whatever it is, it could be backed by NFS.

458
00:23:45,531 --> 00:23:47,071
It could be backed by local volumes.

459
00:23:47,121 --> 00:23:48,791
As I said, I think they are a bad idea.

460
00:23:49,041 --> 00:23:49,631
Don't do it.

461
00:23:49,871 --> 00:23:52,291
they could be backed by a remote storage.

462
00:23:52,411 --> 00:23:56,591
they could be backed by Amazon
EBS or cloud disk or whatever.

463
00:23:56,751 --> 00:24:00,701
there, there's a lot of options
how to get storage into Kubernetes.

464
00:24:00,971 --> 00:24:03,281
the good thing is, Kubernetes for.

465
00:24:03,571 --> 00:24:07,401
a couple of years now has the CSI
interface, which is the CSI stands

466
00:24:07,401 --> 00:24:08,711
for Container Storage Interface.

467
00:24:08,731 --> 00:24:14,261
It was designed as a pluggable
storage API for, for Kubernetes.

468
00:24:14,311 --> 00:24:17,841
But what it became is that it's now
like a more Container Storage Interface.

469
00:24:17,971 --> 00:24:19,681
Standardized container interface.

470
00:24:19,881 --> 00:24:23,461
a lot of container runtime
supported, Docker supports it.

471
00:24:23,861 --> 00:24:26,071
container D supports, cryo supports it.

472
00:24:26,571 --> 00:24:29,371
Not all providers support all backends.

473
00:24:30,071 --> 00:24:31,861
but I think that is just a matter of time.

474
00:24:31,931 --> 00:24:35,881
but for Kubernetes, CSI
drivers are the way to go.

475
00:24:36,021 --> 00:24:38,671
Make sure your CSI driver supports
encryption address, right?

476
00:24:38,671 --> 00:24:40,321
You remember, always encrypt stuff.

477
00:24:40,671 --> 00:24:43,031
make sure you find something
which is high IOPS.

478
00:24:43,091 --> 00:24:44,841
NFS might be out of the picture here.

479
00:24:45,001 --> 00:24:50,941
go for SSD and NVMe, like storages, you
want something low latency because we

480
00:24:50,941 --> 00:24:57,651
know databases love fast storage, Postgres
loves storage as fast as possible.

481
00:24:57,911 --> 00:25:01,221
so if you really want to do
something, that's a great solution.

482
00:25:01,551 --> 00:25:03,691
again, I might be biased, but I think.

483
00:25:03,921 --> 00:25:06,281
Disaggregated storage, is the best way.

484
00:25:06,341 --> 00:25:08,871
Disaggregated means that
you basically separate your

485
00:25:08,871 --> 00:25:10,441
storage from your application.

486
00:25:10,701 --> 00:25:15,916
I think this is the only meaningful
thing because databases Tend to grow

487
00:25:16,156 --> 00:25:21,126
more in data size when they tend
to grow in, compute power, right?

488
00:25:21,176 --> 00:25:25,596
new queries might introduce a higher
overhead for compute, especially

489
00:25:25,606 --> 00:25:27,406
stuff like reports and things.

490
00:25:27,856 --> 00:25:31,636
if you have something like that,
especially running reports, I would

491
00:25:31,786 --> 00:25:36,306
recommend, using a CSI provider
that can take snapshots and clones.

492
00:25:36,716 --> 00:25:41,456
and spin up a second database on the
data, on the cloned data, and run your

493
00:25:41,456 --> 00:25:43,376
report on that, throw it away afterwards.

494
00:25:43,426 --> 00:25:44,346
that would be my approach.

495
00:25:44,406 --> 00:25:49,536
But because there is so many, CSI
drivers already, I found about 150 and

496
00:25:49,546 --> 00:25:53,686
that is not all, there's way more out
there, but because it is so complicated

497
00:25:53,686 --> 00:25:55,156
to figure out what I actually want.

498
00:25:55,566 --> 00:25:59,886
I built a while ago, I built like
storage class info, that lists all of

499
00:25:59,886 --> 00:26:05,406
the CSI drivers that I found and what
the features I think they support.

500
00:26:05,696 --> 00:26:09,246
it's really hard to read the code
because not all give you all the

501
00:26:09,246 --> 00:26:10,826
information in their documentation.

502
00:26:11,106 --> 00:26:14,696
So you basically look for every single
source code and try to figure out what

503
00:26:14,696 --> 00:26:15,866
they actually support and whatnot.

504
00:26:16,146 --> 00:26:18,716
if you use something and you
find an issue, please raise.

505
00:26:19,216 --> 00:26:19,936
A bug report.

506
00:26:19,956 --> 00:26:24,436
it's a massive YAML file on,
on, GitHub, raise an issue.

507
00:26:24,636 --> 00:26:25,876
I'm happy to fix it.

508
00:26:26,116 --> 00:26:31,066
but what it gives you is like the
option to, to filter, the CSI drivers

509
00:26:31,076 --> 00:26:34,446
by, capabilities by life cycle,
by access mode, stuff like that.

510
00:26:34,656 --> 00:26:37,196
So storage class info, CSI
drivers is the way to go for you.

511
00:26:37,246 --> 00:26:40,946
the other thing is, and I hinted
at that containers, containers

512
00:26:40,956 --> 00:26:44,646
have requests, limits, and
quarters in, in Kubernetes, but.

513
00:26:44,776 --> 00:26:50,346
Are different elements, request,
they all kind of manage resources or

514
00:26:50,376 --> 00:26:52,056
available resource for your database.

515
00:26:52,516 --> 00:26:55,056
they're not necessarily
easy to understand.

516
00:26:55,086 --> 00:26:58,076
And from my perspective, that is
one of the things where you really

517
00:26:58,086 --> 00:26:59,346
have to wrap your head around.

518
00:26:59,346 --> 00:27:02,096
It's not, it's, as I said, it's not easy.

519
00:27:02,496 --> 00:27:05,446
so there's a great beginner's
guide, by Ketamite.

520
00:27:05,846 --> 00:27:07,686
read it, try to understand it.

521
00:27:07,686 --> 00:27:11,136
It was one of the things that
took me the longest to really.

522
00:27:11,316 --> 00:27:12,126
Wrap my head around.

523
00:27:12,126 --> 00:27:14,816
What is the difference
between requests and limits?

524
00:27:14,826 --> 00:27:15,886
What are quotas?

525
00:27:16,146 --> 00:27:20,216
But in general, if you have a
sizable database, Just make sure,

526
00:27:20,756 --> 00:27:25,306
or I would actually recommend just
running the database basically as the

527
00:27:25,306 --> 00:27:27,136
only thing on those specific notes.

528
00:27:27,186 --> 00:27:28,606
we'll get back to that later.

529
00:27:28,896 --> 00:27:33,446
but, that is something you really have
to understand when you're in the world,

530
00:27:33,496 --> 00:27:37,926
even for stuff like Docker, but with
Docker it's slightly different, right?

531
00:27:37,936 --> 00:27:39,726
Normally you use Docker on a single node.

532
00:27:40,036 --> 00:27:42,366
Kubernetes is all about, clusters.

533
00:27:42,696 --> 00:27:43,846
and multiple instances.

534
00:27:43,856 --> 00:27:48,696
So make sure you have that in your
mind and you'll remember pages really

535
00:27:48,706 --> 00:27:50,556
enable YouTube pages for Postgres.

536
00:27:50,836 --> 00:27:54,176
and I said, it's a little bit more
complicated with Kubernetes because

537
00:27:54,366 --> 00:27:57,506
you actually have to configure
it in the host operating system.

538
00:27:58,176 --> 00:28:00,786
So yeah, you have to go into
the Kubernetes host, like the

539
00:28:00,786 --> 00:28:04,656
worker nodes itself, and say,
yes, I want YouTube pages.

540
00:28:04,856 --> 00:28:06,276
tell the kernel about it.

541
00:28:06,706 --> 00:28:10,886
And my recommendation is tell the kernel
also that you want to have a certain

542
00:28:10,886 --> 00:28:16,506
amount of memory, reserved for huge pages,
because then the kernel at boot time will,

543
00:28:16,986 --> 00:28:20,906
reserve a huge chunk of memory just for
you, like a continuous chunk of memory,

544
00:28:21,026 --> 00:28:22,486
and that is what you want for huge pages.

545
00:28:22,496 --> 00:28:26,846
Huge pages are a great thing to
minimize memory, allocation overhead.

546
00:28:27,086 --> 00:28:30,046
The thing with Kubernetes is that
you actually have to configure

547
00:28:30,046 --> 00:28:31,576
it basically three times.

548
00:28:31,596 --> 00:28:33,966
So you have to configure it in
your host operationing system.

549
00:28:34,246 --> 00:28:37,396
You have to tell the, in the
deployment descriptor, in the

550
00:28:37,396 --> 00:28:41,846
resource descriptor, that this
part or this container specifically

551
00:28:41,846 --> 00:28:43,356
is supposed to use huge pages.

552
00:28:43,626 --> 00:28:46,866
So you get access to them because
they basically have to be mapped

553
00:28:46,866 --> 00:28:50,046
into your container around
time or container environment.

554
00:28:50,306 --> 00:28:50,466
And.

555
00:28:51,031 --> 00:28:54,381
Tell Postgres that there is
each pages available, right?

556
00:28:54,431 --> 00:28:56,571
great read from the Percona guys.

557
00:28:56,621 --> 00:28:59,361
people that are much more
knowledgeable in running massive

558
00:28:59,401 --> 00:29:01,201
Postgres Kubernetes, set up.

559
00:29:01,201 --> 00:29:03,291
So those are the guys to ask.

560
00:29:03,331 --> 00:29:05,111
Then there is high availability.

561
00:29:05,161 --> 00:29:07,721
And, as I said, Kubernetes
is all about clusters.

562
00:29:07,731 --> 00:29:09,951
So it's really something
you want to look into.

563
00:29:10,751 --> 00:29:12,291
and I think it's important, right?

564
00:29:12,351 --> 00:29:16,051
now that we have Kubernetes, the
only meaningful thing is to run.

565
00:29:16,336 --> 00:29:20,136
Postgres as a cluster and I
personally have Massive, like

566
00:29:20,136 --> 00:29:21,616
good experience with Patroni.

567
00:29:21,726 --> 00:29:23,286
I think Patroni is awesome.

568
00:29:23,916 --> 00:29:27,706
I think it's also the most deployed,
a high available, high availability

569
00:29:27,706 --> 00:29:32,946
and sorry, and cluster manager, but
there's also rep manager and, PG

570
00:29:32,976 --> 00:29:34,516
out of failover and stuff like that.

571
00:29:35,416 --> 00:29:37,246
just make sure you use a cluster manager.

572
00:29:37,296 --> 00:29:38,736
you want automatic failover.

573
00:29:38,766 --> 00:29:39,826
You want to have.

574
00:29:39,846 --> 00:29:42,026
Primary, promotion, stuff like that.

575
00:29:42,346 --> 00:29:44,516
there's a great set of tools.

576
00:29:44,556 --> 00:29:46,786
I would always recommend
just going with Patroni.

577
00:29:47,116 --> 00:29:51,226
the most interesting thing about
Patroni for me specifically was

578
00:29:51,246 --> 00:29:53,256
that it is developed by Zalando.

579
00:29:53,506 --> 00:29:54,736
Zalando to me was.

580
00:29:55,356 --> 00:29:58,196
a company selling shoes
and clothes, right?

581
00:29:58,256 --> 00:29:58,956
Stuff like that.

582
00:29:59,236 --> 00:30:02,906
it was not necessarily like a high
tech company, but what I figured out

583
00:30:02,906 --> 00:30:07,496
is that basically all of the database
setup at Zalando, is Postgres.

584
00:30:08,036 --> 00:30:09,236
And so it makes sense.

585
00:30:09,246 --> 00:30:11,406
We're pretty deep into
the Postgres ecosystem.

586
00:30:11,906 --> 00:30:17,076
the other thing, and that is one of
the things again, that you can't really

587
00:30:17,076 --> 00:30:19,536
stress enough connection pooling.

588
00:30:20,026 --> 00:30:24,036
I would claim never run Postgres
without connection pooling at all.

589
00:30:24,186 --> 00:30:26,366
connection pooling is basically
a proxy in between your

590
00:30:26,366 --> 00:30:28,226
database and your application.

591
00:30:28,526 --> 00:30:31,966
And the reason you want that is
because Postgres really doesn't like

592
00:30:32,006 --> 00:30:33,816
connections being opened and closed.

593
00:30:34,056 --> 00:30:35,926
connection management is very expensive.

594
00:30:36,221 --> 00:30:40,931
in Postgres, so using a connection pool
or keeping connect back end connections

595
00:30:40,931 --> 00:30:45,991
to the database open, while, having
the option to the front to give to

596
00:30:45,991 --> 00:30:50,071
the clients and say, Hey, just do
whatever you want is, removing a lot

597
00:30:50,071 --> 00:30:54,331
of overhead or resource utilization
from Postgres stuff that shouldn't

598
00:30:54,341 --> 00:30:56,791
really be in Postgres at all, right?

599
00:30:56,851 --> 00:30:59,091
Um, the other thing is.

600
00:30:59,491 --> 00:31:02,361
When you go into the cloud,
especially when you go for like

601
00:31:02,431 --> 00:31:05,801
serverless, environments and
serverless, infrastructures or

602
00:31:05,801 --> 00:31:09,581
application architectures, now
it really becomes a thing, right?

603
00:31:09,851 --> 00:31:12,171
you're starting and stopping functions.

604
00:31:13,016 --> 00:31:14,296
on a second basis.

605
00:31:14,656 --> 00:31:18,776
And now imagine I said, as I said,
Postgres doesn't like connections being

606
00:31:18,776 --> 00:31:23,106
open and close, but if you start your
function and you close it down, you're

607
00:31:23,136 --> 00:31:24,886
opening a connection, you're closing it.

608
00:31:25,266 --> 00:31:27,736
at that point, you really want
to go into connection pooling.

609
00:31:27,886 --> 00:31:31,606
So in general, if you don't use
connection pooling now or as of

610
00:31:31,656 --> 00:31:35,276
now is the time to, to fix that,
schedule a maintenance for tomorrow.

611
00:31:35,776 --> 00:31:38,656
but there's a couple of more things
it actually, together with something

612
00:31:38,666 --> 00:31:42,236
like Petroni, connection poolers
really nicely handle fail overs.

613
00:31:42,276 --> 00:31:45,376
They handle the switching of primaries.

614
00:31:45,396 --> 00:31:47,696
Your application doesn't
need to know about stuff.

615
00:31:47,966 --> 00:31:52,278
they often support like an,
an internal retries of stuff

616
00:31:52,458 --> 00:31:53,938
fails for the first iteration.

617
00:31:53,948 --> 00:31:57,098
They just switch over and go back.

618
00:31:57,388 --> 00:31:59,188
All of that kind of stuff is really nice.

619
00:31:59,498 --> 00:32:02,308
Um, and only give you
like the error afterwards.

620
00:32:02,358 --> 00:32:06,058
But, on the other hand, it also
handles, the read replica setup.

621
00:32:06,368 --> 00:32:08,978
if you have read replicas and
you say, okay, I want to use

622
00:32:08,978 --> 00:32:11,248
those as actual query targets.

623
00:32:11,428 --> 00:32:14,738
all of those tools support
reading from read replicas.

624
00:32:14,788 --> 00:32:17,918
I personally prefer, and I know
it's controversial, PGPool2.

625
00:32:18,688 --> 00:32:20,228
but there's also PGBouncer.

626
00:32:20,468 --> 00:32:24,798
just make sure not everything that
looks like a read only query like

627
00:32:24,798 --> 00:32:28,348
a select query, might actually be
non mutating, with timescale, we

628
00:32:28,348 --> 00:32:31,998
have, create hyper table, which is a
mutating operation, but because it's

629
00:32:31,998 --> 00:32:33,528
a function, it's called by select.

630
00:32:33,788 --> 00:32:37,058
So sometimes you have to tell those
proxies, hey, those are operations,

631
00:32:37,068 --> 00:32:39,748
or those are queries we specifically
want to send to the client.

632
00:32:39,933 --> 00:32:42,363
to the, primary, for write operations.

633
00:32:42,423 --> 00:32:43,973
then you have, Kubernetes features.

634
00:32:43,973 --> 00:32:46,713
We're in Kubernetes, so use
stateful sets, use replica sets.

635
00:32:47,043 --> 00:32:47,963
all that kind of stuff.

636
00:32:48,143 --> 00:32:52,223
Interestingly enough, Timescale
just a week or two ago, promoted, or

637
00:32:52,223 --> 00:32:55,943
released a blog post about how they
removed stateful set with the new

638
00:32:56,198 --> 00:33:00,528
abstraction because stateful sets
are very limited in what they can do.

639
00:33:00,578 --> 00:33:02,348
so go and read that one.

640
00:33:02,378 --> 00:33:03,888
you can find it on the timescale block.

641
00:33:03,888 --> 00:33:04,918
You really want to see that.

642
00:33:05,398 --> 00:33:08,108
then network policies,
you remember, right?

643
00:33:08,138 --> 00:33:12,528
Use network policies that there's
TLS, enable it as much as possible.

644
00:33:12,788 --> 00:33:14,298
Use security policies.

645
00:33:14,528 --> 00:33:18,318
If your setup has role based
access control, that's something

646
00:33:18,318 --> 00:33:19,698
you really want to set up as well.

647
00:33:20,143 --> 00:33:23,663
think about policy managers, various
OPA, the open policy agent, various

648
00:33:23,683 --> 00:33:25,853
Kubernetes, be careful with those.

649
00:33:25,923 --> 00:33:27,623
I would recommend thinking about those.

650
00:33:27,643 --> 00:33:32,183
They're basically sitting in between like
your API client and the Kubernetes API.

651
00:33:32,423 --> 00:33:35,853
and they can prevent stuff like,
Hey, there's some container

652
00:33:35,863 --> 00:33:37,283
that wants to mount a volume.

653
00:33:37,618 --> 00:33:39,958
but it's not one of the
database containers.

654
00:33:40,218 --> 00:33:42,328
so you really want to prevent that, right?

655
00:33:42,338 --> 00:33:45,928
You don't want to have, potentially
arbitrarily injected container,

656
00:33:46,228 --> 00:33:48,118
running, mounting your database volume.

657
00:33:48,398 --> 00:33:51,128
The only problem is, I heard
that at least about Kubernetes.

658
00:33:51,418 --> 00:33:52,508
you want to be careful.

659
00:33:52,548 --> 00:33:56,769
Kubernetes has the, Default of preventing
all access, which we're blocking

660
00:33:56,769 --> 00:33:58,679
all access, which sounds meaningful.

661
00:33:59,029 --> 00:34:03,329
but at least for that person, Coverno,
the Converno containers itself died.

662
00:34:03,389 --> 00:34:06,929
and they couldn't restore it because
Coverno didn't have access to be.

663
00:34:07,149 --> 00:34:09,999
Kubernetes APIs in order to
be Kubernetes APIs anymore.

664
00:34:10,249 --> 00:34:11,549
So there can be problems.

665
00:34:11,609 --> 00:34:11,989
be careful.

666
00:34:12,019 --> 00:34:15,649
then there is, observability and
I think our alerting, make sure

667
00:34:15,649 --> 00:34:19,229
that you have a good monitoring
observability tool in place.

668
00:34:19,559 --> 00:34:23,849
unfortunately for, Postgres, Prometheus
is still the best thing we have.

669
00:34:23,909 --> 00:34:28,319
I hope that this will change in the
future, but it does an okay job.

670
00:34:28,569 --> 00:34:32,499
collect locks, make sure that your
locks are actually, More than, I don't

671
00:34:32,499 --> 00:34:36,359
know, like a gigabyte or the last
10, 000 entries or stuff like that.

672
00:34:36,369 --> 00:34:40,419
If you have an issue, 10, 000
lines of lock messages might

673
00:34:40,419 --> 00:34:42,069
be over really fast, right?

674
00:34:42,069 --> 00:34:46,729
So use one of the tools, the
typical, lock collection tools,

675
00:34:46,979 --> 00:34:49,069
aggregate, analyze, trace.

676
00:34:49,609 --> 00:34:51,519
I would always go for full observability.

677
00:34:51,519 --> 00:34:55,739
You remember I work for Instana,
and, observability basically

678
00:34:55,739 --> 00:34:58,649
gives you an insight into the
whole stack from front to back.

679
00:34:59,519 --> 00:35:01,939
that means don't roll your own.

680
00:35:01,989 --> 00:35:02,849
you might've figured it.

681
00:35:02,849 --> 00:35:04,649
I'm not a big fan of
rolling your own stuff.

682
00:35:04,829 --> 00:35:06,259
use a tool like Datadoc.

683
00:35:06,369 --> 00:35:09,379
I'm not sure about Instana
as it was acquired by IBM.

684
00:35:09,419 --> 00:35:12,529
these days, most of the
development goes to IBM technology,

685
00:35:12,669 --> 00:35:13,439
but there is other things.

686
00:35:13,439 --> 00:35:14,259
There's Steinertrace.

687
00:35:14,259 --> 00:35:14,759
There's New Relic.

688
00:35:14,789 --> 00:35:15,869
There's Grafana.

689
00:35:15,869 --> 00:35:18,739
There's I don't know what
else, use one of those tools.

690
00:35:18,889 --> 00:35:19,979
you're in for a good game.

691
00:35:20,539 --> 00:35:24,279
and then is the point where all
of that comes together, right?

692
00:35:24,289 --> 00:35:28,529
Like the little bit of okay,
here we are, with Postgres.

693
00:35:29,029 --> 00:35:30,689
We have to configure a lot of stuff.

694
00:35:30,689 --> 00:35:32,969
We need to make sure that
we have high availability.

695
00:35:32,979 --> 00:35:35,189
We need to make sure that
our backups are set up.

696
00:35:35,729 --> 00:35:37,509
we need, automatic failover.

697
00:35:37,559 --> 00:35:39,079
we all need all that kind of stuff.

698
00:35:39,189 --> 00:35:43,549
and while Helm charts are okay, they
are a static setup system, right?

699
00:35:43,549 --> 00:35:46,969
So Helm charts help you with
the initial, static, deployment.

700
00:35:47,029 --> 00:35:49,559
They don't help you with the
day by day operation setup.

701
00:35:50,394 --> 00:35:52,804
And that is where operators
in general come in.

702
00:35:52,804 --> 00:35:54,863
Kubernetes operators, in this
case, specifically a Postgres

703
00:35:54,864 --> 00:35:59,244
Kubernetes operators, they take
away a lot of the tasks for setup.

704
00:35:59,254 --> 00:36:02,814
They make sure that everything runs,
they make sure that, you can scale

705
00:36:02,824 --> 00:36:06,814
out, scale in, they bring this like
feeling of cloud native to Postgres.

706
00:36:06,834 --> 00:36:10,394
Whereas that's a little
bit of a far fetched thing.

707
00:36:10,394 --> 00:36:14,824
And when we see that in the last slide,
but it integrates Postgres really nice

708
00:36:14,824 --> 00:36:17,084
with Kubernetes, where that is also.

709
00:36:17,364 --> 00:36:18,814
Depending on the operator.

710
00:36:19,044 --> 00:36:21,614
So there is a few operators
and that's not all of them.

711
00:36:21,674 --> 00:36:24,154
if you're, but I think
those are like the big ones.

712
00:36:24,364 --> 00:36:27,584
if you're in for a very
old version, like 9.

713
00:36:27,584 --> 00:36:30,184
6, you're, there's no way
around QDB, the other ones

714
00:36:30,274 --> 00:36:32,394
don't even support that anymore.

715
00:36:32,624 --> 00:36:36,754
Zalando again, from my perspective,
CloudNativePG and StackRest

716
00:36:36,754 --> 00:36:38,344
from Ungrost are the ways to go.

717
00:36:38,364 --> 00:36:40,164
those are like the big new.

718
00:36:40,229 --> 00:36:42,729
Commerce or upcomers from my perspective.

719
00:36:42,979 --> 00:36:46,259
we see that all of these standard
features are all supported where it

720
00:36:46,349 --> 00:36:49,159
falls apart a little bit is backups.

721
00:36:49,399 --> 00:36:51,379
And that is something I
really find confusing.

722
00:36:51,499 --> 00:36:52,209
we're all about.

723
00:36:53,174 --> 00:36:57,524
automation in Kubernetes, but Crunchy
and Zalando don't really support

724
00:36:57,794 --> 00:37:01,014
Kubernetes which, backups, which are
nicely integrated into Kubernetes.

725
00:37:01,044 --> 00:37:05,414
I think that's an oversight, might be
fixed in the future, but it's confusing.

726
00:37:05,624 --> 00:37:10,514
the other thing, that I think
are, is important, use, that they

727
00:37:10,524 --> 00:37:13,944
use a default Postgres image,
like the official standard image.

728
00:37:13,994 --> 00:37:15,744
Cloud Native PG doesn't actually do this.

729
00:37:16,144 --> 00:37:18,074
so I'm a little bit confused about that.

730
00:37:18,314 --> 00:37:22,264
you see that stack rest is the only
one that has all the check marks.

731
00:37:22,294 --> 00:37:26,054
If you really need a web UI, I
think that's up to you or to decide.

732
00:37:26,104 --> 00:37:30,054
but as I said, cloud native PG stack
rest, both are great solutions.

733
00:37:30,164 --> 00:37:31,504
both are great options.

734
00:37:31,524 --> 00:37:31,699
very simple.

735
00:37:32,059 --> 00:37:34,169
Absolutely nothing to say
anything against them.

736
00:37:34,349 --> 00:37:36,519
The only things Dekris
has like a cool feature.

737
00:37:36,519 --> 00:37:38,269
You remember the magic for image layers?

738
00:37:38,499 --> 00:37:42,539
they can, they actually have a virtual
image repository where they take the

739
00:37:42,539 --> 00:37:46,189
standard image and then you say, Hey, I
want this extension and this extension.

740
00:37:46,199 --> 00:37:50,559
They spin up virtual image layers
with the extension code, on the fly.

741
00:37:50,569 --> 00:37:51,779
And that even works at runtime.

742
00:37:51,789 --> 00:37:52,909
You can say, Hey, I want this.

743
00:37:52,939 --> 00:37:56,029
And it magically appears in your
image and you can just load it.

744
00:37:56,729 --> 00:37:59,749
but again, There's more people
that actually wrote about that.

745
00:37:59,769 --> 00:38:02,769
in this case, I actually wrote the
first one, but there's Operator Hub.

746
00:38:02,789 --> 00:38:06,959
anything Kubernetes operators,
that's your, first, way to go.

747
00:38:06,989 --> 00:38:12,669
And the, data on Kubernetes community,
created a massive Postgres specification,

748
00:38:12,709 --> 00:38:15,895
operator specification with all
features for Postgres and, and

749
00:38:15,895 --> 00:38:17,435
operators and how they are supported.

750
00:38:17,655 --> 00:38:20,185
And I think there's over 30,
Postgres operators in there.

751
00:38:20,465 --> 00:38:22,215
So you really want to look into that.

752
00:38:22,870 --> 00:38:25,180
It doesn't have a nice UI yet,
but we're working on that.

753
00:38:25,520 --> 00:38:30,580
the last thing, when you have a meaningful
size database, so anything that needs to

754
00:38:30,580 --> 00:38:36,140
scale, make sure that you use dedicated
machines for your databases, use, node

755
00:38:36,170 --> 00:38:41,330
pools, dedicate a certain set of nodes
in an, or dedicate a node pool to

756
00:38:41,330 --> 00:38:45,130
your database, to your primary and to
reach replicas, make sure that those.

757
00:38:45,490 --> 00:38:49,530
containers or the database containers are
pinned to those hosts, taint the hosts

758
00:38:49,530 --> 00:38:53,400
so that nothing else is running in it,
at it except like the standard Kubernetes

759
00:38:53,400 --> 00:38:55,470
services like kube, kube proxy and stuff.

760
00:38:55,810 --> 00:38:56,960
but that's about it, right?

761
00:38:57,650 --> 00:39:02,750
Make sure your database has
basically all the resources and

762
00:39:02,780 --> 00:39:08,435
use Kubernetes for automation, for
orchestration, Not for virtualization

763
00:39:08,445 --> 00:39:10,285
in the sense of over provisioning.

764
00:39:10,385 --> 00:39:14,465
I think your database still deserves
as much resources as possible.

765
00:39:14,545 --> 00:39:17,205
so with that, I think we're at the end.

766
00:39:17,395 --> 00:39:19,685
A lot of you might know Kelsey Hightower.

767
00:39:20,265 --> 00:39:23,265
I normally say when Kelsey
speaks, the world listens.

768
00:39:23,535 --> 00:39:29,285
And Kate Kelsey had a few things to say
about Postgres or databases on Kubernetes,

769
00:39:29,535 --> 00:39:33,165
which is you can run a database on
Kubernetes because it's fundamentally

770
00:39:33,165 --> 00:39:35,385
the same as running a database on a VM.

771
00:39:35,670 --> 00:39:36,020
okay.

772
00:39:36,040 --> 00:39:36,790
So far, so good.

773
00:39:37,060 --> 00:39:37,900
Oh, we can do that.

774
00:39:38,160 --> 00:39:41,640
The biggest challenge is to understand
that rubbing Kubernetes on Postgres

775
00:39:41,640 --> 00:39:43,980
won't magically turn it into Cloud SQL.

776
00:39:44,320 --> 00:39:48,640
So what he's saying is just because
Postgres now runs on Kubernetes, it

777
00:39:48,640 --> 00:39:53,940
doesn't mean it gives you this, Proclaimed
infinite scalability of something like

778
00:39:53,940 --> 00:39:56,060
Cloud SQL or Aurora or stuff like that.

779
00:39:56,350 --> 00:40:00,150
You're getting close and you can
scale out, with the necessary,

780
00:40:00,480 --> 00:40:01,660
correct storage underneath.

781
00:40:01,690 --> 00:40:07,290
You can get very far, but I also say
most people or most companies probably

782
00:40:07,290 --> 00:40:08,850
don't need something like Cloud SQL.

783
00:40:08,880 --> 00:40:12,450
It's a very overhyped, unnecessary thing.

784
00:40:12,450 --> 00:40:14,990
From my perspective, it makes
stuff easy to get started.

785
00:40:15,395 --> 00:40:17,555
I would claim this is
not where we need to go.

786
00:40:18,515 --> 00:40:22,925
Anyway, the data on Kubernetes
community is, anything data,

787
00:40:22,975 --> 00:40:24,625
stateful workloads on Kubernetes.

788
00:40:24,655 --> 00:40:29,145
it's mostly like a lot of the people
that initially started implementing

789
00:40:29,145 --> 00:40:33,205
stateful workloads on Kubernetes and
the stateful set and a state stuff

790
00:40:33,205 --> 00:40:37,075
like that, they eventually, joined
together in the, doc, community.

791
00:40:37,315 --> 00:40:38,505
they wrote an amazing.

792
00:40:38,740 --> 00:40:43,100
white paper on data on Kubernetes,
read it, go with that, and

793
00:40:43,300 --> 00:40:45,680
that's it, thank you very much.

