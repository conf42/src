1
00:00:00,330 --> 00:00:04,110
AI is reshaping how we build
and shape software, not

2
00:00:04,110 --> 00:00:06,570
gradually, but in giant leaps.

3
00:00:07,020 --> 00:00:11,700
It's writing code, generating
infrastructure, fixing tests, reviewing

4
00:00:11,700 --> 00:00:15,730
pull requests, and making decisions
inside our pipelines that used to

5
00:00:15,730 --> 00:00:18,845
require a human for the first time.

6
00:00:19,305 --> 00:00:22,845
The pace of delivery isn't set by
developers or release managers.

7
00:00:23,595 --> 00:00:28,395
It's said by automation and
specifically AI driven automation.

8
00:00:28,965 --> 00:00:32,115
That means something
fundamental has shifted.

9
00:00:32,895 --> 00:00:37,635
We're delivering faster than
ever, but the guardrails we have

10
00:00:37,635 --> 00:00:39,735
relied on for the past decade.

11
00:00:39,735 --> 00:00:47,475
Were not designed for systems that think,
respond and adapt, and that gap between

12
00:00:47,475 --> 00:00:50,805
how fast AI can move and how slowly.

13
00:00:51,210 --> 00:00:56,820
Traditional security evolves is exactly
what we need to talk about, because if

14
00:00:56,820 --> 00:01:02,850
we don't redesign our security for the AI
era, AI won't just accelerate delivery.

15
00:01:03,420 --> 00:01:05,580
It will accelerate risk.

16
00:01:06,240 --> 00:01:08,640
So today's session is about one idea.

17
00:01:09,240 --> 00:01:15,090
How do we make AI driven delivery
secure by default, not by policy, not

18
00:01:15,090 --> 00:01:18,840
by hope, not by heroics, but by design.

19
00:01:20,610 --> 00:01:23,820
So before we dive into the technical
depth of the talk, let me give

20
00:01:23,820 --> 00:01:27,660
you a quick sense of who I am and
where my perspective come from.

21
00:01:27,810 --> 00:01:28,620
I'm Don Hammed.

22
00:01:28,680 --> 00:01:32,580
I serve as the principal developer
advocate at Harness a company with a

23
00:01:32,580 --> 00:01:37,650
simple but ambitious mission to help
every software engineering team deliver

24
00:01:37,650 --> 00:01:40,920
code quickly, reliably, and efficiently.

25
00:01:41,670 --> 00:01:45,525
If your team is trying to ship fast,
but not break production in the process.

26
00:01:46,229 --> 00:01:48,809
Harness exists for exactly that reason.

27
00:01:49,410 --> 00:01:53,789
Before this role, I spent over 15 years
working across the software delivery

28
00:01:53,789 --> 00:02:00,030
lifecycle as a Java backend developer, QA
lead consultant, and later in advocacy.

29
00:02:00,780 --> 00:02:05,280
I have worked for both small
companies, large enterprise, and on

30
00:02:05,280 --> 00:02:08,220
government projects with one goal.

31
00:02:08,880 --> 00:02:11,940
I wanted to help teams ship software.

32
00:02:12,270 --> 00:02:15,270
With confidence and security baked in.

33
00:02:15,990 --> 00:02:19,170
I live on the East coast and
outside of work I spend a lot of

34
00:02:19,170 --> 00:02:23,940
time giving back to the community
by free resume reviews on LinkedIn.

35
00:02:24,900 --> 00:02:26,340
Alright, enough about me.

36
00:02:26,640 --> 00:02:33,420
Now let's dive into the perspective
of secure Pipeline in the AI era.

37
00:02:35,610 --> 00:02:37,079
Now, here's the dream.

38
00:02:37,170 --> 00:02:41,520
A pipeline that flows in this
beautifully simple, linear way.

39
00:02:41,835 --> 00:02:46,215
You write code, you build it,
you run security, you deploy,

40
00:02:46,815 --> 00:02:48,255
and then you monitor and audit.

41
00:02:48,465 --> 00:02:49,965
Just like the textbooks say.

42
00:02:50,505 --> 00:02:54,285
It's so clean and so orderly
that you could imagine it on a

43
00:02:54,285 --> 00:02:56,895
DevSecOps brochure or a pamphlet.

44
00:02:57,195 --> 00:03:01,755
If you're in the Europe, everything
behaves exactly the way you think it will.

45
00:03:02,055 --> 00:03:04,485
Nothing surprising, nothing out of place.

46
00:03:04,725 --> 00:03:08,865
You push changes and the pipeline gently
moves them through, through production,

47
00:03:08,865 --> 00:03:10,785
like a well-behaved assembly line.

48
00:03:11,475 --> 00:03:15,795
This is the image we all have in our
heads when we think about our DevSecOps

49
00:03:15,795 --> 00:03:21,165
done right is the idealized version, the
Instagram version of software delivery.

50
00:03:21,735 --> 00:03:23,175
But here's a problem.

51
00:03:23,565 --> 00:03:25,875
This is not how real pipelines work.

52
00:03:26,325 --> 00:03:31,905
Real pipelines are messy, real
pipelines are unpredictable, and

53
00:03:31,905 --> 00:03:36,915
most importantly, real pipelines
have layers of hidden complexity.

54
00:03:37,245 --> 00:03:39,465
That this simple diagram doesn't show.

55
00:03:39,975 --> 00:03:45,225
So let's move Zoom in because the moment
you inspect the details, this perfect

56
00:03:45,225 --> 00:03:47,269
pipeline start to look very different.

57
00:03:48,645 --> 00:03:52,785
So now this, and this is closer
to reality, let's break it down

58
00:03:53,235 --> 00:03:57,675
because each stage here represents a
failure mode we have all encountered.

59
00:03:58,395 --> 00:04:02,265
So we start with a base
image or dependency set that

60
00:04:02,265 --> 00:04:03,705
hasn't been touched in years.

61
00:04:04,575 --> 00:04:08,205
It's packed with vulnerabilities,
not because anyone is negligent,

62
00:04:08,715 --> 00:04:12,795
but because teams are juggling so
many priorities that updating the

63
00:04:12,795 --> 00:04:15,225
foundation gets deprioritized.

64
00:04:15,585 --> 00:04:20,235
So right from the first step, we're
injecting risk directly into the pipeline.

65
00:04:21,255 --> 00:04:25,515
Next, the build stretch proudly
announces all test passed,

66
00:04:25,905 --> 00:04:27,435
but when you look closely.

67
00:04:27,620 --> 00:04:32,780
You found out that only a tiny silver
of a code base is actually tested.

68
00:04:33,230 --> 00:04:36,020
This is like checking only
the headlights on a car and

69
00:04:36,020 --> 00:04:38,240
declaring it road trips ready.

70
00:04:38,720 --> 00:04:41,600
It's technically true,
but practically useless.

71
00:04:43,070 --> 00:04:44,240
Next comes security.

72
00:04:44,300 --> 00:04:48,350
So SaaS and das are there
in theory, but in practiced.

73
00:04:48,690 --> 00:04:50,039
They're often skipped.

74
00:04:50,370 --> 00:04:52,260
Maybe scans take too long.

75
00:04:52,440 --> 00:04:56,010
Maybe someone's under pressure to
meet a deadline, and because the

76
00:04:56,010 --> 00:05:01,110
system isn't enforcing anything, the
pipeline just shrugs and moves on.

77
00:05:02,400 --> 00:05:06,000
Then we deploy everything all at once.

78
00:05:06,055 --> 00:05:10,155
No calories, no blue, green,
no gradual rollout, just.

79
00:05:10,800 --> 00:05:13,290
Ship it and hope nothing explodes.

80
00:05:14,190 --> 00:05:18,660
Monitoring fires, alerts only after
the application is already throwing.

81
00:05:18,660 --> 00:05:20,100
HTPs five hundreds.

82
00:05:20,520 --> 00:05:25,320
There's no early warnings, no behavioral
signal, only catastrophic detection.

83
00:05:26,250 --> 00:05:29,940
And finally, audit becomes
a manual guessing game.

84
00:05:30,480 --> 00:05:35,040
No continuous compliance, no real
traceability, just someone asking.

85
00:05:35,430 --> 00:05:37,290
So is production on fire?

86
00:05:37,920 --> 00:05:39,585
The point of this slide is simple.

87
00:05:40,349 --> 00:05:46,080
The ideal pipeline fails because
it ignores reality, and AI is about

88
00:05:46,080 --> 00:05:51,599
to amplify all of these weakness,
which brings us to our next slide.

89
00:05:52,590 --> 00:05:57,510
So over the last decade, we became
experts at automating delivery.

90
00:05:57,599 --> 00:06:02,400
We built modern CICD pipelines, shifted,
left, shifted everywhere, and for the

91
00:06:02,400 --> 00:06:04,590
first time in the industry's history.

92
00:06:05,145 --> 00:06:10,485
We actually had a clear, well
established path from code to production.

93
00:06:11,085 --> 00:06:14,925
Think of that pipeline as a set
of carefully laid train tracks.

94
00:06:15,435 --> 00:06:20,055
A lot of hard work went into getting
them stable, predictable, and safe

95
00:06:20,055 --> 00:06:22,065
enough to run at reasonable speed.

96
00:06:23,235 --> 00:06:24,945
And then we added ai.

97
00:06:25,485 --> 00:06:27,344
That's the bullet train
you see on the slide.

98
00:06:27,555 --> 00:06:28,635
AI writes code.

99
00:06:28,665 --> 00:06:30,165
It generates configuration.

100
00:06:30,195 --> 00:06:31,905
It proposes infrastructure.

101
00:06:32,235 --> 00:06:35,925
It drafts remediation, automatic
decisions, and accelerates

102
00:06:36,015 --> 00:06:38,385
everything we feed into the pipeline.

103
00:06:39,945 --> 00:06:41,625
But here's the critical problem.

104
00:06:42,435 --> 00:06:46,755
We added the bullet train before
checking whether the tracks could

105
00:06:46,755 --> 00:06:52,094
handle it, the rails, our processes,
our guard rails, our security models.

106
00:06:53,025 --> 00:06:58,034
We're built for a slower world, and
the moment you increase speed without

107
00:06:58,034 --> 00:07:02,745
increasing safety, the consequences
aren't just faster delivery.

108
00:07:03,195 --> 00:07:04,695
They're faster failures.

109
00:07:05,205 --> 00:07:08,715
This is the core tension
of modern DevSecOps.

110
00:07:08,865 --> 00:07:11,115
AI doesn't fix broken process.

111
00:07:11,235 --> 00:07:17,865
AI amplifies them and that leads
directly into our next problem, the

112
00:07:17,865 --> 00:07:20,925
real world impact we are already seeing.

113
00:07:24,854 --> 00:07:26,354
Here's the first data point.

114
00:07:26,625 --> 00:07:33,075
76% of enterprises, not startups,
experiment experimenting, not

115
00:07:33,075 --> 00:07:38,414
hobby projects, but established
enterprises have already experienced

116
00:07:38,445 --> 00:07:40,125
a prompt injection incident.

117
00:07:41,730 --> 00:07:46,380
Prompt injection is one of the
simplest attacks against AI systems,

118
00:07:46,470 --> 00:07:49,170
and yet it's incredibly powerful.

119
00:07:49,680 --> 00:07:51,630
An attacker doesn't exploit code.

120
00:07:51,780 --> 00:07:53,490
They exploit behavior.

121
00:07:54,240 --> 00:07:59,880
They manipulate the model's, instructions,
override guardrails, or change

122
00:08:00,000 --> 00:08:02,460
the intent behind the interaction.

123
00:08:03,060 --> 00:08:05,190
All through crafted input.

124
00:08:06,555 --> 00:08:11,295
In traditional security, this is
like someone whispering the right

125
00:08:11,295 --> 00:08:14,115
sequence of words to get root access.

126
00:08:14,505 --> 00:08:18,615
It feels absurd until you realize
how easy it is to pull off.

127
00:08:19,485 --> 00:08:21,255
And this isn't niche.

128
00:08:21,885 --> 00:08:25,425
This is an oh that only
happens in the research labs.

129
00:08:25,515 --> 00:08:28,125
This is happening in
production environment today.

130
00:08:28,920 --> 00:08:33,750
Prompt injection is the warning
sign, the indicator that we are not

131
00:08:33,750 --> 00:08:40,289
adequately prepared for behavior
level attacks that AI enables, and

132
00:08:40,289 --> 00:08:42,270
it doesn't stop at prompt injection.

133
00:08:42,809 --> 00:08:47,760
66% of organizations have shipped
code that contained vulnerabilities

134
00:08:48,000 --> 00:08:50,280
introduced by AI generated suggestions.

135
00:08:51,435 --> 00:08:52,964
This is the part that's our price.

136
00:08:52,964 --> 00:08:58,245
People LLMs are excellent at
generating syntactically correct

137
00:08:58,245 --> 00:09:03,675
code, but they are not inherently
good at generating secure code.

138
00:09:04,185 --> 00:09:05,954
They don't understand memory safety.

139
00:09:06,224 --> 00:09:08,354
They don't have built-in threat modeling.

140
00:09:08,954 --> 00:09:11,625
They don't know your
architectural constraints.

141
00:09:11,925 --> 00:09:12,939
They don't reason about.

142
00:09:13,695 --> 00:09:17,715
Authentication boundaries
or or privilege escalation.

143
00:09:18,735 --> 00:09:23,115
They simply produce what looks right
based on patterns in training data.

144
00:09:23,459 --> 00:09:30,750
Okay, so developers accept a suggestion
pushes a commit and test pass because

145
00:09:30,750 --> 00:09:36,180
tests often cover too little and our
vulnerability quietly enters the system.

146
00:09:36,839 --> 00:09:40,859
In other words, AI accelerates
delivery, but unless we guide it

147
00:09:40,859 --> 00:09:45,569
carefully, it also accelerates
the spread of insecure patterns.

148
00:09:46,469 --> 00:09:50,489
And when you combine that with
increasing speed, limited review

149
00:09:50,489 --> 00:09:52,319
windows and pressure to ship.

150
00:09:52,920 --> 00:09:56,730
A vulnerable code becomes an
automated problem at scale.

151
00:09:57,900 --> 00:10:01,680
Uh, let's look at one more number
and this one reinforces the trend.

152
00:10:03,360 --> 00:10:10,140
66% of enterprises have already
experienced some sort of LMG breaking,

153
00:10:10,500 --> 00:10:14,490
which means someone managed to push
the model into doing something it

154
00:10:14,490 --> 00:10:17,340
was explicitly instructed not to do.

155
00:10:18,030 --> 00:10:20,070
This is different from prompt injection.

156
00:10:20,775 --> 00:10:24,615
Prompted Injection manipulates the
model within its allowed structure.

157
00:10:25,035 --> 00:10:29,745
Jailbreaking convinces the model
to break its own rules entirely.

158
00:10:30,255 --> 00:10:33,645
It's like having a safety system
that says, I'll never disable

159
00:10:33,645 --> 00:10:37,605
breaking, and then someone gets it
to say, well, unless you ask nicely.

160
00:10:38,655 --> 00:10:43,305
The scary part is that jailbreaking
doesn't require advanced hacking skills.

161
00:10:43,335 --> 00:10:46,575
It just requires creativity
and enough persistence.

162
00:10:47,385 --> 00:10:52,305
Once a model breaks its own boundaries,
every downstream workflow that

163
00:10:52,305 --> 00:10:54,105
relies on it become vulnerable.

164
00:10:54,675 --> 00:10:58,965
If the model helps generate configs,
those configs can become unsafe.

165
00:10:59,865 --> 00:11:05,055
If it influences deployment decisions,
those decisions can become risky.

166
00:11:05,985 --> 00:11:11,025
If it shapes, uh, access policies, uh,
permissions can be escalated or weakened.

167
00:11:11,865 --> 00:11:16,635
And if it interacts with user
data, the guard rails around

168
00:11:16,635 --> 00:11:18,944
sensitive content can evaporate.

169
00:11:20,145 --> 00:11:22,005
Jailbreaking is a symptom
of a deeper truth.

170
00:11:23,070 --> 00:11:26,730
AI systems are not purely deterministic.

171
00:11:27,120 --> 00:11:31,860
They behave, they interpret, and
they adapt, and that creates an

172
00:11:31,860 --> 00:11:34,740
entirely new category of threats.

173
00:11:34,770 --> 00:11:39,090
Now let's connect that shift to the
broader picture of software delivery.

174
00:11:40,920 --> 00:11:44,550
So AI has dramatically improved
how we deliver software.

175
00:11:45,045 --> 00:11:50,115
It accelerates development, simplifies
infrastructure, automat decisions, and

176
00:11:50,115 --> 00:11:52,905
turns complex tasks into simple prompts.

177
00:11:52,905 --> 00:11:59,055
In many ways, delivery has never been
more efficient, but the threat landscape

178
00:11:59,055 --> 00:12:01,450
didn't just evolve alongside ai.

179
00:12:02,444 --> 00:12:04,035
It evolved faster.

180
00:12:04,635 --> 00:12:08,204
So traditional security models
were built for static systems.

181
00:12:08,204 --> 00:12:10,395
We scanned for, uh, SQL injection.

182
00:12:10,395 --> 00:12:12,704
We look for, uh, cross edge scripting.

183
00:12:12,704 --> 00:12:14,234
We hardened servers.

184
00:12:14,234 --> 00:12:20,175
We watch dependencies, but AI native
systems don't break the weight.

185
00:12:20,175 --> 00:12:21,795
Traditional systems break.

186
00:12:22,995 --> 00:12:25,964
Their vulnerabilities don't
live in, uh, code lines.

187
00:12:26,025 --> 00:12:30,375
They live in model behavior, uh,
contextual interpretation, uh,

188
00:12:30,375 --> 00:12:35,295
reasoning pathways, uh, decision
making, logic, uh, emergent responses.

189
00:12:36,464 --> 00:12:40,064
The visual on this slide captures
the difference perfectly.

190
00:12:40,245 --> 00:12:45,405
On the left, you have the old
world structured static governed

191
00:12:45,405 --> 00:12:47,805
by predict predictable code paths.

192
00:12:48,165 --> 00:12:50,560
On the right, you have
the AI native world.

193
00:12:51,315 --> 00:12:56,475
Fluid, contextual, adaptive, and
therefore susceptible to entirely

194
00:12:56,475 --> 00:12:58,185
new classes of manipulation.

195
00:12:58,965 --> 00:13:03,495
This is why we are seeing prompt
injection, jailbreaks, data

196
00:13:03,495 --> 00:13:05,115
leakage, and behavioral drift.

197
00:13:05,385 --> 00:13:09,615
They're not bugs, they're consequences
of how AI systems function.

198
00:13:10,485 --> 00:13:14,775
So what happens when we put AI inside
our delivery workforce, inside our

199
00:13:14,775 --> 00:13:16,815
pipelines and inside our automation?

200
00:13:17,385 --> 00:13:19,815
That brings us to the next critical idea.

201
00:13:21,090 --> 00:13:24,480
This is one of the most important
truths in modern DevOps.

202
00:13:24,900 --> 00:13:27,630
Pipelines don't have opinions.

203
00:13:27,990 --> 00:13:32,280
They automate whatever we
put into them, good or bad.

204
00:13:32,760 --> 00:13:37,650
If you give them secure, well tested, well
reviewed code, they automate excellence.

205
00:13:38,100 --> 00:13:43,260
If you give them misconfiguration outdated
images or vulnerable AI generated code.

206
00:13:43,680 --> 00:13:47,820
They automate those mistakes
with the exact same enthusiasm.

207
00:13:48,270 --> 00:13:51,600
Now introduce AI into the equation
and everything accelerates.

208
00:13:51,660 --> 00:13:52,920
AI writes code faster.

209
00:13:52,980 --> 00:13:56,850
AI proposes convic faster, generates
infrastructure faster, approves

210
00:13:56,850 --> 00:13:59,370
changes faster, makes decision faster.

211
00:13:59,880 --> 00:14:05,280
So if there's a crack in the system,
um, we control or an outdated

212
00:14:05,310 --> 00:14:07,470
pattern, uh, permissive policy.

213
00:14:08,100 --> 00:14:09,060
AI doesn't fix it.

214
00:14:09,240 --> 00:14:10,740
AI amplifies it.

215
00:14:11,520 --> 00:14:15,480
So the image on this slide shows this
perfectly, a clean green flow until

216
00:14:15,480 --> 00:14:20,400
one flow enters, and suddenly the
entire system becomes a high speed

217
00:14:20,400 --> 00:14:22,290
distribution mechanism for risk.

218
00:14:22,829 --> 00:14:28,170
This is why the idea of secure by default
is not a slogan in an AI driven pipeline.

219
00:14:29,070 --> 00:14:31,620
Security cannot be optional.

220
00:14:31,950 --> 00:14:35,100
It cannot depend on developers
remembering something or

221
00:14:35,100 --> 00:14:36,810
waiting for a late stage scan.

222
00:14:37,080 --> 00:14:41,340
Security has to be embedded at every
layer because the pipeline will

223
00:14:41,340 --> 00:14:45,210
run and it'll run fast, whether
the safety rails are there or not.

224
00:14:45,810 --> 00:14:49,500
With that in mind, let's talk about how
organizations are currently adopting AI

225
00:14:49,620 --> 00:14:52,470
and why the patterns aren't keeping up.

226
00:14:54,615 --> 00:14:57,435
So across industries, teams
are doing something very

227
00:14:57,435 --> 00:14:59,505
exciting and very dangerous.

228
00:14:59,505 --> 00:15:03,615
At the same time, they're shipping
AI integrated systems into

229
00:15:03,615 --> 00:15:08,385
production, not prototypes, not,
uh, side experiments, real customer

230
00:15:08,385 --> 00:15:10,425
facing business critical systems.

231
00:15:11,025 --> 00:15:16,275
Um, AI is generating code generating yaml,
um, suggesting infrastructure changes.

232
00:15:16,545 --> 00:15:18,435
AI is, uh, triaging incidents.

233
00:15:18,465 --> 00:15:20,625
AI is shaping the
behavior of our pipelines.

234
00:15:22,035 --> 00:15:25,425
And teams are adopting these
capabilities incredibly quickly

235
00:15:25,515 --> 00:15:29,055
because they're powerful and because
they re um, they reduce friction.

236
00:15:29,805 --> 00:15:32,055
But here's the part we're
not talking about enough.

237
00:15:32,175 --> 00:15:35,895
We're not updating our security
patterns at the same speed.

238
00:15:36,255 --> 00:15:40,454
We're still relying on AppSec models
built for deterministic systems.

239
00:15:40,905 --> 00:15:43,485
Still treat security
as a separate workflow.

240
00:15:43,814 --> 00:15:48,435
We still focus on code level flaws
while the risks have moved to be

241
00:15:48,525 --> 00:15:50,834
moved to behavior and context.

242
00:15:52,140 --> 00:15:53,610
This creates a mismatch.

243
00:15:54,180 --> 00:15:58,980
Modern delivery is dynamic, but our
security tools and process are static.

244
00:15:59,430 --> 00:16:04,650
So teams are moving fast with ai, but
without AI aware guard rails policies

245
00:16:04,650 --> 00:16:09,660
or verification, and that mismatch
is exactly where incidents happen.

246
00:16:10,050 --> 00:16:14,070
To understand this gap more clearly,
we need to step back and look at

247
00:16:14,070 --> 00:16:16,860
how delivery itself has changed.

248
00:16:17,160 --> 00:16:17,189
Okay,

249
00:16:19,439 --> 00:16:24,420
so for the last decade, delivery
cycles have been compressing Quarterly

250
00:16:24,420 --> 00:16:26,250
release became monthly release.

251
00:16:26,730 --> 00:16:28,290
Monthly became weekly.

252
00:16:28,530 --> 00:16:33,689
Weekly became daily, and in many teams
now deploy multiple times per day.

253
00:16:34,410 --> 00:16:37,830
Then AI entered the picture
and compressed everything.

254
00:16:37,830 --> 00:16:40,290
Again, work that used to take hours.

255
00:16:40,290 --> 00:16:43,980
Now happening in minutes, work that
took minutes, now happening in seconds.

256
00:16:44,745 --> 00:16:50,895
The velocity of software creation
has fundamentally changed, but

257
00:16:50,895 --> 00:16:53,925
security practices didn't evolve.

258
00:16:53,954 --> 00:16:58,814
Alongside this shift, we're still
depending on manual reviews, periodic

259
00:16:58,814 --> 00:17:04,514
scans, point in time approvals, human
driven decision making, security teams

260
00:17:04,514 --> 00:17:06,734
already overloaded with requests.

261
00:17:07,365 --> 00:17:11,300
In a world where code is generated
instantly and configurations

262
00:17:11,319 --> 00:17:12,780
are modified automatically.

263
00:17:13,605 --> 00:17:19,935
Security that operates on human time
cycles simply cannot keep up even worse.

264
00:17:21,045 --> 00:17:23,145
Misconfigurations are
no longer just mistakes.

265
00:17:23,385 --> 00:17:25,545
They have become automated hazards.

266
00:17:26,025 --> 00:17:30,315
A bad configuration generated by AI
doesn't sit quietly in one environment.

267
00:17:31,020 --> 00:17:34,710
It gets replicated, it gets
de deployed and redeployed.

268
00:17:34,980 --> 00:17:37,530
It becomes infrastructure as as a risk.

269
00:17:38,160 --> 00:17:42,630
This widening gap, fast delivery,
slow security is the core

270
00:17:42,630 --> 00:17:44,970
reason we need a new approach.

271
00:17:45,450 --> 00:17:49,050
And that new approach starts
with understanding that AI

272
00:17:49,080 --> 00:17:50,880
native delivery lifecycle.

273
00:17:53,160 --> 00:17:58,995
Now this slide captures the fundamental
shift in how delivery works in the AI era.

274
00:17:59,669 --> 00:18:01,860
Traditionally, our pipeline was linear.

275
00:18:01,919 --> 00:18:08,729
You code, build, test, deploy, monitor,
changes, move forward step by step.

276
00:18:09,540 --> 00:18:12,120
But AI has changed that model entirely.

277
00:18:12,330 --> 00:18:14,820
Today's delivery lifecycle
looks more like this.

278
00:18:15,060 --> 00:18:16,949
AI influences every layer.

279
00:18:17,189 --> 00:18:21,209
It helps generate code, is suggest,
uh, or modifies configurations.

280
00:18:21,510 --> 00:18:24,090
It influences infrastructure definitions.

281
00:18:24,885 --> 00:18:29,565
And it affects runtime decisions
through automated remediation.

282
00:18:30,795 --> 00:18:34,425
And importantly, this is
no longer a one-way flow.

283
00:18:35,205 --> 00:18:37,365
Issues don't just move downstream.

284
00:18:37,545 --> 00:18:39,645
They move in both directions.

285
00:18:39,855 --> 00:18:40,965
Here's what that means.

286
00:18:41,565 --> 00:18:46,725
A config change can trigger AI to adjust
infrastructure and infrastructure.

287
00:18:46,725 --> 00:18:48,795
Drift can cause AI to regenerate code.

288
00:18:49,545 --> 00:18:53,895
A runtime anomaly can cause automated
remediation that shifts your system

289
00:18:53,895 --> 00:18:55,395
away from its source of truth.

290
00:18:55,785 --> 00:18:58,635
And AI generated fix can
accidentally introduce new

291
00:18:58,635 --> 00:19:00,405
misconfigurations backup upstream.

292
00:19:00,810 --> 00:19:04,230
This creates a closed loop
system, not a linear one.

293
00:19:04,920 --> 00:19:08,520
And in closed loop, a small
mistake doesn't stay small.

294
00:19:08,730 --> 00:19:13,020
It gets amplified, it
propagates, it becomes a pattern.

295
00:19:13,800 --> 00:19:18,570
That's why AI driven delivery
demands new controls, new

296
00:19:18,570 --> 00:19:21,780
guardrails, and a new security model.

297
00:19:21,990 --> 00:19:27,120
One that understands behavior,
context, and system wide effects.

298
00:19:28,125 --> 00:19:31,575
With this lifecycle in mind,
let's talk about what it means

299
00:19:31,575 --> 00:19:36,615
for security, because the attack
surface has fundamentally changed.

300
00:19:39,225 --> 00:19:44,715
So when we think about securing AI native
delivery, it's important to recognize that

301
00:19:44,715 --> 00:19:49,305
the attack surface has expanded far beyond
traditional application vulnerabilities.

302
00:19:49,845 --> 00:19:54,105
In the pre AI world, our
threats mostly lived in code.

303
00:19:54,765 --> 00:19:58,545
SQL injection, uh, cross site
scripting, uh, dependency

304
00:19:58,545 --> 00:20:03,165
vulnerabilities, configuration
mistakes, um, author and access issues.

305
00:20:04,425 --> 00:20:08,745
But, uh, with AI embedded across
the delivery lifecycle, we now face

306
00:20:08,745 --> 00:20:10,845
entirely new categories of risk.

307
00:20:10,875 --> 00:20:13,185
First prompt injection.

308
00:20:13,545 --> 00:20:15,375
Now, this is the most common attack today.

309
00:20:15,405 --> 00:20:20,115
Instead of attacking your code,
attackers manipulate the model's

310
00:20:20,115 --> 00:20:22,485
behavior by injecting crafted prompts.

311
00:20:23,520 --> 00:20:28,020
The model is tricked into revealing
data, altering its reasoning, or

312
00:20:28,020 --> 00:20:30,300
taking actions you never intended.

313
00:20:31,620 --> 00:20:33,840
Second is the AI supply chain.

314
00:20:33,900 --> 00:20:36,030
We're not just depending
on packages anymore.

315
00:20:36,120 --> 00:20:41,070
We rely on model weights, fine tuning
data, prompt libraries, uh, embedding

316
00:20:41,070 --> 00:20:43,410
stores, third party inference, APIs.

317
00:20:43,965 --> 00:20:46,965
Each of these become an attack factor.

318
00:20:47,655 --> 00:20:52,155
Um, if any component is compromised,
it enters your delivery pipeline

319
00:20:52,185 --> 00:20:54,135
just like a toxic dependency.

320
00:20:55,395 --> 00:20:57,554
Third is the automated misconfiguration.

321
00:20:57,615 --> 00:21:02,264
So in the past, misconfigurations
happen manually now AI can generate or

322
00:21:02,264 --> 00:21:04,514
modify configurations at machine speed.

323
00:21:04,754 --> 00:21:09,610
If there's a mistake, a bad IM roll or an
insecure default, a faulty YAML pattern.

324
00:21:10,425 --> 00:21:14,084
That mistake is propagated
instantly across environments.

325
00:21:14,834 --> 00:21:17,504
And last but not the
least, the model exploits.

326
00:21:17,594 --> 00:21:21,584
These include jailbreaking, model
poisoning, output manipulation,

327
00:21:21,615 --> 00:21:25,605
data extraction, uh, via embeddings,
uh, or inference attacks.

328
00:21:26,445 --> 00:21:32,054
These aren't weakness in your code,
their weakness in how the model behaves.

329
00:21:32,534 --> 00:21:35,534
And this is why traditional
AppSec tools fall short.

330
00:21:36,044 --> 00:21:38,985
The design to secure code not behavior.

331
00:21:39,405 --> 00:21:41,024
The threat surface has moved.

332
00:21:41,445 --> 00:21:47,054
Our security model needs to move with
it, and yet the teams responsible

333
00:21:47,054 --> 00:21:51,675
for securing all of this, they're
not being, uh, set up to succeed.

334
00:21:53,895 --> 00:21:58,845
When you look at how organizations are
adopting ai, there's a clear disconnect.

335
00:21:59,385 --> 00:22:03,345
Only 43% of developers say
they're building security

336
00:22:03,345 --> 00:22:04,815
into AI native applications.

337
00:22:05,565 --> 00:22:06,915
Not because they don't care.

338
00:22:07,755 --> 00:22:12,015
Developers always want to build
things correctly, but because they

339
00:22:12,015 --> 00:22:15,975
haven't been trained or equipped
for this new threat landscape,

340
00:22:18,075 --> 00:22:22,395
74% of teams say security is
still viewed as a blocker.

341
00:22:22,995 --> 00:22:27,075
This is the old DevSecOps
friction returning in a new form.

342
00:22:27,989 --> 00:22:31,020
When delivery accelerates,
but security can't keep up.

343
00:22:31,229 --> 00:22:32,610
Teams don't slow down.

344
00:22:32,909 --> 00:22:34,560
They bypass controls.

345
00:22:35,850 --> 00:22:42,479
And 62% of developers report having
no AI security training at all zero.

346
00:22:43,064 --> 00:22:49,044
Yet we are asking them to defend against
prompt injection model manipulation, LLM

347
00:22:49,044 --> 00:22:51,685
data leakage, AI driven misconfiguration.

348
00:22:52,350 --> 00:22:56,970
Embedding level exploits behavioral
automated decision making gone wrong.

349
00:22:57,389 --> 00:23:02,160
This is like asking someone
to secure a distributed system

350
00:23:02,220 --> 00:23:03,345
they've never seen before.

351
00:23:04,274 --> 00:23:09,945
Developers want to ship safely, but the
industry hasn't given them the guardrails.

352
00:23:10,395 --> 00:23:16,004
That gap leads us to central top,
to the central concept of the

353
00:23:16,004 --> 00:23:22,334
stock, secure by default delivery, a
system where safety isn't dependent

354
00:23:22,334 --> 00:23:24,675
on heroics or expertise or luck.

355
00:23:27,675 --> 00:23:29,895
So what does secure by
default actually mean?

356
00:23:31,110 --> 00:23:36,629
It means designing delivery systems in
a way where the safest possible option

357
00:23:36,690 --> 00:23:41,730
is the default option, not an optional
configuration, not a best practice,

358
00:23:41,940 --> 00:23:43,784
not something someone has to remember.

359
00:23:44,760 --> 00:23:50,730
Secure by default means the pipeline
starts in a secure posture without

360
00:23:50,850 --> 00:23:52,620
needing manual intervention.

361
00:23:53,190 --> 00:23:59,040
Developers don't have to constantly
think about security edge cases, risky

362
00:23:59,040 --> 00:23:59,970
changes are caught automatically.

363
00:24:01,110 --> 00:24:05,760
Not through late stage reviews,
AI generated output is evaluated

364
00:24:05,760 --> 00:24:07,740
for safety as it's created.

365
00:24:08,430 --> 00:24:12,899
Unsafe defaults don't exist because
the system won't allow them.

366
00:24:13,440 --> 00:24:19,350
This isn't just philosophy, it's a
practical engineering goal because in an

367
00:24:19,379 --> 00:24:24,960
AI driven world where delivery happens
faster than humans can meaningfully react.

368
00:24:25,575 --> 00:24:29,265
Security has to be
built in, not bolted on.

369
00:24:30,105 --> 00:24:33,765
And the way we achieve this is
by embracing the intelligence

370
00:24:33,765 --> 00:24:38,685
that AI provides, not just for
generating code or configs, but

371
00:24:38,685 --> 00:24:40,755
for securing the pipeline itself.

372
00:24:41,475 --> 00:24:44,655
So the next question is,
how can AI actually help fix

373
00:24:44,685 --> 00:24:46,815
the problems AI introduced?

374
00:24:47,055 --> 00:24:48,315
That's where we go next.

375
00:24:51,990 --> 00:24:56,460
So we have talked a lot about how AI can
introduce new risks, but here's the twist.

376
00:24:57,000 --> 00:25:01,110
AI can also help solve the
very problems it creates.

377
00:25:01,590 --> 00:25:05,490
The key is shifting our mindset
from AI generates code and

378
00:25:05,490 --> 00:25:10,950
configurations to ai, observes,
interprets, and protects the pipeline.

379
00:25:11,159 --> 00:25:13,470
So what does this look like first?

380
00:25:14,205 --> 00:25:19,544
We need pipelines that know when
something simply looks wrong, not

381
00:25:19,544 --> 00:25:23,264
because there's a specific rule or
signature, but because the pattern doesn't

382
00:25:23,264 --> 00:25:25,605
match the system's historic behavior.

383
00:25:26,385 --> 00:25:28,425
AI's great at spotting these anomalies.

384
00:25:28,514 --> 00:25:29,445
Weird output.

385
00:25:29,445 --> 00:25:34,665
Suspicious config changes, unexpected
infra calls, things humans might miss.

386
00:25:35,655 --> 00:25:39,165
Second, the system needs
to understand provenance.

387
00:25:39,225 --> 00:25:41,115
Where did this artifact come from?

388
00:25:41,145 --> 00:25:44,895
Was it written by a developer
generated by an LLM imported from

389
00:25:44,895 --> 00:25:46,544
a third party model or data set?

390
00:25:47,324 --> 00:25:49,425
Without provenance, there is no trust.

391
00:25:49,635 --> 00:25:52,905
AI can track lineage
deeply and automatically.

392
00:25:53,780 --> 00:25:57,195
Third, the pipeline
needs context awareness.

393
00:25:57,540 --> 00:26:02,520
A risky action might be safe in
staging, but catastrophic in production.

394
00:26:03,000 --> 00:26:06,870
A permissive policy might be fine
for r and d, but unacceptable

395
00:26:06,870 --> 00:26:08,520
for a customer facing workflow.

396
00:26:09,060 --> 00:26:10,800
Security shouldn't block everything.

397
00:26:10,890 --> 00:26:14,250
It should understand the
intent and environment.

398
00:26:15,360 --> 00:26:19,500
Finally, the system needs to
understand the behavioral gift.

399
00:26:19,920 --> 00:26:21,780
AI systems change over time.

400
00:26:21,990 --> 00:26:24,420
Their outputs evolve, their
interpretations shift.

401
00:26:25,455 --> 00:26:29,925
If a model that used to produce safe
output suddenly starts acting differently,

402
00:26:30,285 --> 00:26:32,385
that drift needs to be caught early.

403
00:26:33,345 --> 00:26:34,725
So the big idea is this.

404
00:26:34,935 --> 00:26:36,975
AI shouldn't just accelerate delivery.

405
00:26:37,155 --> 00:26:42,555
It should accelerate security by giving
our pipelines, eyes, ears, and judgment.

406
00:26:43,005 --> 00:26:47,295
And this leads us directly to the
framework that ties all of this together.

407
00:26:48,375 --> 00:26:52,635
To build secure by default systems,
we need more than good intentions.

408
00:26:52,980 --> 00:26:58,290
We need structure, a way to operationalize
everything we have talked about so far.

409
00:26:58,890 --> 00:27:05,220
This bring us to the four pillars of
Secure by Default DevSecOps, A framework

410
00:27:05,220 --> 00:27:07,020
designed for AI native delivery.

411
00:27:07,830 --> 00:27:11,790
These four pillars work together
to transform pipelines from

412
00:27:11,790 --> 00:27:16,230
passive automation into intelligent
self-protecting systems.

413
00:27:16,710 --> 00:27:21,750
They are contextual intelligence,
automatic verification, behavior

414
00:27:21,750 --> 00:27:24,780
based, anomaly detection,
and continuous learning.

415
00:27:25,170 --> 00:27:26,370
And here's the important part.

416
00:27:26,370 --> 00:27:28,830
You don't need all four pillars to start.

417
00:27:29,730 --> 00:27:35,220
But eventually a mature AI native
delivery system needs every one of them.

418
00:27:35,730 --> 00:27:39,720
Each pillar solves a specific
part of the risk equation.

419
00:27:40,140 --> 00:27:45,330
Each builds on the others, and together
they create a pipeline that stays

420
00:27:45,330 --> 00:27:47,970
secure even as the delivery speeds up.

421
00:27:48,330 --> 00:27:51,390
So let's walk through each pillar
one by one, starting with the

422
00:27:51,390 --> 00:27:54,240
foundation, contextual intelligence.

423
00:27:55,695 --> 00:27:59,325
This is what separates traditional
DevSecOps from ai, native

424
00:27:59,325 --> 00:28:01,545
World traditional pipelines.

425
00:28:01,545 --> 00:28:03,375
Detect that something changed.

426
00:28:03,765 --> 00:28:08,235
Contextual intelligence, understand
what changed, why it changed, and

427
00:28:08,235 --> 00:28:10,065
how that change affects the system.

428
00:28:10,245 --> 00:28:11,985
So let me break down what it means.

429
00:28:13,500 --> 00:28:17,190
So a regular diff just shows
lines of code contextual

430
00:28:17,190 --> 00:28:18,870
intelligence interprets meaning.

431
00:28:19,110 --> 00:28:21,480
Is this change altering security posture?

432
00:28:21,960 --> 00:28:23,520
Is it affecting permissions?

433
00:28:23,790 --> 00:28:28,110
Uh, is it something AI generated that
doesn't align with the developer's intent?

434
00:28:29,190 --> 00:28:34,139
Then in AI native delivery, these
layers influence each other.

435
00:28:34,590 --> 00:28:40,170
A config tweak may alter infrastructure
and infrastructure drift may

436
00:28:40,170 --> 00:28:41,820
cause AI to regenerate code.

437
00:28:42,330 --> 00:28:45,990
Contextual intelligence ties
this relationship together.

438
00:28:48,180 --> 00:28:51,720
Every team has a typical
pattern deployment, size,

439
00:28:51,720 --> 00:28:53,610
frequency, rollback rates.

440
00:28:54,000 --> 00:28:58,860
When something deviates from the
pattern, it might be a risk signal.

441
00:29:00,390 --> 00:29:02,070
And then the last one, this is huge.

442
00:29:02,490 --> 00:29:05,640
Developers often intend
one thing, but the outcome.

443
00:29:05,970 --> 00:29:07,680
Ends up being something else.

444
00:29:07,890 --> 00:29:12,030
Especially with AI generated
changes, contextual intelligence

445
00:29:12,030 --> 00:29:14,640
catches this inconsistencies early.

446
00:29:15,180 --> 00:29:18,870
This pillar is the foundation because
it gives your pipeline awareness.

447
00:29:19,080 --> 00:29:21,630
Without context, everything
else is guesswork.

448
00:29:22,230 --> 00:29:26,700
With it, your pipeline becomes a system
that understand what's happening,

449
00:29:26,760 --> 00:29:28,830
not just executing steps blindly.

450
00:29:29,520 --> 00:29:34,440
Now that we understand context, the
next step is to verify trust, which

451
00:29:34,440 --> 00:29:36,960
leads us in into pillar number two.

452
00:29:38,070 --> 00:29:41,460
So once we have contextual intelligence,
once the pipeline understand what's

453
00:29:41,460 --> 00:29:45,510
happening, this is the next pillar,
which is automatic verification.

454
00:29:46,170 --> 00:29:50,130
So this is why we shift from trusted
by default, to verify by default.

455
00:29:50,925 --> 00:29:54,195
In the AI era, artifacts
come from everywhere.

456
00:29:54,375 --> 00:29:59,055
Developer written code, AI generated
code, external model outputs, downloaded

457
00:29:59,055 --> 00:30:04,275
containers, uh, infor configurations,
automated re, re, uh, remediation.

458
00:30:04,935 --> 00:30:09,705
And because these sources vary, we
need pipelines that automatically from

459
00:30:09,705 --> 00:30:11,835
trust before anything gets deployed.

460
00:30:12,285 --> 00:30:14,655
Now, here's what automatic
verification include.

461
00:30:15,915 --> 00:30:18,555
The first one is provenance
and integrated checks.

462
00:30:18,615 --> 00:30:20,295
Where did this artifact come from?

463
00:30:20,355 --> 00:30:23,745
Did it come from a trusted bill
system or was it generated by ai?

464
00:30:23,775 --> 00:30:25,005
Has it been tampered with?

465
00:30:25,725 --> 00:30:29,985
If the pipeline can't prove the origin
and integrity, it shouldn't ship.

466
00:30:31,125 --> 00:30:35,325
The second one is the config
environment and infra alignment

467
00:30:35,325 --> 00:30:36,345
with the source of truth.

468
00:30:36,855 --> 00:30:40,485
AI often generates changes
that unintentionally drift

469
00:30:40,485 --> 00:30:41,925
from what's defined in Git.

470
00:30:42,690 --> 00:30:46,530
A verification ensures that
actual environment matches

471
00:30:46,590 --> 00:30:48,030
the declared configuration.

472
00:30:48,120 --> 00:30:50,670
No surprise, no hidden divergence.

473
00:30:52,020 --> 00:30:57,000
The third one is that every pipeline step
is signed, trusted, and re reproducible.

474
00:30:57,660 --> 00:31:02,820
If a bill can be reproduced, it can
be trusted signatures ensure every

475
00:31:02,820 --> 00:31:08,070
piece of software has a verifiable
chain of custody, and the final

476
00:31:08,070 --> 00:31:10,740
one is enforced safety conditions.

477
00:31:11,355 --> 00:31:17,055
If a deployment doesn't meet predefined
safety criteria, wrong version, missing

478
00:31:17,055 --> 00:31:24,255
signature, drifted config, or un
untrusted model, then those enforced,

479
00:31:24,285 --> 00:31:26,835
uh, safety conditions are not met.

480
00:31:31,605 --> 00:31:36,975
So this blocks your pipeline on
worms when the pipelines don't meet

481
00:31:37,035 --> 00:31:39,735
these predefined safety conditions.

482
00:31:41,715 --> 00:31:46,065
Now this leads us to the third pillar,
which is a behavior based anomaly

483
00:31:46,065 --> 00:31:50,655
detection, and this is where traditional
security models completely fall short.

484
00:31:51,435 --> 00:31:57,735
Traditional security looks at code
dependencies, configs, static rules, but

485
00:31:57,825 --> 00:32:00,975
AI native systems break in dynamic way.

486
00:32:01,815 --> 00:32:05,385
This through unexpected behavior, a
reasoning drift or contextual anomalies.

487
00:32:06,495 --> 00:32:09,825
So what does a behavioral
based detection let let us do?

488
00:32:10,815 --> 00:32:14,295
Uh, first one is it detect
abnormal behavior across code

489
00:32:14,325 --> 00:32:16,425
config, infra, and model outputs.

490
00:32:16,425 --> 00:32:21,795
So this means the pipeline actively
watches for things like unusual model

491
00:32:21,795 --> 00:32:26,895
responses, unexpected API calls or
infrastructure activity changes that

492
00:32:26,895 --> 00:32:28,365
don't align with past deployments.

493
00:32:29,685 --> 00:32:31,365
The second one is risky.

494
00:32:31,365 --> 00:32:33,195
Configurations rarely blow up.

495
00:32:33,195 --> 00:32:33,855
Immediately.

496
00:32:34,035 --> 00:32:35,145
They degrade slowly.

497
00:32:35,505 --> 00:32:40,005
So behavioral signals catch these
problems early before the cascade.

498
00:32:41,505 --> 00:32:41,925
Next.

499
00:32:41,925 --> 00:32:45,495
These attacks don't show up in
code, they show up in behavior.

500
00:32:45,705 --> 00:32:47,985
The model suddenly becomes
more permissive, more

501
00:32:47,985 --> 00:32:50,085
confident, or more consistent.

502
00:32:50,835 --> 00:32:51,075
So.

503
00:32:51,929 --> 00:32:53,010
This is important.

504
00:32:53,159 --> 00:32:56,730
Every engineering team has its
own rhythm, deployment sizes,

505
00:32:56,730 --> 00:32:58,050
frequency, rollback rates.

506
00:32:58,500 --> 00:33:03,600
So when something deviates, we need
to understand you need to learn

507
00:33:03,600 --> 00:33:08,790
the normal delivery patterns and
flag the deviations in real time.

508
00:33:11,280 --> 00:33:15,570
And the final pillar, the, and
arguably the most transformative

509
00:33:15,570 --> 00:33:17,610
one, is continuous learning groups.

510
00:33:18,150 --> 00:33:20,520
This is where the pipeline
evolves over time.

511
00:33:20,550 --> 00:33:22,110
It just doesn't detect issues.

512
00:33:22,140 --> 00:33:26,400
It learns from them, adapts and
becomes safer with every execution.

513
00:33:27,570 --> 00:33:31,620
So what it means in practice
is you improve security posture

514
00:33:31,620 --> 00:33:33,900
automatically using real pipeline data.

515
00:33:34,530 --> 00:33:36,900
So the system uses the signal.

516
00:33:37,470 --> 00:33:41,970
That from every build, every deploy, every
rollback, every failure, the generative

517
00:33:41,970 --> 00:33:47,490
signal you get, the system uses that
signal to refine its understanding of

518
00:33:47,490 --> 00:33:49,770
what is normal versus what is risky.

519
00:33:50,820 --> 00:33:53,820
Next teams change tools.

520
00:33:54,060 --> 00:33:55,650
Team set up new frameworks.

521
00:33:55,680 --> 00:33:57,150
They restructure services.

522
00:33:57,210 --> 00:33:59,550
Static rules become outdated quickly.

523
00:34:00,030 --> 00:34:04,050
Continuous learning ensures that
guard rails evolve with the team

524
00:34:04,050 --> 00:34:06,300
instead of blocking valid changes.

525
00:34:08,339 --> 00:34:10,560
Now failures aren't just fires to put out.

526
00:34:10,589 --> 00:34:11,819
They become lessons.

527
00:34:11,819 --> 00:34:13,920
The system absorbs, not just humans.

528
00:34:13,980 --> 00:34:19,350
This turns incident response into
future prevention and finally

529
00:34:19,560 --> 00:34:23,730
turn failures into system level
improvements, not human rework.

530
00:34:24,179 --> 00:34:27,960
With these four pillars, contextual
intelligence, automatic verification,

531
00:34:28,020 --> 00:34:32,279
behavior based detection, and
continuous learning, we now have the

532
00:34:32,279 --> 00:34:34,589
blueprint for Secure by delivery.

533
00:34:34,830 --> 00:34:36,389
Secure by default delivery.

534
00:34:37,109 --> 00:34:40,674
So let's talk about how this actually
shows up in real world through harness.

535
00:34:42,165 --> 00:34:46,574
So now that we have identified
the four, uh, pillars of secure

536
00:34:46,574 --> 00:34:51,645
by default DevSecOps, let's look
at how these ideas can come to

537
00:34:51,799 --> 00:34:53,714
a, a life inside a real platform.

538
00:34:54,795 --> 00:35:00,555
So harness was built on a simple belief
delivery should be fast, safe, and as

539
00:35:00,555 --> 00:35:05,235
automated as possible without recurring
teams to become pipeline expert.

540
00:35:06,405 --> 00:35:11,115
Now, when a pipeline fails, most
systems throw you into a log avalanche.

541
00:35:11,145 --> 00:35:16,305
You are left digging through stack traces,
clicking to artifacts, jumping between

542
00:35:16,305 --> 00:35:20,505
dashboards, and trying to reconstruct
what happened, harness that process.

543
00:35:20,505 --> 00:35:22,125
This approaches this differently.

544
00:35:22,670 --> 00:35:26,780
The system analyzes the pipeline
execution, understands what failed.

545
00:35:26,780 --> 00:35:31,220
So here, harness ai, uh, it,
uh, understand what failed and

546
00:35:31,220 --> 00:35:32,600
automatically explains why.

547
00:35:34,155 --> 00:35:36,405
This is contextual intelligence in action.

548
00:35:36,465 --> 00:35:39,945
The pipeline understand the story behind
the failure, not just the raw output.

549
00:35:40,155 --> 00:35:42,105
And it has two huge benefits.

550
00:35:42,165 --> 00:35:48,495
First, developers get clarity instantly,
no time wasted, uh uh, going through logs

551
00:35:48,495 --> 00:35:50,655
or trying to reproduce flaky behaviors.

552
00:35:50,775 --> 00:35:51,135
Second.

553
00:35:51,970 --> 00:35:54,430
The recovery is faster and safer.

554
00:35:54,700 --> 00:35:58,870
This is the first layer of secure
by default delivery, an intelligent

555
00:35:58,870 --> 00:36:03,845
CICD engine that interprets, explains
and assists, not just executes.

556
00:36:05,924 --> 00:36:09,495
Now one of the biggest historical
problems in DevSecOps is that security

557
00:36:09,495 --> 00:36:15,015
is often bolted on a separate workflow, A
separate tool, a separate responsibility

558
00:36:15,404 --> 00:36:17,145
harness takes a different approach.

559
00:36:17,475 --> 00:36:20,714
Security is not something you
add on top of the pipeline.

560
00:36:20,895 --> 00:36:23,535
It's woven directly
into the delivery path.

561
00:36:23,924 --> 00:36:26,085
Let's look at wha what, what that means.

562
00:36:26,714 --> 00:36:29,595
So on the left side of the screen,
you see continuous compliance.

563
00:36:29,780 --> 00:36:33,470
Cross pipelines, repositories,
services, and environments.

564
00:36:33,770 --> 00:36:39,620
Instead of re-running security scans
once per sprint or only on pull request,

565
00:36:39,920 --> 00:36:45,410
harness, continuous labels, everything
using the CIS benchmarks, WASP standards,

566
00:36:45,410 --> 00:36:46,910
custom policies and environment.

567
00:36:46,940 --> 00:36:47,870
Environment rules.

568
00:36:48,710 --> 00:36:53,450
This gives you a breakdown of passes
versus failures, the severity of risks,

569
00:36:53,720 --> 00:36:57,410
where violations are trending, and
which services are repeatedly failing.

570
00:36:57,410 --> 00:36:58,220
Security checks.

571
00:36:59,160 --> 00:37:03,600
This transforms security from
a reactive process into a

572
00:37:03,600 --> 00:37:05,700
real time posture dashboard.

573
00:37:06,060 --> 00:37:10,380
On the right side, you see a deeper
example harness detecting a command

574
00:37:10,380 --> 00:37:13,560
injection vulnerability inside
a pipeline, and providing a full

575
00:37:13,560 --> 00:37:17,760
contextual explanation what the
vulnerability, what matters, what

576
00:37:17,760 --> 00:37:20,190
it would impact, and how to fix it.

577
00:37:20,970 --> 00:37:23,940
This is not just a scanner
returning a red cross.

578
00:37:24,300 --> 00:37:27,780
This is a system that understand
the risk well enough to teach

579
00:37:27,780 --> 00:37:29,460
you how to remediate it,

580
00:37:31,470 --> 00:37:34,200
and this final piece
ties everything together.

581
00:37:34,290 --> 00:37:37,470
Harness isn't just adding
AI feature to CICD.

582
00:37:37,710 --> 00:37:42,360
It's becoming an AI native software
delivery platform where intelligence is

583
00:37:42,480 --> 00:37:45,330
part of the foundation, not an extension.

584
00:37:45,930 --> 00:37:48,810
Now the gif or gif you see
here is a good example.

585
00:37:49,170 --> 00:37:52,710
This isn't a chatbot sitting beside
your pipeline scoring through logs.

586
00:37:53,055 --> 00:37:57,855
This is AI inside the pipeline
execution, observing the behavior,

587
00:37:57,885 --> 00:38:02,625
interpreting the failure, and
generating precise actionable guidance.

588
00:38:02,835 --> 00:38:05,055
So let me highlight
the key advantage here.

589
00:38:05,595 --> 00:38:10,545
AI that understands delivery, not
just text it, understand deployments,

590
00:38:10,785 --> 00:38:14,955
manifest infrastructure, rollbacks
and traffic routing, the actual

591
00:38:14,955 --> 00:38:16,635
mechanics of software delivery.

592
00:38:17,745 --> 00:38:21,495
You have governance and verification
built into the intelligence layer.

593
00:38:22,125 --> 00:38:26,595
Every incident rollback, successful
redeploy and policy violation

594
00:38:26,625 --> 00:38:28,905
become training data for the system.

595
00:38:28,905 --> 00:38:30,375
So it's continuously learning.

596
00:38:30,795 --> 00:38:34,605
So this is what secure by default
delivery looks like in practice,

597
00:38:34,995 --> 00:38:40,125
a platform that understand
context, verifies trust, monitors

598
00:38:40,125 --> 00:38:42,915
behavior, and learns continuously.

599
00:38:43,605 --> 00:38:46,875
And with that, we have
covered the full journey.

600
00:38:47,235 --> 00:38:51,825
From the risks of AI native delivery
to the framework and the real

601
00:38:51,825 --> 00:38:54,015
world platform implementing it.

602
00:38:56,775 --> 00:39:00,465
So as we wrap up, I want to
bring the entire story together

603
00:39:00,465 --> 00:39:02,715
in a few clear takeaways.

604
00:39:03,435 --> 00:39:08,415
First, AI native delivery has
expanded the attack surface far

605
00:39:08,415 --> 00:39:10,305
beyond traditional code vulnerability.

606
00:39:12,104 --> 00:39:17,475
Second, our old security patterns
can't keep up with this New world.

607
00:39:17,564 --> 00:39:20,895
Manual reviews, pointing time
scans, rule-based checks.

608
00:39:21,225 --> 00:39:23,834
They were already struggling
before AI arrived.

609
00:39:25,185 --> 00:39:30,705
And third, the future of DevSecOps
is secure by default systems.

610
00:39:31,035 --> 00:39:35,774
Pipelines that can detect anomalies,
verify provenance, understand context, and

611
00:39:35,774 --> 00:39:38,084
continuously learn from every deployment.

612
00:39:38,145 --> 00:39:40,425
It is not about slowing teams down.

613
00:39:40,785 --> 00:39:43,605
It's not about adding more
friction or more gates.

614
00:39:43,995 --> 00:39:47,805
It's about building delivery
systems that are smart enough to

615
00:39:47,805 --> 00:39:50,025
keep you safe as you move fast.

616
00:39:50,235 --> 00:39:55,665
Systems that make the secure
choice the default choice, this

617
00:39:55,665 --> 00:39:58,005
is the path forward for DevSecOps.

618
00:39:58,455 --> 00:40:03,105
That is how we build confidence
in AI driven delivery.

619
00:40:04,890 --> 00:40:08,640
Now before we fully wrap up,
I'd love to hear your feedback.

620
00:40:08,700 --> 00:40:12,630
If you scan the QR code on the screen,
it'll take you to a very short form

621
00:40:12,630 --> 00:40:15,775
where you can share what resonated
with you, what you'd like to.

622
00:40:16,455 --> 00:40:21,645
Learn more about your feedback,
genuinely helps me improve and as thank

623
00:40:21,645 --> 00:40:24,915
you, if you fill out this form, I'll
share the resources from this talk

624
00:40:24,915 --> 00:40:28,905
with you, the slides, relevant links,
reference materials, and any deep

625
00:40:28,905 --> 00:40:34,095
dive content that can help you take
these ideas back to your own teams.

626
00:40:35,175 --> 00:40:39,375
Thank you again for spending your time
with me today and for being part of the

627
00:40:39,375 --> 00:40:42,465
future of secure AI driven delivery.

