1
00:00:00,570 --> 00:00:01,290
Hello everyone.

2
00:00:01,350 --> 00:00:05,970
Welcome to the Con 42 Group, native
2025, and welcome to my session on

3
00:00:05,970 --> 00:00:10,140
Ballerina, where I'm going to discuss
in detail about how Ballerina will help

4
00:00:10,140 --> 00:00:12,000
you for the cloud native integrations.

5
00:00:12,570 --> 00:00:15,150
So before starting the session,
let me introduce myself.

6
00:00:15,180 --> 00:00:19,110
I'm a MA currently working as a
director and head of engineering

7
00:00:19,110 --> 00:00:20,580
for the integration business unit.

8
00:00:21,080 --> 00:00:25,310
Software development company specialized
in the API management integration

9
00:00:25,310 --> 00:00:27,050
and identity and access management.

10
00:00:28,009 --> 00:00:31,610
Before deep diving to the today's
topic, let's first understand

11
00:00:31,610 --> 00:00:34,339
what are the problem, what is the
problem that we're trying to solve?

12
00:00:34,769 --> 00:00:38,290
Most of the days most of the time if
you are coming from the development

13
00:00:38,290 --> 00:00:42,250
background, the developers are busy with
the code and designing the applications,

14
00:00:42,519 --> 00:00:45,489
and the DevOps team members and
others are busy with the deployment.

15
00:00:46,385 --> 00:00:50,465
This store is not fully disconnected,
whether you are deploying it on-premise

16
00:00:50,715 --> 00:00:55,295
a setup or in a cloud deployment
developers has to think about it and the

17
00:00:55,295 --> 00:00:59,855
application design and all the aspects
of the application depends on that.

18
00:01:00,245 --> 00:01:05,405
Definitely cloud native deployments
is much easier compared to on-premise

19
00:01:05,405 --> 00:01:07,445
deployment, but at the same time.

20
00:01:08,185 --> 00:01:12,145
It has more and more other
complexities, different challenges

21
00:01:12,235 --> 00:01:14,995
that we had to consider during
the application design itself.

22
00:01:15,325 --> 00:01:18,205
So the developer journey, as
well as the deployment aspects

23
00:01:18,205 --> 00:01:19,885
are not totally disconnected.

24
00:01:20,365 --> 00:01:24,145
So although developer has to worry
about the business logic and the

25
00:01:24,145 --> 00:01:27,745
implementation part of the problem,
they have to think how they're going

26
00:01:27,745 --> 00:01:29,290
to deploy their applications as well.

27
00:01:29,790 --> 00:01:33,720
So cloud native deployment is like
conducting an orchestra with lot of

28
00:01:33,720 --> 00:01:38,940
musicians and each musician or each
service play a beautifully, play a

29
00:01:38,940 --> 00:01:42,240
beautiful piece of things on its own.

30
00:01:42,630 --> 00:01:47,365
But if you don't have a proper
conductor that outcome will not be.

31
00:01:47,865 --> 00:01:48,975
It'll become a noise.

32
00:01:49,455 --> 00:01:54,325
So Kubernetes play a big role here to
seamlessly connect everything at the same

33
00:01:54,325 --> 00:01:59,365
times when it comes to developers context,
ballerina helps a lot to reduce that

34
00:01:59,365 --> 00:02:05,425
complexity of integrations and make sure
the integration, application development

35
00:02:05,425 --> 00:02:07,525
as well as deployment is seamless.

36
00:02:08,025 --> 00:02:11,985
So if we look at the challenges
in the cloud integrations nowadays

37
00:02:11,985 --> 00:02:15,675
when we are moving to microservices
and smaller services, we had to

38
00:02:15,675 --> 00:02:17,945
think about multiple such services.

39
00:02:17,960 --> 00:02:20,330
It's not mono, it's that
we are developing nowadays.

40
00:02:20,825 --> 00:02:25,730
So cloud integration means we had to
integrate with various services, APIs,

41
00:02:25,735 --> 00:02:30,155
SaaS applications, data services,
things like that, and we need to

42
00:02:30,215 --> 00:02:31,775
make sure they are working together.

43
00:02:32,150 --> 00:02:35,450
Environments are highly
dynamic with containers.

44
00:02:35,720 --> 00:02:37,100
They add more complexity.

45
00:02:37,640 --> 00:02:42,320
Also the configuration overhead,
that is also bit of complex

46
00:02:42,320 --> 00:02:45,380
because there are multiple services
and how we manage deployment

47
00:02:45,380 --> 00:02:47,900
configurations, how we scale services.

48
00:02:48,320 --> 00:02:52,820
And also on top of that monitoring and
other runtime related configuration

49
00:02:52,820 --> 00:02:53,930
overhead is getting added.

50
00:02:54,260 --> 00:02:56,450
So likewise, we had to
manage all these things.

51
00:02:56,975 --> 00:03:01,305
Finally, security and compliance every
date of law, we need to make sure it's

52
00:03:01,305 --> 00:03:06,795
secure and compliant to various protocols
and other things, because in the world

53
00:03:06,795 --> 00:03:10,755
of integration, security and compliance
is something that we cannot forget.

54
00:03:11,745 --> 00:03:15,765
So ballerina is a technology for
simplifying cloud native integrations.

55
00:03:15,765 --> 00:03:19,905
I would say it's a technology
because it has many aspects on it.

56
00:03:20,325 --> 00:03:21,945
So let's first look at what is riina.

57
00:03:21,945 --> 00:03:23,210
Vina is cloud native.

58
00:03:23,900 --> 00:03:27,290
Open source technology, which is
highly optimized for integration

59
00:03:27,710 --> 00:03:29,090
based application development.

60
00:03:29,480 --> 00:03:33,860
So it's developed by WS oh two
in 2016, and we released our

61
00:03:33,860 --> 00:03:36,230
first version in February, 2022.

62
00:03:36,770 --> 00:03:41,090
So it has a rich core system of different
services, data formats, rich types

63
00:03:41,090 --> 00:03:46,010
system, and also set of connectors
to help with the integration story.

64
00:03:46,430 --> 00:03:48,020
And also it has great.

65
00:03:48,395 --> 00:03:53,315
Textual as well as graphical capabilities,
which I'll discuss in the upcoming slides.

66
00:03:53,705 --> 00:03:57,995
It'll make, it's very efficient
and effective for the developers

67
00:03:58,355 --> 00:04:00,095
to write the piece of code.

68
00:04:00,515 --> 00:04:03,815
So this is a very high level
timeline on how Ballina has evolved.

69
00:04:04,305 --> 00:04:08,385
It took time because we, it's a
full system along with the compiler

70
00:04:08,385 --> 00:04:13,245
to compile the source code and
the rich ecosystem around that.

71
00:04:13,745 --> 00:04:15,185
So what is the differentiation?

72
00:04:15,335 --> 00:04:16,565
Ballerina provides, right?

73
00:04:16,565 --> 00:04:19,325
Abstractions for data,
network, and concurrency.

74
00:04:19,775 --> 00:04:23,405
So data is the heart of the
integration because at the end of

75
00:04:23,405 --> 00:04:28,535
the day, what we are doing is we are
communicating data and we receive data.

76
00:04:28,535 --> 00:04:30,005
We, send data.

77
00:04:30,395 --> 00:04:31,920
And also we need to represent data.

78
00:04:31,970 --> 00:04:36,500
Data can be in many different formats,
shapes, and we need to manipulate data.

79
00:04:36,860 --> 00:04:40,070
So that's a fundamental
thing in the integrations.

80
00:04:40,370 --> 00:04:43,460
And also integration
means it's in the network.

81
00:04:43,850 --> 00:04:47,330
So communicating data across
different clients and services with

82
00:04:47,330 --> 00:04:49,700
various protocols is mandatory.

83
00:04:50,360 --> 00:04:51,800
And finally, concurrency.

84
00:04:52,280 --> 00:04:54,050
So the last thing because.

85
00:04:54,665 --> 00:04:58,385
Integrations are, integration
applications are inherently concurrent.

86
00:04:58,475 --> 00:05:03,335
That means we need to make sure
concurrency safety protocols are,

87
00:05:03,335 --> 00:05:08,195
or mechanisms are available in place
for developers to develop concurrent

88
00:05:08,195 --> 00:05:10,835
applications easily and effectively.

89
00:05:11,075 --> 00:05:15,065
So Ballerina provides abstractions
for these three different layers,

90
00:05:15,485 --> 00:05:19,625
and I'll go through some of them
in detail in the upcoming slides

91
00:05:20,015 --> 00:05:21,845
and I'll show you how it can.

92
00:05:22,480 --> 00:05:24,910
Help the developers to
develop the applications.

93
00:05:25,840 --> 00:05:30,790
So the first part of the thing is
stories, the development, and also how

94
00:05:30,790 --> 00:05:35,050
we are going to maintain the application
since Meina is open source language.

95
00:05:35,900 --> 00:05:39,230
Open source technology, I would
say, and also we can categorize

96
00:05:39,230 --> 00:05:40,760
it as a programming language.

97
00:05:40,760 --> 00:05:41,120
First of all.

98
00:05:41,990 --> 00:05:43,370
I'll come to that part later.

99
00:05:43,680 --> 00:05:48,180
Because it's a language, because of its
language nature, it can work with V Code

100
00:05:48,210 --> 00:05:53,910
id and we can commit a source code into
GitHub and we can use CSC CD pipelines

101
00:05:53,910 --> 00:06:01,050
to deploy it or have a CS CD pipeline
on your own tools, and we can deploy it.

102
00:06:01,635 --> 00:06:04,125
In Docker, Kubernetes, or
whatever the platform you want.

103
00:06:04,515 --> 00:06:09,045
And finally, during the runtime, you
can monitor, observe using existing

104
00:06:09,045 --> 00:06:13,755
tools, support open telemetry, and you
can connect with the existing tools

105
00:06:14,345 --> 00:06:17,385
like J Grafana all analysis stuff.

106
00:06:17,895 --> 00:06:21,495
So that is the ecosystem comes
with the familiar tool set.

107
00:06:21,885 --> 00:06:22,335
So if you are.

108
00:06:22,835 --> 00:06:26,045
One problem in language because
Ballina, we can classify it as

109
00:06:26,045 --> 00:06:27,485
a problem in language as well.

110
00:06:28,095 --> 00:06:33,955
It has its own syntax, own language
specification, and also own compiler.

111
00:06:34,375 --> 00:06:38,995
So you might wonder because it's
a new language, how easy or how

112
00:06:38,995 --> 00:06:41,215
difficult it is to learn as a language.

113
00:06:41,545 --> 00:06:46,675
So it's a cc plus family language and if
you're familiar with any of the existing

114
00:06:46,675 --> 00:06:51,905
c family language, like cc plus Java
go it's very easy to learn ballina.

115
00:06:52,115 --> 00:06:56,325
And only thing is like you had to learn
a couple of new abstractions or new

116
00:06:56,330 --> 00:07:00,440
constructs that we are providing along
with the language to make it easy.

117
00:07:00,979 --> 00:07:04,219
So this is how we write the first
ballerina package you have to

118
00:07:04,219 --> 00:07:08,359
use Be New Command, and it'll
generate the ballerina package.

119
00:07:08,780 --> 00:07:10,460
It's like any other programming language.

120
00:07:10,460 --> 00:07:12,680
You can simply create a ballerina package.

121
00:07:13,180 --> 00:07:16,030
So once you create that,
you'll create a, it'll create

122
00:07:16,030 --> 00:07:18,640
a folder with couple of files.

123
00:07:18,850 --> 00:07:22,750
So the most important files here
are the main bell file, where the

124
00:07:22,750 --> 00:07:27,910
ballerina source file resides, and
the Ballina Toal file, which identify

125
00:07:27,970 --> 00:07:29,800
a given package as a ballerina.

126
00:07:29,920 --> 00:07:31,690
You directory as a ballerina package.

127
00:07:32,190 --> 00:07:35,760
Now let's look at what are the key
differentiators of this language

128
00:07:36,210 --> 00:07:39,630
and how it differs from typical
programming language or ecosystem.

129
00:07:40,349 --> 00:07:42,419
So first thing is the graphical view.

130
00:07:42,510 --> 00:07:45,450
For every program or every
integration that you are writing

131
00:07:45,450 --> 00:07:48,015
using Ballina, you have equivalent.

132
00:07:48,515 --> 00:07:51,635
Piece of source code as well as a diagram.

133
00:07:51,635 --> 00:07:55,715
So that means we maintain pro code
and low code parity and it happens

134
00:07:55,715 --> 00:07:59,645
automatically by the initial studio
plugin or the toolkit that we are having.

135
00:07:59,975 --> 00:08:03,905
You don't have to do anything, so that
means you can write the program in the

136
00:08:03,905 --> 00:08:07,475
source code side if you are pro code
developer and if you are more towards

137
00:08:07,475 --> 00:08:11,735
low-code developer and you want to deal
with the diagram not to mess with the.

138
00:08:12,010 --> 00:08:16,200
Programming side of the code,
you can add constructs or do

139
00:08:16,200 --> 00:08:17,489
everything from the diagram side.

140
00:08:17,989 --> 00:08:24,230
And also not only that because it's
coming with set of full tool set, it has

141
00:08:24,319 --> 00:08:29,820
certain other helper kind of tools to make
it easy for the integration developers.

142
00:08:29,820 --> 00:08:32,730
So service designers are
that you don't have to write.

143
00:08:33,115 --> 00:08:36,145
Code from scratch, or you don't
have to design everything by

144
00:08:36,705 --> 00:08:38,925
diagram from step by step.

145
00:08:39,015 --> 00:08:42,195
There are service designers kind
of thing where you can easily

146
00:08:42,195 --> 00:08:46,745
design the services HGTP services
or a services, GraphQL services.

147
00:08:46,745 --> 00:08:51,185
And so you can, it provides form like
view so that you can define the HG

148
00:08:51,185 --> 00:08:54,105
GTP methods you want and parameters.

149
00:08:54,465 --> 00:08:57,465
It can be part parameters
or something else.

150
00:08:57,965 --> 00:09:01,565
URL parameters, and it can
provide advanced properties that

151
00:09:01,745 --> 00:09:03,485
define the responses and so on.

152
00:09:04,145 --> 00:09:08,195
And same goes with GraphQL when it
comes to graph, where we are mostly

153
00:09:08,195 --> 00:09:12,095
dealing with data, set of data which
are interrelated with each other.

154
00:09:12,425 --> 00:09:15,985
So that view is properly
provided by the ballerina.

155
00:09:16,485 --> 00:09:20,295
Visual designer and it's very
easy to design such applications.

156
00:09:20,865 --> 00:09:25,245
And also data transformations
has very comprehensive data

157
00:09:25,305 --> 00:09:26,985
transformation capabilities.

158
00:09:27,075 --> 00:09:28,395
That is what we call data map.

159
00:09:28,995 --> 00:09:32,465
So you can map the data
in the visual mode.

160
00:09:32,555 --> 00:09:34,055
You can, this is the visual data map.

161
00:09:34,655 --> 00:09:38,575
And also you can edit the expressions
in between because most of the

162
00:09:38,575 --> 00:09:40,405
time it is not one to one mapping.

163
00:09:40,405 --> 00:09:43,845
We have to do some calculations or some.

164
00:09:44,620 --> 00:09:48,715
Processing in between before we
map data from one field to another.

165
00:09:49,215 --> 00:09:53,175
So Bellina has that capability
as well, and also debugging.

166
00:09:53,305 --> 00:09:56,245
It is very important at the
developer level how we debug

167
00:09:56,245 --> 00:10:00,415
the applications because it has
both low code and code parity.

168
00:10:00,805 --> 00:10:04,555
We have the debugging capabilities, both
in the diagram level as well as the source

169
00:10:04,555 --> 00:10:06,625
code level, given that Bella is language.

170
00:10:07,110 --> 00:10:10,530
It has all the debugging capabilities
that a normal language is having.

171
00:10:10,920 --> 00:10:14,230
Apart from that, we have the
diagram debugging capabilities.

172
00:10:14,230 --> 00:10:18,055
You can add a debug point in the
diagram node and debug your application.

173
00:10:18,555 --> 00:10:20,625
And also everything comes under one roof.

174
00:10:21,045 --> 00:10:25,095
So these are the various protocols that
integration developers has to deal with.

175
00:10:25,605 --> 00:10:29,805
And we have the support, first class
support for all of these services and

176
00:10:29,865 --> 00:10:34,335
client types and services and clients
are part of the language itself.

177
00:10:34,665 --> 00:10:38,445
So defining a service or
defining a client is really easy

178
00:10:38,945 --> 00:10:40,330
and connectors and templates.

179
00:10:41,090 --> 00:10:45,530
When it comes to connecting with
other applications or integrations,

180
00:10:45,860 --> 00:10:47,690
connectors plays a big role.

181
00:10:47,960 --> 00:10:51,770
It can be connectors for various
network protocols, or it can

182
00:10:51,770 --> 00:10:56,180
be databases, or it can be SARS
applications, messaging platforms.

183
00:10:56,540 --> 00:11:01,760
Likewise, we have set of a huge set
of connectors, great set of connectors

184
00:11:01,760 --> 00:11:03,470
to connect with all of these things.

185
00:11:03,970 --> 00:11:04,840
So these are the list of.

186
00:11:05,340 --> 00:11:08,370
Central, which is our
repository management system.

187
00:11:08,820 --> 00:11:13,710
You can see all of these connectors
and also we have persist capabilities.

188
00:11:13,800 --> 00:11:17,370
This is more or less a kind of
diaphragm capability where you can

189
00:11:17,370 --> 00:11:21,230
see 80 D relationship, a d. When you
are working with per persist, when

190
00:11:21,230 --> 00:11:25,160
you are persisting data, this is
very familiar for the diagrams in the

191
00:11:25,160 --> 00:11:29,650
database world, but somewhat similar
to what we are visualizing here.

192
00:11:30,010 --> 00:11:32,950
When you have set of data that you
want to persist in the database or

193
00:11:32,950 --> 00:11:37,000
some other data persistent layer,
this capabilities really helpful.

194
00:11:37,000 --> 00:11:40,000
And also there are many
other integration tools.

195
00:11:40,000 --> 00:11:42,070
I'll not go through the
details of each of them.

196
00:11:42,530 --> 00:11:47,180
These are kind of EDI tools, pro
of tools, GraphQL tools, because.

197
00:11:47,620 --> 00:11:51,730
Most of the time what we are getting
is a contract in different protocol.

198
00:11:51,730 --> 00:11:57,520
For example, open API specification is
a contract that we are getting so ball

199
00:11:57,520 --> 00:12:02,920
and now with using this open API tool,
we have the capability to generate.

200
00:12:03,365 --> 00:12:07,085
Service and clients based on
that open API specification

201
00:12:07,115 --> 00:12:08,945
by executing a single command.

202
00:12:09,335 --> 00:12:12,605
So that flexibility is there for
many protocols, metadata types.

203
00:12:12,935 --> 00:12:13,985
So that is very easy.

204
00:12:14,255 --> 00:12:17,195
You can generate the ballerina code
automatically with these tools.

205
00:12:17,735 --> 00:12:22,475
And also there are in AI capabilities,
we have in inbuilt IS system,

206
00:12:22,475 --> 00:12:24,245
what we call ballerina, copilot.

207
00:12:24,545 --> 00:12:27,395
It helps you to generate
the code automatically.

208
00:12:27,395 --> 00:12:29,980
It acts like a built in.

209
00:12:30,775 --> 00:12:32,695
Companion to pair programming.

210
00:12:33,025 --> 00:12:36,295
You can give the input in the
natural language and it'll

211
00:12:36,295 --> 00:12:37,495
generate the code for you.

212
00:12:37,995 --> 00:12:42,055
And also we have automatically auto
map capability to map the data.

213
00:12:42,595 --> 00:12:46,315
From one type to another, automatically
using the auto map feature of

214
00:12:46,315 --> 00:12:48,265
the data map that will help you.

215
00:12:48,270 --> 00:12:53,305
Let's say you have two records, two
data types to map with large number

216
00:12:53,305 --> 00:12:54,955
of fields, and it's not that easy.

217
00:12:54,955 --> 00:12:57,625
So the auto mapping feature
will help you there.

218
00:12:58,135 --> 00:13:02,005
It analyze existing fields
there, data types and context.

219
00:13:02,750 --> 00:13:07,180
You can provide additional context
if needed to help the assistant to

220
00:13:07,180 --> 00:13:11,410
understand what sort of mapping you
are doing with additional calculations,

221
00:13:11,770 --> 00:13:13,960
and then it'll do the job for you.

222
00:13:14,350 --> 00:13:18,820
So that is about the development part,
and have you maintain the source code.

223
00:13:19,180 --> 00:13:22,840
And let's look at a quick demo,
which I was already developed.

224
00:13:23,350 --> 00:13:26,980
So this is about Music for
Mother, which is a rest service.

225
00:13:27,645 --> 00:13:33,585
In simple terms, what it is doing is
it provides a capability for a user

226
00:13:33,585 --> 00:13:39,645
to get a playlist, which from Spotify,
a music playlist, which is matching

227
00:13:39,645 --> 00:13:41,115
for the given weather condition.

228
00:13:41,115 --> 00:13:44,805
For example, if it is a sunny weather,
you want to listen certain type of

229
00:13:45,315 --> 00:13:49,895
playlist, or if it is rainy weather, you
want to listen to different set of music.

230
00:13:50,375 --> 00:13:51,020
Likewise, you can.

231
00:13:51,800 --> 00:13:55,880
Check the current weather in a
given location and map the weather

232
00:13:55,880 --> 00:13:59,630
to a given mode, and finally get
the music list for that given

233
00:13:59,630 --> 00:14:01,520
mode and it'll return to the user.

234
00:14:01,670 --> 00:14:06,710
So this very simple integration,
which involves a multiple APIs in the

235
00:14:06,710 --> 00:14:09,230
weather, API, as well as this Spotify.

236
00:14:09,680 --> 00:14:13,220
So that is the one that
I'm going to discuss here.

237
00:14:13,720 --> 00:14:16,390
So this is already implemented
application in ballerina.

238
00:14:16,720 --> 00:14:20,800
This is Ballina plugin, which
is installed in VS code, and

239
00:14:20,800 --> 00:14:22,240
the application is developed.

240
00:14:22,610 --> 00:14:24,230
I wanted to highlight a
couple of things here.

241
00:14:24,230 --> 00:14:28,520
This is the design view where you can
see in high level the services and

242
00:14:28,940 --> 00:14:30,830
various endpoints that you are working.

243
00:14:31,100 --> 00:14:34,370
So it'll give you very high level
understanding of how many services

244
00:14:34,370 --> 00:14:37,790
you have, how many resources you
have within each of these service.

245
00:14:38,225 --> 00:14:40,325
And what are the end
points that it is talking?

246
00:14:40,775 --> 00:14:41,345
Likewise.

247
00:14:41,555 --> 00:14:44,405
And when you click here, you can
see the service designer, which

248
00:14:44,405 --> 00:14:47,675
I talked earlier, so you can add
more and more resources here.

249
00:14:47,705 --> 00:14:51,705
This is service resource which
allows you to add more resources.

250
00:14:52,005 --> 00:14:54,795
You can add parameters, but
if you don't add anything, you

251
00:14:54,795 --> 00:14:56,235
can simply add a resource here.

252
00:14:57,195 --> 00:15:00,795
And once you go back to the
service designer, you can see

253
00:15:00,795 --> 00:15:02,295
another resource is getting added.

254
00:15:02,685 --> 00:15:05,835
So all these things in the diagram
level, but at the same time, if you

255
00:15:05,835 --> 00:15:10,915
go to the source file, you can see
the mapping source code of that.

256
00:15:11,425 --> 00:15:14,295
So this is a service
in ballerina, which is.

257
00:15:15,125 --> 00:15:19,685
Listen on a given port service in
Ballina is part of the language syntax

258
00:15:19,685 --> 00:15:21,425
itself, so it's very easy to develop.

259
00:15:21,425 --> 00:15:24,905
A service for ballerina services
can be of many different types.

260
00:15:24,905 --> 00:15:29,405
As you can see here, it, once it is
attached to different protocol listener,

261
00:15:29,465 --> 00:15:31,685
it'll become a service of that protocol.

262
00:15:32,075 --> 00:15:32,445
So this is.

263
00:15:32,945 --> 00:15:36,725
This one is HT DP listener, which is
listening on Port 90 90, and it has

264
00:15:37,385 --> 00:15:41,525
three resources to accept incoming
requests, all luggage resources.

265
00:15:41,705 --> 00:15:45,635
One fundamental principle in
ballerina is we model all of these

266
00:15:45,635 --> 00:15:49,805
things, even whether it's a network
invocation, network resource function.

267
00:15:50,285 --> 00:15:53,775
It's like a normal function which
has name of the function which is

268
00:15:53,775 --> 00:15:55,965
getting mapped to the resource path.

269
00:15:56,330 --> 00:15:58,820
And input parameters and return types.

270
00:15:58,820 --> 00:16:01,250
So developers has to focus
only on the business logic.

271
00:16:02,070 --> 00:16:06,390
And it is very easy for the developers
to stay out of the complexity

272
00:16:06,390 --> 00:16:09,780
of the network, and that is the
abstraction that we are talking about.

273
00:16:10,170 --> 00:16:16,150
And connect seamlessly or develop
the business logic effectively.

274
00:16:16,570 --> 00:16:17,710
And same with the client.

275
00:16:18,020 --> 00:16:20,300
Defining a client in is real easy.

276
00:16:20,300 --> 00:16:23,810
This is a client, Spotify
client that we have created.

277
00:16:25,000 --> 00:16:26,440
This is how we are defining client.

278
00:16:26,440 --> 00:16:27,640
In the syntax level.

279
00:16:28,120 --> 00:16:31,060
You can provide relevant
parameters, URLs, and other things.

280
00:16:31,540 --> 00:16:37,285
And since this is HTTP client,
you can in HT P. Get post

281
00:16:37,285 --> 00:16:38,665
resources using this client.

282
00:16:39,325 --> 00:16:41,275
And also the other thing is type system.

283
00:16:41,575 --> 00:16:45,015
This is Ballina record, which is
the record representation, which

284
00:16:45,015 --> 00:16:49,335
is a canonical format in Ballina
where we can represent the data.

285
00:16:49,465 --> 00:16:54,055
Like if it is Jml, whatever it is, we
can represent it using the record types.

286
00:16:54,505 --> 00:16:58,415
And even in the visual
view, we can see the types.

287
00:16:58,665 --> 00:17:00,170
Effectively in the types view.

288
00:17:00,590 --> 00:17:06,260
So if you open it up, you can see there
are multiple types and the diagram

289
00:17:06,260 --> 00:17:10,190
itself is showing the relationship
between the different types.

290
00:17:10,460 --> 00:17:13,400
If you look at the source code
of the types, it is not easy to

291
00:17:13,400 --> 00:17:14,510
understand these interrelation.

292
00:17:15,010 --> 00:17:17,170
The relationships and other things.

293
00:17:17,200 --> 00:17:21,390
It's more like a er, if you're familiar
with the database, so you can see the

294
00:17:21,990 --> 00:17:24,510
connecting to the items and it has owner.

295
00:17:25,010 --> 00:17:29,400
Whether data has current information
and it's associated with the

296
00:17:29,400 --> 00:17:32,880
location, likewise we can see
all the fields and how they are

297
00:17:32,880 --> 00:17:34,440
interconnecting in the type suite.

298
00:17:34,740 --> 00:17:40,110
So all these graphical tools and
graphical views gives you a very good

299
00:17:40,110 --> 00:17:45,390
understanding about your application, and
it is really helpful when, visualizing

300
00:17:45,390 --> 00:17:46,860
and maintaining the application.

301
00:17:47,370 --> 00:17:51,450
So other thing I mentioned is the
visual diagram capability and the

302
00:17:51,450 --> 00:17:53,010
parity that we are maintaining.

303
00:17:53,400 --> 00:17:57,480
So every piece of code that we are
writing, there's a equivalent diagram.

304
00:17:57,480 --> 00:18:00,360
So that can be a flow
diagram or a sequence diagram

305
00:18:00,360 --> 00:18:01,740
depending on the invocation.

306
00:18:02,100 --> 00:18:03,240
So this is the same.

307
00:18:03,845 --> 00:18:05,435
Thing that I showed in the demo.

308
00:18:05,765 --> 00:18:08,495
Basically, when we are explaining
over application to someone,

309
00:18:08,495 --> 00:18:09,905
we are using sequence diagram.

310
00:18:09,905 --> 00:18:15,035
So the same flow you can see in the
diagram itself because integration

311
00:18:15,035 --> 00:18:18,425
applications means it's always
connecting to different endpoints

312
00:18:18,425 --> 00:18:19,955
and get the results and so on.

313
00:18:20,345 --> 00:18:21,515
So this flow view.

314
00:18:21,665 --> 00:18:24,885
In the flow view, you can
actually edit, you can add many

315
00:18:24,885 --> 00:18:26,325
different constructs and so on.

316
00:18:26,325 --> 00:18:29,355
Let's say you add a if condition
for the simplicity I'm adding.

317
00:18:29,855 --> 00:18:31,535
Making the condition as true.

318
00:18:32,075 --> 00:18:38,225
You can see the if condition is got added
with two parts to and false, and if you

319
00:18:38,225 --> 00:18:42,845
go to the source code, you can see the
same thing got added to the source code.

320
00:18:42,905 --> 00:18:46,175
That's why I'm saying we are
maintaining the parity between

321
00:18:46,175 --> 00:18:47,585
the source and the diagram.

322
00:18:47,585 --> 00:18:50,165
So whether you are developing it
in the source level or the diagram

323
00:18:50,165 --> 00:18:52,150
level you can continue in either way.

324
00:18:52,650 --> 00:18:55,560
So when it comes to the
deployment of ballin applications,

325
00:18:56,130 --> 00:18:57,090
there are multiple ways.

326
00:18:57,090 --> 00:19:00,970
One way is you can build a
self-contained executable Java file

327
00:19:01,000 --> 00:19:03,100
and deploy it anywhere that you want.

328
00:19:03,490 --> 00:19:07,750
So simply you can issue Bell
bill command and deploy it.

329
00:19:07,840 --> 00:19:12,340
So if we go to this application, I can
simply issue bell bill command here.

330
00:19:12,840 --> 00:19:16,950
And it'll compile the source code
and it'll generate the artifacts.

331
00:19:17,550 --> 00:19:22,320
That's one way I'll clean the artifacts
here to proceed with the next steps.

332
00:19:22,620 --> 00:19:25,260
And the other thing is code to
cloud aspect, which is the main

333
00:19:25,260 --> 00:19:27,270
topic of today's discussion.

334
00:19:27,570 --> 00:19:30,870
So it allows people, developers to
write code without thinking about the

335
00:19:30,870 --> 00:19:32,730
complexity of the deployment platform.

336
00:19:33,090 --> 00:19:35,850
So it simplifies a lot
about the development.

337
00:19:36,210 --> 00:19:39,810
Experience as well as how the
developers has to think about.

338
00:19:40,140 --> 00:19:45,060
Because usually when we have to de deploy
our application in Kubernetes kind of

339
00:19:45,060 --> 00:19:49,920
environment, we had to build the docker
images and we had to write Docker files.

340
00:19:50,010 --> 00:19:53,850
And yamal files in the Kubernetes
world, these a bit, two complex tasks.

341
00:19:53,850 --> 00:19:56,040
You had to understand
all these complexities.

342
00:19:56,400 --> 00:20:02,310
But in Ballina we have the
capability to, build the DO or

343
00:20:02,670 --> 00:20:04,110
Kubernetes artifacts easily.

344
00:20:04,440 --> 00:20:06,990
Before doing that, let's
quickly run this application.

345
00:20:07,350 --> 00:20:10,210
I'm using Bell Run command
to run the application.

346
00:20:10,930 --> 00:20:15,820
You can see it's now running and we
can try it using the try tool available

347
00:20:15,820 --> 00:20:18,490
within the language itself or tool itself.

348
00:20:19,100 --> 00:20:25,210
You can provide a location here, let's
say for example, testing and you can.

349
00:20:25,710 --> 00:20:29,580
You can see the current weather
of INE is sunny and you will get

350
00:20:29,580 --> 00:20:33,540
the list of play playlist from
the Spotify to match with that.

351
00:20:33,690 --> 00:20:36,450
Let's say let's pay the
location to London, maybe.

352
00:20:36,950 --> 00:20:41,270
You can see it's different with the
condition at and different playlist.

353
00:20:41,510 --> 00:20:45,680
So this is how easily you can test and
run the application locally as well.

354
00:20:46,100 --> 00:20:49,040
And then it's a matter of deploying
it to the right environment.

355
00:20:49,430 --> 00:20:53,930
So to build the docker artifacts,
the first thing that you have to do

356
00:20:53,930 --> 00:20:59,900
is issue the be command command with
the relevant artifact type you need.

357
00:20:59,900 --> 00:21:04,040
For example, let's first look at
how we can create the Docker file.

358
00:21:04,540 --> 00:21:09,080
The existing artifacts and then
you have to show bell build minus,

359
00:21:09,080 --> 00:21:11,840
minus cloud with the docker option.

360
00:21:12,340 --> 00:21:15,405
Then you can see to compiler
the, compile the application

361
00:21:15,495 --> 00:21:16,875
and build in the Docker image.

362
00:21:17,375 --> 00:21:22,685
Once you go to the Target folder,
you can see the Docker file log image

363
00:21:22,755 --> 00:21:25,665
Docker file with the dependencies.

364
00:21:25,785 --> 00:21:29,265
And then the next thing is how we
can deploy it into the Kubernetes.

365
00:21:29,715 --> 00:21:32,865
So when it comes to the Kubernetes
platform, usually you have to write

366
00:21:32,865 --> 00:21:37,785
the Lam files manually, but in
Ballerina you can do it by issuing.

367
00:21:38,285 --> 00:21:42,865
Let me clean the artifacts first
and let's issue command again, bell

368
00:21:42,865 --> 00:21:48,430
build cloud with the parameter As the
Kubernetes, you can see it is compiling

369
00:21:48,430 --> 00:21:50,410
and generating the Kubernetes artifacts.

370
00:21:50,910 --> 00:21:53,670
Once it is done, you can
see the commands to execute.

371
00:21:54,390 --> 00:21:58,360
And you can see the target files
the Yamal files is generated.

372
00:21:58,860 --> 00:21:59,970
Lemme open it up.

373
00:22:00,470 --> 00:22:04,520
So the generated yamal file is reading the
port and other information from the source

374
00:22:04,520 --> 00:22:07,245
file, and also it comes with the default.

375
00:22:08,135 --> 00:22:12,855
Defaults imposed by the compile
extension for various CPN memory values.

376
00:22:12,855 --> 00:22:17,195
And if you want to change them,
you can add a configuration file to

377
00:22:17,195 --> 00:22:19,685
the folder and get them replaced.

378
00:22:20,105 --> 00:22:22,025
So the next thing is how we can run it.

379
00:22:22,115 --> 00:22:24,545
You can see the commands
run it here itself.

380
00:22:24,965 --> 00:22:27,335
First, let's see whether
the dokey image is created.

381
00:22:27,835 --> 00:22:30,925
Let's issue the Docker images command.

382
00:22:31,315 --> 00:22:34,765
You can see the Docker image
is created 56 seconds ago.

383
00:22:35,095 --> 00:22:38,905
Let's issue this command to deploy
this in the Kubernetes cluster.

384
00:22:39,405 --> 00:22:41,025
So the service is created.

385
00:22:41,025 --> 00:22:42,255
Deployment is created.

386
00:22:42,705 --> 00:22:48,015
So if you issue the Kubernetes
command month to CTL, get deployments.

387
00:22:48,515 --> 00:22:54,575
You can see the deployment is created
and let's expose it as a service.

388
00:22:54,575 --> 00:22:56,525
We are not port using this command.

389
00:22:56,525 --> 00:22:56,855
Now

390
00:22:57,355 --> 00:22:58,585
the service is exposed.

391
00:22:59,035 --> 00:23:00,385
Let's see the group ct.

392
00:23:00,415 --> 00:23:01,135
Let's use the group.

393
00:23:01,135 --> 00:23:01,555
CTL.

394
00:23:02,185 --> 00:23:04,675
Get service command to see the service.

395
00:23:05,175 --> 00:23:07,010
You can see this service is there.

396
00:23:07,510 --> 00:23:09,189
Which exposed with this point.

397
00:23:09,669 --> 00:23:13,760
So likewise, without writing
any piece of Yammer file, you

398
00:23:13,760 --> 00:23:15,199
can deploy to the Kubernetes.

399
00:23:15,500 --> 00:23:18,280
So same applies to other
serverless functions like AWS

400
00:23:18,284 --> 00:23:19,780
Lamb, Azure functions as well.

401
00:23:20,110 --> 00:23:22,179
We have the similar capability to do that.

402
00:23:22,780 --> 00:23:24,429
So that's the deployment part.

403
00:23:24,429 --> 00:23:28,090
So thats, or that fills the
gap between the developers and.

404
00:23:29,000 --> 00:23:30,439
Deployment aspects.

405
00:23:30,709 --> 00:23:32,149
And finally, the operation part.

406
00:23:32,360 --> 00:23:35,030
I will not go through the detail,
but it, we have the capability

407
00:23:35,030 --> 00:23:37,310
to observe the applications.

408
00:23:37,720 --> 00:23:41,320
It can be metrics, tracing, login
activities, and we can connect

409
00:23:41,320 --> 00:23:44,920
to different existing tools and
platform and monitor like this.

410
00:23:45,675 --> 00:23:47,235
And that's about my session today.

411
00:23:47,505 --> 00:23:51,555
So finally, I would like to say
one thing about Ballina community.

412
00:23:51,835 --> 00:23:55,045
We are open source project and
we are conducting many community

413
00:23:55,045 --> 00:23:59,905
events, tech talks, trainings, unity
programs, and also we are participating

414
00:23:59,905 --> 00:24:01,915
in major conferences and events.

415
00:24:02,215 --> 00:24:05,805
So you can visit to Ballina official
website, Ballina io, and you can

416
00:24:05,805 --> 00:24:09,795
download ballerina, try out Ballina,
and you can even contribute to ballerina

417
00:24:10,225 --> 00:24:11,935
because it's an open source language.

418
00:24:12,285 --> 00:24:18,015
Framework and also you can get certified
and you can use, become a user of it.

419
00:24:18,415 --> 00:24:22,075
We have a community around us who
can help you when you have problems,

420
00:24:22,405 --> 00:24:24,715
join the discord and flow as well.

421
00:24:25,285 --> 00:24:30,955
Thank you very much for joining with this
session today and would like to, I would

422
00:24:30,955 --> 00:24:32,635
like to see you in the Ballina community.

423
00:24:33,355 --> 00:24:33,745
Thank you.

